(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Clappr"] = factory();
	else
		root["Clappr"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-runtime/core-js/array/from.js":
/*!**********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/array/from.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ "./node_modules/core-js/library/fn/array/from.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/get-iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/get-iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/get-iterator */ "./node_modules/core-js/library/fn/get-iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/json/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/json/stringify.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/json/stringify */ "./node_modules/core-js/library/fn/json/stringify.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/create.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/create */ "./node_modules/core-js/library/fn/object/create.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptor */ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/keys.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/set-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/set-prototype-of */ "./node_modules/core-js/library/fn/object/set-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/extends.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/extends.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/inherits.js":
/*!********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/inherits.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(/*! ../core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(/*! ../core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/possibleConstructorReturn.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/toConsumableArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/toConsumableArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(/*! ../core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/clappr-zepto/zepto.js":
/*!********************************************!*\
  !*** ./node_modules/clappr-zepto/zepto.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Zepto v1.2.0 - zepto ajax callbacks deferred event ie selector - zeptojs.com/license */


var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,
    singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    rootNodeRE = /^(?:body|html)$/i,
    capitalRE = /([A-Z])/g,

    // special attributes that should be get/set via method calls
    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    readyRE = /complete|loaded|interactive/,
    simpleSelectorRE = /^[\w-]*$/,
    class2type = {},
    toString = class2type.toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div'),
    propMap = {
      'tabindex': 'tabIndex',
      'readonly': 'readOnly',
      'for': 'htmlFor',
      'class': 'className',
      'maxlength': 'maxLength',
      'cellspacing': 'cellSpacing',
      'cellpadding': 'cellPadding',
      'rowspan': 'rowSpan',
      'colspan': 'colSpan',
      'usemap': 'useMap',
      'frameborder': 'frameBorder',
      'contenteditable': 'contentEditable'
    },
    isArray = Array.isArray ||
      function(object){ return object instanceof Array }

  zepto.matches = function(element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false
    var matchesSelector = element.matches || element.webkitMatchesSelector ||
                          element.mozMatchesSelector || element.oMatchesSelector ||
                          element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent
    if (temp) (parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp && tempParent.removeChild(element)
    return match
  }

  function type(obj) {
    return obj == null ? String(obj) :
      class2type[toString.call(obj)] || "object"
  }

  function isFunction(value) { return type(value) == "function" }
  function isWindow(obj)     { return obj != null && obj == obj.window }
  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }
  function isObject(obj)     { return type(obj) == "object" }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
  }

  function likeArray(obj) {
    var length = !!obj && 'length' in obj && obj.length,
      type = $.type(obj)

    return 'function' != type && !isWindow(obj) && (
      'array' == type || length === 0 ||
        (typeof length == 'number' && length > 0 && (length - 1) in obj)
    )
  }

  function compact(array) { return filter.call(array, function(item){ return item != null }) }
  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName)
      document.body.appendChild(element)
      display = getComputedStyle(element, '').getPropertyValue("display")
      element.parentNode.removeChild(element)
      display == "none" && (display = "block")
      elementDisplay[nodeName] = display
    }
    return elementDisplay[nodeName]
  }

  function children(element) {
    return 'children' in element ?
      slice.call(element.children) :
      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })
  }

  function Z(dom, selector) {
    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i]
    this.length = len
    this.selector = selector || ''
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name, properties) {
    var dom, nodes, container

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>")
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
      if (!(name in containers)) name = '*'

      container = containers[name]
      container.innerHTML = '' + html
      dom = $.each(slice.call(container.childNodes), function(){
        container.removeChild(this)
      })
    }

    if (isPlainObject(properties)) {
      nodes = $(dom)
      $.each(properties, function(key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value)
        else nodes.attr(key, value)
      })
    }

    return dom
  }

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function(dom, selector) {
    return new Z(dom, selector)
  }

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  }

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function(selector, context) {
    var dom
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z()
    // Optimize for string selectors
    else if (typeof selector == 'string') {
      selector = selector.trim()
      // If it's a html fragment, create nodes from it
      // Note: In both Chrome 21 and Firefox 15, DOM error 12
      // is thrown if the fragment doesn't begin with <
      if (selector[0] == '<' && fragmentRE.test(selector))
        dom = zepto.fragment(selector, RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // If it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) return $(document).ready(selector)
    // If a Zepto collection is given, just return it
    else if (zepto.isZ(selector)) return selector
    else {
      // normalize array if an array of nodes is given
      if (isArray(selector)) dom = compact(selector)
      // Wrap DOM nodes.
      else if (isObject(selector))
        dom = [selector], selector = null
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // create a new Zepto collection from the nodes found
    return zepto.Z(dom, selector)
  }

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  }

  function extend(target, source, deep) {
    for (key in source)
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          target[key] = {}
        if (isArray(source[key]) && !isArray(target[key]))
          target[key] = []
        extend(target[key], source[key], deep)
      }
      else if (source[key] !== undefined) target[key] = source[key]
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    var deep, args = slice.call(arguments, 1)
    if (typeof target == 'boolean') {
      deep = target
      target = args.shift()
    }
    args.forEach(function(arg){ extend(target, arg, deep) })
    return target
  }

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function(element, selector){
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
        isSimple = simpleSelectorRE.test(nameOnly)
    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById
      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :
      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :
      slice.call(
        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
          element.getElementsByTagName(selector) : // Or a tag
          element.querySelectorAll(selector) // Or it's not simple, and we need to query all
      )
  }

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector)
  }

  $.contains = document.documentElement.contains ?
    function(parent, node) {
      return parent !== node && parent.contains(node)
    } :
    function(parent, node) {
      while (node && (node = node.parentNode))
        if (node === parent) return true
      return false
    }

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value){
    var klass = node.className || '',
        svg   = klass && klass.baseVal !== undefined

    if (value === undefined) return svg ? klass.baseVal : klass
    svg ? (klass.baseVal = value) : (node.className = value)
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ?
        value == "true" ||
        ( value == "false" ? false :
          value == "null" ? null :
          +value + "" == value ? +value :
          /^[\[\{]/.test(value) ? $.parseJSON(value) :
          value )
        : value
    } catch(e) {
      return value
    }
  }

  $.type = type
  $.isFunction = isFunction
  $.isWindow = isWindow
  $.isArray = isArray
  $.isPlainObject = isPlainObject

  $.isEmptyObject = function(obj) {
    var name
    for (name in obj) return false
    return true
  }

  $.isNumeric = function(val) {
    var num = Number(val), type = typeof val
    return val != null && type != 'boolean' &&
      (type != 'string' || val.length) &&
      !isNaN(num) && isFinite(num) || false
  }

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  }

  $.camelCase = camelize
  $.trim = function(str) {
    return str == null ? "" : String.prototype.trim.call(str)
  }

  // plugin compatibility
  $.uuid = 0
  $.support = { }
  $.expr = { }
  $.noop = function() {}

  $.map = function(elements, callback){
    var value, values = [], i, key
    if (likeArray(elements))
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i)
        if (value != null) values.push(value)
      }
    else
      for (key in elements) {
        value = callback(elements[key], key)
        if (value != null) values.push(value)
      }
    return flatten(values)
  }

  $.each = function(elements, callback){
    var i, key
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        if (callback.call(elements[i], i, elements[i]) === false) return elements
    } else {
      for (key in elements)
        if (callback.call(elements[key], key, elements[key]) === false) return elements
    }

    return elements
  }

  $.grep = function(elements, callback){
    return filter.call(elements, callback)
  }

  if (window.JSON) $.parseJSON = JSON.parse

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase()
  })

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function(){
      var i, value, args = []
      for (i = 0; i < arguments.length; i++) {
        value = arguments[i]
        args[i] = zepto.isZ(value) ? value.toArray() : value
      }
      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($)
      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          this.parentNode.removeChild(this)
      })
    },
    each: function(callback){
      emptyArray.every.call(this, function(el, idx){
        return callback.call(el, idx, el) !== false
      })
      return this
    },
    filter: function(selector){
      if (isFunction(selector)) return this.not(this.not(selector))
      return $(filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[]
      if (isFunction(selector) && selector.call !== undefined)
        this.each(function(idx){
          if (!selector.call(this,idx)) nodes.push(this)
        })
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) nodes.push(el)
        })
      }
      return $(nodes)
    },
    has: function(selector){
      return this.filter(function(){
        return isObject(selector) ?
          $.contains(this, selector) :
          $(this).find(selector).size()
      })
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0]
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1]
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result, $this = this
      if (!selector) result = $()
      else if (typeof selector == 'object')
        result = $(selector).filter(function(){
          var node = this
          return emptyArray.some.call($this, function(parent){
            return $.contains(parent, node)
          })
        })
      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))
      else result = this.map(function(){ return zepto.qsa(this, selector) })
      return result
    },
    closest: function(selector, context){
      var nodes = [], collection = typeof selector == 'object' && $(selector)
      this.each(function(_, node){
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))
          node = node !== context && !isDocument(node) && node.parentNode
        if (node && nodes.indexOf(node) < 0) nodes.push(node)
      })
      return $(nodes)
    },
    parents: function(selector){
      var ancestors = [], nodes = this
      while (nodes.length > 0)
        nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node)
            return node
          }
        })
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return children(this) }), selector)
    },
    contents: function() {
      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return filter.call(children(el.parentNode), function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = '' })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return $.map(this, function(el){ return el[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = '')
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          this.style.display = defaultDisplay(this.nodeName)
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(structure){
      var func = isFunction(structure)
      if (this[0] && !func)
        var dom   = $(structure).get(0),
            clone = dom.parentNode || this.length > 1

      return this.each(function(index){
        $(this).wrapAll(
          func ? structure.call(this, index) :
            clone ? dom.cloneNode(true) : dom
        )
      })
    },
    wrapAll: function(structure){
      if (this[0]) {
        $(this[0]).before(structure = $(structure))
        var children
        // drill down to the inmost element
        while ((children = structure.children()).length) structure = children.first()
        $(structure).append(this)
      }
      return this
    },
    wrapInner: function(structure){
      var func = isFunction(structure)
      return this.each(function(index){
        var self = $(this), contents = self.contents(),
            dom  = func ? structure.call(this, index) : structure
        contents.length ? contents.wrapAll(dom) : self.append(dom)
      })
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children())
      })
      return this
    },
    clone: function(){
      return this.map(function(){ return this.cloneNode(true) })
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return this.each(function(){
        var el = $(this)
        ;(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide()
      })
    },
    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },
    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },
    html: function(html){
      return 0 in arguments ?
        this.each(function(idx){
          var originHtml = this.innerHTML
          $(this).empty().append( funcArg(this, html, idx, originHtml) )
        }) :
        (0 in this ? this[0].innerHTML : null)
    },
    text: function(text){
      return 0 in arguments ?
        this.each(function(idx){
          var newText = funcArg(this, text, idx, this.textContent)
          this.textContent = newText == null ? '' : ''+newText
        }) :
        (0 in this ? this.pluck('textContent').join("") : null)
    },
    attr: function(name, value){
      var result
      return (typeof name == 'string' && !(1 in arguments)) ?
        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :
        this.each(function(idx){
          if (this.nodeType !== 1) return
          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])
          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))
        })
    },
    removeAttr: function(name){
      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){
        setAttribute(this, attribute)
      }, this)})
    },
    prop: function(name, value){
      name = propMap[name] || name
      return (1 in arguments) ?
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name])
        }) :
        (this[0] && this[0][name])
    },
    removeProp: function(name){
      name = propMap[name] || name
      return this.each(function(){ delete this[name] })
    },
    data: function(name, value){
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()

      var data = (1 in arguments) ?
        this.attr(attrName, value) :
        this.attr(attrName)

      return data !== null ? deserializeValue(data) : undefined
    },
    val: function(value){
      if (0 in arguments) {
        if (value == null) value = ""
        return this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value)
        })
      } else {
        return this[0] && (this[0].multiple ?
           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :
           this[0].value)
      }
    },
    offset: function(coordinates){
      if (coordinates) return this.each(function(index){
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
              top:  coords.top  - parentOffset.top,
              left: coords.left - parentOffset.left
            }

        if ($this.css('position') == 'static') props['position'] = 'relative'
        $this.css(props)
      })
      if (!this.length) return null
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))
        return {top: 0, left: 0}
      var obj = this[0].getBoundingClientRect()
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      }
    },
    css: function(property, value){
      if (arguments.length < 2) {
        var element = this[0]
        if (typeof property == 'string') {
          if (!element) return
          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)
        } else if (isArray(property)) {
          if (!element) return
          var props = {}
          var computedStyle = getComputedStyle(element, '')
          $.each(property, function(_, prop){
            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))
          })
          return props
        }
      }

      var css = ''
      if (type(property) == 'string') {
        if (!value && value !== 0)
          this.each(function(){ this.style.removeProperty(dasherize(property)) })
        else
          css = dasherize(property) + ":" + maybeAddPx(property, value)
      } else {
        for (key in property)
          if (!property[key] && property[key] !== 0)
            this.each(function(){ this.style.removeProperty(dasherize(key)) })
          else
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
      }

      return this.each(function(){ this.style.cssText += ';' + css })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (!name) return false
      return emptyArray.some.call(this, function(el){
        return this.test(className(el))
      }, classRE(name))
    },
    addClass: function(name){
      if (!name) return this
      return this.each(function(idx){
        if (!('className' in this)) return
        classList = []
        var cls = className(this), newName = funcArg(this, name, idx, cls)
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) classList.push(klass)
        }, this)
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "))
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (!('className' in this)) return
        if (name === undefined) return className(this, '')
        classList = className(this)
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ")
        })
        className(this, classList.trim())
      })
    },
    toggleClass: function(name, when){
      if (!name) return this
      return this.each(function(idx){
        var $this = $(this), names = funcArg(this, name, idx, className(this))
        names.split(/\s+/g).forEach(function(klass){
          (when === undefined ? !$this.hasClass(klass) : when) ?
            $this.addClass(klass) : $this.removeClass(klass)
        })
      })
    },
    scrollTop: function(value){
      if (!this.length) return
      var hasScrollTop = 'scrollTop' in this[0]
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset
      return this.each(hasScrollTop ?
        function(){ this.scrollTop = value } :
        function(){ this.scrollTo(this.scrollX, value) })
    },
    scrollLeft: function(value){
      if (!this.length) return
      var hasScrollLeft = 'scrollLeft' in this[0]
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset
      return this.each(hasScrollLeft ?
        function(){ this.scrollLeft = value } :
        function(){ this.scrollTo(value, this.scrollY) })
    },
    position: function() {
      if (!this.length) return

      var elem = this[0],
        // Get *real* offsetParent
        offsetParent = this.offsetParent(),
        // Get correct offsets
        offset       = this.offset(),
        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0
      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0

      // Add offsetParent borders
      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0
      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0

      // Subtract the two offsets
      return {
        top:  offset.top  - parentOffset.top,
        left: offset.left - parentOffset.left
      }
    },
    offsetParent: function() {
      return this.map(function(){
        var parent = this.offsetParent || document.body
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static")
          parent = parent.offsetParent
        return parent
      })
    }
  }

  // for now
  $.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    var dimensionProperty =
      dimension.replace(/./, function(m){ return m[0].toUpperCase() })

    $.fn[dimension] = function(value){
      var offset, el = this[0]
      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :
        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :
        (offset = this.offset()) && offset[dimension]
      else return this.each(function(idx){
        el = $(this)
        el.css(dimension, funcArg(this, value, idx, el[dimension]()))
      })
    }
  })

  function traverseNode(node, fun) {
    fun(node)
    for (var i = 0, len = node.childNodes.length; i < len; i++)
      traverseNode(node.childNodes[i], fun)
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(operator, operatorIndex) {
    var inside = operatorIndex % 2 //=> prepend, append

    $.fn[operator] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var argType, nodes = $.map(arguments, function(arg) {
            var arr = []
            argType = type(arg)
            if (argType == "array") {
              arg.forEach(function(el) {
                if (el.nodeType !== undefined) return arr.push(el)
                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())
                arr = arr.concat(zepto.fragment(el))
              })
              return arr
            }
            return argType == "object" || arg == null ?
              arg : zepto.fragment(arg)
          }),
          parent, copyByClone = this.length > 1
      if (nodes.length < 1) return this

      return this.each(function(_, target){
        parent = inside ? target : target.parentNode

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling :
                 operatorIndex == 1 ? target.firstChild :
                 operatorIndex == 2 ? target :
                 null

        var parentInDocument = $.contains(document.documentElement, parent)

        nodes.forEach(function(node){
          if (copyByClone) node = node.cloneNode(true)
          else if (!parent) return $(node).remove()

          parent.insertBefore(node, target)
          if (parentInDocument) traverseNode(node, function(el){
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&
               (!el.type || el.type === 'text/javascript') && !el.src){
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window
              target['eval'].call(target, el.innerHTML)
            }
          })
        })
      })
    }

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){
      $(html)[operator](this)
      return this
    }
  })

  zepto.Z.prototype = Z.prototype = $.fn

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq
  zepto.deserializeValue = deserializeValue
  $.zepto = zepto

  return $
})()

window.Zepto = Zepto
window.$ === undefined && (window.$ = Zepto)

;(function($){
  var jsonpID = +new Date(),
      document = window.document,
      key,
      name,
      rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      scriptTypeRE = /^(?:text|application)\/javascript/i,
      xmlTypeRE = /^(?:text|application)\/xml/i,
      jsonType = 'application/json',
      htmlType = 'text/html',
      blankRE = /^\s*$/,
      originAnchor = document.createElement('a')

  originAnchor.href = window.location.href

  // trigger a custom event and return false if it was cancelled
  function triggerAndReturn(context, eventName, data) {
    var event = $.Event(eventName)
    $(context).trigger(event, data)
    return !event.isDefaultPrevented()
  }

  // trigger an Ajax "global" event
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global) return triggerAndReturn(context || document, eventName, data)
  }

  // Number of active Ajax requests
  $.active = 0

  function ajaxStart(settings) {
    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
  }
  function ajaxStop(settings) {
    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
  }

  // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context
    if (settings.beforeSend.call(context, xhr, settings) === false ||
        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)
      return false

    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])
  }
  function ajaxSuccess(data, xhr, settings, deferred) {
    var context = settings.context, status = 'success'
    settings.success.call(context, data, status, xhr)
    if (deferred) deferred.resolveWith(context, [data, status, xhr])
    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])
    ajaxComplete(status, xhr, settings)
  }
  // type: "timeout", "error", "abort", "parsererror"
  function ajaxError(error, type, xhr, settings, deferred) {
    var context = settings.context
    settings.error.call(context, xhr, type, error)
    if (deferred) deferred.rejectWith(context, [xhr, type, error])
    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])
    ajaxComplete(type, xhr, settings)
  }
  // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context
    settings.complete.call(context, xhr, status)
    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])
    ajaxStop(settings)
  }

  function ajaxDataFilter(data, type, settings) {
    if (settings.dataFilter == empty) return data
    var context = settings.context
    return settings.dataFilter.call(context, data, type)
  }

  // Empty function, used as default callback
  function empty() {}

  $.ajaxJSONP = function(options, deferred){
    if (!('type' in options)) return $.ajax(options)

    var _callbackName = options.jsonpCallback,
      callbackName = ($.isFunction(_callbackName) ?
        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),
      script = document.createElement('script'),
      originalCallback = window[callbackName],
      responseData,
      abort = function(errorType) {
        $(script).triggerHandler('error', errorType || 'abort')
      },
      xhr = { abort: abort }, abortTimeout

    if (deferred) deferred.promise(xhr)

    $(script).on('load error', function(e, errorType){
      clearTimeout(abortTimeout)
      $(script).off().remove()

      if (e.type == 'error' || !responseData) {
        ajaxError(null, errorType || 'error', xhr, options, deferred)
      } else {
        ajaxSuccess(responseData[0], xhr, options, deferred)
      }

      window[callbackName] = originalCallback
      if (responseData && $.isFunction(originalCallback))
        originalCallback(responseData[0])

      originalCallback = responseData = undefined
    })

    if (ajaxBeforeSend(xhr, options) === false) {
      abort('abort')
      return xhr
    }

    window[callbackName] = function(){
      responseData = arguments
    }

    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
    document.head.appendChild(script)

    if (options.timeout > 0) abortTimeout = setTimeout(function(){
      abort('timeout')
    }, options.timeout)

    return xhr
  }

  $.ajaxSettings = {
    // Default type of request
    type: 'GET',
    // Callback that is executed before request
    beforeSend: empty,
    // Callback that is executed if the request succeeds
    success: empty,
    // Callback that is executed the the server drops error
    error: empty,
    // Callback that is executed on request complete (both: error and success)
    complete: empty,
    // The context for the callbacks
    context: null,
    // Whether to trigger "global" Ajax events
    global: true,
    // Transport
    xhr: function () {
      return new window.XMLHttpRequest()
    },
    // MIME types mapping
    // IIS returns Javascript as "application/x-javascript"
    accepts: {
      script: 'text/javascript, application/javascript, application/x-javascript',
      json:   jsonType,
      xml:    'application/xml, text/xml',
      html:   htmlType,
      text:   'text/plain'
    },
    // Whether the request is to another domain
    crossDomain: false,
    // Default timeout
    timeout: 0,
    // Whether data should be serialized to string
    processData: true,
    // Whether the browser should be allowed to cache GET responses
    cache: true,
    //Used to handle the raw response data of XMLHttpRequest.
    //This is a pre-filtering function to sanitize the response.
    //The sanitized response should be returned
    dataFilter: empty
  }

  function mimeToDataType(mime) {
    if (mime) mime = mime.split(';', 2)[0]
    return mime && ( mime == htmlType ? 'html' :
      mime == jsonType ? 'json' :
      scriptTypeRE.test(mime) ? 'script' :
      xmlTypeRE.test(mime) && 'xml' ) || 'text'
  }

  function appendQuery(url, query) {
    if (query == '') return url
    return (url + '&' + query).replace(/[&?]{1,2}/, '?')
  }

  // serialize payload and append it to the URL for GET requests
  function serializeData(options) {
    if (options.processData && options.data && $.type(options.data) != "string")
      options.data = $.param(options.data, options.traditional)
    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))
      options.url = appendQuery(options.url, options.data), options.data = undefined
  }

  $.ajax = function(options){
    var settings = $.extend({}, options || {}),
        deferred = $.Deferred && $.Deferred(),
        urlAnchor, hashIndex
    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]

    ajaxStart(settings)

    if (!settings.crossDomain) {
      urlAnchor = document.createElement('a')
      urlAnchor.href = settings.url
      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
      urlAnchor.href = urlAnchor.href
      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)
    }

    if (!settings.url) settings.url = window.location.toString()
    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)
    serializeData(settings)

    var dataType = settings.dataType, hasPlaceholder = /\?.+=\?/.test(settings.url)
    if (hasPlaceholder) dataType = 'jsonp'

    if (settings.cache === false || (
         (!options || options.cache !== true) &&
         ('script' == dataType || 'jsonp' == dataType)
        ))
      settings.url = appendQuery(settings.url, '_=' + Date.now())

    if ('jsonp' == dataType) {
      if (!hasPlaceholder)
        settings.url = appendQuery(settings.url,
          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')
      return $.ajaxJSONP(settings, deferred)
    }

    var mime = settings.accepts[dataType],
        headers = { },
        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },
        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
        xhr = settings.xhr(),
        nativeSetHeader = xhr.setRequestHeader,
        abortTimeout

    if (deferred) deferred.promise(xhr)

    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')
    setHeader('Accept', mime || '*/*')
    if (mime = settings.mimeType || mime) {
      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
      xhr.overrideMimeType && xhr.overrideMimeType(mime)
    }
    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))
      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')

    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])
    xhr.setRequestHeader = setHeader

    xhr.onreadystatechange = function(){
      if (xhr.readyState == 4) {
        xhr.onreadystatechange = empty
        clearTimeout(abortTimeout)
        var result, error = false
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {
          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))

          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')
            result = xhr.response
          else {
            result = xhr.responseText

            try {
              // http://perfectionkills.com/global-eval-what-are-the-options/
              // sanitize response accordingly if data filter callback provided
              result = ajaxDataFilter(result, dataType, settings)
              if (dataType == 'script')    (1,eval)(result)
              else if (dataType == 'xml')  result = xhr.responseXML
              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)
            } catch (e) { error = e }

            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)
          }

          ajaxSuccess(result, xhr, settings, deferred)
        } else {
          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)
        }
      }
    }

    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort()
      ajaxError(null, 'abort', xhr, settings, deferred)
      return xhr
    }

    var async = 'async' in settings ? settings.async : true
    xhr.open(settings.type, settings.url, async, settings.username, settings.password)

    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]

    for (name in headers) nativeSetHeader.apply(xhr, headers[name])

    if (settings.timeout > 0) abortTimeout = setTimeout(function(){
        xhr.onreadystatechange = empty
        xhr.abort()
        ajaxError(null, 'timeout', xhr, settings, deferred)
      }, settings.timeout)

    // avoid sending empty string (#319)
    xhr.send(settings.data ? settings.data : null)
    return xhr
  }

  // handle optional data/success arguments
  function parseArguments(url, data, success, dataType) {
    if ($.isFunction(data)) dataType = success, success = data, data = undefined
    if (!$.isFunction(success)) dataType = success, success = undefined
    return {
      url: url
    , data: data
    , success: success
    , dataType: dataType
    }
  }

  $.get = function(/* url, data, success, dataType */){
    return $.ajax(parseArguments.apply(null, arguments))
  }

  $.post = function(/* url, data, success, dataType */){
    var options = parseArguments.apply(null, arguments)
    options.type = 'POST'
    return $.ajax(options)
  }

  $.getJSON = function(/* url, data, success */){
    var options = parseArguments.apply(null, arguments)
    options.dataType = 'json'
    return $.ajax(options)
  }

  $.fn.load = function(url, data, success){
    if (!this.length) return this
    var self = this, parts = url.split(/\s/), selector,
        options = parseArguments(url, data, success),
        callback = options.success
    if (parts.length > 1) options.url = parts[0], selector = parts[1]
    options.success = function(response){
      self.html(selector ?
        $('<div>').html(response.replace(rscript, "")).find(selector)
        : response)
      callback && callback.apply(self, arguments)
    }
    $.ajax(options)
    return this
  }

  var escape = encodeURIComponent

  function serialize(params, obj, traditional, scope){
    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)
    $.each(obj, function(key, value) {
      type = $.type(value)
      if (scope) key = traditional ? scope :
        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'
      // handle data in serializeArray() format
      if (!scope && array) params.add(value.name, value.value)
      // recurse into nested objects
      else if (type == "array" || (!traditional && type == "object"))
        serialize(params, value, traditional, key)
      else params.add(key, value)
    })
  }

  $.param = function(obj, traditional){
    var params = []
    params.add = function(key, value) {
      if ($.isFunction(value)) value = value()
      if (value == null) value = ""
      this.push(escape(key) + '=' + escape(value))
    }
    serialize(params, obj, traditional)
    return params.join('&').replace(/%20/g, '+')
  }
})(Zepto)

;(function($){
  // Create a collection of callbacks to be fired in a sequence, with configurable behaviour
  // Option flags:
  //   - once: Callbacks fired at most one time.
  //   - memory: Remember the most recent context and arguments
  //   - stopOnFalse: Cease iterating over callback list
  //   - unique: Permit adding at most one instance of the same callback
  $.Callbacks = function(options) {
    options = $.extend({}, options)

    var memory, // Last fire value (for non-forgettable lists)
        fired,  // Flag to know if list was already fired
        firing, // Flag to know if list is currently firing
        firingStart, // First callback to fire (used internally by add and fireWith)
        firingLength, // End of the loop when firing
        firingIndex, // Index of currently firing callback (modified by remove if needed)
        list = [], // Actual callback list
        stack = !options.once && [], // Stack of fire calls for repeatable lists
        fire = function(data) {
          memory = options.memory && data
          fired = true
          firingIndex = firingStart || 0
          firingStart = 0
          firingLength = list.length
          firing = true
          for ( ; list && firingIndex < firingLength ; ++firingIndex ) {
            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
              memory = false
              break
            }
          }
          firing = false
          if (list) {
            if (stack) stack.length && fire(stack.shift())
            else if (memory) list.length = 0
            else Callbacks.disable()
          }
        },

        Callbacks = {
          add: function() {
            if (list) {
              var start = list.length,
                  add = function(args) {
                    $.each(args, function(_, arg){
                      if (typeof arg === "function") {
                        if (!options.unique || !Callbacks.has(arg)) list.push(arg)
                      }
                      else if (arg && arg.length && typeof arg !== 'string') add(arg)
                    })
                  }
              add(arguments)
              if (firing) firingLength = list.length
              else if (memory) {
                firingStart = start
                fire(memory)
              }
            }
            return this
          },
          remove: function() {
            if (list) {
              $.each(arguments, function(_, arg){
                var index
                while ((index = $.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1)
                  // Handle firing indexes
                  if (firing) {
                    if (index <= firingLength) --firingLength
                    if (index <= firingIndex) --firingIndex
                  }
                }
              })
            }
            return this
          },
          has: function(fn) {
            return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length))
          },
          empty: function() {
            firingLength = list.length = 0
            return this
          },
          disable: function() {
            list = stack = memory = undefined
            return this
          },
          disabled: function() {
            return !list
          },
          lock: function() {
            stack = undefined
            if (!memory) Callbacks.disable()
            return this
          },
          locked: function() {
            return !stack
          },
          fireWith: function(context, args) {
            if (list && (!fired || stack)) {
              args = args || []
              args = [context, args.slice ? args.slice() : args]
              if (firing) stack.push(args)
              else fire(args)
            }
            return this
          },
          fire: function() {
            return Callbacks.fireWith(this, arguments)
          },
          fired: function() {
            return !!fired
          }
        }

    return Callbacks
  }
})(Zepto)

;(function($){
  var slice = Array.prototype.slice

  function Deferred(func) {
    var tuples = [
          // action, add listener, listener list, final state
          [ "resolve", "done", $.Callbacks({once:1, memory:1}), "resolved" ],
          [ "reject", "fail", $.Callbacks({once:1, memory:1}), "rejected" ],
          [ "notify", "progress", $.Callbacks({memory:1}) ]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state
          },
          always: function() {
            deferred.done(arguments).fail(arguments)
            return this
          },
          then: function(/* fnDone [, fnFailed [, fnProgress]] */) {
            var fns = arguments
            return Deferred(function(defer){
              $.each(tuples, function(i, tuple){
                var fn = $.isFunction(fns[i]) && fns[i]
                deferred[tuple[1]](function(){
                  var returned = fn && fn.apply(this, arguments)
                  if (returned && $.isFunction(returned.promise)) {
                    returned.promise()
                      .done(defer.resolve)
                      .fail(defer.reject)
                      .progress(defer.notify)
                  } else {
                    var context = this === promise ? defer.promise() : this,
                        values = fn ? [returned] : arguments
                    defer[tuple[0] + "With"](context, values)
                  }
                })
              })
              fns = null
            }).promise()
          },

          promise: function(obj) {
            return obj != null ? $.extend( obj, promise ) : promise
          }
        },
        deferred = {}

    $.each(tuples, function(i, tuple){
      var list = tuple[2],
          stateString = tuple[3]

      promise[tuple[1]] = list.add

      if (stateString) {
        list.add(function(){
          state = stateString
        }, tuples[i^1][2].disable, tuples[2][2].lock)
      }

      deferred[tuple[0]] = function(){
        deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments)
        return this
      }
      deferred[tuple[0] + "With"] = list.fireWith
    })

    promise.promise(deferred)
    if (func) func.call(deferred, deferred)
    return deferred
  }

  $.when = function(sub) {
    var resolveValues = slice.call(arguments),
        len = resolveValues.length,
        i = 0,
        remain = len !== 1 || (sub && $.isFunction(sub.promise)) ? len : 0,
        deferred = remain === 1 ? sub : Deferred(),
        progressValues, progressContexts, resolveContexts,
        updateFn = function(i, ctx, val){
          return function(value){
            ctx[i] = this
            val[i] = arguments.length > 1 ? slice.call(arguments) : value
            if (val === progressValues) {
              deferred.notifyWith(ctx, val)
            } else if (!(--remain)) {
              deferred.resolveWith(ctx, val)
            }
          }
        }

    if (len > 1) {
      progressValues = new Array(len)
      progressContexts = new Array(len)
      resolveContexts = new Array(len)
      for ( ; i < len; ++i ) {
        if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {
          resolveValues[i].promise()
            .done(updateFn(i, resolveContexts, resolveValues))
            .fail(deferred.reject)
            .progress(updateFn(i, progressContexts, progressValues))
        } else {
          --remain
        }
      }
    }
    if (!remain) deferred.resolveWith(resolveContexts, resolveValues)
    return deferred.promise()
  }

  $.Deferred = Deferred
})(Zepto)

;(function($){
  var _zid = 1, undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function(obj){ return typeof obj == 'string' },
      handlers = {},
      specialEvents={},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event)
    if (event.ns) var matcher = matcherFor(event.ns)
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.')
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eventCapture(handler, captureSetting) {
    return handler.del &&
      (!focusinSupported && (handler.e in focus)) ||
      !!captureSetting
  }

  function realEvent(type) {
    return hover[type] || (focusinSupported && focus[type]) || type
  }

  function add(element, events, fn, data, selector, delegator, capture){
    var id = zid(element), set = (handlers[id] || (handlers[id] = []))
    events.split(/\s/).forEach(function(event){
      if (event == 'ready') return $(document).ready(fn)
      var handler   = parse(event)
      handler.fn    = fn
      handler.sel   = selector
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function(e){
        var related = e.relatedTarget
        if (!related || (related !== this && !$.contains(this, related)))
          return handler.fn.apply(this, arguments)
      }
      handler.del   = delegator
      var callback  = delegator || fn
      handler.proxy = function(e){
        e = compatible(e)
        if (e.isImmediatePropagationStopped()) return
        e.data = data
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))
        if (result === false) e.preventDefault(), e.stopPropagation()
        return result
      }
      handler.i = set.length
      set.push(handler)
      if ('addEventListener' in element)
        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
    })
  }
  function remove(element, events, fn, selector, capture){
    var id = zid(element)
    ;(events || '').split(/\s/).forEach(function(event){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i]
      if ('removeEventListener' in element)
        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
      })
    })
  }

  $.event = { add: add, remove: remove }

  $.proxy = function(fn, context) {
    var args = (2 in arguments) && slice.call(arguments, 2)
    if (isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }
      proxyFn._zid = zid(fn)
      return proxyFn
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn)
        return $.proxy.apply(null, args)
      } else {
        return $.proxy(fn[context], fn)
      }
    } else {
      throw new TypeError("expected function")
    }
  }

  $.fn.bind = function(event, data, callback){
    return this.on(event, data, callback)
  }
  $.fn.unbind = function(event, callback){
    return this.off(event, callback)
  }
  $.fn.one = function(event, selector, data, callback){
    return this.on(event, selector, data, callback, 1)
  }

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      }

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event)

      $.each(eventMethods, function(name, predicate) {
        var sourceMethod = source[name]
        event[name] = function(){
          this[predicate] = returnTrue
          return sourceMethod && sourceMethod.apply(source, arguments)
        }
        event[predicate] = returnFalse
      })

      event.timeStamp || (event.timeStamp = Date.now())

      if (source.defaultPrevented !== undefined ? source.defaultPrevented :
          'returnValue' in source ? source.returnValue === false :
          source.getPreventDefault && source.getPreventDefault())
        event.isDefaultPrevented = returnTrue
    }
    return event
  }

  function createProxy(event) {
    var key, proxy = { originalEvent: event }
    for (key in event)
      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]

    return compatible(proxy, event)
  }

  $.fn.delegate = function(selector, event, callback){
    return this.on(event, selector, callback)
  }
  $.fn.undelegate = function(selector, event, callback){
    return this.off(event, selector, callback)
  }

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback)
    return this
  }
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback)
    return this
  }

  $.fn.on = function(event, selector, data, callback, one){
    var autoRemove, delegator, $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.on(type, selector, data, fn, one)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = data, data = selector, selector = undefined
    if (callback === undefined || data === false)
      callback = data, data = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(_, element){
      if (one) autoRemove = function(e){
        remove(element, e.type, callback)
        return callback.apply(this, arguments)
      }

      if (selector) delegator = function(e){
        var evt, match = $(e.target).closest(selector, element).get(0)
        if (match && match !== element) {
          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
        }
      }

      add(element, event, callback, data, selector, delegator || autoRemove)
    })
  }
  $.fn.off = function(event, selector, callback){
    var $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.off(type, selector, fn)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = selector, selector = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(){
      remove(this, event, callback, selector)
    })
  }

  $.fn.trigger = function(event, args){
    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)
    event._args = args
    return this.each(function(){
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]()
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) this.dispatchEvent(event)
      else $(this).triggerHandler(event, args)
    })
  }

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, args){
    var e, result
    this.each(function(i, element){
      e = createProxy(isString(event) ? $.Event(event) : event)
      e._args = args
      e.target = element
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e)
        if (e.isImmediatePropagationStopped()) return false
      })
    })
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback) {
      return (0 in arguments) ?
        this.bind(event, callback) :
        this.trigger(event)
    }
  })

  $.Event = function(type, props) {
    if (!isString(type)) props = type, type = props.type
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
    event.initEvent(type, bubbles, true)
    return compatible(event)
  }

})(Zepto)

;(function(){
  // getComputedStyle shouldn't freak out when called
  // without a valid element as argument
  try {
    getComputedStyle(undefined)
  } catch(e) {
    var nativeGetComputedStyle = getComputedStyle
    window.getComputedStyle = function(element, pseudoElement){
      try {
        return nativeGetComputedStyle(element, pseudoElement)
      } catch(e) {
        return null
      }
    }
  }
})()

;(function($){
  var zepto = $.zepto, oldQsa = zepto.qsa, oldMatches = zepto.matches

  function visible(elem){
    elem = $(elem)
    return !!(elem.width() || elem.height()) && elem.css("display") !== "none"
  }

  // Implements a subset from:
  // http://api.jquery.com/category/selectors/jquery-selector-extensions/
  //
  // Each filter function receives the current index, all nodes in the
  // considered set, and a value if there were parentheses. The value
  // of `this` is the node currently being considered. The function returns the
  // resulting node(s), null, or undefined.
  //
  // Complex selectors are not supported:
  //   li:has(label:contains("foo")) + li:has(label:contains("bar"))
  //   ul.inner:first > li
  var filters = $.expr[':'] = {
    visible:  function(){ if (visible(this)) return this },
    hidden:   function(){ if (!visible(this)) return this },
    selected: function(){ if (this.selected) return this },
    checked:  function(){ if (this.checked) return this },
    parent:   function(){ return this.parentNode },
    first:    function(idx){ if (idx === 0) return this },
    last:     function(idx, nodes){ if (idx === nodes.length - 1) return this },
    eq:       function(idx, _, value){ if (idx === value) return this },
    contains: function(idx, _, text){ if ($(this).text().indexOf(text) > -1) return this },
    has:      function(idx, _, sel){ if (zepto.qsa(this, sel).length) return this }
  }

  var filterRe = new RegExp('(.*):(\\w+)(?:\\(([^)]+)\\))?$\\s*'),
      childRe  = /^\s*>/,
      classTag = 'Zepto' + (+new Date())

  function process(sel, fn) {
    // quote the hash in `a[href^=#]` expression
    sel = sel.replace(/=#\]/g, '="#"]')
    var filter, arg, match = filterRe.exec(sel)
    if (match && match[2] in filters) {
      filter = filters[match[2]], arg = match[3]
      sel = match[1]
      if (arg) {
        var num = Number(arg)
        if (isNaN(num)) arg = arg.replace(/^["']|["']$/g, '')
        else arg = num
      }
    }
    return fn(sel, filter, arg)
  }

  zepto.qsa = function(node, selector) {
    return process(selector, function(sel, filter, arg){
      try {
        var taggedParent
        if (!sel && filter) sel = '*'
        else if (childRe.test(sel))
          // support "> *" child queries by tagging the parent node with a
          // unique class and prepending that classname onto the selector
          taggedParent = $(node).addClass(classTag), sel = '.'+classTag+' '+sel

        var nodes = oldQsa(node, sel)
      } catch(e) {
        console.error('error performing selector: %o', selector)
        throw e
      } finally {
        if (taggedParent) taggedParent.removeClass(classTag)
      }
      return !filter ? nodes :
        zepto.uniq($.map(nodes, function(n, i){ return filter.call(n, i, nodes, arg) }))
    })
  }

  zepto.matches = function(node, selector){
    return process(selector, function(sel, filter, arg){
      return (!sel || oldMatches(node, sel)) &&
        (!filter || filter.call(node, null, arg) === node)
    })
  }
})(Zepto)
module.exports = Zepto


/***/ }),

/***/ "./node_modules/core-js/library/fn/array/from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/es6.array.from */ "./node_modules/core-js/library/modules/es6.array.from.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.from;


/***/ }),

/***/ "./node_modules/core-js/library/fn/get-iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/get-iterator.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ "./node_modules/core-js/library/modules/core.get-iterator.js");


/***/ }),

/***/ "./node_modules/core-js/library/fn/json/stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/json/stringify.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js");
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/create.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.create */ "./node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.keys */ "./node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.keys;


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/set-prototype-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.set-prototype-of */ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.setPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Symbol;


/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_create-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_create-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-keys.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-detect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopd.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn-ext.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-sap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-proto.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-proto.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-define.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var get = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.from.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.from.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/library/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.create.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.create.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.keys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.keys.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.set-prototype-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/library/modules/_set-proto.js").set });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.symbol.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.observable.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/container/public/style.scss":
/*!***************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/container/public/style.scss ***!
  \***************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".container[data-container] {\n  position: absolute;\n  background-color: black;\n  height: 100%;\n  width: 100%;\n  max-width: 100%; }\n  .container[data-container] .chromeless {\n    cursor: default; }\n\n[data-player]:not(.nocursor) .container[data-container]:not(.chromeless).pointer-enabled {\n  cursor: pointer; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/core/public/style.scss":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/core/public/style.scss ***!
  \**********************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[data-player] {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  transform: translate3d(0, 0, 0);\n  position: relative;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-style: normal;\n  font-weight: normal;\n  text-align: center;\n  overflow: hidden;\n  font-size: 100%;\n  font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n  text-shadow: 0 0 0;\n  box-sizing: border-box; }\n  [data-player] div, [data-player] span, [data-player] applet, [data-player] object, [data-player] iframe,\n  [data-player] h1, [data-player] h2, [data-player] h3, [data-player] h4, [data-player] h5, [data-player] h6, [data-player] p, [data-player] blockquote, [data-player] pre,\n  [data-player] a, [data-player] abbr, [data-player] acronym, [data-player] address, [data-player] big, [data-player] cite, [data-player] code,\n  [data-player] del, [data-player] dfn, [data-player] em, [data-player] img, [data-player] ins, [data-player] kbd, [data-player] q, [data-player] s, [data-player] samp,\n  [data-player] small, [data-player] strike, [data-player] strong, [data-player] sub, [data-player] sup, [data-player] tt, [data-player] var,\n  [data-player] b, [data-player] u, [data-player] i, [data-player] center,\n  [data-player] dl, [data-player] dt, [data-player] dd, [data-player] ol, [data-player] ul, [data-player] li,\n  [data-player] fieldset, [data-player] form, [data-player] label, [data-player] legend,\n  [data-player] table, [data-player] caption, [data-player] tbody, [data-player] tfoot, [data-player] thead, [data-player] tr, [data-player] th, [data-player] td,\n  [data-player] article, [data-player] aside, [data-player] canvas, [data-player] details, [data-player] embed,\n  [data-player] figure, [data-player] figcaption, [data-player] footer, [data-player] header, [data-player] hgroup,\n  [data-player] menu, [data-player] nav, [data-player] output, [data-player] ruby, [data-player] section, [data-player] summary,\n  [data-player] time, [data-player] mark, [data-player] audio, [data-player] video {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font: inherit;\n    font-size: 100%;\n    vertical-align: baseline; }\n  [data-player] table {\n    border-collapse: collapse;\n    border-spacing: 0; }\n  [data-player] caption, [data-player] th, [data-player] td {\n    text-align: left;\n    font-weight: normal;\n    vertical-align: middle; }\n  [data-player] q, [data-player] blockquote {\n    quotes: none; }\n    [data-player] q:before, [data-player] q:after, [data-player] blockquote:before, [data-player] blockquote:after {\n      content: \"\";\n      content: none; }\n  [data-player] a img {\n    border: none; }\n  [data-player]:focus {\n    outline: 0; }\n  [data-player] * {\n    max-width: none;\n    box-sizing: inherit;\n    float: none; }\n  [data-player] div {\n    display: block; }\n  [data-player].fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    top: 0;\n    left: 0; }\n  [data-player].nocursor {\n    cursor: none; }\n\n.clappr-style {\n  display: none !important; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html5_video/public/style.scss":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html5_video/public/style.scss ***!
  \****************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[data-html5-video] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: block; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html_img/public/style.scss":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html_img/public/style.scss ***!
  \*************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[data-html-img] {\n  max-width: 100%;\n  max-height: 100%; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/no_op/public/style.scss":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/no_op/public/style.scss ***!
  \**********************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "[data-no-op] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  text-align: center; }\n\n[data-no-op] p[data-no-op-msg] {\n  position: absolute;\n  text-align: center;\n  font-size: 25px;\n  left: 0;\n  right: 0;\n  color: white;\n  padding: 10px;\n  /* center vertically */\n  top: 50%;\n  transform: translateY(-50%);\n  max-height: 100%;\n  overflow: auto; }\n\n[data-no-op] canvas[data-no-op-canvas] {\n  background-color: #777;\n  height: 100%;\n  width: 100%; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/closed_captions/public/closed_captions.scss":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/closed_captions/public/closed_captions.scss ***!
  \****************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".cc-controls[data-cc-controls] {\n  float: right;\n  position: relative;\n  display: none; }\n  .cc-controls[data-cc-controls].available {\n    display: block; }\n  .cc-controls[data-cc-controls] .cc-button {\n    padding: 6px !important; }\n    .cc-controls[data-cc-controls] .cc-button.enabled {\n      display: block;\n      opacity: 1.0; }\n      .cc-controls[data-cc-controls] .cc-button.enabled:hover {\n        opacity: 1.0;\n        text-shadow: none; }\n  .cc-controls[data-cc-controls] > ul {\n    list-style-type: none;\n    position: absolute;\n    bottom: 25px;\n    border: 1px solid black;\n    display: none;\n    background-color: #e6e6e6; }\n  .cc-controls[data-cc-controls] li {\n    font-size: 10px; }\n    .cc-controls[data-cc-controls] li[data-title] {\n      background-color: #c3c2c2;\n      padding: 5px; }\n    .cc-controls[data-cc-controls] li a {\n      color: #444;\n      padding: 2px 10px;\n      display: block;\n      text-decoration: none; }\n      .cc-controls[data-cc-controls] li a:hover {\n        background-color: #555;\n        color: white; }\n        .cc-controls[data-cc-controls] li a:hover a {\n          color: white;\n          text-decoration: none; }\n    .cc-controls[data-cc-controls] li.current a {\n      color: #f00; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/dvr_controls/public/dvr_controls.scss":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/dvr_controls/public/dvr_controls.scss ***!
  \**********************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".dvr-controls[data-dvr-controls] {\n  display: inline-block;\n  float: left;\n  color: #fff;\n  line-height: 32px;\n  font-size: 10px;\n  font-weight: bold;\n  margin-left: 6px; }\n  .dvr-controls[data-dvr-controls] .live-info {\n    cursor: default;\n    font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n    text-transform: uppercase; }\n    .dvr-controls[data-dvr-controls] .live-info:before {\n      content: \"\";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #ff0101; }\n    .dvr-controls[data-dvr-controls] .live-info.disabled {\n      opacity: 0.3; }\n      .dvr-controls[data-dvr-controls] .live-info.disabled:before {\n        background-color: #fff; }\n  .dvr-controls[data-dvr-controls] .live-button {\n    cursor: pointer;\n    outline: none;\n    display: none;\n    border: 0;\n    color: #fff;\n    background-color: transparent;\n    height: 32px;\n    padding: 0;\n    opacity: 0.7;\n    font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n    text-transform: uppercase;\n    transition: all 0.1s ease; }\n    .dvr-controls[data-dvr-controls] .live-button:before {\n      content: \"\";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #fff; }\n    .dvr-controls[data-dvr-controls] .live-button:hover {\n      opacity: 1;\n      text-shadow: rgba(255, 255, 255, 0.75) 0 0 5px; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-info {\n  display: none; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-button {\n  display: block; }\n\n.dvr.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #005aff; }\n\n.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #ff0101; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/error_screen/public/error_screen.scss":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/error_screen/public/error_screen.scss ***!
  \**********************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "div.player-error-screen {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #CCCACA;\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 100%;\n  background-color: rgba(0, 0, 0, 0.7);\n  z-index: 2000;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  -ms-flex-pack: center;\n      justify-content: center; }\n  div.player-error-screen__content[data-error-screen] {\n    font-size: 14px;\n    color: #CCCACA;\n    margin-top: 45px; }\n  div.player-error-screen__title[data-error-screen] {\n    font-weight: bold;\n    line-height: 30px;\n    font-size: 18px; }\n  div.player-error-screen__message[data-error-screen] {\n    width: 90%;\n    margin: 0 auto; }\n  div.player-error-screen__code[data-error-screen] {\n    font-size: 13px;\n    margin-top: 15px; }\n  div.player-error-screen__reload {\n    cursor: pointer;\n    width: 30px;\n    margin: 15px auto 0; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/media_control/public/media-control.scss":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/media_control/public/media-control.scss ***!
  \************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/poster/public/poster.scss":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/poster/public/poster.scss ***!
  \**********************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".player-poster[data-poster] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-pack: center;\n      justify-content: center;\n  -ms-flex-align: center;\n      align-items: center;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 998;\n  top: 0;\n  left: 0;\n  background-color: #000;\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-position: 50% 50%; }\n  .player-poster[data-poster].clickable {\n    cursor: pointer; }\n  .player-poster[data-poster]:hover .play-wrapper[data-poster] {\n    opacity: 1; }\n  .player-poster[data-poster] .play-wrapper[data-poster] {\n    width: 100%;\n    height: 25%;\n    margin: 0 auto;\n    opacity: 0.75;\n    transition: opacity 0.1s ease; }\n    .player-poster[data-poster] .play-wrapper[data-poster] svg {\n      height: 100%; }\n      .player-poster[data-poster] .play-wrapper[data-poster] svg path {\n        fill: #fff; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/seek_time/public/seek_time.scss":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/seek_time/public/seek_time.scss ***!
  \****************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".seek-time[data-seek-time] {\n  position: absolute;\n  white-space: nowrap;\n  height: 20px;\n  line-height: 20px;\n  font-size: 0;\n  left: -100%;\n  bottom: 55px;\n  background-color: rgba(2, 2, 2, 0.5);\n  z-index: 9999;\n  transition: opacity 0.1s ease; }\n  .seek-time[data-seek-time].hidden[data-seek-time] {\n    opacity: 0; }\n  .seek-time[data-seek-time] [data-seek-time] {\n    display: inline-block;\n    color: white;\n    font-size: 10px;\n    padding-left: 7px;\n    padding-right: 7px;\n    vertical-align: top; }\n  .seek-time[data-seek-time] [data-duration] {\n    display: inline-block;\n    color: rgba(255, 255, 255, 0.5);\n    font-size: 10px;\n    padding-right: 7px;\n    vertical-align: top; }\n    .seek-time[data-seek-time] [data-duration]:before {\n      content: \"|\";\n      margin-right: 7px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/spinner_three_bounce/public/spinner.scss":
/*!*************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/spinner_three_bounce/public/spinner.scss ***!
  \*************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".spinner-three-bounce[data-spinner] {\n  position: absolute;\n  margin: 0 auto;\n  width: 70px;\n  text-align: center;\n  z-index: 999;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n  /* center vertically */\n  top: 50%;\n  transform: translateY(-50%); }\n  .spinner-three-bounce[data-spinner] > div {\n    width: 18px;\n    height: 18px;\n    background-color: #FFFFFF;\n    border-radius: 100%;\n    display: inline-block;\n    animation: bouncedelay 1.4s infinite ease-in-out;\n    /* Prevent first frame from flickering when animation starts */\n    animation-fill-mode: both; }\n  .spinner-three-bounce[data-spinner] [data-bounce1] {\n    animation-delay: -0.32s; }\n  .spinner-three-bounce[data-spinner] [data-bounce2] {\n    animation-delay: -0.16s; }\n\n@keyframes bouncedelay {\n  0%, 80%, 100% {\n    transform: scale(0); }\n  40% {\n    transform: scale(1); } }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/watermark/public/watermark.scss":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/lib!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/watermark/public/watermark.scss ***!
  \****************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".clappr-watermark[data-watermark] {\n  position: absolute;\n  min-width: 70px;\n  max-width: 200px;\n  width: 12%;\n  text-align: center;\n  z-index: 10; }\n\n.clappr-watermark[data-watermark] a {\n  outline: none;\n  cursor: pointer; }\n\n.clappr-watermark[data-watermark] img {\n  max-width: 100%; }\n\n.clappr-watermark[data-watermark-bottom-left] {\n  bottom: 10px;\n  left: 10px; }\n\n.clappr-watermark[data-watermark-bottom-right] {\n  bottom: 10px;\n  right: 42px; }\n\n.clappr-watermark[data-watermark-top-left] {\n  top: 10px;\n  left: 10px; }\n\n.clappr-watermark[data-watermark-top-right] {\n  top: 10px;\n  right: 37px; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),

/***/ "./node_modules/hls.js/dist/hls.js":
/*!*****************************************!*\
  !*** ./node_modules/hls.js/dist/hls.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

typeof window !== "undefined" &&
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/hls.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/url-toolkit/src/url-toolkit.js":
/*!*****************************************************!*\
  !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

(function (root) {
  var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#.*)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;

  var URLToolkit = {
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function (baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = URLToolkit.parseURL(baseURL);
        if (!basePartsForNormalise) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(
          basePartsForNormalise.path
        );
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = URLToolkit.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = URLToolkit.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath =
              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
              relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
          ? URLToolkit.normalizePath(relativeParts.path)
          : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function (url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || '',
      };
    },
    normalizePath: function (path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (
        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length
      ) {}
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function (parts) {
      return (
        parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment
      );
    },
  };

  if (true)
    module.exports = URLToolkit;
  else {}
})(this);


/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // define __esModule on exports
/******/  __webpack_require__.r = function(exports) {
/******/    Object.defineProperty(exports, '__esModule', { value: true });
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

var moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@]+'
var dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)' // additional chars when output.pathinfo is true

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function isNumeric(n) {
  return !isNaN(1 * n); // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
}

function getModuleDependencies (sources, module, queueName) {
  var retval = {}
  retval[queueName] = []

  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval
  var webpackRequireName = wrapperSignature[1]

  // main bundle deps
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')
  var match
  while ((match = re.exec(fnString))) {
    if (match[3] === 'dll-reference') continue
    retval[queueName].push(match[3])
  }

  // dll deps
  re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g')
  while ((match = re.exec(fnString))) {
    if (!sources[match[2]]) {
      retval[queueName].push(match[1])
      sources[match[2]] = __webpack_require__(match[1]).m
    }
    retval[match[2]] = retval[match[2]] || []
    retval[match[2]].push(match[4])
  }

  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
  var keys = Object.keys(retval);
  for (var i = 0; i < keys.length; i++) {
    for (var j = 0; j < retval[keys[i]].length; j++) {
      if (isNumeric(retval[keys[i]][j])) {
        retval[keys[i]][j] = 1 * retval[keys[i]][j];
      }
    }
  }

  return retval
}

function hasValuesInQueues (queues) {
  var keys = Object.keys(queues)
  return keys.reduce(function (hasValues, key) {
    return hasValues || queues[key].length > 0
  }, false)
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = {
    main: [moduleId]
  }
  var requiredModules = {
    main: []
  }
  var seenModules = {
    main: {}
  }

  while (hasValuesInQueues(modulesQueue)) {
    var queues = Object.keys(modulesQueue)
    for (var i = 0; i < queues.length; i++) {
      var queueName = queues[i]
      var queue = modulesQueue[queueName]
      var moduleToCheck = queue.pop()
      seenModules[queueName] = seenModules[queueName] || {}
      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue
      seenModules[queueName][moduleToCheck] = true
      requiredModules[queueName] = requiredModules[queueName] || []
      requiredModules[queueName].push(moduleToCheck)
      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)
      var newModulesKeys = Object.keys(newModules)
      for (var j = 0; j < newModulesKeys.length; j++) {
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []
        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])
      }
    }
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = {
    main: __webpack_require__.m
  }

  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)

  var src = ''

  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {
    var entryModule = 0
    while (requiredModules[module][entryModule]) {
      entryModule++
    }
    requiredModules[module].push(entryModule)
    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'
    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\n'
  })

  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/*! exports provided: hlsDefaultConfig, mergeConfig, enableStreamingMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hlsDefaultConfig", function() { return hlsDefaultConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeConfig", function() { return mergeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableStreamingMode", function() { return enableStreamingMode; });
/* harmony import */ var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller/abr-controller */ "./src/controller/abr-controller.ts");
/* harmony import */ var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controller/audio-stream-controller */ "./src/controller/audio-stream-controller.ts");
/* harmony import */ var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./controller/audio-track-controller */ "./src/controller/audio-track-controller.ts");
/* harmony import */ var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controller/subtitle-stream-controller */ "./src/controller/subtitle-stream-controller.ts");
/* harmony import */ var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controller/subtitle-track-controller */ "./src/controller/subtitle-track-controller.ts");
/* harmony import */ var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controller/buffer-controller */ "./src/controller/buffer-controller.ts");
/* harmony import */ var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controller/timeline-controller */ "./src/controller/timeline-controller.ts");
/* harmony import */ var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controller/cap-level-controller */ "./src/controller/cap-level-controller.ts");
/* harmony import */ var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./controller/fps-controller */ "./src/controller/fps-controller.ts");
/* harmony import */ var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./controller/eme-controller */ "./src/controller/eme-controller.ts");
/* harmony import */ var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/xhr-loader */ "./src/utils/xhr-loader.ts");
/* harmony import */ var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/fetch-loader */ "./src/utils/fetch-loader.ts");
/* harmony import */ var _utils_cues__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/cues */ "./src/utils/cues.ts");
/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/mediakeys-helper */ "./src/utils/mediakeys-helper.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.ts");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















// If possible, keep hlsDefaultConfig shallow
// It is cloned whenever a new Hls instance is created, by keeping the config
// shallow the properties are cloned, and we don't end up manipulating the default
var hlsDefaultConfig = _objectSpread(_objectSpread({
  autoStartLoad: true,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: undefined,
  // used by stream-controller
  debug: false,
  // used by logger
  capLevelOnFPSDrop: false,
  // used by fps-controller
  capLevelToPlayerSize: false,
  // used by cap-level-controller
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller
  highBufferWatchdogPeriod: 2,
  // used by stream-controller
  nudgeOffset: 0.1,
  // used by stream-controller
  nudgeMaxRetry: 3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveMaxLatencyDurationCount: Infinity,
  // used by latency-controller
  liveSyncDuration: undefined,
  // used by latency-controller
  liveMaxLatencyDuration: undefined,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1.25,
  // used by latency-controller
  liveDurationInfinity: false,
  // used by buffer-controller
  liveBackBufferLength: Infinity,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: true,
  // used by demuxer
  enableSoftwareAES: true,
  // used by decrypter
  manifestLoadingTimeOut: 10000,
  // used by playlist-loader
  manifestLoadingMaxRetry: 1,
  // used by playlist-loader
  manifestLoadingRetryDelay: 1000,
  // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000,
  // used by playlist-loader
  startLevel: undefined,
  // used by level-controller
  levelLoadingTimeOut: 10000,
  // used by playlist-loader
  levelLoadingMaxRetry: 4,
  // used by playlist-loader
  levelLoadingRetryDelay: 1000,
  // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000,
  // used by playlist-loader
  fragLoadingTimeOut: 20000,
  // used by fragment-loader
  fragLoadingMaxRetry: 6,
  // used by fragment-loader
  fragLoadingRetryDelay: 1000,
  // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000,
  // used by fragment-loader
  startFragPrefetch: false,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_10__["default"],
  // loader: FetchLoader,
  fLoader: undefined,
  // used by fragment-loader
  pLoader: undefined,
  // used by playlist-loader
  xhrSetup: undefined,
  // used by xhr-loader
  licenseXhrSetup: undefined,
  // used by eme-controller
  abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__["default"],
  bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__["default"],
  capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__["default"],
  fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__["default"],
  stretchShortVideoTrack: false,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: false,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: false,
  // used by eme-controller
  widevineLicenseUrl: undefined,
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_13__["requestMediaKeySystemAccess"],
  // used by eme-controller
  testBandwidth: true,
  progressive: false,
  lowLatencyMode: true
}, timelineConfig()), {}, {
  subtitleStreamController:  true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__["SubtitleStreamController"] : undefined,
  subtitleTrackController:  true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__["default"] : undefined,
  timelineController:  true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__["TimelineController"] : undefined,
  audioStreamController:  true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"] : undefined,
  audioTrackController:  true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__["default"] : undefined,
  emeController:  true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__["default"] : undefined
});

function timelineConfig() {
  return {
    cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_12__,
    // used by timeline-controller
    enableCEA708Captions: true,
    // used by timeline-controller
    enableWebVTT: true,
    // used by timeline-controller
    enableIMSC1: true,
    // used by timeline-controller
    captionsTextTrack1Label: 'English',
    // used by timeline-controller
    captionsTextTrack1LanguageCode: 'en',
    // used by timeline-controller
    captionsTextTrack2Label: 'Spanish',
    // used by timeline-controller
    captionsTextTrack2LanguageCode: 'es',
    // used by timeline-controller
    captionsTextTrack3Label: 'Unknown CC',
    // used by timeline-controller
    captionsTextTrack3LanguageCode: '',
    // used by timeline-controller
    captionsTextTrack4Label: 'Unknown CC',
    // used by timeline-controller
    captionsTextTrack4LanguageCode: '',
    // used by timeline-controller
    renderTextTracksNatively: true
  };
}

function mergeConfig(defaultConfig, userConfig) {
  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  }

  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  }

  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  }

  return _extends({}, defaultConfig, userConfig);
}
function enableStreamingMode(config) {
  var currentLoader = config.loader;

  if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_11__["default"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_10__["default"]) {
    // If a developer has configured their own loader, respect that choice
    _utils_logger__WEBPACK_IMPORTED_MODULE_14__["logger"].log('[config]: Custom loader detected, cannot enable progressive streaming');
    config.progressive = false;
  } else {
    var canStreamProgressively = Object(_utils_fetch_loader__WEBPACK_IMPORTED_MODULE_11__["fetchSupported"])();

    if (canStreamProgressively) {
      config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_11__["default"];
      config.progressive = true;
      config.enableSoftwareAES = true;
      _utils_logger__WEBPACK_IMPORTED_MODULE_14__["logger"].log('[config]: Progressive streaming enabled, using FetchLoader');
    }
  }
}

/***/ }),

/***/ "./src/controller/abr-controller.ts":
/*!******************************************!*\
  !*** ./src/controller/abr-controller.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ewma-bandwidth-estimator */ "./src/utils/ewma-bandwidth-estimator.ts");



function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * simple ABR Controller
 *  - compute next level based on last fragment bw heuristics
 *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */






var AbrController = /*#__PURE__*/function () {
  function AbrController(hls) {
    this.hls = void 0;
    this.lastLoadedFragLevel = 0;
    this._nextAutoLevel = -1;
    this.timer = void 0;
    this.onCheck = this._abandonRulesCheck.bind(this);
    this.fragCurrent = null;
    this.partCurrent = null;
    this.bitrateTestDelay = 0;
    this.bwEstimator = void 0;
    this.hls = hls;
    var config = hls.config;
    this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_5__["default"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
    this.registerListeners();
  }

  var _proto = AbrController.prototype;

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADING, this.onFragLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADING, this.onFragLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
  };

  _proto.destroy = function destroy() {
    this.unregisterListeners();
    this.clearTimer();
  };

  _proto.onFragLoading = function onFragLoading(event, data) {
    var frag = data.frag;

    if (frag.type === 'main') {
      if (!this.timer) {
        var _data$part;

        this.fragCurrent = frag;
        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
        this.timer = self.setInterval(this.onCheck, 100);
      }
    }
  };

  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
    var config = this.hls.config;

    if (data.details.live) {
      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
    } else {
      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
    }
  }
  /*
      This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load
      quickly enough to prevent underbuffering
    */
  ;

  _proto._abandonRulesCheck = function _abandonRulesCheck() {
    var frag = this.fragCurrent,
        part = this.partCurrent,
        hls = this.hls;
    var autoLevelEnabled = hls.autoLevelEnabled,
        config = hls.config,
        media = hls.media;

    if (!frag || !media) {
      return;
    }

    var stats = part ? part.stats : frag.stats;
    var duration = part ? part.duration : frag.duration; // If loading has been aborted and not in lowLatencyMode, stop timer and return

    if (stats.aborted) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn('frag loader destroy or aborted, disarm abandonRules');
      this.clearTimer(); // reset forced auto level value so that next level will be selected

      this._nextAutoLevel = -1;
      return;
    } // This check only runs if we're in ABR mode and actually playing


    if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
      return;
    }

    var requestDelay = performance.now() - stats.loading.start;
    var playbackRate = Math.abs(media.playbackRate); // In order to work with a stable bandwidth, only begin monitoring bandwidth after half of the fragment has been loaded

    if (requestDelay <= 500 * duration / playbackRate) {
      return;
    }

    var levels = hls.levels,
        minAutoLevel = hls.minAutoLevel;
    var level = levels[frag.level];
    var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));
    var loadRate = Math.max(1, stats.bwEstimate ? stats.bwEstimate / 8 : stats.loaded * 1000 / requestDelay); // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the entire fragment

    var fragLoadedDelay = (expectedLen - stats.loaded) / loadRate;
    var pos = media.currentTime; // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer

    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__["BufferHelper"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // Attempt an emergency downswitch only if less than 2 fragment lengths are buffered, and the time to finish loading
    // the current fragment is greater than the amount of buffer we have left

    if (bufferStarvationDelay >= 2 * duration / playbackRate || fragLoadedDelay <= bufferStarvationDelay) {
      return;
    }

    var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
    var nextLoadLevel; // Iterate through lower level and try to find the largest one that avoids rebuffering

    for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
      // compute time to load next fragment at lower level
      // 0.8 : consider only 80% of current bw to be conservative
      // 8 = bits per byte (bps/Bps)
      var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
      fragLevelNextLoadedDelay = duration * levelNextBitrate / (8 * 0.8 * loadRate);

      if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
        break;
      }
    } // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing
    // to load the current one


    if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
      return;
    }

    var bwEstimate = this.bwEstimator.getEstimate();
    _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn("Fragment " + frag.sn + (part ? ' part ' + part.index : '') + " of level " + frag.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + nextLoadLevel + "\n      Current BW estimate: " + (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : 'Unknown') + " Kb/s\n      Estimated load time for current fragment: " + fragLoadedDelay.toFixed(3) + " s\n      Estimated load time for the next fragment: " + fragLevelNextLoadedDelay.toFixed(3) + " s\n      Time to underbuffer: " + bufferStarvationDelay.toFixed(3) + " s");
    hls.nextLoadLevel = nextLoadLevel;
    this.bwEstimator.sample(requestDelay, stats.loaded);
    this.clearTimer();

    if (frag.loader) {
      this.fragCurrent = this.partCurrent = null;
      frag.loader.abort();
    }

    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, {
      frag: frag,
      part: part,
      stats: stats
    });
  };

  _proto.onFragLoaded = function onFragLoaded(event, _ref) {
    var frag = _ref.frag,
        part = _ref.part;

    if (frag.type === 'main' && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.sn)) {
      var stats = part ? part.stats : frag.stats;
      var duration = part ? part.duration : frag.duration; // stop monitoring bw once frag loaded

      this.clearTimer(); // store level id after successful fragment load

      this.lastLoadedFragLevel = frag.level; // reset forced auto level value so that next level will be selected

      this._nextAutoLevel = -1; // compute level average bitrate

      if (this.hls.config.abrMaxWithRealBitrate) {
        var level = this.hls.levels[frag.level];
        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
        level.loaded = {
          bytes: loadedBytes,
          duration: loadedDuration
        };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }

      if (frag.bitrateTest) {
        var fragBufferedData = {
          stats: stats,
          frag: frag,
          part: part,
          id: frag.type
        };
        this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_BUFFERED, fragBufferedData);
      }
    }
  };

  _proto.onFragBuffered = function onFragBuffered(event, data) {
    var frag = data.frag,
        part = data.part;
    var stats = part ? part.stats : frag.stats;

    if (stats.aborted) {
      return;
    } // Only count non-alt-audio frags which were actually buffered in our BW calculations


    if (frag.type !== 'main' || frag.sn === 'initSegment' || frag.bitrateTest) {
      return;
    } // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;
    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch
    // is used. If we used buffering in that case, our BW estimate sample will be very large.


    var processingMs = stats.parsing.end - stats.loading.start;
    this.bwEstimator.sample(processingMs, stats.loaded);
    stats.bwEstimate = this.bwEstimator.getEstimate();

    if (frag.bitrateTest) {
      this.bitrateTestDelay = processingMs / 1000;
    } else {
      this.bitrateTestDelay = 0;
    }
  };

  _proto.onError = function onError(event, data) {
    // stop timer in case of frag loading error
    switch (data.details) {
      case _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].FRAG_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
        this.clearTimer();
        break;

      default:
        break;
    }
  };

  _proto.clearTimer = function clearTimer() {
    self.clearInterval(this.timer);
    this.timer = undefined;
  } // return next auto level
  ;

  _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
    var fragCurrent = this.fragCurrent,
        partCurrent = this.partCurrent,
        hls = this.hls;
    var maxAutoLevel = hls.maxAutoLevel,
        config = hls.config,
        minAutoLevel = hls.minAutoLevel,
        media = hls.media;
    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
    var pos = media ? media.currentTime : 0; // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as
    // if we're playing back at the normal rate.

    var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;
    var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate; // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.

    var bufferStarvationDelay = (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__["BufferHelper"].bufferInfo(media, pos, config.maxBufferHole).end - pos) / playbackRate; // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all

    var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);

    if (bestLevel >= 0) {
      return bestLevel;
    }

    _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].trace((bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + ", finding optimal quality level"); // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
    // if no matching level found, logic will return 0

    var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
    var bwFactor = config.abrBandWidthFactor;
    var bwUpFactor = config.abrBandWidthUpFactor;

    if (!bufferStarvationDelay) {
      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
      var bitrateTestDelay = this.bitrateTestDelay;

      if (bitrateTestDelay) {
        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
        // max video loading delay used in  automatic start level selection :
        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
        var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
        _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].trace("bitrate test took " + Math.round(1000 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1000 * maxStarvationDelay) + " ms"); // don't use conservative factor on bitrate test

        bwFactor = bwUpFactor = 1;
      }
    }

    bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);
    return Math.max(bestLevel, 0);
  };

  _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {
    var _level$details;

    var fragCurrent = this.fragCurrent,
        partCurrent = this.partCurrent,
        currentLevel = this.lastLoadedFragLevel;
    var levels = this.hls.levels;
    var level = levels[currentLevel];
    var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);
    var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;
    var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;

    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
      var levelInfo = levels[i];

      if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {
        continue;
      }

      var levelDetails = levelInfo.details;
      var avgDuration = (partCurrent ? levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
      var adjustedbw = void 0; // follow algorithm captured from stagefright :
      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
      // Pick the highest bandwidth stream below or equal to estimated bandwidth.
      // consider only 80% of the available bandwidth, but if we are switching up,
      // be even more conservative (70%) to avoid overestimating and immediately
      // switching back.

      if (i <= currentLevel) {
        adjustedbw = bwFactor * currentBw;
      } else {
        adjustedbw = bwUpFactor * currentBw;
      }

      var bitrate = levels[i].maxBitrate;
      var fetchDuration = bitrate * avgDuration / adjustedbw;
      _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration); // if adjusted bw is greater than level bitrate AND

      if (adjustedbw > bitrate && ( // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
      !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
        // as we are looping from highest to lowest, this will return the best achievable quality level
        return i;
      }
    } // not enough time budget even with quality level 0 ... rebuffering might happen


    return -1;
  };

  _createClass(AbrController, [{
    key: "nextAutoLevel",
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this.bwEstimator; // in case next auto level has been forced, and bw not available or not reliable, return forced value

      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      } // compute next level using ABR logic


      var nextABRAutoLevel = this.getNextABRAutoLevel(); // if forced auto level has been defined, use it to cap ABR computed quality level

      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }

      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }]);

  return AbrController;
}();

/* harmony default export */ __webpack_exports__["default"] = (AbrController);

/***/ }),

/***/ "./src/controller/audio-stream-controller.ts":
/*!***************************************************!*\
  !*** ./src/controller/audio-stream-controller.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.ts");
/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/level */ "./src/types/level.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.ts");
/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../loader/fragment-loader */ "./src/loader/fragment-loader.ts");
/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../demux/chunk-cache */ "./src/demux/chunk-cache.ts");
/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../demux/transmuxer-interface */ "./src/demux/transmuxer-interface.ts");
/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../types/transmuxer */ "./src/types/transmuxer.ts");
/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.ts");
/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.ts");
/* harmony import */ var _gap_controller__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./gap-controller */ "./src/controller/gap-controller.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");



function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

















var TICK_INTERVAL = 100; // how often to tick in ms

var AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {
  _inheritsLoose(AudioStreamController, _BaseStreamController);

  function AudioStreamController(hls, fragmentTracker) {
    var _this;

    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[audio-stream-controller]') || this;
    _this.retryDate = 0;
    _this.videoBuffer = null;
    _this.videoTrackCC = -1;
    _this.waitingVideoCC = -1;
    _this.audioSwitch = false;
    _this.trackId = -1;
    _this.waitingData = null;
    _this.mainDetails = null;
    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_8__["default"](hls.config);

    _this._registerListeners();

    return _this;
  }

  var _proto = AudioStreamController.prototype;

  _proto.onHandlerDestroying = function onHandlerDestroying() {
    this._unregisterListeners();
  };

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_RESET, this.onBufferReset, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_RESET, this.onBufferReset, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
  } // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  ;

  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
    var frag = _ref.frag,
        id = _ref.id,
        initPTS = _ref.initPTS;

    // Always update the new INIT PTS
    // Can change due level switch
    if (id === 'main') {
      var cc = frag.cc;
      this.initPTS[frag.cc] = initPTS;
      this.log("InitPTS for cc: " + cc + " found from main: " + initPTS);
      this.videoTrackCC = cc; // If we are waiting, tick immediately to unblock audio fragment transmuxing

      if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS) {
        this.tick();
      }
    }
  };

  _proto.startLoad = function startLoad(startPosition) {
    if (!this.levels) {
      this.startPosition = startPosition;
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
      return;
    }

    var lastCurrentTime = this.lastCurrentTime;
    this.stopLoad();
    this.setInterval(TICK_INTERVAL);
    this.fragLoadError = 0;

    if (lastCurrentTime > 0 && startPosition === -1) {
      this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
    } else {
      this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
      this.loadedmetadata = false;
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK;
    }

    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
    this.tick();
  };

  _proto.doTick = function doTick() {
    switch (this.state) {
      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE:
        this.doTickIdle();
        break;

      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK:
        {
          var _levels$trackId;

          var levels = this.levels,
              trackId = this.trackId;
          var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;

          if (details) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }

            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
          }

          break;
        }

      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY:
        {
          var _this$media;

          var now = performance.now();
          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {
            this.log('RetryDate reached, switch back to IDLE state');
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          }

          break;
        }

      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS:
        {
          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
          var waitingData = this.waitingData;

          if (waitingData) {
            var frag = waitingData.frag,
                part = waitingData.part,
                cache = waitingData.cache,
                complete = waitingData.complete;

            if (this.initPTS[frag.cc] !== undefined) {
              this.waitingData = null;
              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING;
              var payload = cache.flush();
              var data = {
                frag: frag,
                part: part,
                payload: payload,
                networkDetails: null
              };

              this._handleFragmentLoadProgress(data);

              if (complete) {
                _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);
              }
            } else if (this.videoTrackCC !== this.waitingVideoCC) {
              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found
              _utils_logger__WEBPACK_IMPORTED_MODULE_16__["logger"].log("Waiting fragment cc (" + frag.cc + ") cancelled because video is at cc " + this.videoTrackCC);
              this.clearWaitingFragment();
            } else {
              // Drop waiting fragment if an earlier fragment is needed
              var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(this.mediaBuffer, this.media.currentTime, this.config.maxBufferHole);
              var waitingFragmentAtPosition = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_12__["fragmentWithinToleranceTest"])(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);

              if (waitingFragmentAtPosition < 0) {
                _utils_logger__WEBPACK_IMPORTED_MODULE_16__["logger"].log("Waiting fragment cc (" + frag.cc + ") @ " + frag.start + " cancelled because another fragment at " + bufferInfo.end + " is needed");
                this.clearWaitingFragment();
              }
            }
          } else {
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          }
        }
    }

    this.onTickEnd();
  };

  _proto.clearWaitingFragment = function clearWaitingFragment() {
    var waitingData = this.waitingData;

    if (waitingData) {
      this.fragmentTracker.removeFragment(waitingData.frag);
      this.waitingData = null;
      this.waitingVideoCC = -1;
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
    }
  };

  _proto.onTickEnd = function onTickEnd() {
    var media = this.media;

    if (!media || !media.readyState) {
      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)
      return;
    }

    var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
    var buffered = mediaBuffer.buffered;

    if (!this.loadedmetadata && buffered.length) {
      this.loadedmetadata = true;
    }

    this.lastCurrentTime = media.currentTime;
  };

  _proto.doTickIdle = function doTickIdle() {
    var _frag$decryptdata, _frag$decryptdata2;

    var hls = this.hls,
        levels = this.levels,
        media = this.media,
        trackId = this.trackId;
    var config = hls.config;

    if (!levels) {
      return;
    } // if video not attached AND
    // start fragment already requested OR start frag prefetch not enabled
    // exit loop
    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop


    if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
      return;
    }

    var pos = this.getLoadPosition();

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(pos)) {
      return;
    }

    if (!levels || !levels[trackId]) {
      return;
    }

    var levelInfo = levels[trackId];
    var trackDetails = levelInfo.details;

    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK;
      return;
    }

    var frag = trackDetails.initSegment;
    var targetBufferTime = 0;

    if (!frag || frag.data) {
      var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : this.media;
      var videoBuffer = this.videoBuffer ? this.videoBuffer : this.media;
      var maxBufferHole = pos < config.maxBufferHole ? Math.max(_gap_controller__WEBPACK_IMPORTED_MODULE_14__["MAX_START_GAP_JUMP"], config.maxBufferHole) : config.maxBufferHole;
      var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(mediaBuffer, pos, maxBufferHole);
      var mainBufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(videoBuffer, pos, maxBufferHole);
      var bufferLen = bufferInfo.len;
      var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
      var maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len);
      var audioSwitch = this.audioSwitch; // if buffer length is less than maxBufLen try to load a new fragment

      if (bufferLen >= maxBufLen && !audioSwitch) {
        return;
      }

      if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_EOS, {
          type: 'audio'
        });
        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ENDED;
        return;
      }

      var fragments = trackDetails.fragments;
      var start = fragments[0].start;
      targetBufferTime = bufferInfo.end;

      if (audioSwitch) {
        targetBufferTime = pos; // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime

        if (trackDetails.PTSKnown && pos < start) {
          // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
          if (bufferInfo.end > start || bufferInfo.nextStart) {
            this.log('Alt audio track ahead of main track, seek to start of alt audio track');
            media.currentTime = start + 0.05;
          }
        }
      }

      frag = this.getNextFragment(targetBufferTime, trackDetails);

      if (!frag) {
        return;
      }
    }

    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {
      this.log("Loading key for " + frag.sn + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId);
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].KEY_LOADING;
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].KEY_LOADING, {
        frag: frag
      });
    } else {
      this.loadFragment(frag, trackDetails, targetBufferTime);
    }
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    this.videoBuffer = null;

    _BaseStreamController.prototype.onMediaDetaching.call(this);
  };

  _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {
    var audioTracks = _ref2.audioTracks;
    this.levels = audioTracks.map(function (mediaPlaylist) {
      return new _types_level__WEBPACK_IMPORTED_MODULE_5__["Level"](mediaPlaylist);
    });
  };

  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
    // if any URL found on new audio track, it is an alternate audio track
    var altAudio = !!data.url;
    this.trackId = data.id;
    var fragCurrent = this.fragCurrent,
        transmuxer = this.transmuxer;

    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
      fragCurrent.loader.abort();
    }

    this.fragCurrent = null;
    this.clearWaitingFragment(); // destroy useless transmuxer when switching audio to main

    if (!altAudio) {
      if (transmuxer) {
        transmuxer.destroy();
        this.transmuxer = null;
      }
    } else {
      // switching to audio track, start timer if not already started
      this.setInterval(TICK_INTERVAL);
    } // should we switch tracks ?


    if (altAudio) {
      this.audioSwitch = true; // main audio track are handled by stream-controller, just do something if switching to alt audio track

      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
    } else {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
    }

    this.tick();
  };

  _proto.onManifestLoading = function onManifestLoading() {
    this.mainDetails = null;
    this.fragmentTracker.removeAllFragments();
    this.startPosition = this.lastCurrentTime = 0;
  };

  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
    if (this.mainDetails === null) {
      this.mainDetails = data.details;
    }
  };

  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
    var _track$details;

    var levels = this.levels;
    var newDetails = data.details,
        trackId = data.id;

    if (!levels) {
      this.warn("Audio tracks were reset while loading level " + trackId);
      return;
    }

    this.log("Track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + newDetails.totalduration);
    var track = levels[trackId];
    var sliding = 0;

    if (newDetails.live || (_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live) {
      var _this$mainDetails;

      if (!newDetails.fragments[0]) {
        newDetails.deltaUpdateFailed = true;
      }

      if (newDetails.deltaUpdateFailed) {
        return;
      }

      if (!track.details && (_this$mainDetails = this.mainDetails) !== null && _this$mainDetails !== void 0 && _this$mainDetails.hasProgramDateTime && newDetails.hasProgramDateTime) {
        Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_13__["alignPDT"])(newDetails, this.mainDetails);
        sliding = newDetails.fragments[0].start;
      } else {
        sliding = this.alignPlaylists(newDetails, track.details);
      }
    }

    track.details = newDetails;
    this.levelLastLoaded = trackId; // compute start position

    if (!this.startFragRequested) {
      this.setStartPosition(track.details, sliding);
    } // only switch back to IDLE state if we were waiting for track to start downloading a new fragment


    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
    } // trigger handler right now


    this.tick();
  };

  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
    var _details$initSegment;

    var frag = data.frag,
        part = data.part,
        payload = data.payload;
    var config = this.config,
        trackId = this.trackId,
        levels = this.levels;

    if (!levels) {
      this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
      return;
    }

    var track = levels[trackId];
    console.assert(track, 'Audio track is defined on fragment load progress');
    var details = track.details;
    console.assert(details, 'Audio track details are defined on fragment load progress');
    var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';
    var transmuxer = this.transmuxer;

    if (!transmuxer) {
      transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_10__["default"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    } // Check if we have video initPTS
    // If not we need to wait for it


    var initPTS = this.initPTS[frag.cc];
    var initSegmentData = (_details$initSegment = details.initSegment) === null || _details$initSegment === void 0 ? void 0 : _details$initSegment.data;

    if (initPTS !== undefined) {
      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
      var accurateTimeOffset = false; // details.PTSKnown || !details.live;

      var partIndex = part ? part.index : -1;
      var partial = partIndex !== -1;
      var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_11__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    } else {
      _utils_logger__WEBPACK_IMPORTED_MODULE_16__["logger"].log("Unknown video PTS for cc " + frag.cc + ", waiting for video PTS before demuxing audio frag " + frag.sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);

      var _this$waitingData = this.waitingData = this.waitingData || {
        frag: frag,
        part: part,
        cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_9__["default"](),
        complete: false
      },
          cache = _this$waitingData.cache;

      cache.push(new Uint8Array(payload));
      this.waitingVideoCC = this.videoTrackCC;
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
    }
  };

  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
    if (this.waitingData) {
      this.waitingData.complete = true;
      return;
    }

    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);
  };

  _proto.onBufferReset = function onBufferReset() {
    // reset reference to sourcebuffers
    this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
  };

  _proto.onBufferCreated = function onBufferCreated(event, data) {
    var audioTrack = data.tracks.audio;

    if (audioTrack) {
      this.mediaBuffer = audioTrack.buffer;
    }

    if (data.tracks.video) {
      this.videoBuffer = data.tracks.video.buffer;
    }
  };

  _proto.onFragBuffered = function onFragBuffered(event, data) {
    var frag = data.frag,
        part = data.part;

    if (frag && frag.type !== 'audio') {
      return;
    }

    if (this.fragContextChanged(frag)) {
      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion
      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer
      this.warn("Fragment " + frag.sn + (part ? ' p: ' + part.index : '') + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch);
      return;
    }

    this.fragPrevious = frag;

    if (this.audioSwitch && frag.sn !== 'initSegment') {
      this.audioSwitch = false;
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHED, {
        id: this.trackId
      });
    }

    this.fragBufferedComplete(frag, part);
  };

  _proto.onError = function onError(data) {
    var frag = data.frag; // don't handle frag error not related to audio fragment

    if (frag && frag.type !== 'audio') {
      return;
    }

    switch (data.details) {
      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].FRAG_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
        {
          var _frag = data.frag; // don't handle frag error not related to audio fragment

          if (_frag && _frag.type !== 'audio') {
            break;
          }

          if (!data.fatal) {
            var loadError = this.fragLoadError;

            if (loadError) {
              loadError++;
            } else {
              loadError = 1;
            }

            var config = this.config;

            if (loadError <= config.fragLoadingMaxRetry) {
              this.fragLoadError = loadError; // exponential backoff capped to config.fragLoadingMaxRetryTimeout

              var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
              this.warn("Frag loading failed, retry in " + delay + " ms");
              this.retryDate = performance.now() + delay; // retry loading state

              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY;
            } else {
              _utils_logger__WEBPACK_IMPORTED_MODULE_16__["logger"].error(data.details + " reaches max retry, redispatch as fatal ..."); // switch error to fatal

              data.fatal = true;
              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR;
            }
          }

          break;
        }

      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT:
      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].KEY_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].KEY_LOAD_TIMEOUT:
        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED) {
          // if fatal error, stop processing, otherwise move to IDLE to retry loading
          this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          this.warn(data.details + " while loading frag, switching to " + this.state + " state");
        }

        break;

      case _errors__WEBPACK_IMPORTED_MODULE_15__["ErrorDetails"].BUFFER_FULL_ERROR:
        // if in appending state
        if (data.parent === 'audio' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED)) {
          var media = this.mediaBuffer;
          var currentTime = this.media.currentTime;
          var mediaBuffered = media && _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].isBuffered(media, currentTime) && _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].isBuffered(media, currentTime + 0.5); // reduce max buf len if current position is buffered

          if (mediaBuffered) {
            var _config = this.config;

            if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
              // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
              _config.maxMaxBufferLength /= 2;
              this.warn("Reduce max buffer length to " + _config.maxMaxBufferLength + "s");
            }

            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          } else {
            // current position is not buffered, but browser is still complaining about buffer full error
            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
            // in that case flush the whole audio buffer to recover
            this.warn('Buffer full error also media.currentTime is not buffered, flush audio buffer');
            this.fragCurrent = null; // flush everything

            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: Number.POSITIVE_INFINITY,
              type: 'audio'
            });
          }
        }

        break;

      default:
        break;
    }
  };

  _proto.onBufferFlushed = function onBufferFlushed(event, _ref3) {
    var type = _ref3.type;

    /* after successful buffer flushing, filter flushed fragments from bufferedFrags
      use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
    */
    var media = this.mediaBuffer ? this.mediaBuffer : this.media;

    if (media && type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO) {
      // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
      this.fragmentTracker.detectEvictedFragments(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].getBuffered(media));
    } // reset reference to frag


    this.fragPrevious = null; // move to IDLE once flush complete. this should trigger new fragment loading

    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
  };

  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;

    var id = 'audio';
    var hls = this.hls;
    var remuxResult = transmuxResult.remuxResult,
        chunkMeta = transmuxResult.chunkMeta;
    var context = this.getCurrentContext(chunkMeta);

    if (!context) {
      this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
      return;
    }

    var frag = context.frag,
        part = context.part;
    var audio = remuxResult.audio,
        text = remuxResult.text,
        id3 = remuxResult.id3,
        initSegment = remuxResult.initSegment; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.
    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.

    if (this.fragContextChanged(frag)) {
      return;
    }

    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING;

    if (this.audioSwitch && audio) {
      this.completeAudioSwitch();
    }

    if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {
      this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_INIT_SEGMENT, {
        frag: frag,
        id: id,
        tracks: initSegment.tracks
      }); // Only flush audio from old audio tracks when PTS is known on new audio track
    }

    if (audio) {
      var startPTS = audio.startPTS,
          endPTS = audio.endPTS,
          startDTS = audio.startDTS,
          endDTS = audio.endDTS;

      if (part) {
        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO] = {
          startPTS: startPTS,
          endPTS: endPTS,
          startDTS: startDTS,
          endDTS: endDTS
        };
      }

      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, startPTS, endPTS, startDTS, endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }

    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
      var emittedID3 = _extends({
        frag: frag,
        id: id
      }, id3);

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_METADATA, emittedID3);
    }

    if (text) {
      var emittedText = _extends({
        frag: frag,
        id: id
      }, text);

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_USERDATA, emittedText);
    }
  };

  _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {
    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING) {
      return;
    } // delete any video track found on audio transmuxer


    if (tracks.video) {
      delete tracks.video;
    } // include levelCodec in audio and video tracks


    var track = tracks.audio;

    if (!track) {
      return;
    }

    track.levelCodec = track.codec;
    track.id = 'audio';
    this.log("Init audio buffer, container:" + track.container + ", codecs[parsed]=[" + track.codec + "]");
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CODECS, tracks);
    var initSegment = track.initSegment;

    if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
      var segment = {
        type: 'audio',
        data: initSegment,
        frag: frag,
        part: null,
        chunkMeta: chunkMeta
      };
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_APPENDING, segment);
    } // trigger handler right now


    this.tick();
  };

  _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {
    // only load if fragment is not loaded or if in audio switch
    var fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag; // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch

    if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentState"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentState"].PARTIAL) {
      if (frag.sn === 'initSegment') {
        this._loadInitSegment(frag);
      } else if (trackDetails.live && !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.initPTS[frag.cc])) {
        this.log("Waiting for video PTS in continuity counter " + frag.cc + " of live stream before loading audio fragment " + frag.sn + " of level " + this.trackId);
        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
      } else {
        this.startFragRequested = true;
        this.nextLoadPosition = frag.start + frag.duration;

        _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);
      }
    }
  };

  _proto.completeAudioSwitch = function completeAudioSwitch() {
    var hls = this.hls,
        media = this.media,
        trackId = this.trackId;

    if (media) {
      this.log('Switching audio track : flushing all audio');
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHING, {
        startOffset: 0,
        endOffset: Number.POSITIVE_INFINITY,
        type: 'audio'
      });
    }

    this.audioSwitch = false;
    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHED, {
      id: trackId
    });
  };

  return AudioStreamController;
}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (AudioStreamController);

/***/ }),

/***/ "./src/controller/audio-track-controller.ts":
/*!**************************************************!*\
  !*** ./src/controller/audio-track-controller.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-playlist-controller */ "./src/controller/base-playlist-controller.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






var AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {
  _inheritsLoose(AudioTrackController, _BasePlaylistControll);

  function AudioTrackController(hls) {
    var _this;

    _this = _BasePlaylistControll.call(this, hls, '[audio-track-controller]') || this;
    _this.tracks = [];
    _this.groupId = null;
    _this.tracksInGroup = [];
    _this.trackId = -1;
    _this.selectDefaultTrack = true;

    _this.registerListeners();

    return _this;
  }

  var _proto = AudioTrackController.prototype;

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
  };

  _proto.destroy = function destroy() {
    this.unregisterListeners();

    _BasePlaylistControll.prototype.destroy.call(this);
  };

  _proto.onManifestLoading = function onManifestLoading() {
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.selectDefaultTrack = true;
  };

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    this.tracks = data.audioTracks || [];
  };

  _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
    var id = data.id,
        details = data.details;
    var currentTrack = this.tracksInGroup[id];

    if (!currentTrack) {
      this.warn("Invalid audio track id " + id);
      return;
    }

    var curDetails = currentTrack.details;
    currentTrack.details = data.details;
    this.log("audioTrack " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");

    if (id === this.trackId) {
      this.retryCount = 0;
      this.playlistLoaded(id, data, curDetails);
    }
  }
  /**
   * When a level is loading, if it has redundant audioGroupIds (in the same ordinality as it's redundant URLs)
   * we are setting our audio-group ID internally to the one set, if it is different from the group ID currently set.
   *
   * If group-ID got update, we re-select the appropriate audio-track with this group-ID matching the currently
   * selected one (based on NAME property).
   */
  ;

  _proto.onLevelLoading = function onLevelLoading(event, data) {
    var levelInfo = this.hls.levels[data.level];

    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {
      return;
    }

    var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];

    if (this.groupId !== audioGroupId) {
      this.groupId = audioGroupId;
      var audioTracks = this.tracks.filter(function (track) {
        return !audioGroupId || track.groupId === audioGroupId;
      }); // Disable selectDefaultTrack if there are no default tracks

      if (this.selectDefaultTrack && !audioTracks.some(function (track) {
        return track.default;
      })) {
        this.selectDefaultTrack = false;
      }

      this.tracksInGroup = audioTracks;
      var audioTracksUpdated = {
        audioTracks: audioTracks
      };
      this.log("Updating audio tracks, " + audioTracks.length + " track(s) found in \"" + audioGroupId + "\" group-id");
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACKS_UPDATED, audioTracksUpdated);
      this.selectInitialTrack();
    }
  };

  _proto.onError = function onError(event, data) {
    _BasePlaylistControll.prototype.onError.call(this, event, data);

    if (data.fatal || !data.context) {
      return;
    }

    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__["PlaylistContextType"].AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
      this.retryLoadingOrFail(data);
    }
  };

  _proto.setAudioTrack = function setAudioTrack(newId) {
    var _tracks$newId;

    var tracks = this.tracksInGroup; // noop on same audio track id as already set

    if (this.trackId === newId && (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) {
      return;
    } // check if level idx is valid


    if (newId < 0 || newId >= tracks.length) {
      this.warn('Invalid id passed to audio-track controller');
      return;
    } // stopping live reloading timer if any


    this.clearTimer();
    var lastTrack = tracks[this.trackId];
    var track = tracks[newId];
    this.log("Now switching to audio-track index " + newId);
    this.trackId = newId;
    var url = track.url,
        type = track.type,
        id = track.id;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_SWITCHING, {
      id: id,
      type: type,
      url: url
    });
    var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
    this.loadPlaylist(hlsUrlParameters);
  };

  _proto.selectInitialTrack = function selectInitialTrack() {
    var _audioTracks$this$tra;

    var audioTracks = this.tracksInGroup;
    console.assert(audioTracks.length, 'Initial audio track should be selected when tracks are known');
    var currentAudioTrackName = (_audioTracks$this$tra = audioTracks[this.trackId]) === null || _audioTracks$this$tra === void 0 ? void 0 : _audioTracks$this$tra.name;
    var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();

    if (trackId !== -1) {
      this.setAudioTrack(trackId);
    } else {
      this.warn("No track found for running audio group-ID: " + this.groupId);
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR,
        fatal: true
      });
    }
  };

  _proto.findTrackId = function findTrackId(name) {
    var audioTracks = this.tracksInGroup;

    for (var i = 0; i < audioTracks.length; i++) {
      var track = audioTracks[i];

      if (!this.selectDefaultTrack || track.default) {
        if (!name || name === track.name) {
          return track.id;
        }
      }
    }

    return -1;
  };

  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
    var audioTrack = this.tracksInGroup[this.trackId];

    if (this.shouldLoadTrack(audioTrack)) {
      var id = audioTrack.id;
      var groupId = audioTrack.groupId;
      var url = audioTrack.url;

      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
        }
      } // track not retrieved yet, or live playlist we need to (re)load it


      this.log("loading audio-track playlist for id: " + id);
      this.clearTimer();
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADING, {
        url: url,
        id: id,
        groupId: groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  };

  _createClass(AudioTrackController, [{
    key: "audioTracks",
    get: function get() {
      return this.tracksInGroup;
    }
  }, {
    key: "audioTrack",
    get: function get() {
      return this.trackId;
    },
    set: function set(newId) {
      // If audio track is selected from API then don't choose from the manifest default track
      this.selectDefaultTrack = false;
      this.setAudioTrack(newId);
    }
  }]);

  return AudioTrackController;
}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (AudioTrackController);

/***/ }),

/***/ "./src/controller/base-playlist-controller.ts":
/*!****************************************************!*\
  !*** ./src/controller/base-playlist-controller.ts ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BasePlaylistController; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/level */ "./src/types/level.ts");
/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");








var BasePlaylistController = /*#__PURE__*/function () {
  function BasePlaylistController(hls, logPrefix) {
    this.hls = void 0;
    this.timer = -1;
    this.canLoad = false;
    this.retryCount = 0;
    this.log = void 0;
    this.warn = void 0;
    this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"], logPrefix + ":");
    this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"], logPrefix + ":");
    this.hls = hls;
  }

  var _proto = BasePlaylistController.prototype;

  _proto.destroy = function destroy() {
    this.clearTimer();
  };

  _proto.onError = function onError(event, data) {
    if (data.fatal && data.type === _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].NETWORK_ERROR) {
      this.clearTimer();
    }
  };

  _proto.clearTimer = function clearTimer() {
    clearTimeout(this.timer);
    this.timer = -1;
  };

  _proto.startLoad = function startLoad() {
    this.canLoad = true;
    this.retryCount = 0;
    this.loadPlaylist();
  };

  _proto.stopLoad = function stopLoad() {
    this.canLoad = false;
    this.clearTimer();
  };

  _proto.switchParams = function switchParams(playlistUri, previous) {
    var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;

    if (renditionReports) {
      for (var i = 0; i < renditionReports.length; i++) {
        var attr = renditionReports[i];
        var uri = '' + attr.URI;

        if (uri === playlistUri.substr(-uri.length)) {
          var msn = parseInt(attr['LAST-MSN']);
          var part = parseInt(attr['LAST-PART']);

          if (previous && this.hls.config.lowLatencyMode) {
            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);

            if (part !== undefined && currentGoal > previous.partTarget) {
              part += 1;
            }
          }

          if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(msn)) {
            return new _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsUrlParameters"](msn, Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(part) ? part : undefined, _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsSkip"].No);
          }
        }
      }
    }
  };

  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {};

  _proto.shouldLoadTrack = function shouldLoadTrack(track) {
    return this.canLoad && track && !!track.url && (!track.details || track.details.live);
  };

  _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
    var _this = this;

    var details = data.details,
        stats = data.stats; // Set last updated date-time

    var elapsed = stats.loading.end ? Math.max(0, self.performance.now() - stats.loading.end) : 0;
    details.advancedDateTime = Date.now() - elapsed; // if current playlist is a live playlist, arm a timer to reload it

    if (details.live || previousDetails !== null && previousDetails !== void 0 && previousDetails.live) {
      details.reloaded(previousDetails);

      if (previousDetails) {
        this.log("live playlist " + index + " " + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : 'MISSED'));
      } // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments


      if (previousDetails && details.fragments.length > 0) {
        _level_helper__WEBPACK_IMPORTED_MODULE_2__["mergeDetails"](previousDetails, details);

        if (!details.advanced) {
          details.advancedDateTime = previousDetails.advancedDateTime;
        }
      }

      if (!this.canLoad || !details.live) {
        return;
      }

      if (details.canBlockReload && details.endSN && details.advanced) {
        var _data$deliveryDirecti;

        // Load level with LL-HLS delivery directives
        var lowLatencyMode = this.hls.config.lowLatencyMode;
        var lastPartIndex = details.lastPartIndex;
        var msn;
        var part;

        if (lowLatencyMode) {
          msn = lastPartIndex !== -1 ? details.lastPartSn : details.endSN + 1;
          part = lastPartIndex !== -1 ? lastPartIndex + 1 : undefined;
        } else {
          // This playlist update will be late by one part (0). There is no way to know the last part number,
          // or request just the next sn without a part in most implementations.
          msn = lastPartIndex !== -1 ? details.lastPartSn + 1 : details.endSN + 1;
          part = lastPartIndex !== -1 ? 0 : undefined;
        } // Low-Latency CDN Tune-in: "age" header and time since load indicates we're behind by more than one part
        // Update directives to obtain the Playlist that has the estimated additional duration of media


        var lastAdvanced = details.age;
        var cdnAge = lastAdvanced + details.ageHeader;
        var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);

        if (currentGoal > 0) {
          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
            // If we attempted to get the next or latest playlist update, but currentGoal increased,
            // then we either can't catchup, or the "age" header cannot be trusted.
            this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
            currentGoal = 0;
          } else {
            var segments = Math.floor(currentGoal / details.targetduration);
            msn += segments;

            if (part !== undefined) {
              var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
              part += parts;
            }

            this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
          }

          details.tuneInGoal = currentGoal;
        }

        var skip = Object(_types_level__WEBPACK_IMPORTED_MODULE_1__["getSkipValue"])(details, msn);

        if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {
          if (details.deltaUpdateFailed) {
            msn = data.deliveryDirectives.msn;
            part = data.deliveryDirectives.part;
            skip = _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsSkip"].No;
          }
        }

        this.loadPlaylist(new _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsUrlParameters"](msn, part, skip));
        return;
      }

      var reloadInterval = Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__["computeReloadInterval"])(details, stats);
      this.log("reload live playlist " + index + " in " + Math.round(reloadInterval) + " ms");
      this.timer = self.setTimeout(function () {
        return _this.loadPlaylist();
      }, reloadInterval);
    } else {
      this.clearTimer();
    }
  };

  _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {
    var _this2 = this;

    var config = this.hls.config;
    var retry = this.retryCount < config.levelLoadingMaxRetry;

    if (retry) {
      var _errorEvent$context;

      this.retryCount++;

      if (errorEvent.details.indexOf('LoadTimeOut') > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {
        // The LL-HLS request already timed out so retry immediately
        this.warn("retry playlist loading #" + this.retryCount + " after \"" + errorEvent.details + "\"");
        this.loadPlaylist();
      } else {
        // exponential backoff capped to max retry timeout
        var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout); // Schedule level/track reload

        this.timer = self.setTimeout(function () {
          return _this2.loadPlaylist();
        }, delay);
        this.warn("retry playlist loading #" + this.retryCount + " in " + delay + " ms after \"" + errorEvent.details + "\"");
      }
    } else {
      this.warn("cannot recover from error \"" + errorEvent.details + "\""); // stopping live reloading timer if any

      this.clearTimer(); // switch error to fatal

      errorEvent.fatal = true;
    }

    return retry;
  };

  return BasePlaylistController;
}();



/***/ }),

/***/ "./src/controller/base-stream-controller.ts":
/*!**************************************************!*\
  !*** ./src/controller/base-stream-controller.ts ***!
  \**************************************************/
/*! exports provided: State, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseStreamController; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../task-loop */ "./src/task-loop.ts");
/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.ts");
/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../types/transmuxer */ "./src/types/transmuxer.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/discontinuities */ "./src/utils/discontinuities.ts");
/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.ts");
/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loader/fragment-loader */ "./src/loader/fragment-loader.ts");
/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.ts");
/* harmony import */ var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/time-ranges */ "./src/utils/time-ranges.ts");




function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }















var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BACKTRACKING: 'BACKTRACKING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS',
  WAITING_LEVEL: 'WAITING_LEVEL'
};

var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {
  _inheritsLoose(BaseStreamController, _TaskLoop);

  function BaseStreamController(hls, fragmentTracker, logPrefix) {
    var _this;

    _this = _TaskLoop.call(this) || this;
    _this.hls = void 0;
    _this.fragPrevious = null;
    _this.fragCurrent = null;
    _this.fragmentTracker = void 0;
    _this.transmuxer = null;
    _this._state = State.STOPPED;
    _this.media = void 0;
    _this.mediaBuffer = void 0;
    _this.config = void 0;
    _this.lastCurrentTime = 0;
    _this.nextLoadPosition = 0;
    _this.startPosition = 0;
    _this.loadedmetadata = false;
    _this.fragLoadError = 0;
    _this.levels = null;
    _this.fragmentLoader = void 0;
    _this.levelLastLoaded = null;
    _this.startFragRequested = false;
    _this.decrypter = void 0;
    _this.initPTS = [];
    _this.onvseeking = null;
    _this.onvended = null;
    _this.logPrefix = '';
    _this.log = void 0;
    _this.warn = void 0;
    _this.logPrefix = logPrefix;
    _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"], logPrefix + ":");
    _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"], logPrefix + ":");
    _this.hls = hls;
    _this.fragmentTracker = fragmentTracker;
    _this.config = hls.config;
    _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__["default"](hls, hls.config);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].KEY_LOADED, _this.onKeyLoaded, _assertThisInitialized(_this));
    return _this;
  }

  var _proto = BaseStreamController.prototype;

  _proto.doTick = function doTick() {
    this.onTickEnd();
  };

  _proto.onTickEnd = function onTickEnd() {} // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ;

  _proto.startLoad = function startLoad(startPosition) {};

  _proto.stopLoad = function stopLoad() {
    var frag = this.fragCurrent;

    if (frag) {
      if (frag.loader) {
        frag.loader.abort();
      }

      this.fragmentTracker.removeFragment(frag);
    }

    if (this.transmuxer) {
      this.transmuxer.destroy();
      this.transmuxer = null;
    }

    this.fragCurrent = null;
    this.fragPrevious = null;
    this.clearInterval();
    this.clearNextTick();
    this.state = State.STOPPED;
  };

  _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
    var fragCurrent = this.fragCurrent,
        fragmentTracker = this.fragmentTracker; // we just got done loading the final fragment and there is no other buffered range after ...
    // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
    // so we should not switch to ENDED in that case, to be able to buffer them

    if (!levelDetails.live && fragCurrent && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
      var fragState = fragmentTracker.getState(fragCurrent);
      return fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].PARTIAL || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].OK;
    }

    return false;
  };

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    var media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener('seeking', this.onvseeking);
    media.addEventListener('ended', this.onvended);
    var config = this.config;

    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
      this.startLoad(config.startPosition);
    }
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    var media = this.media;

    if (media !== null && media !== void 0 && media.ended) {
      this.log('MSE detaching and video ended, reset startPosition');
      this.startPosition = this.lastCurrentTime = 0;
    } // remove video listeners


    if (media) {
      media.removeEventListener('seeking', this.onvseeking);
      media.removeEventListener('ended', this.onvended);
      this.onvseeking = this.onvended = null;
    }

    this.media = this.mediaBuffer = null;
    this.loadedmetadata = false;
    this.fragmentTracker.removeAllFragments();
    this.stopLoad();
  };

  _proto.onMediaSeeking = function onMediaSeeking() {
    var config = this.config,
        fragCurrent = this.fragCurrent,
        media = this.media,
        mediaBuffer = this.mediaBuffer,
        state = this.state;
    var currentTime = media ? media.currentTime : null;
    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(mediaBuffer || media, currentTime, config.maxBufferHole);
    this.log("media seeking to " + (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);

    if (state === State.ENDED) {
      // if seeking to unbuffered area, clean up fragPrevious
      if (!bufferInfo.len) {
        this.fragPrevious = null;
        this.fragCurrent = null;
      } // switch to IDLE state to check for potential new fragment


      this.state = State.IDLE;
    } else if (fragCurrent && !bufferInfo.len) {
      // check if we are seeking to a unbuffered area AND if frag loading is in progress
      var tolerance = config.maxFragLookUpTolerance;
      var fragStartOffset = fragCurrent.start - tolerance;
      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance; // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything

      if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
        if (fragCurrent.loader) {
          this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
          fragCurrent.loader.abort();
        }

        this.fragCurrent = null;
        this.fragPrevious = null; // switch to IDLE state to load new fragment

        this.state = State.IDLE;
      }
    }

    if (media) {
      this.lastCurrentTime = currentTime;
    } // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target


    if (!this.loadedmetadata) {
      this.nextLoadPosition = this.startPosition = currentTime;
    } // tick to speed up processing


    this.tick();
  };

  _proto.onMediaEnded = function onMediaEnded() {
    // reset startPosition and lastCurrentTime to restart playback @ stream beginning
    this.startPosition = this.lastCurrentTime = 0;
  };

  _proto.onKeyLoaded = function onKeyLoaded(event, data) {
    if (this.state === State.KEY_LOADING && this.levels) {
      this.state = State.IDLE;
      var levelDetails = this.levels[data.frag.level].details;

      if (levelDetails) {
        this.loadFragment(data.frag, levelDetails, data.frag.start);
      }
    }
  };

  _proto.onHandlerDestroying = function onHandlerDestroying() {
    this.stopLoad();

    _TaskLoop.prototype.onHandlerDestroying.call(this);
  };

  _proto.onHandlerDestroyed = function onHandlerDestroyed() {
    this.state = State.STOPPED;
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].KEY_LOADED, this.onKeyLoaded, this);

    _TaskLoop.prototype.onHandlerDestroyed.call(this);
  };

  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
    this._loadFragForPlayback(frag, levelDetails, targetBufferTime);
  };

  _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {
    var _this2 = this;

    var progressCallback = function progressCallback(data) {
      if (_this2.fragContextChanged(frag)) {
        _this2.warn("Fragment " + frag.sn + (data.part ? ' p: ' + data.part.index : '') + " of level " + frag.level + " was dropped during download.");

        _this2.fragmentTracker.removeFragment(frag);

        return;
      }

      frag.stats.chunkCount++;

      _this2._handleFragmentLoadProgress(data);
    };

    this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback).then(function (data) {
      _this2.fragLoadError = 0;

      if (!data) {
        // if we're here we probably needed to backtrack or are waiting for more parts
        return;
      }

      if (_this2.fragContextChanged(frag)) {
        if (_this2.state === State.FRAG_LOADING || _this2.state === State.BACKTRACKING) {
          _this2.fragmentTracker.removeFragment(frag);

          _this2.state = State.IDLE;
        }

        return;
      }

      if ('payload' in data) {
        _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);

        _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADED, data); // Tracker backtrack must be called after onFragLoaded to update the fragment entity state to BACKTRACKED
        // This happens after handleTransmuxComplete when the worker or progressive is disabled


        if (_this2.state === State.BACKTRACKING) {
          _this2.fragmentTracker.backtrack(frag, data);

          return;
        }
      } // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback


      _this2._handleFragmentLoadComplete(data);
    });
  };

  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
    if (type === void 0) {
      type = null;
    }

    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,
    // passing a null type flushes both buffers
    var flushScope = {
      startOffset: startOffset,
      endOffset: endOffset,
      type: type
    }; // Reset load errors on flush

    this.fragLoadError = 0;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].BUFFER_FLUSHING, flushScope);
  };

  _proto._loadInitSegment = function _loadInitSegment(frag) {
    var _this3 = this;

    this._doFragLoad(frag).then(function (data) {
      if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
        throw new Error('init load aborted');
      }

      return data;
    }).then(function (data) {
      var hls = _this3.hls;
      var payload = data.payload;
      var decryptData = frag.decryptdata; // check to see if the payload needs to be decrypted

      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {
        var startTime = self.performance.now(); // decrypt the subtitles

        return _this3.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {
          var endTime = self.performance.now();
          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_DECRYPTED, {
            frag: frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
          data.payload = decryptedData;
          return data;
        });
      }

      return data;
    }).then(function (data) {
      var fragCurrent = _this3.fragCurrent,
          hls = _this3.hls,
          levels = _this3.levels;

      if (!levels) {
        throw new Error('init load aborted, missing levels');
      }

      var details = levels[frag.level].details;
      console.assert(details, 'Level details are defined when init segment is loaded');
      var initSegment = details.initSegment;
      console.assert(initSegment, 'Fragment initSegment is defined when init segment is loaded');
      var stats = frag.stats;
      _this3.state = State.IDLE;
      _this3.fragLoadError = 0;
      initSegment.data = new Uint8Array(data.payload);
      stats.parsing.start = stats.buffering.start = self.performance.now();
      stats.parsing.end = stats.buffering.end = self.performance.now(); // Silence FRAG_BUFFERED event if fragCurrent is null

      if (data.frag === fragCurrent) {
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_BUFFERED, {
          stats: stats,
          frag: fragCurrent,
          part: null,
          id: frag.type
        });
      }

      _this3.tick();
    }).catch(function (reason) {
      _this3.warn(reason);
    });
  };

  _proto.fragContextChanged = function fragContextChanged(frag) {
    var fragCurrent = this.fragCurrent;
    return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;
  };

  _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
    var media = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? ' part: ' + part.index : '') + " of " + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + " " + frag.level + " " + _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__["default"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].getBuffered(media)));
    this.state = State.IDLE;
    this.tick();
  };

  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
    var transmuxer = this.transmuxer;

    if (!transmuxer) {
      return;
    }

    var frag = fragLoadedEndData.frag,
        part = fragLoadedEndData.part,
        partsLoaded = fragLoadedEndData.partsLoaded; // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data

    var complete = !partsLoaded || partsLoaded && (partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {
      return !fragLoaded;
    }));
    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_8__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
    transmuxer.flush(chunkMeta);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ;

  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};

  _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {
    var _this4 = this;

    if (targetBufferTime === void 0) {
      targetBufferTime = null;
    }

    if (!this.levels) {
      throw new Error('frag load aborted, missing levels');
    }

    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);

    if (this.config.lowLatencyMode && details) {
      var partList = details.partList;

      if (partList && progressCallback) {
        var partIndex = this.getNextPart(partList, frag, targetBufferTime);

        if (partIndex > -1) {
          var part = partList[partIndex];
          this.log("Loading part sn: " + frag.sn + " p: " + part.index + " cc: " + frag.cc + " of playlist [" + details.startSN + "-" + details.endSN + "] parts [0-" + partIndex + "-" + (partList.length - 1) + "] " + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
          this.state = State.FRAG_LOADING;
          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADING, {
            frag: frag,
            part: partList[partIndex],
            targetBufferTime: targetBufferTime
          });
          return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function (error) {
            return _this4.handleFragError(error);
          });
        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
          // Fragment hint has no parts
          return Promise.resolve(null);
        }
      }
    }

    this.log("Loading fragment " + frag.sn + " cc: " + frag.cc + " " + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
    this.state = State.FRAG_LOADING;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADING, {
      frag: frag,
      targetBufferTime: targetBufferTime
    });
    return this.fragmentLoader.load(frag, progressCallback).catch(function (error) {
      return _this4.handleFragError(error);
    });
  };

  _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var partsLoaded = [];

      var loadPartIndex = function loadPartIndex(index) {
        var part = partList[index];

        _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {
          partsLoaded[part.index] = partLoadedData;
          var loadedPart = partLoadedData.part;

          _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADED, partLoadedData);

          var nextPart = partList[index + 1];

          if (nextPart && nextPart.fragment === frag) {
            loadPartIndex(index + 1);
          } else {
            return resolve({
              frag: frag,
              part: loadedPart,
              partsLoaded: partsLoaded
            });
          }
        }).catch(reject);
      };

      loadPartIndex(partIndex);
    });
  };

  _proto.handleFragError = function handleFragError(_ref) {
    var data = _ref.data;

    if (data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorDetails"].INTERNAL_ABORTED) {
      this.handleFragLoadAborted(data.frag, data.part);
    } else {
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].ERROR, data);
    }

    return null;
  };

  _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
    if (this.state !== State.PARSING) {
      this.warn("State is expected to be PARSING on transmuxer flush, but is " + this.state + ".");
      return;
    }

    var context = this.getCurrentContext(chunkMeta);

    if (!context) {
      return;
    }

    var frag = context.frag,
        part = context.part,
        level = context.level;
    var now = self.performance.now();
    frag.stats.parsing.end = now;

    if (part) {
      part.stats.parsing.end = now;
    }

    this.updateLevelTiming(frag, level, chunkMeta.partial);
    this.state = State.PARSED;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_PARSED, {
      frag: frag,
      part: part
    });
  };

  _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
    var levels = this.levels;
    var levelIndex = chunkMeta.level,
        sn = chunkMeta.sn,
        partIndex = chunkMeta.part;

    if (!levels || !levels[levelIndex]) {
      this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
      return null;
    }

    var level = levels[levelIndex];
    var part = partIndex > -1 ? _level_helper__WEBPACK_IMPORTED_MODULE_7__["getPartWith"](level, sn, partIndex) : null;
    var frag = part ? part.fragment : _level_helper__WEBPACK_IMPORTED_MODULE_7__["getFragmentWithSN"](level, sn);

    if (!frag) {
      return null;
    }

    return {
      frag: frag,
      part: part,
      level: level
    };
  };

  _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {
    if (!data || this.state !== State.PARSING) {
      return;
    }

    var data1 = data.data1,
        data2 = data.data2;
    var buffer = data1;

    if (data1 && data2) {
      // Combine the moof + mdat so that we buffer with a single append
      buffer = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_9__["appendUint8Array"])(data1, data2);
    }

    if (!buffer || !buffer.length) {
      return;
    }

    var segment = {
      type: data.type,
      data: buffer,
      frag: frag,
      part: part,
      chunkMeta: chunkMeta
    };
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].BUFFER_APPENDING, segment);

    if (data.dropped && data.independent && !part) {
      // Clear buffer so that we reload previous segments sequentially if required
      this.flushMainBuffer(0, frag.start);
    }
  };

  _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
    var config = this.config,
        startFragRequested = this.startFragRequested;
    var fragments = levelDetails.fragments;
    var fragLen = fragments.length;

    if (!fragLen) {
      return null;
    } // find fragment index, contiguous with end of buffer position


    var start = fragments[0].start;
    var frag; // If an initSegment is present, it must be buffered first

    if (levelDetails.initSegment && !levelDetails.initSegment.data) {
      frag = levelDetails.initSegment;
    } else if (levelDetails.live) {
      var initialLiveManifestSize = config.initialLiveManifestSize;

      if (fragLen < initialLiveManifestSize) {
        this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
        return null;
      } // The real fragment start times for a live stream are only known after the PTS range for that level is known.
      // In order to discover the range, we load the best matching fragment for that level and demux it.
      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that
      // we get the fragment matching that start time


      if (!levelDetails.PTSKnown && !startFragRequested) {
        frag = this.getInitialLiveFragment(levelDetails, fragments);
      }
    } else if (pos <= start) {
      // VoD playlist: if loadPosition before start of playlist, load first fragment
      frag = fragments[0];
    } // If we haven't run into any special cases already, just load the fragment most closely matching the requested position


    if (!frag) {
      var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
      frag = this.getFragmentAtPosition(pos, end, levelDetails);
    }

    return frag;
  };

  _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
    var nextPart = -1;
    var contiguous = false;

    for (var i = 0, len = partList.length; i < len; i++) {
      var part = partList[i];

      if (nextPart > -1 && targetBufferTime < part.start) {
        break;
      }

      var loaded = part.loaded;

      if (!loaded && (contiguous || part.independent) && part.fragment === frag) {
        nextPart = i;
      }

      contiguous = loaded;
    }

    return nextPart;
  };

  _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
    var lastPart = partList[partList.length - 1];
    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  ;

  _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
    var config = this.config,
        fragPrevious = this.fragPrevious;
    var frag = null;

    if (fragPrevious) {
      if (levelDetails.hasProgramDateTime) {
        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding
        this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
        frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__["findFragmentByPDT"])(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
      } else {
        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.
        var targetSN = fragPrevious.sn + 1;

        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
          var fragNext = fragments[targetSN - levelDetails.startSN]; // Ensure that we're staying within the continuity range, since PTS resets upon a new range

          if (fragPrevious.cc === fragNext.cc) {
            frag = fragNext;
            this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
          }
        } // It's important to stay within the continuity range if available; otherwise the fragments in the playlist
        // will have the wrong start times


        if (!frag) {
          frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__["findFragWithCC"])(fragments, fragPrevious.cc);

          if (frag) {
            this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
          }
        }
      }
    }

    return frag;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  ;

  _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
    var config = this.config,
        fragPrevious = this.fragPrevious;
    var fragments = levelDetails.fragments,
        endSN = levelDetails.endSN;
    var fragmentHint = levelDetails.fragmentHint;
    var tolerance = config.maxFragLookUpTolerance;
    var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);

    if (loadingParts && fragmentHint) {
      // Include incomplete fragment with parts at end
      fragments = fragments.concat(fragmentHint);
      endSN = fragmentHint.sn;
    }

    var frag;

    if (bufferEnd < end) {
      var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance; // Remove the tolerance if it would put the bufferEnd past the actual end of stream
      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)

      frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__["findFragmentByPTS"])(fragPrevious, fragments, bufferEnd, lookupTolerance);
    } else {
      // reach end of playlist
      frag = fragments[fragments.length - 1];
    }

    if (frag) {
      var curSNIdx = frag.sn - levelDetails.startSN;
      var sameLevel = fragPrevious && frag.level === fragPrevious.level;
      var nextFrag = fragments[curSNIdx + 1];
      var fragState = this.fragmentTracker.getState(frag);

      if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].BACKTRACKED) {
        frag = null;
        var i = curSNIdx;

        while (fragments[i] && this.fragmentTracker.getState(fragments[i]) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].BACKTRACKED) {
          // When fragPrevious is null, backtrack to first the first fragment is not BACKTRACKED for loading
          // When fragPrevious is set, we want the first BACKTRACKED fragment for parsing and buffering
          if (!fragPrevious) {
            frag = fragments[--i];
          } else {
            frag = fragments[i--];
          }
        }

        if (!frag) {
          frag = nextFrag;
        }
      } else if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {
        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with
        // non-uniform fragment durations
        if (sameLevel) {
          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].OK) {
            this.log("SN " + frag.sn + " just loaded, load next one: " + nextFrag.sn);
            frag = nextFrag;
          } else {
            frag = null;
          }
        }
      }
    }

    return frag;
  };

  _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
    var config = this.config,
        media = this.media;
    var liveSyncPosition = this.hls.liveSyncPosition;
    var currentTime = media.currentTime;

    if (liveSyncPosition !== null && media !== null && media !== void 0 && media.readyState && media.duration > liveSyncPosition && liveSyncPosition > currentTime) {
      var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
      var start = levelDetails.fragments[0].start;
      var end = levelDetails.edge;

      if (currentTime < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
        this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));

        if (!this.loadedmetadata) {
          this.nextLoadPosition = liveSyncPosition;
        }

        media.currentTime = liveSyncPosition;
        return liveSyncPosition;
      }
    }

    return null;
  };

  _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {
    var levels = this.levels,
        levelLastLoaded = this.levelLastLoaded;
    var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null; // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,
    //  this could all go in LevelHelper.mergeDetails

    var sliding = 0;

    if (previousDetails && details.fragments.length > 0) {
      sliding = details.fragments[0].start;

      if (details.alignedSliding && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(sliding)) {
        this.log("Live playlist sliding:" + sliding.toFixed(3));
      } else if (!sliding) {
        this.warn("[" + this.constructor.name + "] Live playlist - outdated PTS, unknown sliding");
        Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_10__["alignStream"])(this.fragPrevious, lastLevel, details);
      }
    } else {
      this.log('Live playlist - first load, unknown sliding');
      Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_10__["alignStream"])(this.fragPrevious, lastLevel, details);
    }

    return sliding;
  };

  _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
    // Wait for Low-Latency CDN Tune-in to get an updated playlist
    var advancePartLimit = 3;
    return details.live && details.canBlockReload && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
  };

  _proto.setStartPosition = function setStartPosition(details, sliding) {
    // compute start position if set to -1. use it straight away if value is defined
    if (this.startPosition === -1 || this.lastCurrentTime === -1) {
      // first, check if start time offset has been set in playlist, if yes, use this value
      var startTimeOffset = details.startTimeOffset;

      if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(startTimeOffset)) {
        if (startTimeOffset < 0) {
          this.log("Negative start time offset " + startTimeOffset + ", count from end of last fragment");
          startTimeOffset = sliding + details.totalduration + startTimeOffset;
        }

        this.log("Start time offset found in playlist, adjust startPosition to " + startTimeOffset);
        this.startPosition = startTimeOffset;
      } else {
        if (details.live) {
          this.startPosition = this.hls.liveSyncPosition || sliding;
          this.log("Configure startPosition to " + this.startPosition);
        } else {
          this.startPosition = 0;
        }
      }

      this.lastCurrentTime = this.startPosition;
    }

    this.nextLoadPosition = this.startPosition;
  };

  _proto.getLoadPosition = function getLoadPosition() {
    var media = this.media; // if we have not yet loaded any fragment, start loading from start position

    var pos = 0;

    if (this.loadedmetadata) {
      pos = media.currentTime;
    } else if (this.nextLoadPosition) {
      pos = this.nextLoadPosition;
    }

    return pos;
  };

  _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
    if (this.transmuxer && frag.sn !== 'initSegment') {
      this.log("Fragment " + frag.sn + " of level " + frag.level + " was aborted, flushing transmuxer");
      this.transmuxer.flush(new _types_transmuxer__WEBPACK_IMPORTED_MODULE_8__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, true));
    }
  };

  _proto.updateLevelTiming = function updateLevelTiming(frag, level, partial) {
    var _this6 = this;

    var details = level.details;
    console.assert(!!details, 'level.details must be defined');
    Object.keys(frag.elementaryStreams).forEach(function (type) {
      var info = frag.elementaryStreams[type];

      if (info) {
        var parsedDuration = info.endPTS - info.startPTS;

        if (parsedDuration <= 0) {
          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.
          // The new transmuxer will be configured with a time offset matching the next fragment start, preventing the timeline from shifting.
          _this6.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ") resetting transmuxer to fallback to playlist timing");

          if (_this6.transmuxer) {
            _this6.transmuxer.destroy();

            _this6.transmuxer = null;
          }
        }

        var drift = partial ? 0 : _level_helper__WEBPACK_IMPORTED_MODULE_7__["updateFragPTSDTS"](details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);

        _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].LEVEL_PTS_UPDATED, {
          details: details,
          level: level,
          drift: drift,
          type: type,
          frag: frag,
          start: info.startPTS,
          end: info.endPTS
        });
      }
    });
  };

  _createClass(BaseStreamController, [{
    key: "state",
    set: function set(nextState) {
      var previousState = this._state;

      if (previousState !== nextState) {
        this._state = nextState; // this.log(`${previousState}->${nextState}`);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return BaseStreamController;
}(_task_loop__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/controller/buffer-controller.ts":
/*!*********************************************!*\
  !*** ./src/controller/buffer-controller.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferController; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.ts");
/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.ts");
/* harmony import */ var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./buffer-operation-queue */ "./src/controller/buffer-operation-queue.ts");












var MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__["getMediaSource"])();
var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\.[^.,]+)+/;

var BufferController = /*#__PURE__*/function () {
  // The level details used to determine duration, target-duration and live
  // cache the self generated object url to detect hijack of video tag
  // A queue of buffer operations which require the SourceBuffer to not be updating upon execution
  // References to event listeners for each SourceBuffer, so that they can be referenced for event removal
  // The number of BUFFER_CODEC events received before any sourceBuffers are created
  // The total number of BUFFER_CODEC events received
  // A reference to the attached media element
  // A reference to the active media source
  // counters
  function BufferController(_hls) {
    var _this = this;

    this.details = null;
    this._objectUrl = null;
    this.operationQueue = void 0;
    this.listeners = void 0;
    this.hls = void 0;
    this.bufferCodecEventsExpected = 0;
    this._bufferCodecEventsTotal = 0;
    this.media = null;
    this.mediaSource = null;
    this.appendError = 0;
    this.tracks = {};
    this.pendingTracks = {};
    this.sourceBuffer = void 0;

    this._onMediaSourceOpen = function () {
      var hls = _this.hls,
          media = _this.media,
          mediaSource = _this.mediaSource;
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: Media source opened');

      if (media) {
        _this.updateMediaElementDuration();

        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, {
          media: media
        });
      }

      if (mediaSource) {
        // once received, don't listen anymore to sourceopen event
        mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);
      }

      _this.checkPendingTracks();
    };

    this._onMediaSourceClose = function () {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: Media source closed');
    };

    this._onMediaSourceEnded = function () {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: Media source ended');
    };

    this.hls = _hls;

    this._initSourceBuffer();

    this.registerListeners();
  }

  var _proto = BufferController.prototype;

  _proto.destroy = function destroy() {
    this.unregisterListeners();
    this.details = null;
  };

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_RESET, this.onBufferReset, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDING, this.onBufferAppending, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_EOS, this.onBufferEos, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSED, this.onFragParsed, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_RESET, this.onBufferReset, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDING, this.onBufferAppending, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_EOS, this.onBufferEos, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSED, this.onFragParsed, this);
  };

  _proto._initSourceBuffer = function _initSourceBuffer() {
    this.sourceBuffer = {};
    this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__["default"](this.sourceBuffer);
    this.listeners = {
      audio: [],
      video: [],
      audiovideo: []
    };
  };

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
    // sourcebuffers will be created all at once when the expected nb of tracks will be reached
    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
    // it will contain the expected nb of source buffers, no need to compute it
    var codecEvents = 2;

    if (data.audio && !data.video || !data.altAudio) {
      codecEvents = 1;
    }

    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
    this.details = null;
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
  };

  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
    var media = this.media = data.media;

    if (media && MediaSource) {
      var ms = this.mediaSource = new MediaSource(); // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound

      ms.addEventListener('sourceopen', this._onMediaSourceOpen);
      ms.addEventListener('sourceended', this._onMediaSourceEnded);
      ms.addEventListener('sourceclose', this._onMediaSourceClose); // link video and media Source

      media.src = self.URL.createObjectURL(ms); // cache the locally generated object url

      this._objectUrl = media.src;
    }
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: media source detaching');
    var media = this.media,
        mediaSource = this.mediaSource,
        _objectUrl = this._objectUrl;

    if (mediaSource) {
      if (mediaSource.readyState === 'open') {
        try {
          // endOfStream could trigger exception if any sourcebuffer is in updating state
          // we don't really care about checking sourcebuffer state here,
          // as we are anyway detaching the MediaSource
          // let's just avoid this exception to propagate
          mediaSource.endOfStream();
        } catch (err) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: onMediaDetaching: " + err.message + " while calling endOfStream");
        }
      } // Clean up the SourceBuffers by invoking onBufferReset


      this.onBufferReset();
      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);
      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);
      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose); // Detach properly the MediaSource from the HTMLMediaElement as
      // suggested in https://github.com/w3c/media-source/issues/53.

      if (media) {
        if (_objectUrl) {
          self.URL.revokeObjectURL(_objectUrl);
        } // clean up video tag src only if it's our own url. some external libraries might
        // hijack the video tag and change its 'src' without destroying the Hls instance first


        if (media.src === _objectUrl) {
          media.removeAttribute('src');
          media.load();
        } else {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('[buffer-controller]: media.src was changed by a third party - skip cleanup');
        }
      }

      this.mediaSource = null;
      this.media = null;
      this._objectUrl = null;
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
      this.pendingTracks = {};
      this.tracks = {};
    }

    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHED, undefined);
  };

  _proto.onBufferReset = function onBufferReset() {
    var _this2 = this;

    var sourceBuffer = this.sourceBuffer;
    this.getSourceBufferTypes().forEach(function (type) {
      var sb = sourceBuffer[type];

      try {
        if (sb) {
          _this2.removeBufferListeners(type);

          if (_this2.mediaSource) {
            _this2.mediaSource.removeSourceBuffer(sb);
          } // Synchronously remove the SB from the map before the next call in order to prevent an async function from
          // accessing it


          sourceBuffer[type] = undefined;
        }
      } catch (err) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to reset the " + type + " buffer", err);
      }
    });

    this._initSourceBuffer();
  };

  _proto.onBufferCodecs = function onBufferCodecs(event, data) {
    var _this3 = this;

    var sourceBufferCount = Object.keys(this.sourceBuffer).length;
    Object.keys(data).forEach(function (trackName) {
      if (sourceBufferCount) {
        // check if SourceBuffer codec needs to change
        var track = _this3.tracks[trackName];

        if (track && typeof track.buffer.changeType === 'function') {
          var _data$trackName = data[trackName],
              codec = _data$trackName.codec,
              levelCodec = _data$trackName.levelCodec,
              container = _data$trackName.container;
          var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');
          var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, '$1');

          if (currentCodec !== nextCodec) {
            var mimeType = container + ";codecs=" + (levelCodec || codec);

            _this3.appendChangeType(trackName, mimeType);
          }
        }
      } else {
        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
        _this3.pendingTracks[trackName] = data[trackName];
      }
    }); // if sourcebuffers already created, do nothing ...

    if (sourceBufferCount) {
      return;
    }

    this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);

    if (this.mediaSource && this.mediaSource.readyState === 'open') {
      this.checkPendingTracks();
    }
  };

  _proto.appendChangeType = function appendChangeType(type, mimeType) {
    var _this4 = this;

    var operationQueue = this.operationQueue;
    var operation = {
      execute: function execute() {
        var sb = _this4.sourceBuffer[type];

        if (sb) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: changing " + type + " sourceBuffer type to " + mimeType);
          sb.changeType(mimeType);
        }

        operationQueue.shiftAndExecuteNext(type);
      },
      onStart: function onStart() {},
      onComplete: function onComplete() {},
      onError: function onError(e) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to change " + type + " SourceBuffer type", e);
      }
    };
    operationQueue.append(operation, type);
  };

  _proto.onBufferAppending = function onBufferAppending(event, eventData) {
    var _this5 = this;

    var hls = this.hls,
        operationQueue = this.operationQueue,
        tracks = this.tracks;
    var data = eventData.data,
        type = eventData.type,
        frag = eventData.frag,
        part = eventData.part,
        chunkMeta = eventData.chunkMeta;
    var chunkStats = chunkMeta.buffering[type];
    var bufferAppendingStart = self.performance.now();
    chunkStats.start = bufferAppendingStart;
    var fragBuffering = frag.stats.buffering;
    var partBuffering = part ? part.stats.buffering : null;

    if (fragBuffering.start === 0) {
      fragBuffering.start = bufferAppendingStart;
    }

    if (partBuffering && partBuffering.start === 0) {
      partBuffering.start = bufferAppendingStart;
    } // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended
    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).
    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486


    var audioTrack = tracks.audio;
    var checkTimestampOffset = type === 'audio' && chunkMeta.id === 1 && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === 'audio/mpeg';
    var operation = {
      execute: function execute() {
        chunkStats.executeStart = self.performance.now();

        if (checkTimestampOffset) {
          var sb = _this5.sourceBuffer[type];

          if (sb) {
            var delta = frag.start - sb.timestampOffset;

            if (Math.abs(delta) >= 0.1) {
              _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + frag.start + " (delta: " + delta + ") sn: " + frag.sn + ")");
              sb.timestampOffset = frag.start;
            }
          }
        }

        _this5.appendExecutor(data, type);
      },
      onStart: function onStart() {// logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);
      },
      onComplete: function onComplete() {
        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);
        var end = self.performance.now();
        chunkStats.executeEnd = chunkStats.end = end;

        if (fragBuffering.first === 0) {
          fragBuffering.first = end;
        }

        if (partBuffering && partBuffering.first === 0) {
          partBuffering.first = end;
        }

        var sourceBuffer = _this5.sourceBuffer;
        var timeRanges = {};

        for (var _type in sourceBuffer) {
          timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(sourceBuffer[_type]);
        }

        _this5.appendError = 0;

        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDED, {
          parent: frag.type,
          timeRanges: timeRanges,
          frag: frag,
          part: part,
          chunkMeta: chunkMeta
        });
      },
      onError: function onError(err) {
        // in case any error occured while appending, put back segment in segments table
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: Error encountered while trying to append to the " + type + " SourceBuffer", err);
        var event = {
          type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
          parent: frag.type,
          details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPEND_ERROR,
          err: err,
          fatal: false
        };

        if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {
          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
          // let's stop appending any segments, and report BUFFER_FULL_ERROR error
          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_FULL_ERROR;
        } else {
          _this5.appendError++;
          event.details = _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPEND_ERROR;
          /* with UHD content, we could get loop of quota exceeded error until
            browser is able to evict some data from sourcebuffer. Retrying can help recover.
          */

          if (_this5.appendError > hls.config.appendErrorMaxRetry) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Failed " + hls.config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
            event.fatal = true;
          }
        }

        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, event);
      }
    };
    operationQueue.append(operation, type);
  };

  _proto.onBufferFlushing = function onBufferFlushing(event, data) {
    var _this6 = this;

    var operationQueue = this.operationQueue;

    var flushOperation = function flushOperation(type) {
      return {
        execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),
        onStart: function onStart() {// logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);
        },
        onComplete: function onComplete() {
          // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);
          _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHED, {
            type: type
          });
        },
        onError: function onError(e) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to remove from " + type + " SourceBuffer", e);
        }
      };
    };

    if (data.type) {
      operationQueue.append(flushOperation(data.type), data.type);
    } else {
      operationQueue.append(flushOperation('audio'), 'audio');
      operationQueue.append(flushOperation('video'), 'video');
    }
  };

  _proto.onFragParsed = function onFragParsed(event, data) {
    var _this7 = this;

    var frag = data.frag,
        part = data.part;
    var buffersAppendedTo = [];
    var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;

    if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].AUDIOVIDEO]) {
      buffersAppendedTo.push('audiovideo');
    } else {
      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].AUDIO]) {
        buffersAppendedTo.push('audio');
      }

      if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].VIDEO]) {
        buffersAppendedTo.push('video');
      }
    }

    var onUnblocked = function onUnblocked() {
      var now = self.performance.now();
      frag.stats.buffering.end = now;

      if (part) {
        part.stats.buffering.end = now;
      }

      var stats = part ? part.stats : frag.stats;

      _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_BUFFERED, {
        frag: frag,
        part: part,
        stats: stats,
        id: frag.type
      });
    };

    if (buffersAppendedTo.length === 0) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
      Promise.resolve(onUnblocked);
      return;
    }

    this.blockBuffers(onUnblocked, buffersAppendedTo);
    this.flushLiveBackBuffer();
  } // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
  // an undefined data.type will mark all buffers as EOS.
  ;

  _proto.onBufferEos = function onBufferEos(event, data) {
    var _this8 = this;

    for (var type in this.sourceBuffer) {
      if (!data.type || data.type === type) {
        var sb = this.sourceBuffer[type];

        if (sb && !sb.ended) {
          sb.ended = true;
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: " + type + " sourceBuffer now EOS");
        }
      }
    }

    var endStream = function endStream() {
      var mediaSource = _this8.mediaSource;

      if (!mediaSource || mediaSource.readyState !== 'open') {
        return;
      } // Allow this to throw and be caught by the enqueueing function


      mediaSource.endOfStream();
    };

    this.blockBuffers(endStream);
  };

  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
    var details = _ref.details;

    if (!details.fragments.length) {
      return;
    }

    this.details = details;

    if (this.getSourceBufferTypes().length) {
      this.blockBuffers(this.updateMediaElementDuration.bind(this));
    } else {
      this.updateMediaElementDuration();
    }
  };

  _proto.flushLiveBackBuffer = function flushLiveBackBuffer() {
    // clear back buffer for live only
    var hls = this.hls,
        details = this.details,
        media = this.media,
        sourceBuffer = this.sourceBuffer;

    if (!media || details === null || details.live === false) {
      return;
    }

    var liveBackBufferLength = hls.config.liveBackBufferLength;

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(liveBackBufferLength) || liveBackBufferLength < 0) {
      return;
    }

    var currentTime = media.currentTime;
    var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, details.levelTargetDuration);
    this.getSourceBufferTypes().forEach(function (type) {
      var sb = sourceBuffer[type];

      if (sb) {
        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(sb); // when target buffer start exceeds actual buffer start

        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LIVE_BACK_BUFFER_REACHED, {
            bufferEnd: targetBackBufferPosition
          });
          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: targetBackBufferPosition,
            type: type
          });
        }
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  ;

  _proto.updateMediaElementDuration = function updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {
      return;
    }

    var details = this.details,
        hls = this.hls,
        media = this.media,
        mediaSource = this.mediaSource;
    var levelDuration = details.fragments[0].start + details.totalduration;
    var mediaDuration = media.duration;
    var msDuration = Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaSource.duration) ? mediaSource.duration : 0;

    if (details.live && hls.config.liveDurationInfinity) {
      // Override duration to Infinity
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: Media Source duration is set to Infinity');
      mediaSource.duration = Infinity;
      this.updateSeekableRange(details);
    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaDuration)) {
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update Media Source duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Updating Media Source duration to " + levelDuration.toFixed(3));
      mediaSource.duration = levelDuration;
    }
  };

  _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {
    var mediaSource = this.mediaSource;
    var fragments = levelDetails.fragments;
    var len = fragments.length;

    if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {
      var start = Math.max(0, fragments[0].start);
      var end = Math.max(start, start + levelDetails.totalduration);
      mediaSource.setLiveSeekableRange(start, end);
    }
  };

  _proto.checkPendingTracks = function checkPendingTracks() {
    var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
        operationQueue = this.operationQueue,
        pendingTracks = this.pendingTracks; // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.
    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after
    // data has been appended to existing ones.
    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.

    var pendingTracksCount = Object.keys(pendingTracks).length;

    if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
      // ok, let's create them now !
      this.createSourceBuffers(pendingTracks);
      this.pendingTracks = {}; // append any pending segments now !

      Object.keys(this.sourceBuffer).forEach(function (type) {
        operationQueue.executeNext(type);
      });
    }
  };

  _proto.createSourceBuffers = function createSourceBuffers(tracks) {
    var sourceBuffer = this.sourceBuffer,
        mediaSource = this.mediaSource;

    if (!mediaSource) {
      throw Error('createSourceBuffers called when mediaSource was null');
    }

    for (var trackName in tracks) {
      if (!sourceBuffer[trackName]) {
        var track = tracks[trackName];

        if (!track) {
          throw Error("source buffer exists for track " + trackName + ", however track does not");
        } // use levelCodec as first priority


        var codec = track.levelCodec || track.codec;
        var mimeType = track.container + ";codecs=" + codec;
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: creating sourceBuffer(" + mimeType + ")");

        try {
          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
          var sbName = trackName;
          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);
          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);
          this.addBufferListener(sbName, 'error', this._onSBUpdateError);
          this.tracks[trackName] = {
            buffer: sb,
            codec: codec,
            container: track.container,
            levelCodec: track.levelCodec,
            id: track.id
          };
        } catch (err) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: error while trying to add sourceBuffer: " + err.message);
          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
            type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_ADD_CODEC_ERROR,
            fatal: false,
            error: err,
            mimeType: mimeType
          });
        }
      }
    }

    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CREATED, {
      tracks: this.tracks
    });
  } // Keep as arrow functions so that we can directly reference these functions directly as event listeners
  ;

  _proto._onSBUpdateStart = function _onSBUpdateStart(type) {
    var operationQueue = this.operationQueue;
    var operation = operationQueue.current(type);
    operation.onStart();
  };

  _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {
    var operationQueue = this.operationQueue;
    var operation = operationQueue.current(type);
    operation.onComplete();
    operationQueue.shiftAndExecuteNext(type);
  };

  _proto._onSBUpdateError = function _onSBUpdateError(type, event) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: " + type + " SourceBuffer error", event); // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event

    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
      type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
      details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPENDING_ERROR,
      fatal: false
    }); // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue

    var operation = this.operationQueue.current(type);

    if (operation) {
      operation.onError(event);
    }
  } // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually
  ;

  _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
    var media = this.media,
        mediaSource = this.mediaSource,
        operationQueue = this.operationQueue,
        sourceBuffer = this.sourceBuffer;
    var sb = sourceBuffer[type];

    if (!media || !mediaSource || !sb) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
      operationQueue.shiftAndExecuteNext(type);
      return;
    }

    var mediaDuration = Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(media.duration) ? media.duration : Infinity;
    var msDuration = Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaSource.duration) ? mediaSource.duration : Infinity;
    var removeStart = Math.max(0, startOffset);
    var removeEnd = Math.min(endOffset, mediaDuration, msDuration);

    if (removeEnd > removeStart) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
      console.assert(!sb.updating, type + " sourceBuffer must not be updating");
      sb.remove(removeStart, removeEnd);
    } else {
      // Cycle the queue
      operationQueue.shiftAndExecuteNext(type);
    }
  } // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually
  ;

  _proto.appendExecutor = function appendExecutor(data, type) {
    var operationQueue = this.operationQueue,
        sourceBuffer = this.sourceBuffer;
    var sb = sourceBuffer[type];

    if (!sb) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Attempting to append to the " + type + " SourceBuffer, but it does not exist");
      operationQueue.shiftAndExecuteNext(type);
      return;
    }

    sb.ended = false;
    console.assert(!sb.updating, type + " sourceBuffer must not be updating");
    sb.appendBuffer(data);
  } // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  ;

  _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {
    var _this9 = this;

    if (buffers === void 0) {
      buffers = this.getSourceBufferTypes();
    }

    if (!buffers.length) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist');
      Promise.resolve(onUnblocked);
      return;
    }

    var operationQueue = this.operationQueue; // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);

    var blockingOperations = buffers.map(function (type) {
      return operationQueue.appendBlocker(type);
    });
    Promise.all(blockingOperations).then(function () {
      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);
      onUnblocked();
      buffers.forEach(function (type) {
        var sb = _this9.sourceBuffer[type]; // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to
        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)
        // While this is a workaround, it's probably useful to have around

        if (!sb || !sb.updating) {
          operationQueue.shiftAndExecuteNext(type);
        }
      });
    });
  };

  _proto.getSourceBufferTypes = function getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer);
  };

  _proto.addBufferListener = function addBufferListener(type, event, fn) {
    var buffer = this.sourceBuffer[type];

    if (!buffer) {
      return;
    }

    var listener = fn.bind(this, type);
    this.listeners[type].push({
      event: event,
      listener: listener
    });
    buffer.addEventListener(event, listener);
  };

  _proto.removeBufferListeners = function removeBufferListeners(type) {
    var buffer = this.sourceBuffer[type];

    if (!buffer) {
      return;
    }

    this.listeners[type].forEach(function (l) {
      buffer.removeEventListener(l.event, l.listener);
    });
  };

  return BufferController;
}();



/***/ }),

/***/ "./src/controller/buffer-operation-queue.ts":
/*!**************************************************!*\
  !*** ./src/controller/buffer-operation-queue.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferOperationQueue; });
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");


var BufferOperationQueue = /*#__PURE__*/function () {
  function BufferOperationQueue(sourceBufferReference) {
    this.buffers = void 0;
    this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    };
    this.buffers = sourceBufferReference;
  }

  var _proto = BufferOperationQueue.prototype;

  _proto.append = function append(operation, type) {
    var queue = this.queues[type];
    queue.push(operation);

    if (queue.length === 1 && this.buffers[type]) {
      this.executeNext(type);
    }
  };

  _proto.insertAbort = function insertAbort(operation, type) {
    var queue = this.queues[type];
    queue.unshift(operation);
    this.executeNext(type);
  };

  _proto.appendBlocker = function appendBlocker(type) {
    var execute;
    var promise = new Promise(function (resolve) {
      execute = resolve;
    });
    var operation = {
      execute: execute,
      onStart: function onStart() {},
      onComplete: function onComplete() {},
      onError: function onError() {}
    };
    this.append(operation, type);
    return promise;
  };

  _proto.executeNext = function executeNext(type) {
    var buffers = this.buffers,
        queues = this.queues;
    var sb = buffers[type];
    var queue = queues[type];

    if (queue.length) {
      var operation = queue[0];

      try {
        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations
        // which do not end with this event must call _onSBUpdateEnd manually
        operation.execute();
      } catch (e) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn('[buffer-operation-queue]: Unhandled exception executing the current operation');
        operation.onError(e); // Only shift the current operation off, otherwise the updateend handler will do this for us

        if (!sb || !sb.updating) {
          queue.shift();
        }
      }
    }
  };

  _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
    this.queues[type].shift();
    this.executeNext(type);
  };

  _proto.current = function current(type) {
    return this.queues[type][0];
  };

  return BufferOperationQueue;
}();



/***/ }),

/***/ "./src/controller/cap-level-controller.ts":
/*!************************************************!*\
  !*** ./src/controller/cap-level-controller.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * cap stream level to media size dimension controller
 */


var CapLevelController = /*#__PURE__*/function () {
  function CapLevelController(hls) {
    this.autoLevelCapping = void 0;
    this.firstLevel = void 0;
    this.levels = void 0;
    this.media = void 0;
    this.restrictedLevels = void 0;
    this.timer = void 0;
    this.hls = void 0;
    this.streamController = void 0;
    this.clientRect = void 0;
    this.hls = hls;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    this.levels = [];
    this.firstLevel = -1;
    this.media = null;
    this.restrictedLevels = [];
    this.timer = undefined;
    this.clientRect = null;
    this.registerListeners();
  }

  var _proto = CapLevelController.prototype;

  _proto.setStreamController = function setStreamController(streamController) {
    this.streamController = streamController;
  };

  _proto.destroy = function destroy() {
    this.unregisterListener();

    if (this.hls.config.capLevelToPlayerSize) {
      this.media = null;
      this.clientRect = null;
      this.stopCapping();
    }
  };

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
  };

  _proto.unregisterListener = function unregisterListener() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
  };

  _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
    // Don't add a restricted level more than once
    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
      this.restrictedLevels.push(data.droppedLevel);
    }
  };

  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
  };

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    var hls = this.hls;
    this.restrictedLevels = [];
    this.levels = data.levels;
    this.firstLevel = data.firstLevel;

    if (hls.config.capLevelToPlayerSize && data.video) {
      // Start capping immediately if the manifest has signaled video codecs
      this.startCapping();
    }
  } // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  ;

  _proto.onBufferCodecs = function onBufferCodecs(event, data) {
    var hls = this.hls;

    if (hls.config.capLevelToPlayerSize && data.video) {
      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present
      this.startCapping();
    }
  };

  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
    this.levels = data.levels;
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    this.stopCapping();
  };

  _proto.detectPlayerSize = function detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      var levelsLength = this.levels ? this.levels.length : 0;

      if (levelsLength) {
        var hls = this.hls;
        hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);

        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
          // usually happen when the user go to the fullscreen mode.
          this.streamController.nextLevelSwitch();
        }

        this.autoLevelCapping = hls.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  ;

  _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
    var _this = this;

    if (!this.levels) {
      return -1;
    }

    var validLevels = this.levels.filter(function (level, index) {
      return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;
    });
    this.clientRect = null;
    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
  };

  _proto.startCapping = function startCapping() {
    if (this.timer) {
      // Don't reset capping if started twice; this can happen if the manifest signals a video codec
      return;
    }

    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
    self.clearInterval(this.timer);
    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);
    this.detectPlayerSize();
  };

  _proto.stopCapping = function stopCapping() {
    this.restrictedLevels = [];
    this.firstLevel = -1;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;

    if (this.timer) {
      self.clearInterval(this.timer);
      this.timer = undefined;
    }
  };

  _proto.getDimensions = function getDimensions() {
    if (this.clientRect) {
      return this.clientRect;
    }

    var media = this.media;
    var boundsRect = {
      width: 0,
      height: 0
    };

    if (media) {
      var clientRect = media.getBoundingClientRect();
      boundsRect.width = clientRect.width;
      boundsRect.height = clientRect.height;

      if (!boundsRect.width && !boundsRect.height) {
        // When the media element has no width or height (equivalent to not being in the DOM),
        // then use its width and height attributes (media.width, media.height)
        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
      }
    }

    this.clientRect = boundsRect;
    return boundsRect;
  };

  CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {
    if (restrictedLevels === void 0) {
      restrictedLevels = [];
    }

    return restrictedLevels.indexOf(level) === -1;
  };

  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
    if (!levels || levels && !levels.length) {
      return -1;
    } // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
    // to determine whether we've chosen the greatest bandwidth for the media's dimensions


    var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
      if (!nextLevel) {
        return true;
      }

      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
    }; // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
    // the max level


    var maxLevelIndex = levels.length - 1;

    for (var i = 0; i < levels.length; i += 1) {
      var level = levels[i];

      if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
        maxLevelIndex = i;
        break;
      }
    }

    return maxLevelIndex;
  };

  _createClass(CapLevelController, [{
    key: "mediaWidth",
    get: function get() {
      return this.getDimensions().width * CapLevelController.contentScaleFactor;
    }
  }, {
    key: "mediaHeight",
    get: function get() {
      return this.getDimensions().height * CapLevelController.contentScaleFactor;
    }
  }], [{
    key: "contentScaleFactor",
    get: function get() {
      var pixelRatio = 1;

      try {
        pixelRatio = self.devicePixelRatio;
      } catch (e) {
        /* no-op */
      }

      return pixelRatio;
    }
  }]);

  return CapLevelController;
}();

/* harmony default export */ __webpack_exports__["default"] = (CapLevelController);

/***/ }),

/***/ "./src/controller/eme-controller.ts":
/*!******************************************!*\
  !*** ./src/controller/eme-controller.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/mediakeys-helper */ "./src/utils/mediakeys-helper.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @author Stephan Hesse <disparat@gmail.com> | <tchakabam@gmail.com>
 *
 * DRM support for Hls.js
 */




var MAX_LICENSE_REQUEST_FAILURES = 3;
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @param {object} drmSystemOptions Optional parameters/requirements for the key-system
 * @returns {Array<MediaSystemConfiguration>} An array of supported configurations
 */

var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
  /* jshint ignore:line */
  var baseConfig = {
    // initDataTypes: ['keyids', 'mp4'],
    // label: "",
    // persistentState: "not-allowed", // or "required" ?
    // distinctiveIdentifier: "not-allowed", // or "required" ?
    // sessionTypes: ['temporary'],
    audioCapabilities: [],
    // { contentType: 'audio/mp4; codecs="mp4a.40.2"' }
    videoCapabilities: [] // { contentType: 'video/mp4; codecs="avc1.42E01E"' }

  };
  audioCodecs.forEach(function (codec) {
    baseConfig.audioCapabilities.push({
      contentType: "audio/mp4; codecs=\"" + codec + "\"",
      robustness: drmSystemOptions.audioRobustness || ''
    });
  });
  videoCodecs.forEach(function (codec) {
    baseConfig.videoCapabilities.push({
      contentType: "video/mp4; codecs=\"" + codec + "\"",
      robustness: drmSystemOptions.videoRobustness || ''
    });
  });
  return [baseConfig];
};
/**
 * The idea here is to handle key-system (and their respective platforms) specific configuration differences
 * in order to work with the local requestMediaKeySystemAccess method.
 *
 * We can also rule-out platform-related key-system support at this point by throwing an error.
 *
 * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
 * @param {Array<string>} audioCodecs List of required audio codecs to support
 * @param {Array<string>} videoCodecs List of required video codecs to support
 * @throws will throw an error if a unknown key system is passed
 * @returns {Array<MediaSystemConfiguration>} A non-empty Array of MediaKeySystemConfiguration objects
 */


var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
  switch (keySystem) {
    case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
      return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions);

    default:
      throw new Error("Unknown key-system: " + keySystem);
  }
};

/**
 * Controller to deal with encrypted media extensions (EME)
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API
 *
 * @class
 * @constructor
 */
var EMEController = /*#__PURE__*/function () {
  /**
   * @constructs
   * @param {Hls} hls Our Hls.js instance
   */
  function EMEController(hls) {
    var _this = this;

    this.hls = void 0;
    this._widevineLicenseUrl = void 0;
    this._licenseXhrSetup = void 0;
    this._emeEnabled = void 0;
    this._requestMediaKeySystemAccess = void 0;
    this._drmSystemOptions = void 0;
    this._config = void 0;
    this._mediaKeysList = [];
    this._media = null;
    this._hasSetMediaKeys = false;
    this._requestLicenseFailureCount = 0;
    this.mediaKeysPromise = null;

    this._onMediaEncrypted = function (e) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Media is encrypted using \"" + e.initDataType + "\" init data type");

      if (!_this.mediaKeysPromise) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Fatal: Media is encrypted but no CDM access or no keys have been requested');

        _this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
          type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
          details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
          fatal: true
        });

        return;
      }

      var finallySetKeyAndStartSession = function finallySetKeyAndStartSession(mediaKeys) {
        if (!_this._media) {
          return;
        }

        _this._attemptSetMediaKeys(mediaKeys);

        _this._generateRequestWithPreferredKeySession(e.initDataType, e.initData);
      }; // Could use `Promise.finally` but some Promise polyfills are missing it


      _this.mediaKeysPromise.then(finallySetKeyAndStartSession).catch(finallySetKeyAndStartSession);
    };

    this.hls = hls;
    this._config = hls.config;
    this._widevineLicenseUrl = this._config.widevineLicenseUrl;
    this._licenseXhrSetup = this._config.licenseXhrSetup;
    this._emeEnabled = this._config.emeEnabled;
    this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc;
    this._drmSystemOptions = this._config.drmSystemOptions;

    this._registerListeners();
  }

  var _proto = EMEController.prototype;

  _proto.destroy = function destroy() {
    this._unregisterListeners();
  };

  _proto._registerListeners = function _registerListeners() {
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
  }
  /**
   * @param {string} keySystem Identifier for the key-system, see `KeySystems` enum
   * @returns {string} License server URL for key-system (if any configured, otherwise causes error)
   * @throws if a unsupported keysystem is passed
   */
  ;

  _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
    switch (keySystem) {
      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
        if (!this._widevineLicenseUrl) {
          break;
        }

        return this._widevineLicenseUrl;
    }

    throw new Error("no license server URL configured for key-system \"" + keySystem + "\"");
  }
  /**
   * Requests access object and adds it to our list upon success
   * @private
   * @param {string} keySystem System ID (see `KeySystems`)
   * @param {Array<string>} audioCodecs List of required audio codecs to support
   * @param {Array<string>} videoCodecs List of required video codecs to support
   * @throws When a unsupported KeySystem is passed
   */
  ;

  _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
    var _this2 = this;

    // This can throw, but is caught in event handler callpath
    var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this._drmSystemOptions);
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Requesting encrypted media key-system access'); // expecting interface like window.navigator.requestMediaKeySystemAccess

    var keySystemAccessPromise = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
    this.mediaKeysPromise = keySystemAccessPromise.then(function (mediaKeySystemAccess) {
      return _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
    });
    keySystemAccessPromise.catch(function (err) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Failed to obtain key-system \"" + keySystem + "\" access:", err);
    });
  };

  /**
   * Handles obtaining access to a key-system
   * @private
   * @param {string} keySystem
   * @param {MediaKeySystemAccess} mediaKeySystemAccess https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemAccess
   */
  _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
    var _this3 = this;

    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Access for key-system \"" + keySystem + "\" obtained");
    var mediaKeysListItem = {
      mediaKeysSessionInitialized: false,
      mediaKeySystemAccess: mediaKeySystemAccess,
      mediaKeySystemDomain: keySystem
    };

    this._mediaKeysList.push(mediaKeysListItem);

    var mediaKeysPromise = Promise.resolve().then(function () {
      return mediaKeySystemAccess.createMediaKeys();
    }).then(function (mediaKeys) {
      mediaKeysListItem.mediaKeys = mediaKeys;
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Media-keys created for key-system \"" + keySystem + "\"");

      _this3._onMediaKeysCreated();

      return mediaKeys;
    });
    mediaKeysPromise.catch(function (err) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Failed to create media-keys:', err);
    });
    return mediaKeysPromise;
  }
  /**
   * Handles key-creation (represents access to CDM). We are going to create key-sessions upon this
   * for all existing keys where no session exists yet.
   *
   * @private
   */
  ;

  _proto._onMediaKeysCreated = function _onMediaKeysCreated() {
    var _this4 = this;

    // check for all key-list items if a session exists, otherwise, create one
    this._mediaKeysList.forEach(function (mediaKeysListItem) {
      if (!mediaKeysListItem.mediaKeysSession) {
        // mediaKeys is definitely initialized here
        mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();

        _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
      }
    });
  }
  /**
   * @private
   * @param {*} keySession
   */
  ;

  _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {
    var _this5 = this;

    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("New key-system session " + keySession.sessionId);
    keySession.addEventListener('message', function (event) {
      _this5._onKeySessionMessage(keySession, event.message);
    }, false);
  }
  /**
   * @private
   * @param {MediaKeySession} keySession
   * @param {ArrayBuffer} message
   */
  ;

  _proto._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Got EME message event, creating license request');

    this._requestLicense(message, function (data) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Received license data (length: " + (data ? data.byteLength : data) + "), updating key-session");
      keySession.update(data);
    });
  }
  /**
   * @private
   * @param e {MediaEncryptedEvent}
   */
  ;

  /**
   * @private
   */
  _proto._attemptSetMediaKeys = function _attemptSetMediaKeys(mediaKeys) {
    if (!this._media) {
      throw new Error('Attempted to set mediaKeys without first attaching a media element');
    }

    if (!this._hasSetMediaKeys) {
      // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
      var keysListItem = this._mediaKeysList[0];

      if (!keysListItem || !keysListItem.mediaKeys) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet');
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
          type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
          details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
          fatal: true
        });
        return;
      }

      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Setting keys for encrypted media');

      this._media.setMediaKeys(keysListItem.mediaKeys);

      this._hasSetMediaKeys = true;
    }
  }
  /**
   * @private
   */
  ;

  _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(initDataType, initData) {
    var _this6 = this;

    // FIXME: see if we can/want/need-to really to deal with several potential key-sessions?
    var keysListItem = this._mediaKeysList[0];

    if (!keysListItem) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Fatal: Media is encrypted but not any key-system access has been obtained yet');
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
        fatal: true
      });
      return;
    }

    if (keysListItem.mediaKeysSessionInitialized) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('Key-Session already initialized but requested again');
      return;
    }

    var keySession = keysListItem.mediaKeysSession;

    if (!keySession) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Fatal: Media is encrypted but no key-session existing');
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
        fatal: true
      });
      return;
    } // initData is null if the media is not CORS-same-origin


    if (!initData) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('Fatal: initData required for generating a key session is null');
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_INIT_DATA,
        fatal: true
      });
      return;
    }

    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Generating key-session request for \"" + initDataType + "\" init data type");
    keysListItem.mediaKeysSessionInitialized = true;
    keySession.generateRequest(initDataType, initData).then(function () {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].debug('Key-session generation succeeded');
    }).catch(function (err) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Error generating key-session request:', err);

      _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
        fatal: false
      });
    });
  }
  /**
   * @private
   * @param {string} url License server URL
   * @param {ArrayBuffer} keyMessage Message data issued by key-system
   * @param {function} callback Called when XHR has succeeded
   * @returns {XMLHttpRequest} Unsent (but opened state) XHR object
   * @throws if XMLHttpRequest construction failed
   */
  ;

  _proto._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {
    var xhr = new XMLHttpRequest();
    var licenseXhrSetup = this._licenseXhrSetup;

    try {
      if (licenseXhrSetup) {
        try {
          licenseXhrSetup(xhr, url);
        } catch (e) {
          // let's try to open before running setup
          xhr.open('POST', url, true);
          licenseXhrSetup(xhr, url);
        }
      } // if licenseXhrSetup did not yet call open, let's do it now


      if (!xhr.readyState) {
        xhr.open('POST', url, true);
      }
    } catch (e) {
      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
      throw new Error("issue setting up KeySystem license XHR " + e);
    } // Because we set responseType to ArrayBuffer here, callback is typed as handling only array buffers


    xhr.responseType = 'arraybuffer';
    xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
    return xhr;
  }
  /**
   * @private
   * @param {XMLHttpRequest} xhr
   * @param {string} url License server URL
   * @param {ArrayBuffer} keyMessage Message data issued by key-system
   * @param {function} callback Called when XHR has succeeded
   */
  ;

  _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
    switch (xhr.readyState) {
      case 4:
        if (xhr.status === 200) {
          this._requestLicenseFailureCount = 0;
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('License request succeeded');

          if (xhr.responseType !== 'arraybuffer') {
            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('xhr response type was not set to the expected arraybuffer for license request');
          }

          callback(xhr.response);
        } else {
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")");
          this._requestLicenseFailureCount++;

          if (this._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES) {
            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
              type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
              details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
              fatal: true
            });
            return;
          }

          var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
          _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Retrying license request, " + attemptsLeft + " attempts left");

          this._requestLicense(keyMessage, callback);
        }

        break;
    }
  }
  /**
   * @private
   * @param {MediaKeysListItem} keysListItem
   * @param {ArrayBuffer} keyMessage
   * @returns {ArrayBuffer} Challenge data posted to license server
   * @throws if KeySystem is unsupported
   */
  ;

  _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
    switch (keysListItem.mediaKeySystemDomain) {
      // case KeySystems.PLAYREADY:
      // from https://github.com/MicrosoftEdge/Demos/blob/master/eme/scripts/demo.js

      /*
      if (this.licenseType !== this.LICENSE_TYPE_WIDEVINE) {
        // For PlayReady CDMs, we need to dig the Challenge out of the XML.
        var keyMessageXml = new DOMParser().parseFromString(String.fromCharCode.apply(null, new Uint16Array(keyMessage)), 'application/xml');
        if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
            challenge = atob(keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0].nodeValue);
        } else {
            throw 'Cannot find <Challenge> in key message';
        }
        var headerNames = keyMessageXml.getElementsByTagName('name');
        var headerValues = keyMessageXml.getElementsByTagName('value');
        if (headerNames.length !== headerValues.length) {
            throw 'Mismatched header <name>/<value> pair in key message';
        }
        for (var i = 0; i < headerNames.length; i++) {
            xhr.setRequestHeader(headerNames[i].childNodes[0].nodeValue, headerValues[i].childNodes[0].nodeValue);
        }
      }
      break;
      */
      case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
        // For Widevine CDMs, the challenge is the keyMessage.
        return keyMessage;
    }

    throw new Error("unsupported key-system: " + keysListItem.mediaKeySystemDomain);
  }
  /**
   * @private
   * @param keyMessage
   * @param callback
   */
  ;

  _proto._requestLicense = function _requestLicense(keyMessage, callback) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Requesting content license for key-system');
    var keysListItem = this._mediaKeysList[0];

    if (!keysListItem) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Fatal error: Media is encrypted but no key-system access has been obtained yet');
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
        fatal: true
      });
      return;
    }

    try {
      var _url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);

      var _xhr = this._createLicenseXhr(_url, keyMessage, callback);

      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Sending license request to URL: " + _url);

      var challenge = this._generateLicenseRequestChallenge(keysListItem, keyMessage);

      _xhr.send(challenge);
    } catch (e) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Failure requesting DRM license: " + e);
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
        fatal: true
      });
    }
  };

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    if (!this._emeEnabled) {
      return;
    }

    var media = data.media; // keep reference of media

    this._media = media;
    media.addEventListener('encrypted', this._onMediaEncrypted);
  };

  _proto.onMediaDetached = function onMediaDetached() {
    var media = this._media;
    var mediaKeysList = this._mediaKeysList;

    if (!media) {
      return;
    }

    media.removeEventListener('encrypted', this._onMediaEncrypted);
    this._media = null;
    this._mediaKeysList = []; // Close all sessions and remove media keys from the video element.

    Promise.all(mediaKeysList.map(function (mediaKeysListItem) {
      if (mediaKeysListItem.mediaKeysSession) {
        return mediaKeysListItem.mediaKeysSession.close().catch(function () {// Ignore errors when closing the sessions. Closing a session that
          // generated no key requests will throw an error.
        });
      }
    })).then(function () {
      return media.setMediaKeys(null);
    }).catch(function () {// Ignore any failures while removing media keys from the video element.
    });
  };

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    if (!this._emeEnabled) {
      return;
    }

    var audioCodecs = data.levels.map(function (level) {
      return level.audioCodec;
    }).filter(function (audioCodec) {
      return !!audioCodec;
    });
    var videoCodecs = data.levels.map(function (level) {
      return level.videoCodec;
    }).filter(function (videoCodec) {
      return !!videoCodec;
    });

    this._attemptKeySystemAccess(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE, audioCodecs, videoCodecs);
  };

  _createClass(EMEController, [{
    key: "requestMediaKeySystemAccess",
    get: function get() {
      if (!this._requestMediaKeySystemAccess) {
        throw new Error('No requestMediaKeySystemAccess function configured');
      }

      return this._requestMediaKeySystemAccess;
    }
  }]);

  return EMEController;
}();

/* harmony default export */ __webpack_exports__["default"] = (EMEController);

/***/ }),

/***/ "./src/controller/fps-controller.ts":
/*!******************************************!*\
  !*** ./src/controller/fps-controller.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");



var FPSController = /*#__PURE__*/function () {
  // stream controller must be provided as a dependency!
  function FPSController(hls) {
    this.hls = void 0;
    this.isVideoPlaybackQualityAvailable = false;
    this.timer = void 0;
    this.media = null;
    this.lastTime = void 0;
    this.lastDroppedFrames = 0;
    this.lastDecodedFrames = 0;
    this.streamController = void 0;
    this.hls = hls;
    this.registerListeners();
  }

  var _proto = FPSController.prototype;

  _proto.setStreamController = function setStreamController(streamController) {
    this.streamController = streamController;
  };

  _proto.registerListeners = function registerListeners() {
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching);
  };

  _proto.destroy = function destroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }

    this.unregisterListeners();
    this.isVideoPlaybackQualityAvailable = false;
    this.media = null;
  };

  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
    var config = this.hls.config;

    if (config.capLevelOnFPSDrop) {
      var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
      this.media = media;

      if (media && typeof media.getVideoPlaybackQuality === 'function') {
        this.isVideoPlaybackQualityAvailable = true;
      }

      self.clearInterval(this.timer);
      this.timer = self.setTimeout(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
    }
  };

  _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
    var currentTime = performance.now();

    if (decodedFrames) {
      if (this.lastTime) {
        var currentPeriod = currentTime - this.lastTime;
        var currentDropped = droppedFrames - this.lastDroppedFrames;
        var currentDecoded = decodedFrames - this.lastDecodedFrames;
        var droppedFPS = 1000 * currentDropped / currentPeriod;
        var hls = this.hls;
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP, {
          currentDropped: currentDropped,
          currentDecoded: currentDecoded,
          totalDroppedFrames: droppedFrames
        });

        if (droppedFPS > 0) {
          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
            var currentLevel = hls.currentLevel;
            _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);

            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
              currentLevel = currentLevel - 1;
              hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, {
                level: currentLevel,
                droppedLevel: hls.currentLevel
              });
              hls.autoLevelCapping = currentLevel;
              this.streamController.nextLevelSwitch();
            }
          }
        }
      }

      this.lastTime = currentTime;
      this.lastDroppedFrames = droppedFrames;
      this.lastDecodedFrames = decodedFrames;
    }
  };

  _proto.checkFPSInterval = function checkFPSInterval() {
    var video = this.media;

    if (video) {
      if (this.isVideoPlaybackQualityAvailable) {
        var videoPlaybackQuality = video.getVideoPlaybackQuality();
        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
      } else {
        // HTMLVideoElement doesn't include the webkit types
        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
      }
    }
  };

  return FPSController;
}();

/* harmony default export */ __webpack_exports__["default"] = (FPSController);

/***/ }),

/***/ "./src/controller/fragment-finders.ts":
/*!********************************************!*\
  !*** ./src/controller/fragment-finders.ts ***!
  \********************************************/
/*! exports provided: findFragmentByPDT, findFragmentByPTS, fragmentWithinToleranceTest, pdtWithinToleranceTest, findFragWithCC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFragmentByPDT", function() { return findFragmentByPDT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFragmentByPTS", function() { return findFragmentByPTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentWithinToleranceTest", function() { return fragmentWithinToleranceTest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pdtWithinToleranceTest", function() { return pdtWithinToleranceTest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFragWithCC", function() { return findFragWithCC; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/binary-search */ "./src/utils/binary-search.ts");



/**
 * Returns first fragment whose endPdt value exceeds the given PDT.
 * @param {Array<Fragment>} fragments - The array of candidate fragments
 * @param {number|null} [PDTValue = null] - The PDT value which must be exceeded
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*|null} fragment - The best matching fragment
 */
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(PDTValue)) {
    return null;
  } // if less than start


  var startPDT = fragments[0].programDateTime;

  if (PDTValue < (startPDT || 0)) {
    return null;
  }

  var endPDT = fragments[fragments.length - 1].endProgramDateTime;

  if (PDTValue >= (endPDT || 0)) {
    return null;
  }

  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;

  for (var seg = 0; seg < fragments.length; ++seg) {
    var frag = fragments[seg];

    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }

  return null;
}
/**
 * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.
 * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus
 * breaking any traps which would cause the same fragment to be continuously selected within a small range.
 * @param {*} fragPrevious - The last frag successfully appended
 * @param {Array} fragments - The array of candidate fragments
 * @param {number} [bufferEnd = 0] - The end of the contiguous buffered range the playhead is currently within
 * @param {number} maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous
 * @returns {*} foundFrag - The best matching fragment
 */

function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
  if (bufferEnd === void 0) {
    bufferEnd = 0;
  }

  if (maxFragLookUpTolerance === void 0) {
    maxFragLookUpTolerance = 0;
  }

  var fragNext = null;

  if (fragPrevious) {
    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1];
  } else if (bufferEnd === 0 && fragments[0].start === 0) {
    fragNext = fragments[0];
  } // Prefer the next fragment if it's within tolerance


  if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
    return fragNext;
  } // We might be seeking past the tolerance so find the best match


  var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));

  if (foundFragment) {
    return foundFragment;
  } // If no match was found return the next fragment after fragPrevious, or null


  return fragNext;
}
/**
 * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.
 * @param {*} candidate - The fragment to test
 * @param {number} [bufferEnd = 0] - The end of the current buffered range the playhead is currently within
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {number} - 0 if it matches, 1 if too low, -1 if too high
 */

function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
  if (bufferEnd === void 0) {
    bufferEnd = 0;
  }

  if (maxFragLookUpTolerance === void 0) {
    maxFragLookUpTolerance = 0;
  }

  // offset should be within fragment boundary - config.maxFragLookUpTolerance
  // this is to cope with situations like
  // bufferEnd = 9.991
  // frag[] : [0,10]
  // frag[1] : [10,20]
  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
  //              frag start               frag start+duration
  //                  |-----------------------------|
  //              <--->                         <--->
  //  ...--------><-----------------------------><---------....
  // previous frag         matching fragment         next frag
  //  return -1             return 0                 return 1
  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));

  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
    return -1;
  }

  return 0;
}
/**
 * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.
 * This function tests the candidate's program date time values, as represented in Unix time
 * @param {*} candidate - The fragment to test
 * @param {number} [pdtBufferEnd = 0] - The Unix time representing the end of the current buffered range
 * @param {number} [maxFragLookUpTolerance = 0] - The amount of time that a fragment's start can be within in order to be considered contiguous
 * @returns {boolean} True if contiguous, false otherwise
 */

function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000; // endProgramDateTime can be null, default to zero

  var endProgramDateTime = candidate.endProgramDateTime || 0;
  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}
function findFragWithCC(fragments, CC) {
  return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

/***/ }),

/***/ "./src/controller/fragment-tracker.ts":
/*!********************************************!*\
  !*** ./src/controller/fragment-tracker.ts ***!
  \********************************************/
/*! exports provided: FragmentState, FragmentTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentState", function() { return FragmentState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentTracker", function() { return FragmentTracker; });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");

var FragmentState;

(function (FragmentState) {
  FragmentState["NOT_LOADED"] = "NOT_LOADED";
  FragmentState["BACKTRACKED"] = "BACKTRACKED";
  FragmentState["APPENDING"] = "APPENDING";
  FragmentState["PARTIAL"] = "PARTIAL";
  FragmentState["OK"] = "OK";
})(FragmentState || (FragmentState = {}));

var FragmentTracker = /*#__PURE__*/function () {
  function FragmentTracker(hls) {
    this.activeFragment = null;
    this.activePart = null;
    this.fragments = Object.create(null);
    this.timeRanges = Object.create(null);
    this.bufferPadding = 0.2;
    this.hls = void 0;
    this.hls = hls;

    this._registerListeners();
  }

  var _proto = FragmentTracker.prototype;

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_APPENDED, this.onBufferAppended, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_LOADED, this.onFragLoaded, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_APPENDED, this.onBufferAppended, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_LOADED, this.onFragLoaded, this);
  };

  _proto.destroy = function destroy() {
    this.fragments = Object.create(null);
    this.timeRanges = Object.create(null);

    this._unregisterListeners();
  }
  /**
   * Return a Fragment with an appended range that matches the position and levelType.
   * If not found any Fragment, return null
   */
  ;

  _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
    var activeFragment = this.activeFragment;

    if (!activeFragment) {
      return null;
    }

    if (activeFragment.appendedPTS !== undefined && activeFragment.start <= position && position <= activeFragment.appendedPTS) {
      return activeFragment;
    }

    return this.getBufferedFrag(position, levelType);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  ;

  _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
    var fragments = this.fragments;
    var keys = Object.keys(fragments);

    for (var i = keys.length; i--;) {
      var fragmentEntity = fragments[keys[i]];

      if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
        var frag = fragmentEntity.body;

        if (frag.start <= position && position <= frag.end) {
          return frag;
        }
      }
    }

    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  ;

  _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange) {
    var _this = this;

    // Check if any flagged fragments have been unloaded
    Object.keys(this.fragments).forEach(function (key) {
      var fragmentEntity = _this.fragments[key];

      if (!fragmentEntity || !fragmentEntity.buffered) {
        return;
      }

      var esData = fragmentEntity.range[elementaryStream];

      if (!esData) {
        return;
      }

      esData.time.some(function (time) {
        var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);

        if (isNotBuffered) {
          // Unregister partial fragment as it needs to load again to be reused
          _this.removeFragment(fragmentEntity.body);
        }

        return isNotBuffered;
      });
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  ;

  _proto.detectPartialFragments = function detectPartialFragments(data) {
    var _this2 = this;

    var timeRanges = this.timeRanges;
    var frag = data.frag,
        part = data.part;

    if (!timeRanges || frag.sn === 'initSegment') {
      return;
    }

    var fragKey = getFragmentKey(frag);
    var fragmentEntity = this.fragments[fragKey];

    if (!fragmentEntity) {
      return;
    }

    fragmentEntity.buffered = true;
    fragmentEntity.backtrack = fragmentEntity.loaded = null;
    Object.keys(timeRanges).forEach(function (elementaryStream) {
      var streamInfo = frag.elementaryStreams[elementaryStream];

      if (!streamInfo) {
        return;
      }

      var timeRange = timeRanges[elementaryStream];
      var partial = part !== null || streamInfo.partial === true;
      fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
    });
  };

  _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
    var buffered = {
      time: [],
      partial: partial
    };
    var startPTS = part ? part.start : fragment.start;
    var endPTS = part ? part.end : fragment.end;
    var minEndPTS = fragment.minEndPTS || endPTS;
    var maxStartPTS = fragment.maxStartPTS || startPTS;

    for (var i = 0; i < timeRange.length; i++) {
      var startTime = timeRange.start(i) - this.bufferPadding;
      var endTime = timeRange.end(i) + this.bufferPadding;

      if (maxStartPTS >= startTime && minEndPTS <= endTime) {
        // Fragment is entirely contained in buffer
        // No need to check the other timeRange times since it's completely playable
        buffered.time.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
        break;
      } else if (startPTS < endTime && endPTS > startTime) {
        buffered.partial = true; // Check for intersection with buffer
        // Get playable sections of the fragment

        buffered.time.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
      } else if (endPTS <= startTime) {
        // No need to check the rest of the timeRange as it is in order
        break;
      }
    }

    return buffered;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  ;

  _proto.getPartialFragment = function getPartialFragment(time) {
    var bestFragment = null;
    var timePadding;
    var startTime;
    var endTime;
    var bestOverlap = 0;
    var bufferPadding = this.bufferPadding,
        fragments = this.fragments;
    Object.keys(fragments).forEach(function (key) {
      var fragmentEntity = fragments[key];

      if (!fragmentEntity) {
        return;
      }

      if (isPartial(fragmentEntity)) {
        startTime = fragmentEntity.body.start - bufferPadding;
        endTime = fragmentEntity.body.end + bufferPadding;

        if (time >= startTime && time <= endTime) {
          // Use the fragment that has the most padding from start and end time
          timePadding = Math.min(time - startTime, endTime - time);

          if (bestOverlap <= timePadding) {
            bestFragment = fragmentEntity.body;
            bestOverlap = timePadding;
          }
        }
      }
    });
    return bestFragment;
  };

  _proto.getState = function getState(fragment) {
    var fragKey = getFragmentKey(fragment);
    var fragmentEntity = this.fragments[fragKey];

    if (fragmentEntity) {
      if (!fragmentEntity.buffered) {
        if (fragmentEntity.backtrack) {
          return FragmentState.BACKTRACKED;
        }

        return FragmentState.APPENDING;
      } else if (isPartial(fragmentEntity)) {
        return FragmentState.PARTIAL;
      } else {
        return FragmentState.OK;
      }
    }

    return FragmentState.NOT_LOADED;
  };

  _proto.backtrack = function backtrack(frag, data) {
    var fragKey = getFragmentKey(frag);
    var fragmentEntity = this.fragments[fragKey];

    if (!fragmentEntity || fragmentEntity.backtrack) {
      return;
    }

    fragmentEntity.backtrack = data ? data : fragmentEntity.loaded;
    fragmentEntity.loaded = null;
  };

  _proto.getBacktrackData = function getBacktrackData(fragment) {
    var fragKey = getFragmentKey(fragment);
    var fragmentEntity = this.fragments[fragKey];

    if (fragmentEntity) {
      var _backtrack$payload;

      var backtrack = fragmentEntity.backtrack; // If data was already sent to Worker it is detached no longer available

      if (backtrack !== null && backtrack !== void 0 && (_backtrack$payload = backtrack.payload) !== null && _backtrack$payload !== void 0 && _backtrack$payload.byteLength) {
        return backtrack;
      } else {
        this.removeFragment(fragment);
      }
    }

    return null;
  };

  _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
    var startTime;
    var endTime;

    for (var i = 0; i < timeRange.length; i++) {
      startTime = timeRange.start(i) - this.bufferPadding;
      endTime = timeRange.end(i) + this.bufferPadding;

      if (startPTS >= startTime && endPTS <= endTime) {
        return true;
      }

      if (endPTS <= startTime) {
        // No need to check the rest of the timeRange as it is in order
        return false;
      }
    }

    return false;
  };

  _proto.onFragLoaded = function onFragLoaded(event, data) {
    var frag = data.frag,
        part = data.part; // don't track initsegment (for which sn is not a number)
    // don't track frags used for bitrateTest, they're irrelevant.

    if (frag.sn === 'initSegment' || frag.bitrateTest || part) {
      return;
    }

    var fragKey = getFragmentKey(frag);
    this.fragments[fragKey] = {
      body: frag,
      part: part,
      loaded: data,
      backtrack: null,
      buffered: false,
      range: Object.create(null)
    };
  };

  _proto.onBufferAppended = function onBufferAppended(event, data) {
    var _this3 = this;

    var frag = data.frag,
        part = data.part,
        timeRanges = data.timeRanges;
    this.activeFragment = frag;
    this.activePart = part; // Store the latest timeRanges loaded in the buffer

    this.timeRanges = timeRanges;
    Object.keys(timeRanges).forEach(function (elementaryStream) {
      var timeRange = timeRanges[elementaryStream];

      _this3.detectEvictedFragments(elementaryStream, timeRange);

      if (!part) {
        for (var i = 0; i < timeRange.length; i++) {
          frag.appendedPTS = Math.max(timeRange.end(i), frag.appendedPTS || 0);
        }
      }
    });
  };

  _proto.onFragBuffered = function onFragBuffered(event, data) {
    this.detectPartialFragments(data);
  };

  _proto.hasFragment = function hasFragment(fragment) {
    var fragKey = getFragmentKey(fragment);
    return !!this.fragments[fragKey];
  };

  _proto.removeFragment = function removeFragment(fragment) {
    var fragKey = getFragmentKey(fragment);
    fragment.stats.loaded = 0;
    fragment.clearElementaryStreamInfo();
    delete this.fragments[fragKey];
  };

  _proto.removeAllFragments = function removeAllFragments() {
    this.fragments = Object.create(null);
  };

  return FragmentTracker;
}();

function isPartial(fragmentEntity) {
  var _fragmentEntity$range, _fragmentEntity$range2;

  return fragmentEntity.buffered && (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial));
}

function getFragmentKey(fragment) {
  return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
}

/***/ }),

/***/ "./src/controller/gap-controller.ts":
/*!******************************************!*\
  !*** ./src/controller/gap-controller.ts ***!
  \******************************************/
/*! exports provided: STALL_MINIMUM_DURATION_MS, MAX_START_GAP_JUMP, SKIP_BUFFER_HOLE_STEP_SECONDS, SKIP_BUFFER_RANGE_START, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STALL_MINIMUM_DURATION_MS", function() { return STALL_MINIMUM_DURATION_MS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_START_GAP_JUMP", function() { return MAX_START_GAP_JUMP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SKIP_BUFFER_HOLE_STEP_SECONDS", function() { return SKIP_BUFFER_HOLE_STEP_SECONDS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SKIP_BUFFER_RANGE_START", function() { return SKIP_BUFFER_RANGE_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GapController; });
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");




var STALL_MINIMUM_DURATION_MS = 250;
var MAX_START_GAP_JUMP = 2.0;
var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
var SKIP_BUFFER_RANGE_START = 0.05;

var GapController = /*#__PURE__*/function () {
  function GapController(config, media, fragmentTracker, hls) {
    this.config = void 0;
    this.media = void 0;
    this.fragmentTracker = void 0;
    this.hls = void 0;
    this.nudgeRetry = 0;
    this.stallReported = false;
    this.stalled = null;
    this.moved = false;
    this.seeking = false;
    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param {number} lastCurrentTime Previously read playhead position
   */


  var _proto = GapController.prototype;

  _proto.poll = function poll(lastCurrentTime) {
    var config = this.config,
        media = this.media,
        stalled = this.stalled;
    var currentTime = media.currentTime,
        seeking = media.seeking;
    var seeked = this.seeking && !seeking;
    var beginSeek = !this.seeking && seeking;
    this.seeking = seeking; // The playhead is moving, no-op

    if (currentTime !== lastCurrentTime) {
      this.moved = true;

      if (stalled !== null) {
        // The playhead is now moving, but was previously stalled
        if (this.stallReported) {
          var _stalledDuration = self.performance.now() - stalled;

          _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
          this.stallReported = false;
        }

        this.stalled = null;
        this.nudgeRetry = 0;
      }

      return;
    } // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek


    if (beginSeek || seeked) {
      this.stalled = null;
    } // The playhead should not be moving


    if (media.paused || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].getBuffered(media).length) {
      return;
    }

    var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].bufferInfo(media, currentTime, 0);
    var isBuffered = bufferInfo.len > 0;
    var nextStart = bufferInfo.nextStart || 0; // There is no playable buffer (seeked, waiting for buffer)

    if (!isBuffered && !nextStart) {
      return;
    }

    if (seeking) {
      // Waiting for seeking in a buffered range to complete
      var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP; // Next buffered range is too far ahead to jump to while still seeking

      var noBufferGap = !nextStart || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);

      if (hasEnoughBuffer || noBufferGap) {
        return;
      } // Reset moved state when seeking to a point in or before a gap


      this.moved = false;
    } // Skip start gaps if we haven't played, but the last poll detected the start of a stall
    // The addition poll gives the browser a chance to jump the gap for us


    if (!this.moved && this.stalled !== null) {
      var _level$details;

      // Jump start gaps within jump threshold
      var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime; // When joining a live stream with audio tracks, account for live playlist window sliding by allowing
      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment
      // that begins over 1 target duration after the video start position.

      var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
      var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;
      var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;

      if (startJump > 0 && startJump <= maxStartGapJump) {
        this._trySkipBufferHole(null);

        return;
      }
    } // Start tracking stall time


    var tnow = self.performance.now();

    if (stalled === null) {
      this.stalled = tnow;
      return;
    }

    var stalledDuration = tnow - stalled;

    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
      // Report stalling after trying to fix
      this._reportStall(bufferInfo.len);
    }

    var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].bufferInfo(media, currentTime, config.maxBufferHole);

    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  ;

  _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
    var config = this.config,
        fragmentTracker = this.fragmentTracker,
        media = this.media;
    var currentTime = media.currentTime;
    var partial = fragmentTracker.getPartialFragment(currentTime);

    if (partial) {
      // Try to skip over the buffer hole caused by a partial fragment
      // This method isn't limited by the size of the gap between buffered ranges
      var targetTime = this._trySkipBufferHole(partial); // we return here in this case, meaning
      // the branch below only executes when we don't handle a partial fragment


      if (targetTime) {
        return;
      }
    } // if we haven't had to skip over a buffer hole of a partial fragment
    // we may just have to "nudge" the playlist as the browser decoding/rendering engine
    // needs to cross some sort of threshold covering all source-buffers content
    // to start playing properly.


    if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn('Trying to nudge playhead over buffer-hole'); // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds
      // We only try to jump the hole if it's under the configured size
      // Reset stalled so to rearm watchdog timer

      this.stalled = null;

      this._tryNudgeBuffer();
    }
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  ;

  _proto._reportStall = function _reportStall(bufferLen) {
    var hls = this.hls,
        media = this.media,
        stallReported = this.stallReported;

    if (!stallReported) {
      // Report stalled error once
      this.stallReported = true;
      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Playback stalling at @" + media.currentTime + " due to low buffer (buffer=" + bufferLen + ")");
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_STALLED_ERROR,
        fatal: false,
        buffer: bufferLen
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param partial - The partial fragment found at the current time (where playback is stalling).
   * @private
   */
  ;

  _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
    var config = this.config,
        hls = this.hls,
        media = this.media;
    var currentTime = media.currentTime;
    var lastEndTime = 0; // Check if currentTime is between unbuffered regions of partial fragments

    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].getBuffered(media);

    for (var i = 0; i < buffered.length; i++) {
      var startTime = buffered.start(i);

      if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {
        var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
        this.moved = true;
        this.stalled = null;
        media.currentTime = targetTime;

        if (partial) {
          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime,
            frag: partial
          });
        }

        return targetTime;
      }

      lastEndTime = buffered.end(i);
    }

    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  ;

  _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
    var config = this.config,
        hls = this.hls,
        media = this.media;
    var currentTime = media.currentTime;
    var nudgeRetry = (this.nudgeRetry || 0) + 1;
    this.nudgeRetry = nudgeRetry;

    if (nudgeRetry < config.nudgeMaxRetry) {
      var targetTime = currentTime + nudgeRetry * config.nudgeOffset; // playback stalled in buffered area ... let's nudge currentTime to try to overcome this

      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
      media.currentTime = targetTime;
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_NUDGE_ON_STALL,
        fatal: false
      });
    } else {
      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_STALLED_ERROR,
        fatal: true
      });
    }
  };

  return GapController;
}();



/***/ }),

/***/ "./src/controller/id3-track-controller.ts":
/*!************************************************!*\
  !*** ./src/controller/id3-track-controller.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");



var MIN_CUE_DURATION = 0.25;

var ID3TrackController = /*#__PURE__*/function () {
  function ID3TrackController(hls) {
    this.hls = void 0;
    this.id3Track = null;
    this.media = null;
    this.hls = hls;

    this._registerListeners();
  }

  var _proto = ID3TrackController.prototype;

  _proto.destroy = function destroy() {
    this._unregisterListeners();
  };

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
  } // Add ID3 metatadata text track.
  ;

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    this.media = data.media;
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    if (!this.id3Track) {
      return;
    }

    Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__["clearCurrentCues"])(this.id3Track);
    this.id3Track = null;
    this.media = null;
  };

  _proto.getID3Track = function getID3Track(textTracks) {
    if (!this.media) {
      return;
    }

    for (var i = 0; i < textTracks.length; i++) {
      var textTrack = textTracks[i];

      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {
        // send 'addtrack' when reusing the textTrack for metadata,
        // same as what we do for captions
        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__["sendAddTrackEvent"])(textTrack, this.media);
        return textTrack;
      }
    }

    return this.media.addTextTrack('metadata', 'id3');
  };

  _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
    if (!this.media) {
      return;
    }

    var fragment = data.frag;
    var samples = data.samples; // create track dynamically

    if (!this.id3Track) {
      this.id3Track = this.getID3Track(this.media.textTracks);
      this.id3Track.mode = 'hidden';
    } // Attempt to recreate Safari functionality by creating
    // WebKitDataCue objects when available and store the decoded
    // ID3 data in the value property of the cue


    var Cue = self.WebKitDataCue || self.VTTCue || self.TextTrackCue;

    for (var i = 0; i < samples.length; i++) {
      var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_2__["getID3Frames"](samples[i].data);

      if (frames) {
        var startTime = samples[i].pts;
        var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.end;
        var timeDiff = endTime - startTime;

        if (timeDiff <= 0) {
          endTime = startTime + MIN_CUE_DURATION;
        }

        for (var j = 0; j < frames.length; j++) {
          var frame = frames[j]; // Safari doesn't put the timestamp frame in the TextTrack

          if (!_demux_id3__WEBPACK_IMPORTED_MODULE_2__["isTimeStampFrame"](frame)) {
            var cue = new Cue(startTime, endTime, '');
            cue.value = frame;
            this.id3Track.addCue(cue);
          }
        }
      }
    }
  };

  _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
    var startOffset = _ref.startOffset,
        endOffset = _ref.endOffset,
        type = _ref.type;

    if (!type || type === 'audio') {
      // id3 cues come from parsed audio only remove cues when audio buffer is cleared
      var id3Track = this.id3Track;

      if (!id3Track || !id3Track.cues || !id3Track.cues.length) {
        return;
      }

      var cues = Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__["getCuesInRange"])(id3Track.cues, startOffset, endOffset);

      for (var i = 0; i < cues.length; i++) {
        id3Track.removeCue(cues[i]);
      }
    }
  };

  return ID3TrackController;
}();

/* harmony default export */ __webpack_exports__["default"] = (ID3TrackController);

/***/ }),

/***/ "./src/controller/latency-controller.ts":
/*!**********************************************!*\
  !*** ./src/controller/latency-controller.ts ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LatencyController; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var LatencyController = /*#__PURE__*/function () {
  function LatencyController(hls) {
    var _this = this;

    this.hls = void 0;
    this.config = void 0;
    this.media = null;
    this.levelDetails = null;
    this.currentTime = 0;
    this.stallCount = 0;
    this._latency = null;

    this.timeupdateHandler = function () {
      return _this.timeupdate();
    };

    this.hls = hls;
    this.config = hls.config;
    this.registerListeners();
  }

  var _proto = LatencyController.prototype;

  _proto.destroy = function destroy() {
    this.unregisterListeners();
    this.onMediaDetaching();
  };

  _proto.registerListeners = function registerListeners() {
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated);
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError);
  };

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    this.media = data.media;
    this.media.addEventListener('timeupdate', this.timeupdateHandler);
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    if (this.media) {
      this.media.removeEventListener('timeupdate', this.timeupdateHandler);
      this.media = null;
    }
  };

  _proto.onManifestLoading = function onManifestLoading() {
    this.levelDetails = null;
    this._latency = null;
    this.stallCount = 0;
  };

  _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
    var details = _ref.details;
    this.levelDetails = details;

    if (details.advanced) {
      this.timeupdate();
    }

    if (!details.live && this.media) {
      this.media.removeEventListener('timeupdate', this.timeupdateHandler);
    }
  };

  _proto.onError = function onError(event, data) {
    if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__["ErrorDetails"].BUFFER_STALLED_ERROR) {
      return;
    }

    this.stallCount++;
    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('[playback-rate-controller]: Stall detected, adjusting target latency');
  };

  _proto.timeupdate = function timeupdate() {
    var media = this.media,
        levelDetails = this.levelDetails;

    if (!media || !levelDetails) {
      return;
    }

    this.currentTime = media.currentTime;
    var latency = this.computeLatency();

    if (latency === null) {
      return;
    }

    this._latency = latency; // Adapt playbackRate to meet target latency in low-latency mode

    var _this$config = this.config,
        lowLatencyMode = _this$config.lowLatencyMode,
        maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;

    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {
      return;
    }

    var targetLatency = this.targetLatency;

    if (targetLatency === null) {
      return;
    }

    var distanceFromTarget = latency - targetLatency; // Only adjust playbackRate when within one target duration of targetLatency
    // and more than one second from under-buffering.
    // Playback further than one target duration from target can be considered DVR playback.

    var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
    var inLiveRange = distanceFromTarget < liveMinLatencyDuration;

    if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
      var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));
      var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
      media.playbackRate = Math.min(max, Math.max(1, rate));
    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
      media.playbackRate = 1;
    }
  };

  _proto.estimateLiveEdge = function estimateLiveEdge() {
    var levelDetails = this.levelDetails;

    if (levelDetails === null) {
      return null;
    }

    return levelDetails.edge + levelDetails.age;
  };

  _proto.computeLatency = function computeLatency() {
    var liveEdge = this.estimateLiveEdge();

    if (liveEdge === null) {
      return null;
    }

    return liveEdge - this.currentTime;
  };

  _createClass(LatencyController, [{
    key: "latency",
    get: function get() {
      return this._latency || 0;
    }
  }, {
    key: "maxLatency",
    get: function get() {
      var config = this.config,
          levelDetails = this.levelDetails;

      if (config.liveMaxLatencyDuration !== undefined) {
        return config.liveMaxLatencyDuration;
      }

      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
    }
  }, {
    key: "targetLatency",
    get: function get() {
      var levelDetails = this.levelDetails;

      if (levelDetails === null) {
        return null;
      }

      var holdBack = levelDetails.holdBack,
          partHoldBack = levelDetails.partHoldBack,
          targetduration = levelDetails.targetduration;
      var _this$config2 = this.config,
          liveSyncDuration = _this$config2.liveSyncDuration,
          liveSyncDurationCount = _this$config2.liveSyncDurationCount,
          lowLatencyMode = _this$config2.lowLatencyMode;
      var userConfig = this.hls.userConfig;
      var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;

      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
        targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
      }

      var maxLiveSyncOnStallIncrease = levelDetails.targetduration;
      var liveSyncOnStallIncrease = 1.0;
      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
    }
  }, {
    key: "liveSyncPosition",
    get: function get() {
      var liveEdge = this.estimateLiveEdge();
      var targetLatency = this.targetLatency;

      if (liveEdge === null || targetLatency === null || this.levelDetails === null) {
        return null;
      }

      return Math.min(this.levelDetails.edge, liveEdge - targetLatency - this.edgeStalled);
    }
  }, {
    key: "edgeStalled",
    get: function get() {
      var levelDetails = this.levelDetails;

      if (levelDetails === null) {
        return 0;
      }

      var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
    }
  }, {
    key: "forwardBufferLength",
    get: function get() {
      var media = this.media,
          levelDetails = this.levelDetails;

      if (!media || !levelDetails) {
        return 0;
      }

      var bufferedRanges = media.buffered.length;
      return bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge - this.currentTime;
    }
  }]);

  return LatencyController;
}();



/***/ }),

/***/ "./src/controller/level-controller.ts":
/*!********************************************!*\
  !*** ./src/controller/level-controller.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelController; });
/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/level */ "./src/types/level.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.ts");
/* harmony import */ var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./level-helper */ "./src/controller/level-helper.ts");
/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base-playlist-controller */ "./src/controller/base-playlist-controller.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*
 * Level Controller
 */







var chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());

var LevelController = /*#__PURE__*/function (_BasePlaylistControll) {
  _inheritsLoose(LevelController, _BasePlaylistControll);

  function LevelController(hls) {
    var _this;

    _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;
    _this._levels = [];
    _this._firstLevel = -1;
    _this._startLevel = void 0;
    _this.currentLevelIndex = -1;
    _this.manualLevelIndex = -1;
    _this.onParsedComplete = void 0;

    _this._registerListeners();

    return _this;
  }

  var _proto = LevelController.prototype;

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
  };

  _proto.destroy = function destroy() {
    _BasePlaylistControll.prototype.destroy.call(this);

    this._unregisterListeners();

    this.manualLevelIndex = -1;
  };

  _proto.startLoad = function startLoad() {
    var levels = this._levels; // clean up live level details to force reload them, and reset load errors

    levels.forEach(function (level) {
      level.loadError = 0;
    });

    _BasePlaylistControll.prototype.startLoad.call(this);
  };

  _proto.onManifestLoaded = function onManifestLoaded(event, data) {
    var levels = [];
    var audioTracks = [];
    var subtitleTracks = [];
    var bitrateStart;
    var levelSet = {};
    var levelFromSet;
    var videoCodecFound = false;
    var audioCodecFound = false; // regroup redundant levels together

    data.levels.forEach(function (levelParsed) {
      var attributes = levelParsed.attrs;
      videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;
      audioCodecFound = audioCodecFound || !!levelParsed.audioCodec; // erase audio codec info if browser does not support mp4a.40.34.
      // demuxer will autodetect codec and fallback to mpeg/audio

      if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf('mp4a.40.34') !== -1) {
        levelParsed.audioCodec = undefined;
      }

      levelFromSet = levelSet[levelParsed.bitrate]; // FIXME: we would also have to match the resolution here

      if (!levelFromSet) {
        levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__["Level"](levelParsed);
        levelSet[levelParsed.bitrate] = levelFromSet;
        levels.push(levelFromSet);
      } else {
        levelFromSet.url.push(levelParsed.url);
      }

      if (attributes) {
        if (attributes.AUDIO) {
          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addGroupId"])(levelFromSet, 'audio', attributes.AUDIO);
        }

        if (attributes.SUBTITLES) {
          Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addGroupId"])(levelFromSet, 'text', attributes.SUBTITLES);
        }
      }
    }); // remove audio-only level if we also have levels with audio+video codecs signalled

    if (videoCodecFound && audioCodecFound) {
      levels = levels.filter(function (_ref) {
        var videoCodec = _ref.videoCodec;
        return !!videoCodec;
      });
    } // only keep levels with supported audio/video codecs


    levels = levels.filter(function (_ref2) {
      var audioCodec = _ref2.audioCodec,
          videoCodec = _ref2.videoCodec;
      return (!audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(audioCodec, 'audio')) && (!videoCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(videoCodec, 'video'));
    });

    if (data.audioTracks) {
      audioTracks = data.audioTracks.filter(function (track) {
        return !track.audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(track.audioCodec, 'audio');
      }); // Assign ids after filtering as array indices by group-id

      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["assignTrackIdsByGroup"])(audioTracks);
    }

    if (data.subtitles) {
      subtitleTracks = data.subtitles;
      Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["assignTrackIdsByGroup"])(subtitleTracks);
    }

    if (levels.length > 0) {
      // start bitrate is the first bitrate of the manifest
      bitrateStart = levels[0].bitrate; // sort level on bitrate

      levels.sort(function (a, b) {
        return a.bitrate - b.bitrate;
      });
      this._levels = levels; // find index of first level in sorted levels

      for (var i = 0; i < levels.length; i++) {
        if (levels[i].bitrate === bitrateStart) {
          this._firstLevel = i;
          this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + bitrateStart);
          break;
        }
      } // Audio is only alternate if manifest include a URI along with the audio group tag,
      // and this is not an audio-only stream where levels contain audio-only


      var audioOnly = audioCodecFound && !videoCodecFound;
      var edata = {
        levels: levels,
        audioTracks: audioTracks,
        subtitleTracks: subtitleTracks,
        firstLevel: this._firstLevel,
        stats: data.stats,
        audio: audioCodecFound,
        video: videoCodecFound,
        altAudio: !audioOnly && audioTracks.some(function (t) {
          return !!t.url;
        })
      };
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, edata);
      this.onParsedComplete();
    } else {
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_INCOMPATIBLE_CODECS_ERROR,
        fatal: true,
        url: data.url,
        reason: 'no level with compatible codecs found in manifest'
      });
    }
  };

  _proto.onError = function onError(event, data) {
    _BasePlaylistControll.prototype.onError.call(this, event, data);

    if (data.fatal) {
      return;
    } // Switch to redundant level when track fails to load


    var context = data.context;
    var level = this._levels[this.currentLevelIndex];

    if (context && (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId] || context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId])) {
      this.redundantFailover(this.currentLevelIndex);
      return;
    }

    var levelError = false;
    var fragmentError = false;
    var levelSwitch = true;
    var levelIndex; // try to recover not fatal errors

    switch (data.details) {
      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].FRAG_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].KEY_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].KEY_LOAD_TIMEOUT:
        // FIXME: What distinguishes these fragment events from level or track fragments?
        //   We shouldn't recover a level if the fragment or key is for a media track
        console.assert(data.frag, 'Event has a fragment defined.');
        levelIndex = data.frag.level;
        fragmentError = true;
        break;

      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
        // Do not perform level switch if an error occurred using delivery directives
        // Attempt to reload level without directives first
        if (context) {
          if (context.deliveryDirectives) {
            levelSwitch = false;
          }

          levelIndex = context.level;
        }

        levelError = true;
        break;

      case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].REMUX_ALLOC_ERROR:
        levelIndex = data.level;
        levelError = true;
        break;
    }

    if (levelIndex !== undefined) {
      this.recoverLevel(data, levelIndex, levelError, fragmentError, levelSwitch);
    }
  }
  /**
   * Switch to a redundant stream if any available.
   * If redundant stream is not available, emergency switch down if ABR mode is enabled.
   */
  ;

  _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, fragmentError, levelSwitch) {
    var errorDetails = errorEvent.details;
    var level = this._levels[levelIndex];
    level.loadError++;
    level.fragmentError = fragmentError;

    if (levelError) {
      var retrying = this.retryLoadingOrFail(errorEvent);

      if (retrying) {
        // boolean used to inform stream controller not to switch back to IDLE on non fatal error
        errorEvent.levelRetry = true;
      } else {
        this.currentLevelIndex = -1;
        return;
      }
    } // Try any redundant streams if available for both errors: level and fragment
    // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down


    if (levelSwitch && (levelError || fragmentError)) {
      var redundantLevels = level.url.length;

      if (redundantLevels > 1 && level.loadError < redundantLevels) {
        this.redundantFailover(levelIndex);
      } else {
        // Search for available level
        if (this.manualLevelIndex === -1) {
          // When lowest level has been reached, let's start hunt from the top
          var nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;

          if (this.currentLevelIndex !== nextLevel) {
            fragmentError = false;
            this.warn(errorDetails + ": switch to " + nextLevel);
            this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
          }
        }

        if (fragmentError) {
          // Allow fragment retry as long as configuration allows.
          // reset this._level so that another call to set level() will trigger again a frag load
          this.warn(errorDetails + ": reload a fragment");
          this.currentLevelIndex = -1;
        }
      }
    }
  };

  _proto.redundantFailover = function redundantFailover(levelIndex) {
    var level = this._levels[levelIndex];
    var redundantLevels = level.url.length;

    if (redundantLevels > 1) {
      // Update the url id of all levels so that we stay on the same set of variants when level switching
      var newUrlId = (level.urlId + 1) % redundantLevels;
      this.warn("Switching to redundant URL-id " + newUrlId);

      this._levels.forEach(function (level) {
        level.urlId = newUrlId;
      });

      this.level = levelIndex;
    }
  } // reset errors on the successful load of a fragment
  ;

  _proto.onFragLoaded = function onFragLoaded(event, _ref3) {
    var frag = _ref3.frag;

    if (frag !== undefined && frag.type === 'main') {
      var level = this._levels[frag.level];

      if (level !== undefined) {
        level.fragmentError = false;
        level.loadError = 0;
      }
    }
  };

  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
    var _data$deliveryDirecti2;

    var level = data.level,
        details = data.details;
    var curLevel = this._levels[level];

    if (!curLevel) {
      var _data$deliveryDirecti;

      this.warn("Invalid level index " + level);

      if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {
        details.deltaUpdateFailed = true;
      }

      return;
    } // only process level loaded events matching with expected level


    if (level === this.currentLevelIndex) {
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (!curLevel.fragmentError) {
        curLevel.loadError = 0;
        this.retryCount = 0;
      }

      this.playlistLoaded(level, data, curLevel.details);
    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {
      // received a delta playlist update that cannot be merged
      details.deltaUpdateFailed = true;
    }
  };

  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
    var currentLevel = this.hls.levels[this.currentLevelIndex];

    if (!currentLevel) {
      return;
    }

    if (currentLevel.audioGroupIds) {
      var urlId = -1;
      var audioGroupId = this.hls.audioTracks[data.id].groupId;

      for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
        if (currentLevel.audioGroupIds[i] === audioGroupId) {
          urlId = i;
          break;
        }
      }

      if (urlId !== currentLevel.urlId) {
        currentLevel.urlId = urlId;
        this.startLoad();
      }
    }
  };

  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
    var level = this.currentLevelIndex;
    var currentLevel = this._levels[level];

    if (this.canLoad && currentLevel && currentLevel.url.length > 0) {
      var id = currentLevel.urlId;
      var url = currentLevel.url[id];

      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
        }
      }

      this.log("Attempt loading level index " + level + (hlsUrlParameters ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + " with URL-id " + id + " " + url); // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);
      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);

      this.clearTimer();
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, {
        url: url,
        level: level,
        id: id,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  };

  _proto.removeLevel = function removeLevel(levelIndex, urlId) {
    var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {
      return id !== urlId;
    };

    var levels = this._levels.filter(function (level, index) {
      if (index !== levelIndex) {
        return true;
      }

      if (level.url.length > 1 && urlId !== undefined) {
        level.url = level.url.filter(filterLevelAndGroupByIdIndex);

        if (level.audioGroupIds) {
          level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);
        }

        if (level.textGroupIds) {
          level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);
        }

        level.urlId = 0;
        return true;
      }

      return false;
    }).map(function (level, index) {
      var details = level.details;

      if (details !== null && details !== void 0 && details.fragments) {
        details.fragments.forEach(function (fragment) {
          fragment.level = index;
        });
      }

      return level;
    });

    this._levels = levels;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVELS_UPDATED, {
      levels: levels
    });
  };

  _createClass(LevelController, [{
    key: "levels",
    get: function get() {
      if (this._levels.length === 0) {
        return null;
      }

      return this._levels;
    }
  }, {
    key: "level",
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var _levels$newLevel;

      var levels = this._levels;

      if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {
        return;
      } // check if level idx is valid


      if (newLevel < 0 || newLevel >= levels.length) {
        // invalid level id given, trigger error
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
          type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].OTHER_ERROR,
          details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal: false,
          reason: 'invalid level idx'
        });
        return;
      } // stopping live reloading timer if any


      this.clearTimer();
      var lastLevelIndex = this.currentLevelIndex;
      var lastLevel = levels[lastLevelIndex];
      var level = levels[newLevel];
      this.log("switching to level " + newLevel + " from " + lastLevelIndex);
      this.currentLevelIndex = newLevel;

      var levelSwitchingData = _extends({}, level, {
        level: newLevel,
        maxBitrate: level.maxBitrate,
        uri: level.uri,
        urlId: level.urlId
      }); // @ts-ignore


      delete levelSwitchingData._urlId;
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_SWITCHING, levelSwitchingData); // check if we need to load playlist for this level

      var levelDetails = level.details;

      if (!levelDetails || levelDetails.live) {
        // level not retrieved yet, or live playlist we need to (re)load it
        var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);
        this.loadPlaylist(hlsUrlParameters);
      }
    }
  }, {
    key: "manualLevel",
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;

      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }

      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: "firstLevel",
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: "startLevel",
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;

        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: "nextLoadLevel",
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;

      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__["default"]);



/***/ }),

/***/ "./src/controller/level-helper.ts":
/*!****************************************!*\
  !*** ./src/controller/level-helper.ts ***!
  \****************************************/
/*! exports provided: addGroupId, assignTrackIdsByGroup, updatePTS, updateFragPTSDTS, mergeDetails, mapPartIntersection, mapFragmentIntersection, adjustSliding, computeReloadInterval, getFragmentWithSN, getPartWith */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addGroupId", function() { return addGroupId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignTrackIdsByGroup", function() { return assignTrackIdsByGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updatePTS", function() { return updatePTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateFragPTSDTS", function() { return updateFragPTSDTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDetails", function() { return mergeDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapPartIntersection", function() { return mapPartIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapFragmentIntersection", function() { return mapFragmentIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjustSliding", function() { return adjustSliding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeReloadInterval", function() { return computeReloadInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFragmentWithSN", function() { return getFragmentWithSN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPartWith", function() { return getPartWith; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");






/**
 * @module LevelHelper
 * Providing methods dealing with playlist sliding and drift
 * */

function addGroupId(level, type, id) {
  switch (type) {
    case 'audio':
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }

      level.audioGroupIds.push(id);
      break;

    case 'text':
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }

      level.textGroupIds.push(id);
      break;
  }
}
function assignTrackIdsByGroup(tracks) {
  var groups = {};
  tracks.forEach(function (track) {
    var groupId = track.groupId || '';
    track.id = groups[groupId] = groups[groupId] || 0;
    groups[groupId]++;
  });
}
function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx];
  var fragTo = fragments[toIdx];
  updateFromToPTS(fragFrom, fragTo);
}

function updateFromToPTS(fragFrom, fragTo) {
  var fragToPTS = fragTo.startPTS; // if we know startPTS[toIdx]

  if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    var duration = 0;
    var frag;

    if (fragTo.sn > fragFrom.sn) {
      duration = fragToPTS - fragFrom.start;
      frag = fragFrom;
    } else {
      duration = fragFrom.start - fragToPTS;
      frag = fragTo;
    } // TODO? Drift can go either way, or the playlist could be completely accurate
    // console.assert(duration > 0,
    //   `duration of ${duration} computed for frag ${frag.sn}, level ${frag.level}, there should be some duration drift between playlist and fragment!`);


    if (frag.duration !== duration) {
      frag.duration = duration;
    } // we dont know startPTS[toIdx]

  } else if (fragTo.sn > fragFrom.sn) {
    var contiguous = fragFrom.cc === fragTo.cc; // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS

    if (contiguous && fragFrom.minEndPTS) {
      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
    } else {
      fragTo.start = fragFrom.start + fragFrom.duration;
    }
  } else {
    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  var parsedMediaDuration = endPTS - startPTS;

  if (parsedMediaDuration <= 0) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn('Fragment should have a positive duration', frag);
    endPTS = startPTS + frag.duration;
    endDTS = startDTS + frag.duration;
  }

  var maxStartPTS = startPTS;
  var minEndPTS = endPTS;
  var fragStartPts = frag.startPTS;
  var fragEndPts = frag.endPTS;

  if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(fragStartPts)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(fragStartPts - startPTS);

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }

    maxStartPTS = Math.max(startPTS, fragStartPts);
    startPTS = Math.min(startPTS, fragStartPts);
    startDTS = Math.min(startDTS, frag.startDTS);
    minEndPTS = Math.min(endPTS, fragEndPts);
    endPTS = Math.max(endPTS, fragEndPts);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  frag.duration = endPTS - startPTS;
  var drift = startPTS - frag.start;
  frag.appendedPTS = endPTS;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.startDTS = startDTS;
  frag.endPTS = endPTS;
  frag.minEndPTS = minEndPTS;
  frag.endDTS = endDTS;
  var sn = frag.sn; // 'initSegment'
  // exit if sn out of range

  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }

  var i;
  var fragIdx = sn - details.startSN;
  var fragments = details.fragments; // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation

  fragments[fragIdx] = frag; // adjust fragment PTS/duration from seqnum-1 to frag 0

  for (i = fragIdx; i > 0; i--) {
    updateFromToPTS(fragments[i], fragments[i - 1]);
  } // adjust fragment PTS/duration from seqnum to last frag


  for (i = fragIdx; i < fragments.length - 1; i++) {
    updateFromToPTS(fragments[i], fragments[i + 1]);
  }

  if (details.fragmentHint) {
    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
  }

  details.PTSKnown = details.alignedSliding = true;
  return drift;
}
function mergeDetails(oldDetails, newDetails) {
  // potentially retrieve cached initsegment
  if (newDetails.initSegment && oldDetails.initSegment) {
    newDetails.initSegment = oldDetails.initSegment;
  }

  if (oldDetails.fragmentHint) {
    // prevent PTS and duration from being adjusted on the next hint
    delete oldDetails.fragmentHint.endPTS;
  } // check if old/new playlists have fragments in common
  // loop through overlapping SN and update startPTS , cc, and duration if any found


  var ccOffset = 0;
  var PTSFrag;
  mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
    ccOffset = oldFrag.cc - newFrag.cc;

    if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(oldFrag.startPTS) && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(oldFrag.endPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.startDTS = oldFrag.startDTS;
      newFrag.appendedPTS = oldFrag.appendedPTS;
      newFrag.maxStartPTS = oldFrag.maxStartPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.endDTS = oldFrag.endDTS;
      newFrag.minEndPTS = oldFrag.minEndPTS;
      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;

      if (newFrag.duration) {
        PTSFrag = newFrag;
      } // PTS is known when any segment has startPTS and endPTS


      newDetails.PTSKnown = newDetails.alignedSliding = true;
    }

    newFrag.elementaryStreams = oldFrag.elementaryStreams;
    newFrag.loader = oldFrag.loader;
    newFrag.stats = oldFrag.stats;
    newFrag.urlId = oldFrag.urlId;
  });

  if (newDetails.skippedSegments) {
    newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {
      return !frag;
    });

    if (newDetails.deltaUpdateFailed) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn('[level-helper] Previous playlist missing segments skipped in delta playlist');

      for (var i = newDetails.skippedSegments; i--;) {
        newDetails.fragments.shift();
      }

      newDetails.startSN = newDetails.fragments[0].sn;
      newDetails.startCC = newDetails.fragments[0].cc;
    }
  }

  var newFragments = newDetails.fragments;

  if (ccOffset) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log('discontinuity sliding from playlist, take drift into account');

    for (var _i = 0; _i < newFragments.length; _i++) {
      newFragments[_i].cc += ccOffset;
    }
  }

  if (newDetails.skippedSegments) {
    if (!newDetails.initSegment) {
      newDetails.initSegment = oldDetails.initSegment;
    }

    newDetails.startCC = newDetails.fragments[0].cc;
  } // Merge parts


  mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {
    newPart.elementaryStreams = oldPart.elementaryStreams;
    newPart.stats = oldPart.stats;
  }); // if at least one fragment contains PTS info, recompute PTS information for all fragments

  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldFragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    adjustSliding(oldDetails, newDetails);
  }

  if (newFragments.length) {
    newDetails.totalduration = newDetails.edge - newFragments[0].start;
  }
}
function mapPartIntersection(oldParts, newParts, intersectionFn) {
  if (oldParts && newParts) {
    var delta = 0;

    for (var i = 0, len = oldParts.length; i <= len; i++) {
      var _oldPart = oldParts[i];
      var _newPart = newParts[i + delta];

      if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
        intersectionFn(_oldPart, _newPart);
      } else {
        delta--;
      }
    }
  }
}
function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
  var skippedSegments = newDetails.skippedSegments;
  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
  var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
  var delta = newDetails.startSN - oldDetails.startSN;
  var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
  var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;

  for (var i = start; i <= end; i++) {
    var _oldFrag = oldFrags[delta + i];
    var _newFrag = newFrags[i];

    if (skippedSegments && !_newFrag && i < skippedSegments) {
      // Fill in skipped segments in delta playlist
      _newFrag = newDetails.fragments[i] = _oldFrag;
    }

    if (_oldFrag && _newFrag) {
      intersectionFn(_oldFrag, _newFrag);
    }
  }
}
function adjustSliding(oldDetails, newDetails) {
  var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
  var oldFragments = oldDetails.fragments;
  var newFragments = newDetails.fragments;

  if (delta < 0 || delta >= oldFragments.length) {
    return;
  }

  var playlistStartOffset = oldFragments[delta].start;

  if (playlistStartOffset) {
    for (var i = newDetails.skippedSegments; i < newFragments.length; i++) {
      newFragments[i].start += playlistStartOffset;
    }

    if (newDetails.fragmentHint) {
      newDetails.fragmentHint.start += playlistStartOffset;
    }
  }
}
function computeReloadInterval(newDetails, stats) {
  var reloadInterval = 1000 * newDetails.levelTargetDuration;
  var reloadIntervalAfterMiss = reloadInterval / 2;
  var timeSinceLastModified = newDetails.age;
  var useLastModified = timeSinceLastModified > 0 && timeSinceLastModified < reloadInterval * 3;
  var roundTrip = stats.loading.end - stats.loading.start;
  var estimatedTimeUntilUpdate = reloadInterval;
  var availabilityDelay = newDetails.availabilityDelay; // let estimate = 'average';

  if (newDetails.updated === false) {
    if (useLastModified) {
      // estimate = 'miss round trip';
      // We should have had a hit so try again in the time it takes to get a response,
      // but no less than 1/3 second.
      var minRetry = 333 * newDetails.misses;
      estimatedTimeUntilUpdate = Math.max(Math.min(reloadIntervalAfterMiss, roundTrip * 2), minRetry);
      newDetails.availabilityDelay = (newDetails.availabilityDelay || 0) + estimatedTimeUntilUpdate;
    } else {
      // estimate = 'miss half average';
      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
      // changed then it MUST wait for a period of one-half the target
      // duration before retrying.
      estimatedTimeUntilUpdate = reloadIntervalAfterMiss;
    }
  } else if (useLastModified) {
    // estimate = 'next modified date';
    // Get the closest we've been to timeSinceLastModified on update
    availabilityDelay = Math.min(availabilityDelay || reloadInterval / 2, timeSinceLastModified);
    newDetails.availabilityDelay = availabilityDelay;
    estimatedTimeUntilUpdate = availabilityDelay + reloadInterval - timeSinceLastModified;
  } else {
    estimatedTimeUntilUpdate = reloadInterval - roundTrip;
  } // console.log(`[computeReloadInterval] live reload ${newDetails.updated ? 'REFRESHED' : 'MISSED'}`,
  //   '\n  method', estimate,
  //   '\n  estimated time until update =>', estimatedTimeUntilUpdate,
  //   '\n  average target duration', reloadInterval,
  //   '\n  time since modified', timeSinceLastModified,
  //   '\n  time round trip', roundTrip,
  //   '\n  availability delay', availabilityDelay);


  return Math.round(estimatedTimeUntilUpdate);
}
function getFragmentWithSN(level, sn) {
  if (!level || !level.details) {
    return null;
  }

  var levelDetails = level.details;
  var fragment = levelDetails.fragments[sn - levelDetails.startSN];

  if (fragment) {
    return fragment;
  }

  fragment = levelDetails.fragmentHint;

  if (fragment && fragment.sn === sn) {
    return fragment;
  }

  return null;
}
function getPartWith(level, sn, partIndex) {
  if (!level || !level.details) {
    return null;
  }

  var partList = level.details.partList;

  if (partList) {
    for (var i = partList.length; i--;) {
      var part = partList[i];

      if (part.index === partIndex && part.fragment.sn === sn) {
        return part;
      }
    }
  }

  return null;
}

/***/ }),

/***/ "./src/controller/stream-controller.ts":
/*!*********************************************!*\
  !*** ./src/controller/stream-controller.ts ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StreamController; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.ts");
/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../is-supported */ "./src/is-supported.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.ts");
/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../loader/fragment-loader */ "./src/loader/fragment-loader.ts");
/* harmony import */ var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../demux/transmuxer-interface */ "./src/demux/transmuxer-interface.ts");
/* harmony import */ var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../types/transmuxer */ "./src/types/transmuxer.ts");
/* harmony import */ var _gap_controller__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./gap-controller */ "./src/controller/gap-controller.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");





function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }














var TICK_INTERVAL = 100; // how often to tick in ms

var StreamController = /*#__PURE__*/function (_BaseStreamController) {
  _inheritsLoose(StreamController, _BaseStreamController);

  function StreamController(hls, fragmentTracker) {
    var _this;

    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[stream-controller]') || this;
    _this.audioCodecSwap = false;
    _this.bitrateTest = false;
    _this.gapController = null;
    _this.level = -1;
    _this._forceStartLoad = false;
    _this.retryDate = 0;
    _this.altAudio = false;
    _this.audioOnly = false;
    _this.fragPlaying = null;
    _this.onvplaying = null;
    _this.onvseeked = null;
    _this.fragLastKbps = 0;
    _this.stalled = false;
    _this.audioCodecSwitch = false;
    _this.videoBuffer = null;
    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_8__["default"](hls.config);
    _this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;

    _this._registerListeners();

    return _this;
  }

  var _proto = StreamController.prototype;

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, this.onError, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, this.onError, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
  };

  _proto.onHandlerDestroying = function onHandlerDestroying() {
    this._unregisterListeners();
  };

  _proto.startLoad = function startLoad(startPosition) {
    if (this.levels) {
      var lastCurrentTime = this.lastCurrentTime,
          hls = this.hls;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL);
      this.level = -1;
      this.fragLoadError = 0;

      if (!this.startFragRequested) {
        // determine load level
        var startLevel = hls.startLevel;

        if (startLevel === -1) {
          if (hls.config.testBandwidth) {
            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
            startLevel = 0;
            this.bitrateTest = true;
          } else {
            startLevel = hls.nextAutoLevel;
          }
        } // set new level to playlist loader : this will trigger start level load
        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded


        this.level = hls.nextLoadLevel = startLevel;
        this.loadedmetadata = false;
      } // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime


      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
        startPosition = lastCurrentTime;
      }

      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    } else {
      this._forceStartLoad = true;
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
    }
  };

  _proto.stopLoad = function stopLoad() {
    this._forceStartLoad = false;

    _BaseStreamController.prototype.stopLoad.call(this);
  };

  _proto.doTick = function doTick() {
    switch (this.state) {
      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE:
        this.doTickIdle();
        break;

      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL:
        {
          var _levels$level;

          var levels = this.levels,
              level = this.level;
          var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;

          if (details && (!details.live || this.levelLastLoaded === this.level)) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }

            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
            break;
          }

          break;
        }

      case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY:
        {
          var _this$media;

          var now = self.performance.now();
          var retryDate = this.retryDate; // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading

          if (!retryDate || now >= retryDate || (_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking) {
            this.log('retryDate reached, switch back to IDLE state');
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          }
        }
        break;

      default:
        break;
    } // check buffer
    // check/update current fragment


    this.onTickEnd();
  };

  _proto.onTickEnd = function onTickEnd() {
    _BaseStreamController.prototype.onTickEnd.call(this);

    this.checkBuffer();
    this.checkFragmentChanged();
  };

  _proto.doTickIdle = function doTickIdle() {
    var _frag$decryptdata, _frag$decryptdata2;

    var hls = this.hls,
        levelLastLoaded = this.levelLastLoaded,
        levels = this.levels,
        media = this.media;
    var config = hls.config,
        level = hls.nextLoadLevel; // if start level not parsed yet OR
    // if video not attached AND start fragment already requested OR start frag prefetch not enabled
    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment

    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {
      return;
    } // If the "main" level is audio-only but we are loading an alternate track in the same group, do not load anything


    if (this.altAudio && this.audioOnly) {
      return;
    }

    if (!levels || !levels[level]) {
      return;
    }

    var levelInfo = levels[level]; // if buffer length is less than maxBufLen try to load a new fragment
    // set next load level : this will trigger a playlist load if needed

    this.level = hls.nextLoadLevel = level;
    var levelDetails = levelInfo.details; // if level info not retrieved yet, switch state and wait for level retrieval
    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)

    if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL;
      return;
    }

    var pos = this.getLoadPosition();

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(pos)) {
      return;
    }

    var frag = levelDetails.initSegment;
    var targetBufferTime = 0;

    if (!frag || frag.data) {
      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
      var levelBitrate = levelInfo.maxBitrate;
      var maxBufLen;

      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }

      maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength); // determine next candidate fragment to be loaded, based on current position and end of buffer position
      // ensure up to `config.maxMaxBufferLength` of buffer upfront

      var maxBufferHole = pos < config.maxBufferHole ? Math.max(_gap_controller__WEBPACK_IMPORTED_MODULE_11__["MAX_START_GAP_JUMP"], config.maxBufferHole) : config.maxBufferHole;
      var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, maxBufferHole);
      var bufferLen = bufferInfo.len; // Stay idle if we are still with buffer margins

      if (bufferLen >= maxBufLen) {
        return;
      }

      if (this._streamEnded(bufferInfo, levelDetails)) {
        var data = {};

        if (this.altAudio) {
          data.type = 'video';
        }

        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_EOS, data);
        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ENDED;
        return;
      }

      targetBufferTime = bufferInfo.end;
      frag = this.getNextFragment(targetBufferTime, levelDetails); // Avoid loop loading by using nextLoadPosition set for backtracking
      // TODO: this could be improved to simply pick next sn fragment

      if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].OK && this.nextLoadPosition > targetBufferTime) {
        frag = this.getNextFragment(this.nextLoadPosition, levelDetails);
      }

      if (!frag) {
        return;
      }
    } // We want to load the key if we're dealing with an identity key, because we will decrypt
    // this content using the key we fetch. Other keys will be handled by the DRM CDM via EME.


    if (((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === 'identity' && !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)) {
      this.log("Loading key for " + frag.sn + " of [" + levelDetails.startSN + "-" + levelDetails.endSN + "], level " + level);
      this.loadKey(frag);
    } else {
      this.loadFragment(frag, levelDetails, targetBufferTime);
    }
  };

  _proto.loadKey = function loadKey(frag) {
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].KEY_LOADING;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].KEY_LOADING, {
      frag: frag
    });
  };

  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
    var _this$media2;

    // Check if fragment is not loaded
    var fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag; // Don't update nextLoadPosition for fragments which are not buffered

    if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.sn) && !this.bitrateTest) {
      this.nextLoadPosition = frag.start + frag.duration;
    } // Use data from loaded backtracked fragment if available


    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].BACKTRACKED) {
      var data = this.fragmentTracker.getBacktrackData(frag);

      if (data) {
        this._handleFragmentLoadProgress(data);

        this._handleFragmentLoadComplete(data);

        return;
      } else {
        fragState = _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].NOT_LOADED;
      }
    }

    if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].PARTIAL) {
      if (frag.sn === 'initSegment') {
        this._loadInitSegment(frag);
      } else if (this.bitrateTest) {
        frag.bitrateTest = true;
        this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");

        this._loadBitrateTestFrag(frag);
      } else {
        this.startFragRequested = true;

        _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
      }
    } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].APPENDING) {
      // Lower the buffer size and try again
      if (this._reduceMaxBufferLength(frag.duration)) {
        this.fragmentTracker.removeFragment(frag);
      }
    } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {
      // Stop gap for bad tracker / buffer flush behavior
      this.fragmentTracker.removeAllFragments();
    }
  };

  _proto.getAppendedFrag = function getAppendedFrag(position) {
    return this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
  };

  _proto.getBufferedFrag = function getBufferedFrag(position) {
    return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
  };

  _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
    if (frag) {
      // try to get range of next fragment (500ms after this range)
      return this.getBufferedFrag(frag.end + 0.5);
    }

    return null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  ;

  _proto.immediateLevelSwitch = function immediateLevelSwitch() {
    this.abortCurrentFrag();
    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  ;

  _proto.nextLevelSwitch = function nextLevelSwitch() {
    var levels = this.levels,
        media = this.media; // ensure that media is defined and that metadata are available (to retrieve currentTime)

    if (media !== null && media !== void 0 && media.readyState) {
      var fetchdelay;
      var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);

      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
        // flush buffer preceding current fragment (flush until current fragment start offset)
        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
      }

      if (!media.paused && levels) {
        // add a safety delay of 1s
        var nextLevelId = this.hls.nextLoadLevel;
        var nextLevel = levels[nextLevelId];
        var fragLastKbps = this.fragLastKbps;

        if (fragLastKbps && this.fragCurrent) {
          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;
        } else {
          fetchdelay = 0;
        }
      } else {
        fetchdelay = 0;
      } // this.log('fetchdelay:'+fetchdelay);
      // find buffer range that will be reached once new fragment will be fetched


      var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);

      if (bufferedFrag) {
        // we can flush buffer range following this one without stalling playback
        var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);

        if (nextBufferedFrag) {
          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
          this.abortCurrentFrag(); // start flush position is the start PTS of next buffered frag.
          // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
          // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment

          var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
          var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(this.config.maxFragLookUpTolerance, nextBufferedFrag.duration));
          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
        }
      }
    }
  };

  _proto.abortCurrentFrag = function abortCurrentFrag() {
    var fragCurrent = this.fragCurrent;

    if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
      fragCurrent.loader.abort();
    }

    this.fragCurrent = null;
  };

  _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
    _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);
  };

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    _BaseStreamController.prototype.onMediaAttached.call(this, event, data);

    var media = data.media;
    this.onvplaying = this.onMediaPlaying.bind(this);
    this.onvseeked = this.onMediaSeeked.bind(this);
    media.addEventListener('playing', this.onvplaying);
    media.addEventListener('seeked', this.onvseeked);
    this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_11__["default"](this.config, media, this.fragmentTracker, this.hls);
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    var media = this.media;

    if (media) {
      media.removeEventListener('playing', this.onvplaying);
      media.removeEventListener('seeked', this.onvseeked);
      this.onvplaying = this.onvseeked = null;
    }

    _BaseStreamController.prototype.onMediaDetaching.call(this);
  };

  _proto.onMediaPlaying = function onMediaPlaying() {
    // tick to speed up FRAG_CHANGED triggering
    this.tick();
  };

  _proto.onMediaSeeked = function onMediaSeeked() {
    var media = this.media;
    var currentTime = media ? media.currentTime : null;

    if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(currentTime)) {
      this.log("Media seeked to " + currentTime.toFixed(3));
    } // tick to speed up FRAG_CHANGED triggering


    this.tick();
  };

  _proto.onManifestLoading = function onManifestLoading() {
    // reset buffer on manifest loading
    this.log('Trigger BUFFER_RESET');
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_RESET, undefined);
    this.fragmentTracker.removeAllFragments();
    this.stalled = false;
    this.startPosition = this.lastCurrentTime = 0;
    this.fragPlaying = null;
  };

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    var aac = false;
    var heaac = false;
    var codec;
    data.levels.forEach(function (level) {
      // detect if we have different kind of audio codecs used amongst playlists
      codec = level.audioCodec;

      if (codec) {
        if (codec.indexOf('mp4a.40.2') !== -1) {
          aac = true;
        }

        if (codec.indexOf('mp4a.40.5') !== -1) {
          heaac = true;
        }
      }
    });
    this.audioCodecSwitch = aac && heaac && !Object(_is_supported__WEBPACK_IMPORTED_MODULE_2__["changeTypeSupported"])();

    if (this.audioCodecSwitch) {
      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
    }

    this.levels = data.levels;
    this.startFragRequested = false;
  };

  _proto.onLevelLoading = function onLevelLoading(event, data) {
    var levels = this.levels;

    if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE) {
      return;
    }

    var level = levels[data.level];

    if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL;
    }
  };

  _proto.onLevelLoaded = function onLevelLoaded(event, data) {
    var _curLevel$details;

    var levels = this.levels;
    var newLevelId = data.level;
    var newDetails = data.details;
    var duration = newDetails.totalduration;

    if (!levels) {
      this.warn("Levels were reset while loading level " + newLevelId);
      return;
    }

    this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "], cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
    var fragCurrent = this.fragCurrent;

    if (fragCurrent && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY)) {
      if (fragCurrent.level !== data.level && fragCurrent.loader) {
        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
        fragCurrent.loader.abort();
      }
    }

    var curLevel = levels[newLevelId];
    var sliding = 0;

    if (newDetails.live || (_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live) {
      if (!newDetails.fragments[0]) {
        newDetails.deltaUpdateFailed = true;
      }

      if (newDetails.deltaUpdateFailed) {
        return;
      }

      sliding = this.alignPlaylists(newDetails, curLevel.details);
    } // override level info


    curLevel.details = newDetails;
    this.levelLastLoaded = newLevelId;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_UPDATED, {
      details: newDetails,
      level: newLevelId
    }); // only switch back to IDLE state if we were waiting for level to start downloading a new fragment

    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(newDetails)) {
        // Wait for Low-Latency CDN Tune-in
        return;
      }

      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
    }

    if (!this.startFragRequested) {
      this.setStartPosition(newDetails, sliding);
    } else if (newDetails.live) {
      this.synchronizeToLiveEdge(newDetails);
    } // trigger handler right now


    this.tick();
  };

  _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
    var _details$initSegment;

    var frag = data.frag,
        part = data.part,
        payload = data.payload;
    var levels = this.levels;

    if (!levels) {
      this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
      return;
    }

    var currentLevel = levels[frag.level];
    var details = currentLevel.details;

    if (!details) {
      this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
      return;
    }

    var videoCodec = currentLevel.videoCodec; // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)

    var accurateTimeOffset = details.PTSKnown || !details.live;
    var initSegmentData = (_details$initSegment = details.initSegment) === null || _details$initSegment === void 0 ? void 0 : _details$initSegment.data;

    var audioCodec = this._getAudioCodec(currentLevel); // transmux the MPEG-TS data to ISO-BMFF segments
    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);


    var transmuxer = this.transmuxer = this.transmuxer || new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__["default"](this.hls, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    var partIndex = part ? part.index : -1;
    var partial = partIndex !== -1;
    var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
    var initPTS = this.initPTS[frag.cc];
    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
  };

  _proto.resetTransmuxer = function resetTransmuxer() {
    if (this.transmuxer) {
      this.transmuxer.destroy();
      this.transmuxer = null;
    }
  };

  _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
    // if any URL found on new audio track, it is an alternate audio track
    var fromAltAudio = this.altAudio;
    var altAudio = !!data.url;
    var trackId = data.id; // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
    // don't do anything if we switch to alt audio: audio stream controller is handling it.
    // we will just have to change buffer scheduling on audioTrackSwitched

    if (!altAudio) {
      if (this.mediaBuffer !== this.media) {
        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');
        this.mediaBuffer = this.media;
        var fragCurrent = this.fragCurrent; // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch

        if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
          this.log('Switching to main audio track, cancel main fragment load');
          fragCurrent.loader.abort();
        }

        this.fragCurrent = null;
        this.fragPrevious = null; // destroy transmuxer to force init segment generation (following audio switch)

        this.resetTransmuxer(); // switch to IDLE state to load new fragment

        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
      } else if (this.audioOnly) {
        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off
        this.resetTransmuxer();
      }

      var hls = this.hls; // If switching from alt to main audio, flush all audio and trigger track switched

      if (fromAltAudio) {
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: 'audio'
        });
      }

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, {
        id: trackId
      });
    }
  };

  _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
    var trackId = data.id;
    var altAudio = !!this.hls.audioTracks[trackId].url;

    if (altAudio) {
      var videoBuffer = this.videoBuffer; // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered

      if (videoBuffer && this.mediaBuffer !== videoBuffer) {
        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');
        this.mediaBuffer = videoBuffer;
      }
    }

    this.altAudio = altAudio;
    this.tick();
  };

  _proto.onBufferCreated = function onBufferCreated(event, data) {
    var tracks = data.tracks;
    var mediaTrack;
    var name;
    var alternate = false;

    for (var type in tracks) {
      var track = tracks[type];

      if (track.id === 'main') {
        name = type;
        mediaTrack = track; // keep video source buffer reference

        if (type === 'video') {
          var videoTrack = tracks[type];

          if (videoTrack) {
            this.videoBuffer = videoTrack.buffer;
          }
        }
      } else {
        alternate = true;
      }
    }

    if (alternate && mediaTrack) {
      this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
      this.mediaBuffer = mediaTrack.buffer;
    } else {
      this.mediaBuffer = this.media;
    }
  };

  _proto.onFragBuffered = function onFragBuffered(event, data) {
    var frag = data.frag,
        part = data.part;

    if (frag && frag.type !== 'main') {
      return;
    }

    if (this.fragContextChanged(frag)) {
      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion
      // Avoid setting state back to IDLE, since that will interfere with a level switch
      this.warn("Fragment " + frag.sn + (part ? ' p: ' + part.index : '') + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
      return;
    }

    var stats = part ? part.stats : frag.stats;
    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
    this.fragPrevious = frag;
    this.fragBufferedComplete(frag, part);
  };

  _proto.onError = function onError(event, data) {
    var frag = data.frag || this.fragCurrent; // don't handle frag error not related to main fragment

    if (frag && frag.type !== 'main') {
      return;
    } // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end


    var mediaBuffered = !!this.media && _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(this.media, this.media.currentTime) && _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(this.media, this.media.currentTime + 0.5);

    switch (data.details) {
      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].FRAG_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].KEY_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].KEY_LOAD_TIMEOUT:
        if (!data.fatal) {
          // keep retrying until the limit will be reached
          if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
            // exponential backoff capped to config.fragLoadingMaxRetryTimeout
            var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout); // @ts-ignore - frag is potentially null according to TS here

            this.warn("Fragment " + (frag === null || frag === void 0 ? void 0 : frag.sn) + " of level " + (frag === null || frag === void 0 ? void 0 : frag.level) + " failed to load, retrying in " + delay + "ms");
            this.retryDate = self.performance.now() + delay; // retry loading state
            // if loadedmetadata is not set, it means that we are emergency switch down on first frag
            // in that case, reset startFragRequested flag

            if (!this.loadedmetadata) {
              this.startFragRequested = false;
              this.nextLoadPosition = this.startPosition;
            }

            this.fragLoadError++;
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY;
          } else {
            _utils_logger__WEBPACK_IMPORTED_MODULE_13__["logger"].error("[stream-controller]: " + data.details + " reaches max retry, redispatch as fatal ..."); // switch error to fatal

            data.fatal = true;
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR;
          }
        }

        break;

      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].LEVEL_LOAD_ERROR:
      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR) {
          if (data.fatal) {
            // if fatal error, stop processing
            this.warn("" + data.details);
            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR;
          } else {
            // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
            if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL) {
              this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
            }
          }
        }

        break;

      case _errors__WEBPACK_IMPORTED_MODULE_12__["ErrorDetails"].BUFFER_FULL_ERROR:
        // if in appending state
        if (data.parent === 'main' && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED)) {
          // reduce max buf len if current position is buffered
          if (mediaBuffered) {
            this._reduceMaxBufferLength(this.config.maxBufferLength);

            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
          } else {
            // current position is not buffered, but browser is still complaining about buffer full error
            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
            // in that case flush the whole buffer to recover
            this.warn('buffer full error also media.currentTime is not buffered, flush everything'); // flush everything

            this.immediateLevelSwitch();
          }
        }

        break;

      default:
        break;
    }
  };

  _proto._reduceMaxBufferLength = function _reduceMaxBufferLength(minLength) {
    var config = this.config;

    if (config.maxMaxBufferLength >= minLength) {
      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
      config.maxMaxBufferLength /= 2;
      this.warn("Reduce max buffer length to " + config.maxMaxBufferLength + "s");
      return true;
    }

    return false;
  } // Checks the health of the buffer and attempts to resolve playback stalls.
  ;

  _proto.checkBuffer = function checkBuffer() {
    var media = this.media,
        gapController = this.gapController;

    if (!media || !gapController || !media.readyState) {
      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)
      return;
    } // Check combined buffer


    var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(media);

    if (!this.loadedmetadata && buffered.length) {
      this.loadedmetadata = true;

      this._seekToStartPos();
    } else {
      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers
      gapController.poll(this.lastCurrentTime);
    }

    this.lastCurrentTime = media.currentTime;
  };

  _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE; // if loadedmetadata is not set, it means that we are emergency switch down on first frag
    // in that case, reset startFragRequested flag

    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      this.nextLoadPosition = this.startPosition;
    }

    this.tick();
  };

  _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
    var type = _ref.type;

    /* after successful buffer flushing, filter flushed fragments from bufferedFrags
      use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
    */
    var media = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;

    if (media && type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO) {
      this.fragmentTracker.detectEvictedFragments(type, _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(media));
    } // reset reference to frag


    this.fragPrevious = null; // move to IDLE once flush complete. this should trigger new fragment loading

    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
  };

  _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
    this.levels = data.levels;
  };

  _proto.swapAudioCodec = function swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   * @private
   */
  ;

  _proto._seekToStartPos = function _seekToStartPos() {
    var media = this.media;
    var currentTime = media.currentTime;
    var startPosition = this.startPosition; // only adjust currentTime if different from startPosition or if startPosition not buffered
    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered

    if (startPosition >= 0 && currentTime < startPosition) {
      if (media.seeking) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_13__["logger"].log("could not seek to " + startPosition + ", already seeking at " + currentTime);
        return;
      }

      var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(media);
      var bufferStart = buffered.length ? buffered.start(0) : 0;
      var delta = bufferStart - startPosition;

      if (delta > 0 && delta < this.config.maxBufferHole) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_13__["logger"].log("adjusting start position by " + delta + " to match buffer start");
        startPosition += delta;
        this.startPosition = startPosition;
      }

      this.log("seek to target start position " + startPosition + " from current time " + currentTime);
      media.currentTime = startPosition;
    }
  };

  _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
    var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;

    if (this.audioCodecSwap && audioCodec) {
      this.log('Swapping audio codec');

      if (audioCodec.indexOf('mp4a.40.5') !== -1) {
        audioCodec = 'mp4a.40.2';
      } else {
        audioCodec = 'mp4a.40.5';
      }
    }

    return audioCodec;
  };

  _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag) {
    var _this2 = this;

    this._doFragLoad(frag).then(function (data) {
      var hls = _this2.hls;

      if (!data || hls.nextLoadLevel || _this2.fragContextChanged(frag)) {
        return;
      }

      _this2.fragLoadError = 0;
      _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
      _this2.startFragRequested = false;
      _this2.bitrateTest = false;
      frag.bitrateTest = false;
      var stats = frag.stats; // Bitrate tests fragments are neither parsed nor buffered

      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_BUFFERED, {
        stats: stats,
        frag: frag,
        part: null,
        id: 'main'
      });

      _this2.tick();
    });
  };

  _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;

    var id = 'main';
    var hls = this.hls;
    var remuxResult = transmuxResult.remuxResult,
        chunkMeta = transmuxResult.chunkMeta;
    var context = this.getCurrentContext(chunkMeta);

    if (!context) {
      this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
      return;
    }

    var frag = context.frag,
        part = context.part,
        level = context.level;
    var video = remuxResult.video,
        text = remuxResult.text,
        id3 = remuxResult.id3,
        initSegment = remuxResult.initSegment; // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track

    var audio = this.altAudio ? undefined : remuxResult.audio; // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.
    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.

    if (this.fragContextChanged(frag)) {
      return;
    }

    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING;

    if (initSegment) {
      if (initSegment.tracks) {
        this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);

        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_INIT_SEGMENT, {
          frag: frag,
          id: id,
          tracks: initSegment.tracks
        });
      } // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038


      var initPTS = initSegment.initPTS;
      var timescale = initSegment.timescale;

      if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS)) {
        this.initPTS[frag.cc] = initPTS;
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].INIT_PTS_FOUND, {
          frag: frag,
          id: id,
          initPTS: initPTS,
          timescale: timescale
        });
      }
    } // Avoid buffering if backtracking this fragment


    if (video && remuxResult.independent !== false) {
      if (level.details) {
        var startPTS = video.startPTS,
            endPTS = video.endPTS,
            startDTS = video.startDTS,
            endDTS = video.endDTS;

        if (part) {
          part.elementaryStreams[video.type] = {
            startPTS: startPTS,
            endPTS: endPTS,
            startDTS: startDTS,
            endDTS: endDTS
          };
        } else if (video.dropped && video.independent) {
          // Backtrack if dropped frames create a gap at currentTime
          var pos = this.getLoadPosition() + this.config.maxBufferHole;

          if (pos > frag.start && pos < startPTS) {
            this.backtrack(frag);
            return;
          } // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial


          frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
        }

        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(video, frag, part, chunkMeta);
      }
    } else if (remuxResult.independent === false) {
      this.backtrack(frag);
      return;
    }

    if (audio) {
      var _startPTS = audio.startPTS,
          _endPTS = audio.endPTS,
          _startDTS = audio.startDTS,
          _endDTS = audio.endDTS;

      if (part) {
        part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO] = {
          startPTS: _startPTS,
          endPTS: _endPTS,
          startDTS: _startDTS,
          endDTS: _endDTS
        };
      }

      frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }

    if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
      var emittedID3 = {
        frag: frag,
        id: id,
        samples: id3.samples
      };
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_METADATA, emittedID3);
    }

    if (text) {
      var emittedText = {
        frag: frag,
        id: id,
        samples: text.samples
      };
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_USERDATA, emittedText);
    }
  };

  _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
    var _this3 = this;

    if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING) {
      return;
    }

    this.audioOnly = !!tracks.audio && !tracks.video; // if audio track is expected to come from audio stream controller, discard any coming from main

    if (this.altAudio && !this.audioOnly) {
      delete tracks.audio;
    } // include levelCodec in audio and video tracks


    var audio = tracks.audio,
        video = tracks.video,
        audiovideo = tracks.audiovideo;

    if (audio) {
      var audioCodec = currentLevel.audioCodec;
      var ua = navigator.userAgent.toLowerCase();

      if (this.audioCodecSwitch) {
        if (audioCodec) {
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        } // In the case that AAC and HE-AAC audio codecs are signalled in manifest,
        // force HE-AAC, as it seems that most browsers prefers it.
        // don't force HE-AAC if mono stream, or in Firefox


        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {
          audioCodec = 'mp4a.40.5';
        }
      } // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise


      if (ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {
        // Exclude mpeg audio
        audioCodec = 'mp4a.40.2';
        this.log("Android: force audio codec to " + audioCodec);
      }

      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
        this.log("Swapping manifest audio codec \"" + currentLevel.audioCodec + "\" for \"" + audioCodec + "\"");
      }

      audio.levelCodec = audioCodec;
      audio.id = 'main';
      this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || '') + "/" + (currentLevel.audioCodec || '') + "/" + audio.codec + "]");
    }

    if (video) {
      video.levelCodec = currentLevel.videoCodec;
      video.id = 'main';
      this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || '') + "/" + video.codec + "]");
    }

    if (audiovideo) {
      this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + (currentLevel.attrs.CODECS || '') + "/" + audiovideo.codec + "]");
    }

    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CODECS, tracks); // loop through tracks that are going to be provided to bufferController

    Object.keys(tracks).forEach(function (trackName) {
      var track = tracks[trackName];
      var initSegment = track.initSegment;

      if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
        _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_APPENDING, {
          type: trackName,
          data: initSegment,
          frag: frag,
          part: null,
          chunkMeta: chunkMeta
        });
      }
    }); // trigger handler right now

    this.tick();
  };

  _proto.backtrack = function backtrack(frag) {
    // Causes findFragments to backtrack through fragments to find the keyframe
    this.resetTransmuxer();
    this.flushMainBuffer(0, frag.start);
    this.fragmentTracker.backtrack(frag);
    this.fragPrevious = null;
    this.nextLoadPosition = frag.start;
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].BACKTRACKING;
  };

  _proto.checkFragmentChanged = function checkFragmentChanged() {
    var video = this.media;
    var fragPlayingCurrent = null;

    if (video && video.readyState > 1 && video.seeking === false) {
      var currentTime = video.currentTime;
      /* if video element is in seeked state, currentTime can only increase.
        (assuming that playback rate is positive ...)
        As sometimes currentTime jumps back to zero after a
        media decode error, check this, to avoid seeking back to
        wrong position after a media decode error
      */

      if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(video, currentTime)) {
        fragPlayingCurrent = this.getAppendedFrag(currentTime);
      } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(video, currentTime + 0.1)) {
        /* ensure that FRAG_CHANGED event is triggered at startup,
          when first video frame is displayed and playback is paused.
          add a tolerance of 100ms, in case current position is not buffered,
          check if current pos+100ms is buffered and use that buffer range
          for FRAG_CHANGED event reporting */
        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
      }

      if (fragPlayingCurrent) {
        var fragPlaying = this.fragPlaying;
        var fragCurrentLevel = fragPlayingCurrent.level;

        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {
          this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_CHANGED, {
            frag: fragPlayingCurrent
          });

          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_SWITCHED, {
              level: fragCurrentLevel
            });
          }

          this.fragPlaying = fragPlayingCurrent;
        }
      }
    }
  };

  _createClass(StreamController, [{
    key: "nextLevel",
    get: function get() {
      var frag = this.nextBufferedFrag;

      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: "currentLevel",
    get: function get() {
      var media = this.media;

      if (media) {
        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);

        if (fragPlayingCurrent) {
          return fragPlayingCurrent.level;
        }
      }

      return -1;
    }
  }, {
    key: "nextBufferedFrag",
    get: function get() {
      var media = this.media;

      if (media) {
        // first get end range of current fragment
        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
        return this.followingBufferedFrag(fragPlayingCurrent);
      } else {
        return null;
      }
    }
  }, {
    key: "forceStartLoad",
    get: function get() {
      return this._forceStartLoad;
    }
  }]);

  return StreamController;
}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/controller/subtitle-stream-controller.ts":
/*!******************************************************!*\
  !*** ./src/controller/subtitle-stream-controller.ts ***!
  \******************************************************/
/*! exports provided: SubtitleStreamController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtitleStreamController", function() { return SubtitleStreamController; });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer-helper */ "./src/utils/buffer-helper.ts");
/* harmony import */ var _fragment_finders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fragment-finders */ "./src/controller/fragment-finders.ts");
/* harmony import */ var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragment-tracker */ "./src/controller/fragment-tracker.ts");
/* harmony import */ var _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base-stream-controller */ "./src/controller/base-stream-controller.ts");
/* harmony import */ var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../loader/fragment-loader */ "./src/loader/fragment-loader.ts");
/* harmony import */ var _types_level__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../types/level */ "./src/types/level.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }









var TICK_INTERVAL = 500; // how often to tick in ms

var SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {
  _inheritsLoose(SubtitleStreamController, _BaseStreamController);

  function SubtitleStreamController(hls, fragmentTracker) {
    var _this;

    _this = _BaseStreamController.call(this, hls, fragmentTracker, '[subtitle-stream-controller]') || this;
    _this.levels = [];
    _this.currentTrackId = -1;
    _this.tracksBuffered = void 0;
    _this.config = hls.config;
    _this.fragCurrent = null;
    _this.fragPrevious = null;
    _this.media = null;
    _this.mediaBuffer = null;
    _this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].STOPPED;
    _this.tracksBuffered = [];
    _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_6__["default"](hls.config);

    _this._registerListeners();

    return _this;
  }

  var _proto = SubtitleStreamController.prototype;

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
  };

  _proto.startLoad = function startLoad() {
    this.stopLoad();
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE; // Check if we already have a track with necessary details to load fragments

    var currentTrack = this.levels[this.currentTrackId];

    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {
      this.setInterval(TICK_INTERVAL);
      this.tick();
    }
  };

  _proto.onHandlerDestroyed = function onHandlerDestroyed() {
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].STOPPED;

    this._unregisterListeners();

    _BaseStreamController.prototype.onHandlerDestroyed.call(this);
  };

  _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {
    var frag = data.frag,
        success = data.success;
    this.fragPrevious = frag;
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE;

    if (!success) {
      return;
    }

    var buffered = this.tracksBuffered[this.currentTrackId];

    if (!buffered) {
      return;
    } // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo
    // so we can re-use the logic used to detect how much have been buffered


    var timeRange;
    var fragStart = frag.start;

    for (var i = 0; i < buffered.length; i++) {
      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
        timeRange = buffered[i];
        break;
      }
    }

    var fragEnd = frag.start + frag.duration;

    if (timeRange) {
      timeRange.end = fragEnd;
    } else {
      timeRange = {
        start: fragStart,
        end: fragEnd
      };
      buffered.push(timeRange);
    }
  };

  _proto.onMediaAttached = function onMediaAttached(event, _ref) {
    var media = _ref.media;
    this.media = media;
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE;
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    var _this2 = this;

    if (!this.media) {
      return;
    }

    this.fragmentTracker.removeAllFragments();
    this.currentTrackId = -1;
    this.levels.forEach(function (level) {
      _this2.tracksBuffered[level.id] = [];
    });
    this.media = null;
    this.mediaBuffer = null;
    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].STOPPED;
  } // If something goes wrong, proceed to next frag, if we were processing one.
  ;

  _proto.onError = function onError(event, data) {
    var _this$fragCurrent;

    var frag = data.frag; // don't handle error not related to subtitle fragment

    if (!frag || frag.type !== 'subtitle') {
      return;
    }

    if ((_this$fragCurrent = this.fragCurrent) !== null && _this$fragCurrent !== void 0 && _this$fragCurrent.loader) {
      this.fragCurrent.loader.abort();
    }

    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE;
  } // Got all new subtitle levels.
  ;

  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref2) {
    var _this3 = this;

    var subtitleTracks = _ref2.subtitleTracks;
    this.tracksBuffered = [];
    this.levels = subtitleTracks.map(function (mediaPlaylist) {
      return new _types_level__WEBPACK_IMPORTED_MODULE_7__["Level"](mediaPlaylist);
    });
    this.levels.forEach(function (level) {
      _this3.tracksBuffered[level.id] = [];
    });
    this.mediaBuffer = null;
  };

  _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {
    this.currentTrackId = data.id;

    if (!this.levels.length || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    } // Check if track has the necessary details to load fragments


    var currentTrack = this.levels[this.currentTrackId];

    if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {
      this.mediaBuffer = this.mediaBufferTimeRanges;
      this.setInterval(TICK_INTERVAL);
    } else {
      this.mediaBuffer = null;
    }
  } // Got a new set of subtitle fragments.
  ;

  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
    var _currentTrack$details;

    var id = data.id,
        details = data.details;
    var currentTrackId = this.currentTrackId,
        levels = this.levels;

    if (!levels.length || !details) {
      return;
    }

    var currentTrack = levels[currentTrackId];

    if (id >= levels.length || id !== currentTrackId || !currentTrack) {
      return;
    }

    this.mediaBuffer = this.mediaBufferTimeRanges;

    if (details.live || (_currentTrack$details = currentTrack.details) !== null && _currentTrack$details !== void 0 && _currentTrack$details.live) {
      if (details.deltaUpdateFailed) {
        return;
      } // TODO: Subtitle Fragments should be assigned startPTS and endPTS once VTT/TTML is parsed
      //  otherwise this depends on DISCONTINUITY or PROGRAM-DATE-TIME tags to align playlists


      this.alignPlaylists(details, currentTrack.details);
    }

    currentTrack.details = details;
    this.levelLastLoaded = id;
    this.setInterval(TICK_INTERVAL);
  };

  _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
    var frag = fragLoadedData.frag,
        payload = fragLoadedData.payload;
    var decryptData = frag.decryptdata;
    var hls = this.hls;

    if (this.fragContextChanged(frag)) {
      return;
    } // check to see if the payload needs to be decrypted


    if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {
      var startTime = performance.now(); // decrypt the subtitles

      this.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {
        var endTime = performance.now();
        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_DECRYPTED, {
          frag: frag,
          payload: decryptedData,
          stats: {
            tstart: startTime,
            tdecrypt: endTime
          }
        });
      });
    }
  };

  _proto.doTick = function doTick() {
    if (!this.media) {
      this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE;
      return;
    }

    if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].IDLE) {
      var _foundFrag;

      var config = this.config,
          currentTrackId = this.currentTrackId,
          fragmentTracker = this.fragmentTracker,
          media = this.media,
          levels = this.levels;

      if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {
        return;
      }

      var maxBufferHole = config.maxBufferHole,
          maxFragLookUpTolerance = config.maxFragLookUpTolerance;
      var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
      var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__["BufferHelper"].bufferedInfo(this.mediaBufferTimeRanges, media.currentTime, maxBufferHole);
      var targetBufferTime = bufferedInfo.end,
          bufferLen = bufferedInfo.len;

      if (bufferLen > maxConfigBuffer) {
        return;
      }

      var trackDetails = levels[currentTrackId].details;
      console.assert(trackDetails, 'Subtitle track details are defined on idle subtitle stream controller tick');
      var fragments = trackDetails.fragments;
      var fragLen = fragments.length;
      var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;
      var foundFrag;
      var fragPrevious = this.fragPrevious;

      if (targetBufferTime < end) {
        if (fragPrevious && trackDetails.hasProgramDateTime) {
          foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_3__["findFragmentByPDT"])(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
        }

        if (!foundFrag) {
          foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_3__["findFragmentByPTS"])(fragPrevious, fragments, targetBufferTime, maxFragLookUpTolerance);
        }
      } else {
        foundFrag = fragments[fragLen - 1];
      }

      if ((_foundFrag = foundFrag) !== null && _foundFrag !== void 0 && _foundFrag.encrypted) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("Loading key for " + foundFrag.sn);
        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["State"].KEY_LOADING;
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADING, {
          frag: foundFrag
        });
      } else if (foundFrag && fragmentTracker.getState(foundFrag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentState"].NOT_LOADED) {
        // only load if fragment is not loaded
        this.loadFragment(foundFrag, trackDetails, targetBufferTime);
      }
    }
  };

  _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
    this.fragCurrent = frag;

    _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
  };

  _proto.stopLoad = function stopLoad() {
    this.fragPrevious = null;

    _BaseStreamController.prototype.stopLoad.call(this);
  };

  _createClass(SubtitleStreamController, [{
    key: "mediaBufferTimeRanges",
    get: function get() {
      return this.tracksBuffered[this.currentTrackId] || [];
    }
  }]);

  return SubtitleStreamController;
}(_base_stream_controller__WEBPACK_IMPORTED_MODULE_5__["default"]);

/***/ }),

/***/ "./src/controller/subtitle-track-controller.ts":
/*!*****************************************************!*\
  !*** ./src/controller/subtitle-track-controller.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.ts");
/* harmony import */ var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-playlist-controller */ "./src/controller/base-playlist-controller.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






var SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {
  _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);

  // Enable/disable subtitle display rendering
  function SubtitleTrackController(hls) {
    var _this;

    _this = _BasePlaylistControll.call(this, hls, '[subtitle-track-controller]') || this;
    _this.media = null;
    _this.tracks = [];
    _this.groupId = null;
    _this.tracksInGroup = [];
    _this.trackId = -1;
    _this.selectDefaultTrack = true;
    _this.queuedDefaultTrack = -1;

    _this.trackChangeListener = function () {
      return _this.onTextTracksChanged();
    };

    _this.useTextTrackPolling = false;
    _this.subtitlePollingInterval = -1;
    _this.subtitleDisplay = true;

    _this.registerListeners();

    return _this;
  }

  var _proto = SubtitleTrackController.prototype;

  _proto.destroy = function destroy() {
    this.unregisterListeners();

    _BasePlaylistControll.prototype.destroy.call(this);
  };

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
  } // Listen for subtitle track change, then extract the current track ID.
  ;

  _proto.onMediaAttached = function onMediaAttached(event, data) {
    var _this2 = this;

    this.media = data.media;

    if (!this.media) {
      return;
    }

    if (this.queuedDefaultTrack > -1) {
      this.subtitleTrack = this.queuedDefaultTrack;
      this.queuedDefaultTrack = -1;
    }

    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);

    if (this.useTextTrackPolling) {
      self.clearInterval(this.subtitlePollingInterval);
      this.subtitlePollingInterval = self.setInterval(function () {
        _this2.trackChangeListener();
      }, 500);
    } else {
      this.media.textTracks.addEventListener('change', this.trackChangeListener);
    }
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    if (!this.media) {
      return;
    }

    if (this.useTextTrackPolling) {
      self.clearInterval(this.subtitlePollingInterval);
    } else {
      this.media.textTracks.removeEventListener('change', this.trackChangeListener);
    }

    if (this.trackId > -1) {
      this.queuedDefaultTrack = this.trackId;
    }

    var textTracks = filterSubtitleTracks(this.media.textTracks); // Clear loaded cues on media detachment from tracks

    textTracks.forEach(function (track) {
      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__["clearCurrentCues"])(track);
    }); // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.

    this.subtitleTrack = -1;
    this.media = null;
  };

  _proto.onManifestLoading = function onManifestLoading() {
    this.tracks = [];
    this.groupId = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.selectDefaultTrack = true;
  } // Fired whenever a new manifest is loaded.
  ;

  _proto.onManifestParsed = function onManifestParsed(event, data) {
    this.tracks = data.subtitleTracks;
  };

  _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
    var id = data.id,
        details = data.details;
    var trackId = this.trackId;
    var currentTrack = this.tracksInGroup[trackId];

    if (!currentTrack) {
      this.warn("Invalid subtitle track id " + id);
      return;
    }

    var curDetails = currentTrack.details;
    currentTrack.details = data.details;
    this.log("subtitle track " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");

    if (id === this.trackId) {
      this.retryCount = 0;
      this.playlistLoaded(id, data, curDetails);
    }
  };

  _proto.onLevelLoading = function onLevelLoading(event, data) {
    var levelInfo = this.hls.levels[data.level];

    if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {
      return;
    }

    var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];

    if (this.groupId !== textGroupId) {
      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;
      var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();
      var subtitleTracks = this.tracks.filter(function (track) {
        return !textGroupId || track.groupId === textGroupId;
      });
      this.groupId = textGroupId;
      this.tracksInGroup = subtitleTracks;
      var subtitleTracksUpdated = {
        subtitleTracks: subtitleTracks
      };
      this.log("Updating subtitle tracks, " + subtitleTracks.length + " track(s) found in \"" + textGroupId + "\" group-id");
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);

      if (initialTrackId !== -1) {
        this.setSubtitleTrack(initialTrackId, lastTrack);
      }
    }
  };

  _proto.findTrackId = function findTrackId(name) {
    var audioTracks = this.tracksInGroup;

    for (var i = 0; i < audioTracks.length; i++) {
      var track = audioTracks[i];

      if (!this.selectDefaultTrack || track.default) {
        if (!name || name === track.name) {
          return track.id;
        }
      }
    }

    return -1;
  };

  _proto.onError = function onError(event, data) {
    _BasePlaylistControll.prototype.onError.call(this, event, data);

    if (data.fatal || !data.context) {
      return;
    }

    if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__["PlaylistContextType"].SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
      this.retryLoadingOrFail(data);
    }
  }
  /** get alternate subtitle tracks list from playlist **/
  ;

  _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
    var currentTrack = this.tracksInGroup[this.trackId];

    if (this.shouldLoadTrack(currentTrack)) {
      var id = currentTrack.id;
      var groupId = currentTrack.groupId;
      var url = currentTrack.url;

      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
        }
      }

      this.log("Loading subtitle playlist for id " + id);
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADING, {
        url: url,
        id: id,
        groupId: groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  ;

  _proto.toggleTrackModes = function toggleTrackModes(newId) {
    var _this3 = this;

    var media = this.media,
        subtitleDisplay = this.subtitleDisplay,
        trackId = this.trackId;

    if (!media) {
      return;
    }

    var textTracks = filterSubtitleTracks(media.textTracks);
    var groupTracks = textTracks.filter(function (track) {
      return track.groupId === _this3.groupId;
    });

    if (newId === -1) {
      [].slice.call(textTracks).forEach(function (track) {
        track.mode = 'disabled';
      });
    } else {
      var oldTrack = groupTracks[trackId];

      if (oldTrack) {
        oldTrack.mode = 'disabled';
      }
    }

    var nextTrack = groupTracks[newId];

    if (nextTrack) {
      nextTrack.mode = subtitleDisplay ? 'showing' : 'hidden';
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  ;

  _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {
    var _tracks$newId;

    var tracks = this.tracksInGroup; // setting this.subtitleTrack will trigger internal logic
    // if media has not been attached yet, it will fail
    // we keep a reference to the default track id
    // and we'll set subtitleTrack when onMediaAttached is triggered

    if (!this.media) {
      this.queuedDefaultTrack = newId;
      return;
    }

    if (this.trackId !== newId) {
      this.toggleTrackModes(newId);
    } // exit if track id as already set or invalid


    if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {
      return;
    } // stopping live reloading timer if any


    this.clearTimer();
    var track = tracks[newId];
    this.log("Switching to subtitle track " + newId);
    this.trackId = newId;

    if (track) {
      var url = track.url,
          type = track.type,
          id = track.id;
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, {
        id: id,
        type: type,
        url: url
      });
      var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
      this.loadPlaylist(hlsUrlParameters);
    } else {
      // switch to -1
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, {
        id: newId
      });
    }
  };

  _proto.onTextTracksChanged = function onTextTracksChanged() {
    // Media is undefined when switching streams via loadSource()
    if (!this.media || !this.hls.config.renderTextTracksNatively) {
      return;
    }

    var trackId = -1;
    var tracks = filterSubtitleTracks(this.media.textTracks);

    for (var id = 0; id < tracks.length; id++) {
      if (tracks[id].mode === 'hidden') {
        // Do not break in case there is a following track with showing.
        trackId = id;
      } else if (tracks[id].mode === 'showing') {
        trackId = id;
        break;
      }
    } // Setting current subtitleTrack will invoke code.


    this.subtitleTrack = trackId;
  };

  _createClass(SubtitleTrackController, [{
    key: "subtitleTracks",
    get: function get() {
      return this.tracksInGroup;
    }
    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: "subtitleTrack",
    get: function get() {
      return this.trackId;
    }
    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(newId) {
      this.selectDefaultTrack = false;
      var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;
      this.setSubtitleTrack(newId, lastTrack);
    }
  }]);

  return SubtitleTrackController;
}(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);

function filterSubtitleTracks(textTrackList) {
  var tracks = [];

  for (var i = 0; i < textTrackList.length; i++) {
    var track = textTrackList[i]; // Edge adds a track without a label; we don't want to use it

    if (track.kind === 'subtitles' && track.label) {
      tracks.push(textTrackList[i]);
    }
  }

  return tracks;
}

/* harmony default export */ __webpack_exports__["default"] = (SubtitleTrackController);

/***/ }),

/***/ "./src/controller/timeline-controller.ts":
/*!***********************************************!*\
  !*** ./src/controller/timeline-controller.ts ***!
  \***********************************************/
/*! exports provided: TimelineController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineController", function() { return TimelineController; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cea-608-parser */ "./src/utils/cea-608-parser.ts");
/* harmony import */ var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/output-filter */ "./src/utils/output-filter.ts");
/* harmony import */ var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/webvtt-parser */ "./src/utils/webvtt-parser.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/texttrack-utils */ "./src/utils/texttrack-utils.ts");
/* harmony import */ var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/imsc1-ttml-parser */ "./src/utils/imsc1-ttml-parser.ts");









var TimelineController = /*#__PURE__*/function () {
  function TimelineController(hls) {
    this.hls = void 0;
    this.media = null;
    this.config = void 0;
    this.enabled = true;
    this.Cues = void 0;
    this.textTracks = [];
    this.tracks = [];
    this.initPTS = [];
    this.timescale = [];
    this.unparsedVttFrags = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.cea608Parser1 = void 0;
    this.cea608Parser2 = void 0;
    this.lastSn = -1;
    this.prevCC = -1;
    this.vttCCs = newVTTCCs();
    this.captionsProperties = void 0;
    this.hls = hls;
    this.config = hls.config;
    this.Cues = hls.config.cueHandler;
    this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    };

    if (this.config.enableCEA708Captions) {
      var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, 'textTrack1');
      var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, 'textTrack2');
      var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, 'textTrack3');
      var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, 'textTrack4');
      this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](1, channel1, channel2);
      this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](3, channel3, channel4);
    }

    this._registerListeners();
  }

  var _proto = TimelineController.prototype;

  _proto._registerListeners = function _registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
  };

  _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
    // skip cues which overlap more than 50% with previously parsed time ranges
    var merged = false;

    for (var i = cueRanges.length; i--;) {
      var cueRange = cueRanges[i];
      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);

      if (overlap >= 0) {
        cueRange[0] = Math.min(cueRange[0], startTime);
        cueRange[1] = Math.max(cueRange[1], endTime);
        merged = true;

        if (overlap / (endTime - startTime) > 0.5) {
          return;
        }
      }
    }

    if (!merged) {
      cueRanges.push([startTime, endTime]);
    }

    if (this.config.renderTextTracksNatively) {
      this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
    } else {
      var cues = this.Cues.newCue(null, startTime, endTime, screen);
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].CUES_PARSED, {
        type: 'captions',
        cues: cues,
        track: trackName
      });
    }
  } // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  ;

  _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
    var _this = this;

    var frag = _ref.frag,
        id = _ref.id,
        initPTS = _ref.initPTS,
        timescale = _ref.timescale;
    var unparsedVttFrags = this.unparsedVttFrags;

    if (id === 'main') {
      this.initPTS[frag.cc] = initPTS;
      this.timescale[frag.cc] = timescale;
    } // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.
    // Parse any unparsed fragments upon receiving the initial PTS.


    if (unparsedVttFrags.length) {
      this.unparsedVttFrags = [];
      unparsedVttFrags.forEach(function (frag) {
        _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, frag);
      });
    }
  };

  _proto.getExistingTrack = function getExistingTrack(trackName) {
    var media = this.media;

    if (media) {
      for (var i = 0; i < media.textTracks.length; i++) {
        var textTrack = media.textTracks[i];

        if (textTrack[trackName]) {
          return textTrack;
        }
      }
    }

    return null;
  };

  _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
    if (this.config.renderTextTracksNatively) {
      this.createNativeTrack(trackName);
    } else {
      this.createNonNativeTrack(trackName);
    }
  };

  _proto.createNativeTrack = function createNativeTrack(trackName) {
    if (this.captionsTracks[trackName]) {
      return;
    }

    var captionsProperties = this.captionsProperties,
        captionsTracks = this.captionsTracks,
        media = this.media;
    var _captionsProperties$t = captionsProperties[trackName],
        label = _captionsProperties$t.label,
        languageCode = _captionsProperties$t.languageCode; // Enable reuse of existing text track.

    var existingTrack = this.getExistingTrack(trackName);

    if (!existingTrack) {
      var textTrack = this.createTextTrack('captions', label, languageCode);

      if (textTrack) {
        // Set a special property on the track so we know it's managed by Hls.js
        textTrack[trackName] = true;
        captionsTracks[trackName] = textTrack;
      }
    } else {
      captionsTracks[trackName] = existingTrack;
      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_6__["clearCurrentCues"])(captionsTracks[trackName]);
      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_6__["sendAddTrackEvent"])(captionsTracks[trackName], media);
    }
  };

  _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
    if (this.nonNativeCaptionsTracks[trackName]) {
      return;
    } // Create a list of a single track for the provider to consume


    var trackProperties = this.captionsProperties[trackName];

    if (!trackProperties) {
      return;
    }

    var label = trackProperties.label;
    var track = {
      _id: trackName,
      label: label,
      kind: 'captions',
      default: trackProperties.media ? !!trackProperties.media.default : false,
      closedCaptions: trackProperties.media
    };
    this.nonNativeCaptionsTracks[trackName] = track;
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [track]
    });
  };

  _proto.createTextTrack = function createTextTrack(kind, label, lang) {
    var media = this.media;

    if (!media) {
      return;
    }

    return media.addTextTrack(kind, label, lang);
  };

  _proto.destroy = function destroy() {
    this._unregisterListeners();
  };

  _proto.onMediaAttaching = function onMediaAttaching(event, data) {
    this.media = data.media;

    this._cleanTracks();
  };

  _proto.onMediaDetaching = function onMediaDetaching() {
    var captionsTracks = this.captionsTracks;
    Object.keys(captionsTracks).forEach(function (trackName) {
      Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_6__["clearCurrentCues"])(captionsTracks[trackName]);
      delete captionsTracks[trackName];
    });
    this.nonNativeCaptionsTracks = {};
  };

  _proto.onManifestLoading = function onManifestLoading() {
    this.lastSn = -1; // Detect discontinuity in fragment parsing

    this.prevCC = -1;
    this.vttCCs = newVTTCCs(); // Detect discontinuity in subtitle manifests

    this._cleanTracks();

    this.tracks = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.textTracks = [];
    this.unparsedVttFrags = this.unparsedVttFrags || [];
    this.initPTS = [];
    this.timescale = [];

    if (this.cea608Parser1 && this.cea608Parser2) {
      this.cea608Parser1.reset();
      this.cea608Parser2.reset();
    }
  };

  _proto._cleanTracks = function _cleanTracks() {
    // clear outdated subtitles
    var media = this.media;

    if (!media) {
      return;
    }

    var textTracks = media.textTracks;

    if (textTracks) {
      for (var i = 0; i < textTracks.length; i++) {
        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_6__["clearCurrentCues"])(textTracks[i]);
      }
    }
  };

  _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {
    var _this2 = this;

    this.textTracks = [];
    var tracks = data.subtitleTracks || [];
    var hasIMSC1 = tracks.some(function (track) {
      return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__["IMSC1_CODEC"];
    });

    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
      var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;
      this.tracks = tracks || [];

      if (this.config.renderTextTracksNatively) {
        var inUseTracks = this.media ? this.media.textTracks : [];
        this.tracks.forEach(function (track, index) {
          var textTrack;

          if (index < inUseTracks.length) {
            var inUseTrack = null;

            for (var i = 0; i < inUseTracks.length; i++) {
              if (canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                break;
              }
            } // Reuse tracks with the same label, but do not reuse 608/708 tracks


            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }

          if (!textTrack) {
            textTrack = _this2.createTextTrack('subtitles', track.name, track.lang);

            if (textTrack) {
              textTrack.mode = 'disabled';
            }
          }

          if (textTrack) {
            textTrack.groupId = track.groupId;

            _this2.textTracks.push(textTrack);
          }
        });
      } else if (!sameTracks && this.tracks && this.tracks.length) {
        // Create a list of tracks for the provider to consume
        var tracksList = this.tracks.map(function (track) {
          return {
            label: track.name,
            kind: track.type.toLowerCase(),
            default: track.default,
            subtitleTrack: track
          };
        });
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: tracksList
        });
      }
    }
  };

  _proto.onManifestLoaded = function onManifestLoaded(event, data) {
    var _this3 = this;

    if (this.config.enableCEA708Captions && data.captions) {
      data.captions.forEach(function (captionsTrack) {
        var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);

        if (!instreamIdMatch) {
          return;
        }

        var trackName = "textTrack" + instreamIdMatch[1];
        var trackProperties = _this3.captionsProperties[trackName];

        if (!trackProperties) {
          return;
        }

        trackProperties.label = captionsTrack.name;

        if (captionsTrack.lang) {
          // optional attribute
          trackProperties.languageCode = captionsTrack.lang;
        }

        trackProperties.media = captionsTrack;
      });
    }
  };

  _proto.onFragLoaded = function onFragLoaded(event, data) {
    var frag = data.frag,
        payload = data.payload;
    var cea608Parser1 = this.cea608Parser1,
        cea608Parser2 = this.cea608Parser2,
        initPTS = this.initPTS,
        lastSn = this.lastSn,
        unparsedVttFrags = this.unparsedVttFrags;

    if (frag.type === 'main') {
      var sn = frag.sn; // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack

      if (sn !== lastSn + 1) {
        if (cea608Parser1 && cea608Parser2) {
          cea608Parser1.reset();
          cea608Parser2.reset();
        }
      }

      this.lastSn = sn;
    } else if (frag.type === 'subtitle') {
      // If fragment is subtitle type, parse as WebVTT.
      if (payload.byteLength) {
        // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
        if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS[frag.cc])) {
          unparsedVttFrags.push(data);

          if (initPTS.length) {
            // finish unsuccessfully, otherwise the subtitle-stream-controller could be blocked from loading new frags.
            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
              success: false,
              frag: frag,
              error: new Error('Missing initial subtitle PTS')
            });
          }

          return;
        }

        var decryptData = frag.decryptdata; // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.

        if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
          var trackPlaylistMedia = this.tracks[frag.level];
          var vttCCs = this.vttCCs;

          if (!vttCCs[frag.cc]) {
            vttCCs[frag.cc] = {
              start: frag.start,
              prevCC: this.prevCC,
              new: true
            };
            this.prevCC = frag.cc;
          }

          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__["IMSC1_CODEC"]) {
            this._parseIMSC1(frag, payload);
          } else {
            this._parseVTTs(frag, payload, vttCCs);
          }
        }
      } else {
        // In case there is no payload, finish unsuccessfully.
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag: frag,
          error: new Error('Empty subtitle payload')
        });
      }
    }
  };

  _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {
    var _this4 = this;

    var hls = this.hls;
    Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__["parseIMSC1"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function (cues) {
      _this4._appendCues(cues, frag.level);

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag: frag
      });
    }, function (error) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("Failed to parse IMSC1: " + error);
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag: frag,
        error: error
      });
    });
  };

  _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {
    var _this5 = this;

    var hls = this.hls; // Parse the WebVTT file contents.

    Object(_utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__["parseWebVTT"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], vttCCs, frag.cc, frag.start, function (cues) {
      _this5._appendCues(cues, frag.level);

      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag: frag
      });
    }, function (error) {
      _this5._fallbackToIMSC1(frag, payload); // Something went wrong while parsing. Trigger event with success false.


      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("Failed to parse VTT cue: " + error);
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag: frag,
        error: error
      });
    });
  };

  _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {
    var _this6 = this;

    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result
    var trackPlaylistMedia = this.tracks[frag.level];

    if (!trackPlaylistMedia.textCodec) {
      Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__["parseIMSC1"])(payload, this.initPTS[frag.cc], this.timescale[frag.cc], function () {
        trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_7__["IMSC1_CODEC"];

        _this6._parseIMSC1(frag, payload);
      }, function () {
        trackPlaylistMedia.textCodec = 'wvtt';
      });
    }
  };

  _proto._appendCues = function _appendCues(cues, fragLevel) {
    var hls = this.hls;

    if (this.config.renderTextTracksNatively) {
      var textTrack = this.textTracks[fragLevel]; // WebVTTParser.parse is an async method and if the currently selected text track mode is set to "disabled"
      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null
      // and trying to access getCueById method of cues will throw an exception
      // Because we check if the mode is diabled, we can force check `cues` below. They can't be null.

      if (textTrack.mode === 'disabled') {
        return;
      } // Sometimes there are cue overlaps on segmented vtts so the same
      // cue can appear more than once in different vtt files.
      // This avoid showing duplicated cues with same timecode and text.


      cues.filter(function (cue) {
        return !textTrack.cues.getCueById(cue.id);
      }).forEach(function (cue) {
        try {
          textTrack.addCue(cue);

          if (!textTrack.cues.getCueById(cue.id)) {
            throw new Error("addCue is failed for: " + cue);
          }
        } catch (err) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].debug("Failed occurred on adding cues: " + err);
          var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
          textTrackCue.id = cue.id;
          textTrack.addCue(textTrackCue);
        }
      });
    } else {
      var currentTrack = this.tracks[fragLevel];
      var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].CUES_PARSED, {
        type: 'subtitles',
        cues: cues,
        track: track
      });
    }
  };

  _proto.onFragDecrypted = function onFragDecrypted(event, data) {
    var frag = data.frag;

    if (frag.type === 'subtitle') {
      if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.initPTS[frag.cc])) {
        this.unparsedVttFrags.push(data);
        return;
      }

      this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, data);
    }
  };

  _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {
    this.tracks = [];
    this.captionsTracks = {};
  };

  _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {
    var cea608Parser1 = this.cea608Parser1,
        cea608Parser2 = this.cea608Parser2;

    if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
      return;
    } // If the event contains captions (found in the bytes property), push all bytes into the parser immediately
    // It will create the proper timestamps based on the PTS value


    for (var i = 0; i < data.samples.length; i++) {
      var ccBytes = data.samples[i].bytes;

      if (ccBytes) {
        var ccdatas = this.extractCea608Data(ccBytes);
        cea608Parser1.addData(data.samples[i].pts, ccdatas[0]);
        cea608Parser2.addData(data.samples[i].pts, ccdatas[1]);
      }
    }
  };

  _proto.extractCea608Data = function extractCea608Data(byteArray) {
    var count = byteArray[0] & 31;
    var position = 2;
    var actualCCBytes = [[], []];

    for (var j = 0; j < count; j++) {
      var tmpByte = byteArray[position++];
      var ccbyte1 = 0x7f & byteArray[position++];
      var ccbyte2 = 0x7f & byteArray[position++];
      var ccValid = (4 & tmpByte) !== 0;
      var ccType = 3 & tmpByte;

      if (ccbyte1 === 0 && ccbyte2 === 0) {
        continue;
      }

      if (ccValid) {
        if (ccType === 0 || ccType === 1) {
          actualCCBytes[ccType].push(ccbyte1);
          actualCCBytes[ccType].push(ccbyte2);
        }
      }
    }

    return actualCCBytes;
  };

  return TimelineController;
}();

function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

function newVTTCCs() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: false
    }
  };
}

/***/ }),

/***/ "./src/crypt/aes-crypto.ts":
/*!*********************************!*\
  !*** ./src/crypt/aes-crypto.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AESCrypto; });
var AESCrypto = /*#__PURE__*/function () {
  function AESCrypto(subtle, iv) {
    this.subtle = void 0;
    this.aesIV = void 0;
    this.subtle = subtle;
    this.aesIV = iv;
  }

  var _proto = AESCrypto.prototype;

  _proto.decrypt = function decrypt(data, key) {
    return this.subtle.decrypt({
      name: 'AES-CBC',
      iv: this.aesIV
    }, key, data);
  };

  return AESCrypto;
}();



/***/ }),

/***/ "./src/crypt/aes-decryptor.ts":
/*!************************************!*\
  !*** ./src/crypt/aes-decryptor.ts ***!
  \************************************/
/*! exports provided: removePadding, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removePadding", function() { return removePadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AESDecryptor; });
/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/typed-array */ "./src/utils/typed-array.ts");
 // PKCS7

function removePadding(array) {
  var outputBytes = array.byteLength;
  var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);

  if (paddingBytes) {
    return Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(array, 0, outputBytes - paddingBytes);
  }

  return array;
}

var AESDecryptor = /*#__PURE__*/function () {
  function AESDecryptor() {
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);
    this.key = new Uint32Array(0);
    this.ksRows = 0;
    this.keySize = 0;
    this.keySchedule = void 0;
    this.invKeySchedule = void 0;
    this.initTable();
  } // Using view.getUint32() also swaps the byte order.


  var _proto = AESDecryptor.prototype;

  _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
    var view = new DataView(arrayBuffer);
    var newArray = new Uint32Array(4);

    for (var i = 0; i < 4; i++) {
      newArray[i] = view.getUint32(i * 4);
    }

    return newArray;
  };

  _proto.initTable = function initTable() {
    var sBox = this.sBox;
    var invSBox = this.invSBox;
    var subMix = this.subMix;
    var subMix0 = subMix[0];
    var subMix1 = subMix[1];
    var subMix2 = subMix[2];
    var subMix3 = subMix[3];
    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];
    var d = new Uint32Array(256);
    var x = 0;
    var xi = 0;
    var i = 0;

    for (i = 0; i < 256; i++) {
      if (i < 128) {
        d[i] = i << 1;
      } else {
        d[i] = i << 1 ^ 0x11b;
      }
    }

    for (i = 0; i < 256; i++) {
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
      sBox[x] = sx;
      invSBox[sx] = x; // Compute multiplication

      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4]; // Compute sub/invSub bytes, mix columns tables

      var t = d[sx] * 0x101 ^ sx * 0x1010100;
      subMix0[x] = t << 24 | t >>> 8;
      subMix1[x] = t << 16 | t >>> 16;
      subMix2[x] = t << 8 | t >>> 24;
      subMix3[x] = t; // Compute inv sub bytes, inv mix columns tables

      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
      invSubMix0[sx] = t << 24 | t >>> 8;
      invSubMix1[sx] = t << 16 | t >>> 16;
      invSubMix2[sx] = t << 8 | t >>> 24;
      invSubMix3[sx] = t; // Compute next counter

      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  };

  _proto.expandKey = function expandKey(keyBuffer) {
    // convert keyBuffer to Uint32Array
    var key = this.uint8ArrayToUint32Array_(keyBuffer);
    var sameKey = true;
    var offset = 0;

    while (offset < key.length && sameKey) {
      sameKey = key[offset] === this.key[offset];
      offset++;
    }

    if (sameKey) {
      return;
    }

    this.key = key;
    var keySize = this.keySize = key.length;

    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
      throw new Error('Invalid aes key size=' + keySize);
    }

    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
    var ksRow;
    var invKsRow;
    var keySchedule = this.keySchedule = new Uint32Array(ksRows);
    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
    var sbox = this.sBox;
    var rcon = this.rcon;
    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];
    var prev;
    var t;

    for (ksRow = 0; ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        prev = keySchedule[ksRow] = key[ksRow];
        continue;
      }

      t = prev;

      if (ksRow % keySize === 0) {
        // Rot word
        t = t << 8 | t >>> 24; // Sub word

        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff]; // Mix Rcon

        t ^= rcon[ksRow / keySize | 0] << 24;
      } else if (keySize > 6 && ksRow % keySize === 4) {
        // Sub word
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
      }

      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
    }

    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
      ksRow = ksRows - invKsRow;

      if (invKsRow & 3) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }

      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
      }

      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
    }
  } // Adding this as a method greatly improves performance.
  ;

  _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
  };

  _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
    var nRounds = this.keySize + 6;
    var invKeySchedule = this.invKeySchedule;
    var invSBOX = this.invSBox;
    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];
    var initVector = this.uint8ArrayToUint32Array_(aesIV);
    var initVector0 = initVector[0];
    var initVector1 = initVector[1];
    var initVector2 = initVector[2];
    var initVector3 = initVector[3];
    var inputInt32 = new Int32Array(inputArrayBuffer);
    var outputInt32 = new Int32Array(inputInt32.length);
    var t0, t1, t2, t3;
    var s0, s1, s2, s3;
    var inputWords0, inputWords1, inputWords2, inputWords3;
    var ksRow, i;
    var swapWord = this.networkToHostOrderSwap;

    while (offset < inputInt32.length) {
      inputWords0 = swapWord(inputInt32[offset]);
      inputWords1 = swapWord(inputInt32[offset + 1]);
      inputWords2 = swapWord(inputInt32[offset + 2]);
      inputWords3 = swapWord(inputInt32[offset + 3]);
      s0 = inputWords0 ^ invKeySchedule[0];
      s1 = inputWords3 ^ invKeySchedule[1];
      s2 = inputWords2 ^ invKeySchedule[2];
      s3 = inputWords1 ^ invKeySchedule[3];
      ksRow = 4; // Iterate through the rounds of decryption

      for (i = 1; i < nRounds; i++) {
        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3]; // Update state

        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
        ksRow = ksRow + 4;
      } // Shift rows, sub bytes, add round key


      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
      ksRow = ksRow + 3; // Write

      outputInt32[offset] = swapWord(t0 ^ initVector0);
      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
      outputInt32[offset + 3] = swapWord(t1 ^ initVector3); // reset initVector to last 4 unsigned int

      initVector0 = inputWords0;
      initVector1 = inputWords1;
      initVector2 = inputWords2;
      initVector3 = inputWords3;
      offset = offset + 4;
    }

    return outputInt32.buffer;
  };

  return AESDecryptor;
}();



/***/ }),

/***/ "./src/crypt/decrypter.ts":
/*!********************************!*\
  !*** ./src/crypt/decrypter.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Decrypter; });
/* harmony import */ var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aes-crypto */ "./src/crypt/aes-crypto.ts");
/* harmony import */ var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fast-aes-key */ "./src/crypt/fast-aes-key.ts");
/* harmony import */ var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aes-decryptor */ "./src/crypt/aes-decryptor.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/typed-array */ "./src/utils/typed-array.ts");






var CHUNK_SIZE = 16; // 16 bytes, 128 bits

var Decrypter = /*#__PURE__*/function () {
  function Decrypter(observer, config, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;

    this.logEnabled = true;
    this.observer = void 0;
    this.config = void 0;
    this.removePKCS7Padding = void 0;
    this.subtle = null;
    this.softwareDecrypter = null;
    this.key = null;
    this.fastAesKey = null;
    this.remainderData = null;
    this.currentIV = null;
    this.currentResult = null;
    this.observer = observer;
    this.config = config;
    this.removePKCS7Padding = removePKCS7Padding; // built in decryptor expects PKCS7 padding

    if (removePKCS7Padding) {
      try {
        var browserCrypto = self.crypto;

        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        } else {
          this.config.enableSoftwareAES = true;
        }
      } catch (e) {
        /* no-op */
      }
    }
  }

  var _proto = Decrypter.prototype;

  _proto.isSync = function isSync() {
    return this.config.enableSoftwareAES;
  };

  _proto.flush = function flush() {
    var currentResult = this.currentResult;

    if (!currentResult) {
      this.reset();
      return;
    }

    var data = new Uint8Array(currentResult);
    this.reset();

    if (this.removePKCS7Padding) {
      return Object(_aes_decryptor__WEBPACK_IMPORTED_MODULE_2__["removePadding"])(data);
    }

    return data;
  };

  _proto.reset = function reset() {
    this.currentResult = null;
    this.currentIV = null;
    this.remainderData = null;

    if (this.softwareDecrypter) {
      this.softwareDecrypter = null;
    }
  };

  _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
    var currentIV = this.currentIV,
        currentResult = this.currentResult,
        remainderData = this.remainderData;
    this.logOnce('JS AES decrypt'); // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call
    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached
    // the end on flush(), but by that time we have already received all bytes for the segment.
    // Progressive decryption does not work with WebCrypto

    if (remainderData) {
      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["appendUint8Array"])(remainderData, data);
      this.remainderData = null;
    } // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)


    var currentChunk = this.getValidChunk(data);

    if (!currentChunk.length) {
      return null;
    }

    if (currentIV) {
      iv = currentIV;
    }

    var softwareDecrypter = this.softwareDecrypter;

    if (!softwareDecrypter) {
      softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__["default"]();
    }

    softwareDecrypter.expandKey(key);
    var result = currentResult;
    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
    this.currentIV = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(currentChunk, -16).buffer;

    if (!result) {
      return null;
    }

    return result;
  };

  _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
    var _this = this;

    var subtle = this.subtle;

    if (this.key !== key || !this.fastAesKey) {
      this.key = key;
      this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__["default"](subtle, key);
    }

    return this.fastAesKey.expandKey().then(function (aesKey) {
      // decrypt using web crypto
      if (!subtle) {
        return Promise.reject(new Error('web crypto not initialized'));
      }

      var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__["default"](subtle, iv);
      return crypto.decrypt(data.buffer, aesKey);
    }).catch(function (err) {
      return _this.onWebCryptoError(err, data, key, iv);
    });
  };

  _proto.onWebCryptoError = function onWebCryptoError(err, data, key, iv) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn('[decrypter.ts]: WebCrypto Error, disable WebCrypto API:', err);
    this.config.enableSoftwareAES = true;
    this.logEnabled = true;
    return this.softwareDecrypt(data, key, iv);
  };

  _proto.getValidChunk = function getValidChunk(data) {
    var currentChunk = data;
    var splitPoint = data.length - data.length % CHUNK_SIZE;

    if (splitPoint !== data.length) {
      currentChunk = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(data, 0, splitPoint);
      this.remainderData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(data, splitPoint);
    }

    return currentChunk;
  };

  _proto.logOnce = function logOnce(msg) {
    if (!this.logEnabled) {
      return;
    }

    _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[decrypter.ts]: " + msg);
    this.logEnabled = false;
  };

  return Decrypter;
}();



/***/ }),

/***/ "./src/crypt/fast-aes-key.ts":
/*!***********************************!*\
  !*** ./src/crypt/fast-aes-key.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FastAESKey; });
var FastAESKey = /*#__PURE__*/function () {
  function FastAESKey(subtle, key) {
    this.subtle = void 0;
    this.key = void 0;
    this.subtle = subtle;
    this.key = key;
  }

  var _proto = FastAESKey.prototype;

  _proto.expandKey = function expandKey() {
    return this.subtle.importKey('raw', this.key, {
      name: 'AES-CBC'
    }, false, ['encrypt', 'decrypt']);
  };

  return FastAESKey;
}();



/***/ }),

/***/ "./src/demux/aacdemuxer.ts":
/*!*********************************!*\
  !*** ./src/demux/aacdemuxer.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-audio-demuxer */ "./src/demux/base-audio-demuxer.ts");
/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adts */ "./src/demux/adts.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * AAC demuxer
 */





var AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {
  _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);

  function AACDemuxer(observer, config) {
    var _this;

    _this = _BaseAudioDemuxer.call(this) || this;
    _this.observer = void 0;
    _this.config = void 0;
    _this.observer = observer;
    _this.config = config;
    return _this;
  }

  var _proto = AACDemuxer.prototype;

  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {
    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, audioCodec, videoCodec, duration);

    this._audioTrack = {
      container: 'audio/adts',
      type: 'audio',
      id: 0,
      pid: -1,
      sequenceNumber: 0,
      isAAC: true,
      samples: [],
      manifestCodec: audioCodec,
      duration: duration,
      inputTimeScale: 90000,
      dropped: 0
    };
  } // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  ;

  AACDemuxer.probe = function probe(data) {
    if (!data) {
      return false;
    } // Check for the ADTS sync word
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS


    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__["getID3Data"](data, 0) || [];
    var offset = id3Data.length;

    for (var length = data.length; offset < length; offset++) {
      if (_adts__WEBPACK_IMPORTED_MODULE_1__["probe"](data, offset)) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('ADTS sync word found !');
        return true;
      }
    }

    return false;
  };

  _proto.canParse = function canParse(data, offset) {
    return _adts__WEBPACK_IMPORTED_MODULE_1__["canParse"](data, offset);
  };

  _proto.appendFrame = function appendFrame(track, data, offset) {
    _adts__WEBPACK_IMPORTED_MODULE_1__["initTrackConfig"](track, this.observer, data, offset, track.manifestCodec);
    return _adts__WEBPACK_IMPORTED_MODULE_1__["appendFrame"](track, data, offset, this.initPTS, this.frameIndex);
  };

  return AACDemuxer;
}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);

AACDemuxer.minProbeByteLength = 9;
/* harmony default export */ __webpack_exports__["default"] = (AACDemuxer);

/***/ }),

/***/ "./src/demux/adts.ts":
/*!***************************!*\
  !*** ./src/demux/adts.ts ***!
  \***************************/
/*! exports provided: getAudioConfig, isHeaderPattern, getHeaderLength, getFullFrameLength, canGetFrameLength, isHeader, canParse, probe, initTrackConfig, getFrameDuration, parseFrameHeader, appendFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAudioConfig", function() { return getAudioConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHeaderPattern", function() { return isHeaderPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeaderLength", function() { return getHeaderLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFullFrameLength", function() { return getFullFrameLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canGetFrameLength", function() { return canGetFrameLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHeader", function() { return isHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParse", function() { return canParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "probe", function() { return probe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initTrackConfig", function() { return initTrackConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFrameDuration", function() { return getFrameDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFrameHeader", function() { return parseFrameHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendFrame", function() { return appendFrame; });
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/**
 * ADTS parser helper
 * @link https://wiki.multimedia.cx/index.php?title=ADTS
 */



function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType;
  var adtsExtensionSampleingIndex;
  var adtsChanelConfig;
  var config;
  var userAgent = navigator.userAgent.toLowerCase();
  var manifestCodec = audioCodec;
  var adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]; // byte 2

  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;
  var adtsSampleingIndex = (data[offset + 2] & 0x3c) >>> 2;

  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
      type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
      details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_PARSING_ERROR,
      fatal: true,
      reason: "invalid ADTS sampling index:" + adtsSampleingIndex
    });
    return;
  }

  adtsChanelConfig = (data[offset + 2] & 0x01) << 2; // byte 3

  adtsChanelConfig |= (data[offset + 3] & 0xc0) >>> 6;
  _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("manifest codec:" + audioCodec + ",ADTS data:type:" + adtsObjectType + ",sampleingIndex:" + adtsSampleingIndex + "[" + adtsSampleingRates[adtsSampleingIndex] + "Hz],channelConfig:" + adtsChanelConfig); // firefox: freq less than 24kHz = AAC SBR (HE-AAC)

  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4); // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)

      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    } // Android : always use AAC

  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4); // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)

    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }

      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1


  config[0] = adtsObjectType << 3; // samplingFrequencyIndex

  config[0] |= (adtsSampleingIndex & 0x0e) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7; // channelConfiguration

  config[1] |= adtsChanelConfig << 3;

  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0e) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7; // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc

    config[2] |= 2 << 2;
    config[3] = 0;
  }

  return {
    config: config,
    samplerate: adtsSampleingRates[adtsSampleingIndex],
    channelCount: adtsChanelConfig,
    codec: 'mp4a.40.' + adtsObjectType,
    manifestCodec: manifestCodec
  };
}
function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}
function getHeaderLength(data, offset) {
  return data[offset + 1] & 0x01 ? 7 : 9;
}
function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;
}
function canGetFrameLength(data, offset) {
  return offset + 5 < data.length;
}
function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  return offset + 1 < data.length && isHeaderPattern(data, offset);
}
function canParse(data, offset) {
  return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) < data.length - offset;
}
function probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (isHeader(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);

    if (offset + headerLength >= data.length) {
      return false;
    } // ADTS frame Length


    var frameLength = getFullFrameLength(data, offset);

    if (frameLength <= headerLength) {
      return false;
    }

    var newOffset = offset + frameLength;
    return newOffset === data.length || isHeader(data, newOffset);
  }

  return false;
}
function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);

    if (!config) {
      return;
    }

    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("parsed codec:" + track.codec + ",rate:" + config.samplerate + ",nb channel:" + config.channelCount);
  }
}
function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}
function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var length = data.length; // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header

  var headerLength = getHeaderLength(data, offset); // retrieve frame size

  var frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    var stamp = pts + frameIndex * frameDuration; // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);

    return {
      headerLength: headerLength,
      frameLength: frameLength,
      stamp: stamp
    };
  }
}
function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);

  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength; // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);

    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };
    track.samples.push(aacSample);
    return {
      sample: aacSample,
      length: frameLength + headerLength
    };
  }
}

/***/ }),

/***/ "./src/demux/base-audio-demuxer.ts":
/*!*****************************************!*\
  !*** ./src/demux/base-audio-demuxer.ts ***!
  \*****************************************/
/*! exports provided: initPTSFn, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initPTSFn", function() { return initPTSFn; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dummy-demuxed-track */ "./src/demux/dummy-demuxed-track.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _utils_typed_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/typed-array */ "./src/utils/typed-array.ts");






var BaseAudioDemuxer = /*#__PURE__*/function () {
  function BaseAudioDemuxer() {
    this._audioTrack = void 0;
    this._id3Track = void 0;
    this.frameIndex = 0;
    this.cachedData = null;
    this.initPTS = null;
  }

  var _proto = BaseAudioDemuxer.prototype;

  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {
    this._id3Track = {
      type: 'id3',
      id: 0,
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  };

  _proto.resetTimeStamp = function resetTimeStamp() {};

  _proto.resetContiguity = function resetContiguity() {};

  _proto.canParse = function canParse(data, offset) {
    return false;
  };

  _proto.appendFrame = function appendFrame(track, data, offset) {} // feed incoming data to the front of the parsing pipeline
  ;

  _proto.demux = function demux(data, timeOffset) {
    if (this.cachedData) {
      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__["appendUint8Array"])(this.cachedData, data);
      this.cachedData = null;
    }

    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, 0);
    var offset = id3Data ? id3Data.length : 0;
    var lastDataIndex;
    var pts;
    var track = this._audioTrack;
    var id3Track = this._id3Track;
    var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"](id3Data) : undefined;
    var length = data.length;

    if (this.frameIndex === 0 || this.initPTS === null) {
      this.initPTS = initPTSFn(timestamp, timeOffset);
    } // more expressive than alternative: id3Data?.length


    if (id3Data && id3Data.length > 0) {
      id3Track.samples.push({
        pts: this.initPTS,
        dts: this.initPTS,
        data: id3Data
      });
    }

    pts = this.initPTS;

    while (offset < length) {
      if (this.canParse(data, offset)) {
        var frame = this.appendFrame(track, data, offset);

        if (frame) {
          this.frameIndex++;
          pts = frame.sample.pts;
          offset += frame.length;
          lastDataIndex = offset;
        } else {
          offset = length;
        }
      } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__["canParse"](data, offset)) {
        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data
        id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, offset);
        id3Track.samples.push({
          pts: pts,
          dts: pts,
          data: id3Data
        });
        offset += id3Data.length;
        lastDataIndex = offset;
      } else {
        offset++;
      }

      if (offset === length && lastDataIndex !== length) {
        var partialData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_4__["sliceUint8"])(data, lastDataIndex);

        if (this.cachedData) {
          this.cachedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_3__["appendUint8Array"])(this.cachedData, partialData);
        } else {
          this.cachedData = partialData;
        }
      }
    }

    return {
      audioTrack: track,
      avcTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__["dummyTrack"])(),
      id3Track: id3Track,
      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__["dummyTrack"])()
    };
  };

  _proto.demuxSampleAes = function demuxSampleAes(data, decryptData, timeOffset) {
    return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
  };

  _proto.flush = function flush(timeOffset) {
    // Parse cache in case of remaining frames.
    if (this.cachedData) {
      this.demux(this.cachedData, 0);
    }

    this.frameIndex = 0;
    this.cachedData = null;
    return {
      audioTrack: this._audioTrack,
      avcTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__["dummyTrack"])(),
      id3Track: this._id3Track,
      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_2__["dummyTrack"])()
    };
  };

  _proto.destroy = function destroy() {};

  return BaseAudioDemuxer;
}();
/**
 * Initialize PTS
 * <p>
 *    use timestamp unless it is undefined, NaN or Infinity
 * </p>
 */


var initPTSFn = function initPTSFn(timestamp, timeOffset) {
  return Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(timestamp) ? timestamp * 90 : timeOffset * 90000;
};
/* harmony default export */ __webpack_exports__["default"] = (BaseAudioDemuxer);

/***/ }),

/***/ "./src/demux/chunk-cache.ts":
/*!**********************************!*\
  !*** ./src/demux/chunk-cache.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ChunkCache; });
var ChunkCache = /*#__PURE__*/function () {
  function ChunkCache() {
    this.chunks = [];
    this.dataLength = 0;
  }

  var _proto = ChunkCache.prototype;

  _proto.push = function push(chunk) {
    this.chunks.push(chunk);
    this.dataLength += chunk.length;
  };

  _proto.flush = function flush() {
    var chunks = this.chunks,
        dataLength = this.dataLength;
    var result;

    if (!chunks.length) {
      return new Uint8Array(0);
    } else if (chunks.length === 1) {
      result = chunks[0];
    } else {
      result = concatUint8Arrays(chunks, dataLength);
    }

    this.reset();
    return result;
  };

  _proto.reset = function reset() {
    this.chunks.length = 0;
    this.dataLength = 0;
  };

  return ChunkCache;
}();



function concatUint8Arrays(chunks, dataLength) {
  var result = new Uint8Array(dataLength);
  var offset = 0;

  for (var i = 0; i < chunks.length; i++) {
    var chunk = chunks[i];
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return result;
}

/***/ }),

/***/ "./src/demux/dummy-demuxed-track.ts":
/*!******************************************!*\
  !*** ./src/demux/dummy-demuxed-track.ts ***!
  \******************************************/
/*! exports provided: dummyTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dummyTrack", function() { return dummyTrack; });
function dummyTrack() {
  return {
    type: '',
    id: -1,
    pid: -1,
    inputTimeScale: 90000,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}

/***/ }),

/***/ "./src/demux/exp-golomb.js":
/*!*********************************!*\
  !*** ./src/demux/exp-golomb.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/**
 * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
 */


var ExpGolomb = /*#__PURE__*/function () {
  function ExpGolomb(data) {
    this.data = data; // the number of bytes left to examine in this.data

    this.bytesAvailable = data.byteLength; // the current word being examined

    this.word = 0; // :uint
    // the number of bits left to examine in the current word

    this.bitsAvailable = 0; // :uint
  } // ():void


  var _proto = ExpGolomb.prototype;

  _proto.loadWord = function loadWord() {
    var data = this.data;
    var bytesAvailable = this.bytesAvailable;
    var position = data.byteLength - bytesAvailable;
    var workingBytes = new Uint8Array(4);
    var availableBytes = Math.min(4, bytesAvailable);

    if (availableBytes === 0) {
      throw new Error('no bytes available');
    }

    workingBytes.set(data.subarray(position, position + availableBytes));
    this.word = new DataView(workingBytes.buffer).getUint32(0); // track the amount of this.data that has been processed

    this.bitsAvailable = availableBytes * 8;
    this.bytesAvailable -= availableBytes;
  } // (count:int):void
  ;

  _proto.skipBits = function skipBits(count) {
    var skipBytes; // :int

    if (this.bitsAvailable > count) {
      this.word <<= count;
      this.bitsAvailable -= count;
    } else {
      count -= this.bitsAvailable;
      skipBytes = count >> 3;
      count -= skipBytes >> 3;
      this.bytesAvailable -= skipBytes;
      this.loadWord();
      this.word <<= count;
      this.bitsAvailable -= count;
    }
  } // (size:int):uint
  ;

  _proto.readBits = function readBits(size) {
    var bits = Math.min(this.bitsAvailable, size); // :uint

    var valu = this.word >>> 32 - bits; // :uint

    if (size > 32) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].error('Cannot read more than 32 bits at a time');
    }

    this.bitsAvailable -= bits;

    if (this.bitsAvailable > 0) {
      this.word <<= bits;
    } else if (this.bytesAvailable > 0) {
      this.loadWord();
    }

    bits = size - bits;

    if (bits > 0 && this.bitsAvailable) {
      return valu << bits | this.readBits(bits);
    } else {
      return valu;
    }
  } // ():uint
  ;

  _proto.skipLZ = function skipLZ() {
    var leadingZeroCount; // :uint

    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {
        // the first bit of working word is 1
        this.word <<= leadingZeroCount;
        this.bitsAvailable -= leadingZeroCount;
        return leadingZeroCount;
      }
    } // we exhausted word and still have not found a 1


    this.loadWord();
    return leadingZeroCount + this.skipLZ();
  } // ():void
  ;

  _proto.skipUEG = function skipUEG() {
    this.skipBits(1 + this.skipLZ());
  } // ():void
  ;

  _proto.skipEG = function skipEG() {
    this.skipBits(1 + this.skipLZ());
  } // ():uint
  ;

  _proto.readUEG = function readUEG() {
    var clz = this.skipLZ(); // :uint

    return this.readBits(clz + 1) - 1;
  } // ():int
  ;

  _proto.readEG = function readEG() {
    var valu = this.readUEG(); // :int

    if (0x01 & valu) {
      // the number is odd if the low order bit is set
      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
    } else {
      return -1 * (valu >>> 1); // divide by two then make it negative
    }
  } // Some convenience functions
  // :Boolean
  ;

  _proto.readBoolean = function readBoolean() {
    return this.readBits(1) === 1;
  } // ():int
  ;

  _proto.readUByte = function readUByte() {
    return this.readBits(8);
  } // ():int
  ;

  _proto.readUShort = function readUShort() {
    return this.readBits(16);
  } // ():int
  ;

  _proto.readUInt = function readUInt() {
    return this.readBits(32);
  }
  /**
   * Advance the ExpGolomb decoder past a scaling list. The scaling
   * list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count {number} the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  ;

  _proto.skipScalingList = function skipScalingList(count) {
    var lastScale = 8;
    var nextScale = 8;
    var deltaScale;

    for (var j = 0; j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = this.readEG();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }

      lastScale = nextScale === 0 ? lastScale : nextScale;
    }
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @param data {Uint8Array} the bytes of a sequence parameter set
   * @return {object} an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  ;

  _proto.readSPS = function readSPS() {
    var frameCropLeftOffset = 0;
    var frameCropRightOffset = 0;
    var frameCropTopOffset = 0;
    var frameCropBottomOffset = 0;
    var numRefFramesInPicOrderCntCycle;
    var scalingListCount;
    var i;
    var readUByte = this.readUByte.bind(this);
    var readBits = this.readBits.bind(this);
    var readUEG = this.readUEG.bind(this);
    var readBoolean = this.readBoolean.bind(this);
    var skipBits = this.skipBits.bind(this);
    var skipEG = this.skipEG.bind(this);
    var skipUEG = this.skipUEG.bind(this);
    var skipScalingList = this.skipScalingList.bind(this);
    readUByte();
    var profileIdc = readUByte(); // profile_idc

    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)

    skipBits(3); // reserved_zero_3bits u(3),

    readUByte(); // level_idc u(8)

    skipUEG(); // seq_parameter_set_id
    // some profiles have more optional data we don't need

    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
      var chromaFormatIdc = readUEG();

      if (chromaFormatIdc === 3) {
        skipBits(1);
      } // separate_colour_plane_flag


      skipUEG(); // bit_depth_luma_minus8

      skipUEG(); // bit_depth_chroma_minus8

      skipBits(1); // qpprime_y_zero_transform_bypass_flag

      if (readBoolean()) {
        // seq_scaling_matrix_present_flag
        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;

        for (i = 0; i < scalingListCount; i++) {
          if (readBoolean()) {
            // seq_scaling_list_present_flag[ i ]
            if (i < 6) {
              skipScalingList(16);
            } else {
              skipScalingList(64);
            }
          }
        }
      }
    }

    skipUEG(); // log2_max_frame_num_minus4

    var picOrderCntType = readUEG();

    if (picOrderCntType === 0) {
      readUEG(); // log2_max_pic_order_cnt_lsb_minus4
    } else if (picOrderCntType === 1) {
      skipBits(1); // delta_pic_order_always_zero_flag

      skipEG(); // offset_for_non_ref_pic

      skipEG(); // offset_for_top_to_bottom_field

      numRefFramesInPicOrderCntCycle = readUEG();

      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
        skipEG();
      } // offset_for_ref_frame[ i ]

    }

    skipUEG(); // max_num_ref_frames

    skipBits(1); // gaps_in_frame_num_value_allowed_flag

    var picWidthInMbsMinus1 = readUEG();
    var picHeightInMapUnitsMinus1 = readUEG();
    var frameMbsOnlyFlag = readBits(1);

    if (frameMbsOnlyFlag === 0) {
      skipBits(1);
    } // mb_adaptive_frame_field_flag


    skipBits(1); // direct_8x8_inference_flag

    if (readBoolean()) {
      // frame_cropping_flag
      frameCropLeftOffset = readUEG();
      frameCropRightOffset = readUEG();
      frameCropTopOffset = readUEG();
      frameCropBottomOffset = readUEG();
    }

    var pixelRatio = [1, 1];

    if (readBoolean()) {
      // vui_parameters_present_flag
      if (readBoolean()) {
        // aspect_ratio_info_present_flag
        var aspectRatioIdc = readUByte();

        switch (aspectRatioIdc) {
          case 1:
            pixelRatio = [1, 1];
            break;

          case 2:
            pixelRatio = [12, 11];
            break;

          case 3:
            pixelRatio = [10, 11];
            break;

          case 4:
            pixelRatio = [16, 11];
            break;

          case 5:
            pixelRatio = [40, 33];
            break;

          case 6:
            pixelRatio = [24, 11];
            break;

          case 7:
            pixelRatio = [20, 11];
            break;

          case 8:
            pixelRatio = [32, 11];
            break;

          case 9:
            pixelRatio = [80, 33];
            break;

          case 10:
            pixelRatio = [18, 11];
            break;

          case 11:
            pixelRatio = [15, 11];
            break;

          case 12:
            pixelRatio = [64, 33];
            break;

          case 13:
            pixelRatio = [160, 99];
            break;

          case 14:
            pixelRatio = [4, 3];
            break;

          case 15:
            pixelRatio = [3, 2];
            break;

          case 16:
            pixelRatio = [2, 1];
            break;

          case 255:
            {
              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
              break;
            }
        }
      }
    }

    return {
      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
      pixelRatio: pixelRatio
    };
  };

  _proto.readSliceType = function readSliceType() {
    // skip NALu type
    this.readUByte(); // discard first_mb_in_slice

    this.readUEG(); // return slice_type

    return this.readUEG();
  };

  return ExpGolomb;
}();

/* harmony default export */ __webpack_exports__["default"] = (ExpGolomb);

/***/ }),

/***/ "./src/demux/id3.ts":
/*!**************************!*\
  !*** ./src/demux/id3.ts ***!
  \**************************/
/*! exports provided: isHeader, isFooter, getID3Data, canParse, getTimeStamp, isTimeStampFrame, getID3Frames, decodeFrame, utf8ArrayToStr, testables */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHeader", function() { return isHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFooter", function() { return isFooter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getID3Data", function() { return getID3Data; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParse", function() { return canParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTimeStamp", function() { return getTimeStamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTimeStampFrame", function() { return isTimeStampFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getID3Frames", function() { return getID3Frames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeFrame", function() { return decodeFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utf8ArrayToStr", function() { return utf8ArrayToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "testables", function() { return testables; });
// breaking up those two types in order to clarify what is happening in the decoding path.

/**
 * Returns true if an ID3 header can be found at offset in data
 * @param {Uint8Array} data - The data to search in
 * @param {number} offset - The offset at which to start searching
 * @return {boolean} - True if an ID3 header is found
 */
var isHeader = function isHeader(data, offset) {
  /*
   * http://id3.org/id3v2.3.0
   * [0]     = 'I'
   * [1]     = 'D'
   * [2]     = '3'
   * [3,4]   = {Version}
   * [5]     = {Flags}
   * [6-9]   = {ID3 Size}
   *
   * An ID3v2 tag can be detected with the following pattern:
   *  $49 44 33 yy yy xx zz zz zz zz
   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
   */
  if (offset + 10 <= data.length) {
    // look for 'ID3' identifier
    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
      // check version is within range
      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
        // check size is within range
        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
          return true;
        }
      }
    }
  }

  return false;
};
/**
 * Returns true if an ID3 footer can be found at offset in data
 * @param {Uint8Array} data - The data to search in
 * @param {number} offset - The offset at which to start searching
 * @return {boolean} - True if an ID3 footer is found
 */

var isFooter = function isFooter(data, offset) {
  /*
   * The footer is a copy of the header, but with a different identifier
   */
  if (offset + 10 <= data.length) {
    // look for '3DI' identifier
    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
      // check version is within range
      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {
        // check size is within range
        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
          return true;
        }
      }
    }
  }

  return false;
};
/**
 * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
 * @param {Uint8Array} data - The data to search in
 * @param {number} offset - The offset at which to start searching
 * @return {Uint8Array | undefined} - The block of data containing any ID3 tags found
 * or *undefined* if no header is found at the starting offset
 */

var getID3Data = function getID3Data(data, offset) {
  var front = offset;
  var length = 0;

  while (isHeader(data, offset)) {
    // ID3 header is 10 bytes
    length += 10;
    var size = readSize(data, offset + 6);
    length += size;

    if (isFooter(data, offset + 10)) {
      // ID3 footer is 10 bytes
      length += 10;
    }

    offset += length;
  }

  if (length > 0) {
    return data.subarray(front, front + length);
  }

  return undefined;
};

var readSize = function readSize(data, offset) {
  var size = 0;
  size = (data[offset] & 0x7f) << 21;
  size |= (data[offset + 1] & 0x7f) << 14;
  size |= (data[offset + 2] & 0x7f) << 7;
  size |= data[offset + 3] & 0x7f;
  return size;
};

var canParse = function canParse(data, offset) {
  return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
};
/**
 * Searches for the Elementary Stream timestamp found in the ID3 data chunk
 * @param {Uint8Array} data - Block of data containing one or more ID3 tags
 * @return {number | undefined} - The timestamp
 */

var getTimeStamp = function getTimeStamp(data) {
  var frames = getID3Frames(data);

  for (var i = 0; i < frames.length; i++) {
    var frame = frames[i];

    if (isTimeStampFrame(frame)) {
      return readTimeStamp(frame);
    }
  }

  return undefined;
};
/**
 * Returns true if the ID3 frame is an Elementary Stream timestamp frame
 * @param {ID3 frame} frame
 */

var isTimeStampFrame = function isTimeStampFrame(frame) {
  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
};

var getFrameData = function getFrameData(data) {
  /*
  Frame ID       $xx xx xx xx (four characters)
  Size           $xx xx xx xx
  Flags          $xx xx
  */
  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
  var size = readSize(data, 4); // skip frame id, size, and flags

  var offset = 10;
  return {
    type: type,
    size: size,
    data: data.subarray(offset, offset + size)
  };
};
/**
 * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
 * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
 * @return {ID3.Frame[]} - Array of ID3 frame objects
 */


var getID3Frames = function getID3Frames(id3Data) {
  var offset = 0;
  var frames = [];

  while (isHeader(id3Data, offset)) {
    var size = readSize(id3Data, offset + 6); // skip past ID3 header

    offset += 10;
    var end = offset + size; // loop through frames in the ID3 tag

    while (offset + 8 < end) {
      var frameData = getFrameData(id3Data.subarray(offset));
      var frame = decodeFrame(frameData);

      if (frame) {
        frames.push(frame);
      } // skip frame header and frame data


      offset += frameData.size + 10;
    }

    if (isFooter(id3Data, offset)) {
      offset += 10;
    }
  }

  return frames;
};
var decodeFrame = function decodeFrame(frame) {
  if (frame.type === 'PRIV') {
    return decodePrivFrame(frame);
  } else if (frame.type[0] === 'W') {
    return decodeURLFrame(frame);
  }

  return decodeTextFrame(frame);
};

var decodePrivFrame = function decodePrivFrame(frame) {
  /*
  Format: <text string>\0<binary data>
  */
  if (frame.size < 2) {
    return undefined;
  }

  var owner = utf8ArrayToStr(frame.data, true);
  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
  return {
    key: frame.type,
    info: owner,
    data: privateData.buffer
  };
};

var decodeTextFrame = function decodeTextFrame(frame) {
  if (frame.size < 2) {
    return undefined;
  }

  if (frame.type === 'TXXX') {
    /*
    Format:
    [0]   = {Text Encoding}
    [1-?] = {Description}\0{Value}
    */
    var index = 1;
    var description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    var value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  /*
  Format:
  [0]   = {Text Encoding}
  [1-?] = {Value}
  */


  var text = utf8ArrayToStr(frame.data.subarray(1));
  return {
    key: frame.type,
    data: text
  };
};

var decodeURLFrame = function decodeURLFrame(frame) {
  if (frame.type === 'WXXX') {
    /*
    Format:
    [0]   = {Text Encoding}
    [1-?] = {Description}\0{URL}
    */
    if (frame.size < 2) {
      return undefined;
    }

    var index = 1;
    var description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    var value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  /*
  Format:
  [0-?] = {URL}
  */


  var url = utf8ArrayToStr(frame.data);
  return {
    key: frame.type,
    data: url
  };
};

var readTimeStamp = function readTimeStamp(timeStampFrame) {
  if (timeStampFrame.data.byteLength === 8) {
    var data = new Uint8Array(timeStampFrame.data); // timestamp is 33 bit expressed as a big-endian eight-octet number,
    // with the upper 31 bits set to zero.

    var pts33Bit = data[3] & 0x1;
    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
    timestamp /= 45;

    if (pts33Bit) {
      timestamp += 47721858.84;
    } // 2^32 / 90


    return Math.round(timestamp);
  }

  return undefined;
}; // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt

/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */


var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {
  if (exitOnNull === void 0) {
    exitOnNull = false;
  }

  var decoder = getTextDecoder();

  if (decoder) {
    var decoded = decoder.decode(array);

    if (exitOnNull) {
      // grab up to the first null
      var idx = decoded.indexOf('\0');
      return idx !== -1 ? decoded.substring(0, idx) : decoded;
    } // remove any null characters


    return decoded.replace(/\0/g, '');
  }

  var len = array.length;
  var c;
  var char2;
  var char3;
  var out = '';
  var i = 0;

  while (i < len) {
    c = array[i++];

    if (c === 0x00 && exitOnNull) {
      return out;
    } else if (c === 0x00 || c === 0x03) {
      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
      continue;
    }

    switch (c >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;

      case 12:
      case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[i++];
        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);
        break;

      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);
        break;

      default:
    }
  }

  return out;
};
var testables = {
  decodeTextFrame: decodeTextFrame
};
var decoder;

function getTextDecoder() {
  if (!decoder && typeof self.TextDecoder !== 'undefined') {
    decoder = new self.TextDecoder('utf-8');
  }

  return decoder;
}

/***/ }),

/***/ "./src/demux/mp3demuxer.ts":
/*!*********************************!*\
  !*** ./src/demux/mp3demuxer.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base-audio-demuxer */ "./src/demux/base-audio-demuxer.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.ts");
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * MP3 demuxer
 */





var MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {
  _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);

  function MP3Demuxer() {
    return _BaseAudioDemuxer.apply(this, arguments) || this;
  }

  var _proto = MP3Demuxer.prototype;

  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {
    _BaseAudioDemuxer.prototype.resetInitSegment.call(this, audioCodec, videoCodec, duration);

    this._audioTrack = {
      container: 'audio/mpeg',
      type: 'audio',
      id: 0,
      pid: -1,
      sequenceNumber: 0,
      isAAC: false,
      samples: [],
      manifestCodec: audioCodec,
      duration: duration,
      inputTimeScale: 90000,
      dropped: 0
    };
  };

  MP3Demuxer.probe = function probe(data) {
    if (!data) {
      return false;
    } // check if data contains ID3 timestamp and MPEG sync word
    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
    // More info http://www.mp3-tech.org/programmer/frame_header.html


    var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, 0) || [];
    var offset = id3Data.length;

    for (var length = data.length; offset < length; offset++) {
      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__["probe"](data, offset)) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('MPEG Audio sync word found !');
        return true;
      }
    }

    return false;
  };

  _proto.canParse = function canParse(data, offset) {
    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__["canParse"](data, offset);
  };

  _proto.appendFrame = function appendFrame(track, data, offset) {
    if (this.initPTS === null) {
      return;
    }

    return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__["appendFrame"](track, data, offset, this.initPTS, this.frameIndex);
  };

  return MP3Demuxer;
}(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);

MP3Demuxer.minProbeByteLength = 4;
/* harmony default export */ __webpack_exports__["default"] = (MP3Demuxer);

/***/ }),

/***/ "./src/demux/mp4demuxer.ts":
/*!*********************************!*\
  !*** ./src/demux/mp4demuxer.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dummy-demuxed-track */ "./src/demux/dummy-demuxed-track.ts");
/**
 * MP4 demuxer
 */



var MP4Demuxer = /*#__PURE__*/function () {
  function MP4Demuxer(observer, config) {
    this.remainderData = null;
    this.config = void 0;
    this.config = config;
  }

  var _proto = MP4Demuxer.prototype;

  _proto.resetTimeStamp = function resetTimeStamp() {};

  _proto.resetInitSegment = function resetInitSegment() {};

  _proto.resetContiguity = function resetContiguity() {};

  MP4Demuxer.probe = function probe(data) {
    // ensure we find a moof box in the first 16 kB
    return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__["findBox"])({
      data: data,
      start: 0,
      end: Math.min(data.length, 16384)
    }, ['moof']).length > 0;
  };

  _proto.demux = function demux(data) {
    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter
    var avcSamples = data;
    var avcTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])();

    if (this.config.progressive) {
      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.
      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee
      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.
      if (this.remainderData) {
        avcSamples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__["appendUint8Array"])(this.remainderData, data);
      }

      var segmentedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_0__["segmentValidRange"])(avcSamples);
      this.remainderData = segmentedData.remainder;
      avcTrack.samples = segmentedData.valid || new Uint8Array();
    } else {
      avcTrack.samples = avcSamples;
    }

    return {
      audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])(),
      avcTrack: avcTrack,
      id3Track: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])(),
      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])()
    };
  };

  _proto.flush = function flush() {
    var avcTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])();
    avcTrack.samples = this.remainderData || new Uint8Array();
    this.remainderData = null;
    return {
      audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])(),
      avcTrack: avcTrack,
      id3Track: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])(),
      textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_1__["dummyTrack"])()
    };
  };

  _proto.demuxSampleAes = function demuxSampleAes(data, decryptData, timeOffset) {
    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));
  };

  _proto.destroy = function destroy() {};

  return MP4Demuxer;
}();

MP4Demuxer.minProbeByteLength = 1024;
/* harmony default export */ __webpack_exports__["default"] = (MP4Demuxer);

/***/ }),

/***/ "./src/demux/mpegaudio.ts":
/*!********************************!*\
  !*** ./src/demux/mpegaudio.ts ***!
  \********************************/
/*! exports provided: appendFrame, parseHeader, isHeaderPattern, isHeader, canParse, probe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendFrame", function() { return appendFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseHeader", function() { return parseHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHeaderPattern", function() { return isHeaderPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHeader", function() { return isHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParse", function() { return canParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "probe", function() { return probe; });
/**
 *  MPEG parser helper
 */
var chromeVersion = null;
var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];
var SamplesCoefficients = [// MPEG 2.5
[0, // Reserved
72, // Layer3
144, // Layer2
12 // Layer1
], // Reserved
[0, // Reserved
0, // Layer3
0, // Layer2
0 // Layer1
], // MPEG 2
[0, // Reserved
72, // Layer3
144, // Layer2
12 // Layer1
], // MPEG 1
[0, // Reserved
144, // Layer3
144, // Layer2
12 // Layer1
]];
var BytesInSlot = [0, // Reserved
1, // Layer3
1, // Layer2
4 // Layer1
];
function appendFrame(track, data, offset, pts, frameIndex) {
  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
  if (offset + 24 > data.length) {
    return;
  }

  var header = parseHeader(data, offset);

  if (header && offset + header.frameLength <= data.length) {
    var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
    var stamp = pts + frameIndex * frameDuration;
    var sample = {
      unit: data.subarray(offset, offset + header.frameLength),
      pts: stamp,
      dts: stamp
    };
    track.config = [];
    track.channelCount = header.channelCount;
    track.samplerate = header.sampleRate;
    track.samples.push(sample);
    return {
      sample: sample,
      length: header.frameLength
    };
  }
}
function parseHeader(data, offset) {
  var mpegVersion = data[offset + 1] >> 3 & 3;
  var mpegLayer = data[offset + 1] >> 1 & 3;
  var bitRateIndex = data[offset + 2] >> 4 & 15;
  var sampleRateIndex = data[offset + 2] >> 2 & 3;

  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
    var paddingBit = data[offset + 2] >> 1 & 1;
    var channelMode = data[offset + 3] >> 6;
    var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
    var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;
    var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
    var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
    var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)

    var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
    var bytesInSlot = BytesInSlot[mpegLayer];
    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
    var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;

    if (chromeVersion === null) {
      var userAgent = navigator.userAgent || '';
      var result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion = result ? parseInt(result[1]) : 0;
    }

    var needChromeFix = !!chromeVersion && chromeVersion <= 87;

    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {
      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)
      data[offset + 3] = data[offset + 3] | 0x80;
    }

    return {
      sampleRate: sampleRate,
      channelCount: channelCount,
      frameLength: frameLength,
      samplesPerFrame: samplesPerFrame
    };
  }
}
function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
}
function isHeader(data, offset) {
  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
  // More info http://www.mp3-tech.org/programmer/frame_header.html
  return offset + 1 < data.length && isHeaderPattern(data, offset);
}
function canParse(data, offset) {
  var headerSize = 4;
  return isHeaderPattern(data, offset) && data.length - offset >= headerSize;
}
function probe(data, offset) {
  // same as isHeader but we also check that MPEG frame follows last MPEG frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // MPEG header Length
    var headerLength = 4; // MPEG frame Length

    var header = parseHeader(data, offset);
    var frameLength = headerLength;

    if (header !== null && header !== void 0 && header.frameLength) {
      frameLength = header.frameLength;
    }

    var newOffset = offset + frameLength;
    return newOffset === data.length || isHeader(data, newOffset);
  }

  return false;
}

/***/ }),

/***/ "./src/demux/sample-aes.js":
/*!*********************************!*\
  !*** ./src/demux/sample-aes.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.ts");
/**
 * SAMPLE-AES decrypter
 */


var SampleAesDecrypter = /*#__PURE__*/function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__["default"](observer, config, {
      removePKCS7Padding: false
    });
  }

  var _proto = SampleAesDecrypter.prototype;

  _proto.decryptBuffer = function decryptBuffer(encryptedData, callback) {
    this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
  } // AAC - encrypt all full 16 bytes blocks starting from offset 16
  ;

  _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {
    var curUnit = samples[sampleIndex].unit;
    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
    var localthis = this;
    this.decryptBuffer(encryptedBuffer, function (decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      curUnit.set(decryptedData, 16);

      if (!sync) {
        localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
      }
    });
  };

  _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
    for (;; sampleIndex++) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      if (samples[sampleIndex].unit.length < 32) {
        continue;
      }

      var sync = this.decrypter.isSync();
      this.decryptAacSample(samples, sampleIndex, callback, sync);

      if (!sync) {
        return;
      }
    }
  } // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  ;

  _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
    var encryptedData = new Int8Array(encryptedDataLen);
    var outputPos = 0;

    for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
    }

    return encryptedData;
  };

  _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
    decryptedData = new Uint8Array(decryptedData);
    var inputPos = 0;

    for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
      decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
    }

    return decodedData;
  };

  _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
    var decodedData = this.discardEPB(curUnit.data);
    var encryptedData = this.getAvcEncryptedData(decodedData);
    var localthis = this;
    this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

      if (!sync) {
        localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
      }
    });
  };

  _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
    for (;; sampleIndex++, unitIndex = 0) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      var curUnits = samples[sampleIndex].units;

      for (;; unitIndex++) {
        if (unitIndex >= curUnits.length) {
          break;
        }

        var curUnit = curUnits[unitIndex];

        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
          continue;
        }

        var sync = this.decrypter.isSync();
        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

        if (!sync) {
          return;
        }
      }
    }
  };

  return SampleAesDecrypter;
}();

/* harmony default export */ __webpack_exports__["default"] = (SampleAesDecrypter);

/***/ }),

/***/ "./src/demux/transmuxer-interface.ts":
/*!*******************************************!*\
  !*** ./src/demux/transmuxer-interface.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransmuxerInterface; });
/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webworkify-webpack */ "./node_modules/webworkify-webpack/index.js");
/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../demux/transmuxer */ "./src/demux/transmuxer.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/mediasource-helper */ "./src/utils/mediasource-helper.ts");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);







var MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__["getMediaSource"])() || {
  isTypeSupported: function isTypeSupported() {
    return false;
  }
};

var TransmuxerInterface = /*#__PURE__*/function () {
  function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {
    var _this = this;

    this.hls = void 0;
    this.id = void 0;
    this.observer = void 0;
    this.frag = null;
    this.part = null;
    this.worker = void 0;
    this.onwmsg = void 0;
    this.transmuxer = null;
    this.onTransmuxComplete = void 0;
    this.onFlush = void 0;
    this.hls = hls;
    this.id = id;
    this.onTransmuxComplete = onTransmuxComplete;
    this.onFlush = onFlush;
    var config = hls.config;

    var forwardMessage = function forwardMessage(ev, data) {
      data = data || {};
      data.frag = _this.frag;
      data.id = _this.id;
      hls.trigger(ev, data);
    }; // forward events to main thread


    this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__["EventEmitter"]();
    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, forwardMessage);
    this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, forwardMessage);
    var typeSupported = {
      mp4: MediaSource.isTypeSupported('video/mp4'),
      mpeg: MediaSource.isTypeSupported('audio/mpeg'),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    }; // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator

    var vendor = navigator.vendor;

    if (config.enableWorker && typeof Worker !== 'undefined') {
      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log('demuxing in webworker');
      var worker;

      try {
        worker = this.worker = webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__(/*require.resolve*/(/*! ../demux/transmuxer-worker.ts */ "./src/demux/transmuxer-worker.ts"));
        this.onwmsg = this.onWorkerMessage.bind(this);
        worker.addEventListener('message', this.onwmsg);

        worker.onerror = function (event) {
          hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
            type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].OTHER_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].INTERNAL_EXCEPTION,
            fatal: true,
            event: 'demuxerWorker',
            err: {
              message: event.message + ' (' + event.filename + ':' + event.lineno + ')'
            }
          });
        };

        worker.postMessage({
          cmd: 'init',
          typeSupported: typeSupported,
          vendor: vendor,
          id: id,
          config: JSON.stringify(config)
        });
      } catch (err) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn('Error in worker:', err);
        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].error('Error while initializing DemuxerWorker, fallback to inline');

        if (worker) {
          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it
          self.URL.revokeObjectURL(worker.objectURL);
        }

        this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor);
        this.worker = null;
      }
    } else {
      this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor);
    }
  }

  var _proto = TransmuxerInterface.prototype;

  _proto.destroy = function destroy() {
    var w = this.worker;

    if (w) {
      w.removeEventListener('message', this.onwmsg);
      w.terminate();
      this.worker = null;
    } else {
      var transmuxer = this.transmuxer;

      if (transmuxer) {
        transmuxer.destroy();
        this.transmuxer = null;
      }
    }

    var observer = this.observer;

    if (observer) {
      observer.removeAllListeners();
    } // @ts-ignore


    this.observer = null;
  };

  _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
    var _this2 = this;

    chunkMeta.transmuxing.start = self.performance.now();
    var transmuxer = this.transmuxer,
        worker = this.worker;
    var timeOffset = part ? part.start : frag.start;
    var decryptdata = frag.decryptdata;
    var lastFrag = this.frag;
    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
    var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
    var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
    var partDiff = this.part ? chunkMeta.part - this.part.index : 1;
    var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && partDiff === 1);
    var now = self.performance.now();

    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
      frag.stats.parsing.start = now;
    }

    if (part && (partDiff || !contiguous)) {
      part.stats.parsing.start = now;
    }

    var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["TransmuxState"](discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset);

    if (!contiguous || discontinuity) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[transmuxer-interface, " + frag.type + "]: Starting new transmux session for sn: " + chunkMeta.sn + " p: " + chunkMeta.part + " level: " + chunkMeta.level + " id: " + chunkMeta.id + "\n        discontinuity: " + discontinuity + "\n        trackSwitch: " + trackSwitch + "\n        contiguous: " + contiguous + "\n        accurateTimeOffset: " + accurateTimeOffset + "\n        timeOffset: " + timeOffset);
      var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["TransmuxConfig"](audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
      this.configureTransmuxer(config);
    }

    this.frag = frag;
    this.part = part; // Frags with sn of 'initSegment' are not transmuxed

    if (worker) {
      // post fragment payload as transferable objects for ArrayBuffer (no copy)
      worker.postMessage({
        cmd: 'demux',
        data: data,
        decryptdata: decryptdata,
        chunkMeta: chunkMeta,
        state: state
      }, data instanceof ArrayBuffer ? [data] : []);
    } else if (transmuxer) {
      var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);

      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["isPromise"])(_transmuxResult)) {
        _transmuxResult.then(function (data) {
          _this2.handleTransmuxComplete(data);
        });
      } else {
        this.handleTransmuxComplete(_transmuxResult);
      }
    }
  };

  _proto.flush = function flush(chunkMeta) {
    var _this3 = this;

    chunkMeta.transmuxing.start = self.performance.now();
    var transmuxer = this.transmuxer,
        worker = this.worker;

    if (worker) {
      worker.postMessage({
        cmd: 'flush',
        chunkMeta: chunkMeta
      });
    } else if (transmuxer) {
      var _transmuxResult2 = transmuxer.flush(chunkMeta);

      if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["isPromise"])(_transmuxResult2)) {
        _transmuxResult2.then(function (data) {
          _this3.handleFlushResult(data, chunkMeta);
        });
      } else {
        this.handleFlushResult(_transmuxResult2, chunkMeta);
      }
    }
  };

  _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {
    var _this4 = this;

    results.forEach(function (result) {
      _this4.handleTransmuxComplete(result);
    });
    this.onFlush(chunkMeta);
  };

  _proto.onWorkerMessage = function onWorkerMessage(ev) {
    var data = ev.data;
    var hls = this.hls;

    switch (data.event) {
      case 'init':
        {
          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it
          self.URL.revokeObjectURL(this.worker.objectURL);
          break;
        }

      case 'transmuxComplete':
        {
          this.handleTransmuxComplete(data.data);
          break;
        }

      case 'flush':
        {
          this.onFlush(data.data);
          break;
        }

      /* falls through */

      default:
        {
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
        }
    }
  };

  _proto.configureTransmuxer = function configureTransmuxer(config) {
    var worker = this.worker,
        transmuxer = this.transmuxer;

    if (worker) {
      worker.postMessage({
        cmd: 'configure',
        config: config
      });
    } else if (transmuxer) {
      transmuxer.configure(config);
    }
  };

  _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
    result.chunkMeta.transmuxing.end = self.performance.now();
    this.onTransmuxComplete(result);
  };

  return TransmuxerInterface;
}();



/***/ }),

/***/ "./src/demux/transmuxer-worker.ts":
/*!****************************************!*\
  !*** ./src/demux/transmuxer-worker.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransmuxerWorker; });
/* harmony import */ var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../demux/transmuxer */ "./src/demux/transmuxer.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);




function TransmuxerWorker(self) {
  var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({
      event: ev,
      data: data
    });
  }; // forward events to main thread


  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, forwardMessage);
  observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, forwardMessage);
  self.addEventListener('message', function (ev) {
    var data = ev.data;

    switch (data.cmd) {
      case 'init':
        {
          var config = JSON.parse(data.config);
          self.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["default"](observer, data.typeSupported, config, data.vendor);
          Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__["enableLogs"])(config.debug);
          forwardMessage('init', null);
          break;
        }

      case 'configure':
        {
          self.transmuxer.configure(data.config);
          break;
        }

      case 'demux':
        {
          var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);

          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(transmuxResult)) {
            transmuxResult.then(function (data) {
              emitTransmuxComplete(self, data);
            });
          } else {
            emitTransmuxComplete(self, transmuxResult);
          }

          break;
        }

      case 'flush':
        {
          var id = data.chunkMeta;

          var _transmuxResult = self.transmuxer.flush(id);

          if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(_transmuxResult)) {
            _transmuxResult.then(function (results) {
              handleFlushResult(self, results, id);
            });
          } else {
            handleFlushResult(self, _transmuxResult, id);
          }

          break;
        }

      default:
        break;
    }
  });
}

function emitTransmuxComplete(self, transmuxResult) {
  if (isEmptyResult(transmuxResult.remuxResult)) {
    return;
  }

  var transferable = [];
  var _transmuxResult$remux = transmuxResult.remuxResult,
      audio = _transmuxResult$remux.audio,
      video = _transmuxResult$remux.video;

  if (audio) {
    addToTransferable(transferable, audio);
  }

  if (video) {
    addToTransferable(transferable, video);
  }

  self.postMessage({
    event: 'transmuxComplete',
    data: transmuxResult
  }, transferable);
} // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)
// in order to minimize message passing overhead


function addToTransferable(transferable, track) {
  if (track.data1) {
    transferable.push(track.data1.buffer);
  }

  if (track.data2) {
    transferable.push(track.data2.buffer);
  }
}

function handleFlushResult(self, results, chunkMeta) {
  results.forEach(function (result) {
    emitTransmuxComplete(self, result);
  });
  self.postMessage({
    event: 'flush',
    data: chunkMeta
  });
}

function isEmptyResult(remuxResult) {
  return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
}

/***/ }),

/***/ "./src/demux/transmuxer.ts":
/*!*********************************!*\
  !*** ./src/demux/transmuxer.ts ***!
  \*********************************/
/*! exports provided: default, isPromise, TransmuxConfig, TransmuxState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Transmuxer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransmuxConfig", function() { return TransmuxConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransmuxState", function() { return TransmuxState; });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypt/decrypter */ "./src/crypt/decrypter.ts");
/* harmony import */ var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../demux/aacdemuxer */ "./src/demux/aacdemuxer.ts");
/* harmony import */ var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../demux/mp4demuxer */ "./src/demux/mp4demuxer.ts");
/* harmony import */ var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../demux/tsdemuxer */ "./src/demux/tsdemuxer.ts");
/* harmony import */ var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../demux/mp3demuxer */ "./src/demux/mp3demuxer.ts");
/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/remux/mp4-remuxer.ts");
/* harmony import */ var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../remux/passthrough-remuxer */ "./src/remux/passthrough-remuxer.ts");
/* harmony import */ var _chunk_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./chunk-cache */ "./src/demux/chunk-cache.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");












var now; // performance.now() not available on WebWorker, at least on Safari Desktop

try {
  now = self.performance.now.bind(self.performance);
} catch (err) {
  _utils_logger__WEBPACK_IMPORTED_MODULE_11__["logger"].debug('Unable to use Performance API on this environment');
  now = self.Date.now;
}

var muxConfig = [{
  demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__["default"],
  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
}, {
  demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__["default"],
  remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__["default"]
}, {
  demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__["default"],
  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
}, {
  demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__["default"],
  remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"]
}];
var minProbeByteLength = 1024;
muxConfig.forEach(function (_ref) {
  var demux = _ref.demux;
  minProbeByteLength = Math.max(minProbeByteLength, demux.minProbeByteLength);
});

var Transmuxer = /*#__PURE__*/function () {
  function Transmuxer(observer, typeSupported, config, vendor) {
    this.observer = void 0;
    this.typeSupported = void 0;
    this.config = void 0;
    this.vendor = void 0;
    this.demuxer = void 0;
    this.remuxer = void 0;
    this.decrypter = void 0;
    this.probe = void 0;
    this.decryptionPromise = null;
    this.transmuxConfig = void 0;
    this.currentTransmuxState = void 0;
    this.cache = new _chunk_cache__WEBPACK_IMPORTED_MODULE_9__["default"]();
    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  var _proto = Transmuxer.prototype;

  _proto.configure = function configure(transmuxConfig) {
    this.transmuxConfig = transmuxConfig;

    if (this.decrypter) {
      this.decrypter.reset();
    }
  };

  _proto.push = function push(data, decryptdata, chunkMeta, state) {
    var _this = this;

    var stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    var uintData = new Uint8Array(data);
    var cache = this.cache,
        config = this.config,
        currentTransmuxState = this.currentTransmuxState,
        transmuxConfig = this.transmuxConfig;

    if (state) {
      this.currentTransmuxState = state;
    }

    var encryptionType = getEncryptionType(uintData, decryptdata);

    if (encryptionType === 'AES-128') {
      var decrypter = this.getDecrypter(); // Software decryption is synchronous; webCrypto is not

      if (config.enableSoftwareAES) {
        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
        // data is handled in the flush() call
        var decryptedData = decrypter.softwareDecrypt(uintData, decryptdata.key.buffer, decryptdata.iv.buffer);

        if (!decryptedData) {
          stats.executeEnd = now();
          return emptyResult(chunkMeta);
        }

        uintData = new Uint8Array(decryptedData);
      } else {
        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, decryptdata.key.buffer, decryptdata.iv.buffer).then(function (decryptedData) {
          // Calling push here is important; if flush() is called while this is still resolving, this ensures that
          // the decrypted data has been transmuxed
          var result = _this.push(decryptedData, null, chunkMeta);

          _this.decryptionPromise = null;
          return result;
        });
        return this.decryptionPromise;
      }
    }

    var _ref2 = state || currentTransmuxState,
        contiguous = _ref2.contiguous,
        discontinuity = _ref2.discontinuity,
        trackSwitch = _ref2.trackSwitch,
        accurateTimeOffset = _ref2.accurateTimeOffset,
        timeOffset = _ref2.timeOffset;

    var audioCodec = transmuxConfig.audioCodec,
        videoCodec = transmuxConfig.videoCodec,
        defaultInitPts = transmuxConfig.defaultInitPts,
        duration = transmuxConfig.duration,
        initSegmentData = transmuxConfig.initSegmentData; // Reset muxers before probing to ensure that their state is clean, even if flushing occurs before a successful probe

    if (discontinuity || trackSwitch) {
      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);
    }

    if (discontinuity) {
      this.resetInitialTimestamp(defaultInitPts);
    }

    if (!contiguous) {
      this.resetContiguity();
    }

    var demuxer = this.demuxer,
        remuxer = this.remuxer;

    if (this.needsProbing(uintData, discontinuity, trackSwitch)) {
      if (cache.dataLength) {
        var cachedData = cache.flush();
        uintData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_10__["appendUint8Array"])(cachedData, uintData);
      }

      var _this$configureTransm = this.configureTransmuxer(uintData, transmuxConfig);

      demuxer = _this$configureTransm.demuxer;
      remuxer = _this$configureTransm.remuxer;
    }

    if (!demuxer || !remuxer) {
      cache.push(uintData);
      stats.executeEnd = now();
      return emptyResult(chunkMeta);
    }

    var result = this.transmux(uintData, decryptdata, encryptionType, timeOffset, accurateTimeOffset, chunkMeta);
    var currentState = this.currentTransmuxState;
    currentState.contiguous = true;
    currentState.discontinuity = false;
    currentState.trackSwitch = false;
    stats.executeEnd = now();
    return result;
  } // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  ;

  _proto.flush = function flush(chunkMeta) {
    var _this2 = this;

    var stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    var decrypter = this.decrypter,
        cache = this.cache,
        currentTransmuxState = this.currentTransmuxState,
        decryptionPromise = this.decryptionPromise,
        observer = this.observer;
    var transmuxResults = [];

    if (decryptionPromise) {
      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore
      // only flushing is required for async decryption
      return decryptionPromise.then(function () {
        return _this2.flush(chunkMeta);
      });
    }

    var accurateTimeOffset = currentTransmuxState.accurateTimeOffset,
        timeOffset = currentTransmuxState.timeOffset;

    if (decrypter) {
      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults
      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,
      // or for progressive downloads with small segments)
      var decryptedData = decrypter.flush();

      if (decryptedData) {
        // Push always returns a TransmuxerResult if decryptdata is null
        transmuxResults.push(this.push(decryptedData, null, chunkMeta));
      }
    }

    var bytesSeen = cache.dataLength;
    cache.reset();
    var demuxer = this.demuxer,
        remuxer = this.remuxer;

    if (!demuxer || !remuxer) {
      // If probing failed, and each demuxer saw enough bytes to be able to probe, then Hls.js has been given content its not able to handle
      if (bytesSeen >= minProbeByteLength) {
        observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
          type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
          details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_PARSING_ERROR,
          fatal: true,
          reason: 'no demux matching with content found'
        });
      }

      stats.executeEnd = now();
      return [emptyResult(chunkMeta)];
    }

    var _demuxer$flush = demuxer.flush(timeOffset),
        audioTrack = _demuxer$flush.audioTrack,
        avcTrack = _demuxer$flush.avcTrack,
        id3Track = _demuxer$flush.id3Track,
        textTrack = _demuxer$flush.textTrack;

    _utils_logger__WEBPACK_IMPORTED_MODULE_11__["logger"].log("[transmuxer.ts]: Flushed fragment " + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + " of level " + chunkMeta.level);
    var remuxResult = remuxer.remux(audioTrack, avcTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true);
    transmuxResults.push({
      remuxResult: remuxResult,
      chunkMeta: chunkMeta
    });
    stats.executeEnd = now();
    return transmuxResults;
  };

  _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
    var demuxer = this.demuxer,
        remuxer = this.remuxer;

    if (!demuxer || !remuxer) {
      return;
    }

    demuxer.resetTimeStamp(defaultInitPts);
    remuxer.resetTimeStamp(defaultInitPts);
  };

  _proto.resetContiguity = function resetContiguity() {
    var demuxer = this.demuxer,
        remuxer = this.remuxer;

    if (!demuxer || !remuxer) {
      return;
    }

    demuxer.resetContiguity();
    remuxer.resetNextTimestamp();
  };

  _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, duration) {
    var demuxer = this.demuxer,
        remuxer = this.remuxer;

    if (!demuxer || !remuxer) {
      return;
    }

    demuxer.resetInitSegment(audioCodec, videoCodec, duration);
    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec);
  };

  _proto.destroy = function destroy() {
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = undefined;
    }

    if (this.remuxer) {
      this.remuxer.destroy();
      this.remuxer = undefined;
    }
  };

  _proto.transmux = function transmux(data, decryptData, encryptionType, timeOffset, accurateTimeOffset, chunkMeta) {
    var result;

    if (encryptionType === 'SAMPLE-AES') {
      result = this.transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta);
    } else {
      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
    }

    return result;
  };

  _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
    var _demux = this.demuxer.demux(data, timeOffset, false),
        audioTrack = _demux.audioTrack,
        avcTrack = _demux.avcTrack,
        id3Track = _demux.id3Track,
        textTrack = _demux.textTrack;

    var remuxResult = this.remuxer.remux(audioTrack, avcTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false);
    return {
      remuxResult: remuxResult,
      chunkMeta: chunkMeta
    };
  } // TODO: Handle flush with Sample-AES
  ;

  _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
    var _this3 = this;

    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {
      return {
        remuxResult: _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.avcTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false),
        chunkMeta: chunkMeta
      };
    });
  };

  _proto.configureTransmuxer = function configureTransmuxer(data, transmuxConfig) {
    var config = this.config,
        observer = this.observer,
        typeSupported = this.typeSupported,
        vendor = this.vendor;
    var audioCodec = transmuxConfig.audioCodec,
        defaultInitPts = transmuxConfig.defaultInitPts,
        duration = transmuxConfig.duration,
        initSegmentData = transmuxConfig.initSegmentData,
        videoCodec = transmuxConfig.videoCodec; // probe for content type

    var mux;

    for (var i = 0, len = muxConfig.length; i < len; i++) {
      mux = muxConfig[i];

      if (mux.demux.probe(data)) {
        break;
      }
    }

    if (!mux) {
      return {
        remuxer: undefined,
        demuxer: undefined
      };
    } // so let's check that current remuxer and demuxer are still valid


    var demuxer = this.demuxer;
    var remuxer = this.remuxer;
    var Remuxer = mux.remux;
    var Demuxer = mux.demux;

    if (!remuxer || !(remuxer instanceof Remuxer)) {
      remuxer = this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
    }

    if (!demuxer || !(demuxer instanceof Demuxer)) {
      demuxer = this.demuxer = new Demuxer(observer, config, typeSupported);
      this.probe = Demuxer.probe;
    } // Ensure that muxers are always initialized with an initSegment


    this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);
    this.resetInitialTimestamp(defaultInitPts);
    return {
      demuxer: demuxer,
      remuxer: remuxer
    };
  };

  _proto.needsProbing = function needsProbing(data, discontinuity, trackSwitch) {
    // in case of continuity change, or track switch
    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
    return !this.demuxer || discontinuity || trackSwitch;
  };

  _proto.getDecrypter = function getDecrypter() {
    var decrypter = this.decrypter;

    if (!decrypter) {
      decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, this.config);
    }

    return decrypter;
  };

  return Transmuxer;
}();



function getEncryptionType(data, decryptData) {
  var encryptionType = null;

  if (data.byteLength > 0 && decryptData != null && decryptData.key != null) {
    encryptionType = decryptData.method;
  }

  return encryptionType;
}

var emptyResult = function emptyResult(chunkMeta) {
  return {
    remuxResult: {},
    chunkMeta: chunkMeta
  };
};

function isPromise(p) {
  return 'then' in p && p.then instanceof Function;
}
var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
  this.audioCodec = void 0;
  this.videoCodec = void 0;
  this.initSegmentData = void 0;
  this.duration = void 0;
  this.defaultInitPts = void 0;
  this.audioCodec = audioCodec;
  this.videoCodec = videoCodec;
  this.initSegmentData = initSegmentData;
  this.duration = duration;
  this.defaultInitPts = defaultInitPts;
};
var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset) {
  this.discontinuity = void 0;
  this.contiguous = void 0;
  this.accurateTimeOffset = void 0;
  this.trackSwitch = void 0;
  this.timeOffset = void 0;
  this.discontinuity = discontinuity;
  this.contiguous = contiguous;
  this.accurateTimeOffset = accurateTimeOffset;
  this.trackSwitch = trackSwitch;
  this.timeOffset = timeOffset;
};

/***/ }),

/***/ "./src/demux/tsdemuxer.ts":
/*!********************************!*\
  !*** ./src/demux/tsdemuxer.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adts */ "./src/demux/adts.ts");
/* harmony import */ var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mpegaudio */ "./src/demux/mpegaudio.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _exp_golomb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./exp-golomb */ "./src/demux/exp-golomb.js");
/* harmony import */ var _sample_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sample-aes */ "./src/demux/sample-aes.js");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
/**
 * highly optimized TS demuxer:
 * parse PAT, PMT
 * extract PES packet from audio and video PIDs
 * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
 * trigger the remuxer upon parsing completion
 * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
 * it also controls the remuxing process :
 * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
 */









// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};

var TSDemuxer = /*#__PURE__*/function () {
  function TSDemuxer(observer, config, typeSupported) {
    this.observer = void 0;
    this.config = void 0;
    this.typeSupported = void 0;
    this.sampleAes = null;
    this.pmtParsed = false;
    this.contiguous = false;
    this.audioCodec = void 0;
    this.videoCodec = void 0;
    this._duration = 0;
    this.aacLastPTS = null;
    this._initPTS = null;
    this._initDTS = null;
    this._pmtId = -1;
    this._avcTrack = void 0;
    this._audioTrack = void 0;
    this._id3Track = void 0;
    this._txtTrack = void 0;
    this.aacOverFlow = null;
    this.avcSample = null;
    this.remainderData = null;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
  }

  TSDemuxer.probe = function probe(data) {
    var syncOffset = TSDemuxer._syncOffset(data);

    if (syncOffset < 0) {
      return false;
    } else {
      if (syncOffset) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset + ", junk ahead ?");
      }

      return true;
    }
  };

  TSDemuxer._syncOffset = function _syncOffset(data) {
    // scan 1000 first bytes
    var scanwindow = Math.min(1000, data.length - 3 * 188);
    var i = 0;

    while (i < scanwindow) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
        return i;
      } else {
        i++;
      }
    }

    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   *
   * @param {string} type 'audio' | 'video' | 'id3' | 'text'
   * @param {number} duration
   * @return {object} TSDemuxer's internal track model
   */
  ;

  TSDemuxer.createTrack = function createTrack(type, duration) {
    return {
      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
      type: type,
      id: RemuxerTrackIdConfig[type],
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: type === 'audio' ? duration : undefined
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  ;

  var _proto = TSDemuxer.prototype;

  _proto.resetInitSegment = function resetInitSegment(audioCodec, videoCodec, duration) {
    this.pmtParsed = false;
    this._pmtId = -1;
    this._avcTrack = TSDemuxer.createTrack('video', duration);
    this._audioTrack = TSDemuxer.createTrack('audio', duration);
    this._id3Track = TSDemuxer.createTrack('id3', duration);
    this._txtTrack = TSDemuxer.createTrack('text', duration);
    this._audioTrack.isAAC = true; // flush any partial content

    this.aacOverFlow = null;
    this.aacLastPTS = null;
    this.avcSample = null;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this._duration = duration;
  };

  _proto.resetTimeStamp = function resetTimeStamp() {};

  _proto.resetContiguity = function resetContiguity() {
    var _audioTrack = this._audioTrack,
        _avcTrack = this._avcTrack,
        _id3Track = this._id3Track;

    if (_audioTrack) {
      _audioTrack.pesData = null;
    }

    if (_avcTrack) {
      _avcTrack.pesData = null;
    }

    if (_id3Track) {
      _id3Track.pesData = null;
    }

    this.aacOverFlow = null;
    this.aacLastPTS = null;
  };

  _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
    if (isSampleAes === void 0) {
      isSampleAes = false;
    }

    if (flush === void 0) {
      flush = false;
    }

    if (!isSampleAes) {
      this.sampleAes = null;
    }

    var start;
    var stt;
    var pid;
    var atf;
    var offset;
    var pes;
    var avcTrack = this._avcTrack;
    var audioTrack = this._audioTrack;
    var id3Track = this._id3Track;
    var avcId = avcTrack.pid;
    var avcData = avcTrack.pesData;
    var audioId = audioTrack.pid;
    var id3Id = id3Track.pid;
    var audioData = audioTrack.pesData;
    var id3Data = id3Track.pesData;
    var unknownPIDs = false;
    var pmtParsed = this.pmtParsed;
    var pmtId = this._pmtId;
    var len = data.length;

    if (this.remainderData) {
      data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__["appendUint8Array"])(this.remainderData, data);
      len = data.length;
      this.remainderData = null;
    }

    if (len < 188 && !flush) {
      this.remainderData = data;
      return {
        audioTrack: audioTrack,
        avcTrack: avcTrack,
        id3Track: id3Track,
        textTrack: this._txtTrack
      };
    }

    var syncOffset = Math.max(0, TSDemuxer._syncOffset(data));
    len -= (len + syncOffset) % 188;

    if (len < data.byteLength && !flush) {
      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
    } // loop through TS packets


    for (start = syncOffset; start < len; start += 188) {
      if (data[start] === 0x47) {
        stt = !!(data[start + 1] & 0x40); // pid is a 13-bit field starting at the last bit of TS[1]

        pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
        atf = (data[start + 3] & 0x30) >> 4; // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.

        if (atf > 1) {
          offset = start + 5 + data[start + 4]; // continue if there is only adaptation field

          if (offset === start + 188) {
            continue;
          }
        } else {
          offset = start + 4;
        }

        switch (pid) {
          case avcId:
            if (stt) {
              if (avcData && (pes = parsePES(avcData))) {
                this._parseAVCPES(pes, false);
              }

              avcData = {
                data: [],
                size: 0
              };
            }

            if (avcData) {
              avcData.data.push(data.subarray(offset, start + 188));
              avcData.size += start + 188 - offset;
            }

            break;

          case audioId:
            if (stt) {
              if (audioData && (pes = parsePES(audioData))) {
                if (audioTrack.isAAC) {
                  this._parseAACPES(pes);
                } else {
                  this._parseMPEGPES(pes);
                }
              }

              audioData = {
                data: [],
                size: 0
              };
            }

            if (audioData) {
              audioData.data.push(data.subarray(offset, start + 188));
              audioData.size += start + 188 - offset;
            }

            break;

          case id3Id:
            if (stt) {
              if (id3Data && (pes = parsePES(id3Data))) {
                this._parseID3PES(pes);
              }

              id3Data = {
                data: [],
                size: 0
              };
            }

            if (id3Data) {
              id3Data.data.push(data.subarray(offset, start + 188));
              id3Data.size += start + 188 - offset;
            }

            break;

          case 0:
            if (stt) {
              offset += data[offset] + 1;
            }

            pmtId = this._pmtId = parsePAT(data, offset);
            break;

          case pmtId:
            {
              if (stt) {
                offset += data[offset] + 1;
              }

              var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, isSampleAes); // only update track id if track PID found while parsing PMT
              // this is to avoid resetting the PID to -1 in case
              // track PID transiently disappears from the stream
              // this could happen in case of transient missing audio samples for example
              // NOTE this is only the PID of the track as found in TS,
              // but we are not using this for MP4 track IDs.

              avcId = parsedPIDs.avc;

              if (avcId > 0) {
                avcTrack.pid = avcId;
              }

              audioId = parsedPIDs.audio;

              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.isAAC = parsedPIDs.isAAC;
              }

              id3Id = parsedPIDs.id3;

              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }

              if (unknownPIDs && !pmtParsed) {
                _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('reparse from beginning');
                unknownPIDs = false; // we set it to -188, the += 188 in the for loop will reset start to 0

                start = syncOffset - 188;
              }

              pmtParsed = this.pmtParsed = true;
              break;
            }

          case 17:
          case 0x1fff:
            break;

          default:
            unknownPIDs = true;
            break;
        }
      } else {
        this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
          type: _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorTypes"].MEDIA_ERROR,
          details: _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorDetails"].FRAG_PARSING_ERROR,
          fatal: false,
          reason: 'TS packet did not start with 0x47'
        });
      }
    }

    avcTrack.pesData = avcData;
    audioTrack.pesData = audioData;
    id3Track.pesData = id3Data;
    return {
      audioTrack: audioTrack,
      avcTrack: avcTrack,
      id3Track: id3Track,
      textTrack: this._txtTrack
    };
  };

  _proto.flush = function flush() {
    var remainderData = this.remainderData;
    this.remainderData = null;
    var result;

    if (remainderData) {
      result = this.demux(remainderData, -1, false, true);
    } else {
      result = {
        audioTrack: this._audioTrack,
        avcTrack: this._avcTrack,
        textTrack: this._txtTrack,
        id3Track: this._id3Track
      };
    }

    this.extractRemainingSamples(result);
    return result;
  };

  _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
    var audioTrack = demuxResult.audioTrack,
        avcTrack = demuxResult.avcTrack,
        id3Track = demuxResult.id3Track;
    var avcData = avcTrack.pesData;
    var audioData = audioTrack.pesData;
    var id3Data = id3Track.pesData; // try to parse last PES packets

    var pes;

    if (avcData && (pes = parsePES(avcData))) {
      this._parseAVCPES(pes, true);

      avcTrack.pesData = null;
    } else {
      // either avcData null or PES truncated, keep it for next frag parsing
      avcTrack.pesData = avcData;
    }

    if (audioData && (pes = parsePES(audioData))) {
      if (audioTrack.isAAC) {
        this._parseAACPES(pes);
      } else {
        this._parseMPEGPES(pes);
      }

      audioTrack.pesData = null;
    } else {
      if (audioData !== null && audioData !== void 0 && audioData.size) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('last AAC PES packet truncated,might overlap between fragments');
      } // either audioData null or PES truncated, keep it for next frag parsing


      audioTrack.pesData = audioData;
    }

    if (id3Data && (pes = parsePES(id3Data))) {
      this._parseID3PES(pes);

      id3Track.pesData = null;
    } else {
      // either id3Data null or PES truncated, keep it for next frag parsing
      id3Track.pesData = id3Data;
    }
  };

  _proto.demuxSampleAes = function demuxSampleAes(data, decryptData, timeOffset) {
    var _this = this;

    var demuxResult = this.demux(data, timeOffset, true);
    var sampleAes = this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_4__["default"](this.observer, this.config, decryptData, this.discardEPB);
    return new Promise(function (resolve, reject) {
      _this.decrypt(demuxResult.audioTrack, demuxResult.avcTrack, sampleAes).then(function () {
        resolve(demuxResult);
      });
    });
  };

  _proto.decrypt = function decrypt(audioTrack, videoTrack, sampleAes) {
    return new Promise(function (resolve) {
      if (audioTrack.samples && audioTrack.isAAC) {
        sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
          if (videoTrack.samples) {
            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
              resolve();
            });
          } else {
            resolve();
          }
        });
      } else if (videoTrack.samples) {
        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
          resolve();
        });
      }
    });
  };

  _proto.destroy = function destroy() {
    this._initPTS = this._initDTS = null;
    this._duration = 0;
  };

  _proto.pushAccessUnit = function pushAccessUnit(avcSample, avcTrack) {
    if (avcSample.units.length && avcSample.frame) {
      // if sample does not have PTS/DTS, patch with last sample PTS/DTS
      if (isNaN(avcSample.pts)) {
        var samples = avcTrack.samples;
        var nbSamples = samples.length;

        if (nbSamples) {
          var lastSample = samples[nbSamples - 1];
          avcSample.pts = lastSample.pts;
          avcSample.dts = lastSample.dts;
        } else {
          // dropping samples, no timestamp found
          avcTrack.dropped++;
          return;
        }
      }

      avcTrack.samples.push(avcSample);
    }

    if (avcSample.debug.length) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
    }
  };

  _proto._parseAVCPES = function _parseAVCPES(pes, last) {
    var _this2 = this;

    // logger.log('parse new PES');
    var track = this._avcTrack;

    var units = this._parseAVCNALu(pes.data);

    var debug = false;
    var expGolombDecoder;
    var avcSample = this.avcSample;
    var push;
    var spsfound = false;
    var i;
    var pushAccessUnit = this.pushAccessUnit.bind(this); // free pes.data to save up some memory

    pes.data = null; // if new NAL units found and last sample still there, let's push ...
    // this helps parsing streams with missing AUD (only do this if AUD never found)

    if (avcSample && units.length && !track.audFound) {
      pushAccessUnit(avcSample, track);
      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
    }

    units.forEach(function (unit) {
      switch (unit.type) {
        // NDR
        case 1:
          {
            push = true;

            if (!avcSample) {
              avcSample = _this2.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
            }

            if (debug) {
              avcSample.debug += 'NDR ';
            }

            avcSample.frame = true;
            var data = unit.data; // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)

            if (spsfound && data.length > 4) {
              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
              var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_3__["default"](data).readSliceType(); // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
              // if (sliceType === 2 || sliceType === 7) {

              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                avcSample.key = true;
              }
            }

            break; // IDR
          }

        case 5:
          push = true; // handle PES not starting with AUD

          if (!avcSample) {
            avcSample = _this2.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
          }

          if (debug) {
            avcSample.debug += 'IDR ';
          }

          avcSample.key = true;
          avcSample.frame = true;
          break;
        // SEI

        case 6:
          {
            push = true;

            if (debug && avcSample) {
              avcSample.debug += 'SEI ';
            }

            expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_3__["default"](_this2.discardEPB(unit.data)); // skip frameType

            expGolombDecoder.readUByte();
            var payloadType = 0;
            var payloadSize = 0;
            var endOfCaptions = false;
            var b = 0;

            while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
              payloadType = 0;

              do {
                b = expGolombDecoder.readUByte();
                payloadType += b;
              } while (b === 0xff); // Parse payload size.


              payloadSize = 0;

              do {
                b = expGolombDecoder.readUByte();
                payloadSize += b;
              } while (b === 0xff); // TODO: there can be more than one payload in an SEI packet...
              // TODO: need to read type and size in a while loop to get them all


              if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;
                var countryCode = expGolombDecoder.readUByte();

                if (countryCode === 181) {
                  var providerCode = expGolombDecoder.readUShort();

                  if (providerCode === 49) {
                    var userStructure = expGolombDecoder.readUInt();

                    if (userStructure === 0x47413934) {
                      var userDataType = expGolombDecoder.readUByte(); // Raw CEA-608 bytes wrapped in CEA-708 packet

                      if (userDataType === 3) {
                        var firstByte = expGolombDecoder.readUByte();
                        var secondByte = expGolombDecoder.readUByte();
                        var totalCCs = 31 & firstByte;
                        var byteArray = [firstByte, secondByte];

                        for (i = 0; i < totalCCs; i++) {
                          // 3 bytes per CC
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                          byteArray.push(expGolombDecoder.readUByte());
                        }

                        _this2._insertSampleInOrder(_this2._txtTrack.samples, {
                          type: 3,
                          pts: pes.pts,
                          bytes: byteArray
                        });
                      }
                    }
                  }
                }
              } else if (payloadType === 5 && expGolombDecoder.bytesAvailable !== 0) {
                endOfCaptions = true;

                if (payloadSize > 16) {
                  var uuidStrArray = [];

                  for (i = 0; i < 16; i++) {
                    uuidStrArray.push(expGolombDecoder.readUByte().toString(16));

                    if (i === 3 || i === 5 || i === 7 || i === 9) {
                      uuidStrArray.push('-');
                    }
                  }

                  var length = payloadSize - 16;
                  var userDataPayloadBytes = new Uint8Array(length);

                  for (i = 0; i < length; i++) {
                    userDataPayloadBytes[i] = expGolombDecoder.readUByte();
                  }

                  _this2._insertSampleInOrder(_this2._txtTrack.samples, {
                    pts: pes.pts,
                    payloadType: payloadType,
                    uuid: uuidStrArray.join(''),
                    userData: Object(_demux_id3__WEBPACK_IMPORTED_MODULE_8__["utf8ArrayToStr"])(userDataPayloadBytes),
                    userDataBytes: userDataPayloadBytes
                  });
                }
              } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                for (i = 0; i < payloadSize; i++) {
                  expGolombDecoder.readUByte();
                }
              }
            }

            break; // SPS
          }

        case 7:
          push = true;
          spsfound = true;

          if (debug && avcSample) {
            avcSample.debug += 'SPS ';
          }

          if (!track.sps) {
            expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_3__["default"](unit.data);
            var config = expGolombDecoder.readSPS();
            track.width = config.width;
            track.height = config.height;
            track.pixelRatio = config.pixelRatio;
            track.sps = [unit.data];
            track.duration = _this2._duration;
            var codecarray = unit.data.subarray(1, 4);
            var codecstring = 'avc1.';

            for (i = 0; i < 3; i++) {
              var h = codecarray[i].toString(16);

              if (h.length < 2) {
                h = '0' + h;
              }

              codecstring += h;
            }

            track.codec = codecstring;
          }

          break;
        // PPS

        case 8:
          push = true;

          if (debug && avcSample) {
            avcSample.debug += 'PPS ';
          }

          if (!track.pps) {
            track.pps = [unit.data];
          }

          break;
        // AUD

        case 9:
          push = false;
          track.audFound = true;

          if (avcSample) {
            pushAccessUnit(avcSample, track);
          }

          avcSample = _this2.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
          break;
        // Filler Data

        case 12:
          push = false;
          break;

        default:
          push = false;

          if (avcSample) {
            avcSample.debug += 'unknown NAL ' + unit.type + ' ';
          }

          break;
      }

      if (avcSample && push) {
        var _units = avcSample.units;

        _units.push(unit);
      }
    }); // if last PES packet, push samples

    if (last && avcSample) {
      pushAccessUnit(avcSample, track);
      this.avcSample = null;
    }
  };

  _proto._insertSampleInOrder = function _insertSampleInOrder(arr, data) {
    var len = arr.length;

    if (len > 0) {
      if (data.pts >= arr[len - 1].pts) {
        arr.push(data);
      } else {
        for (var pos = len - 1; pos >= 0; pos--) {
          if (data.pts < arr[pos].pts) {
            arr.splice(pos, 0, data);
            break;
          }
        }
      }
    } else {
      arr.push(data);
    }
  };

  _proto._getLastNalUnit = function _getLastNalUnit() {
    var _avcSample;

    var avcSample = this.avcSample;
    var lastUnit; // try to fallback to previous sample if current one is empty

    if (!avcSample || avcSample.units.length === 0) {
      var samples = this._avcTrack.samples;
      avcSample = samples[samples.length - 1];
    }

    if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {
      var units = avcSample.units;
      lastUnit = units[units.length - 1];
    }

    return lastUnit;
  };

  _proto._parseAVCNALu = function _parseAVCNALu(array) {
    var len = array.byteLength;
    var track = this._avcTrack;
    var state = track.naluState || 0;
    var lastState = state;
    var units = [];
    var i = 0;
    var value;
    var overflow;
    var unit;
    var unitType;
    var lastUnitStart = -1;
    var lastUnitType; // logger.log('PES:' + Hex.hexDump(array));

    if (state === -1) {
      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
      lastUnitStart = 0; // NALu type is value read from offset 0

      lastUnitType = array[0] & 0x1f;
      state = 0;
      i = 1;
    }

    while (i < len) {
      value = array[i++]; // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case

      if (!state) {
        state = value ? 0 : 1;
        continue;
      }

      if (state === 1) {
        state = value ? 0 : 2;
        continue;
      } // here we have state either equal to 2 or 3


      if (!value) {
        state = 3;
      } else if (value === 1) {
        if (lastUnitStart >= 0) {
          unit = {
            data: array.subarray(lastUnitStart, i - state - 1),
            type: lastUnitType
          }; // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);

          units.push(unit);
        } else {
          // lastUnitStart is undefined => this is the first start code found in this PES packet
          // first check if start code delimiter is overlapping between 2 PES packets,
          // ie it started in last packet (lastState not zero)
          // and ended at the beginning of this PES packet (i <= 4 - lastState)
          var lastUnit = this._getLastNalUnit();

          if (lastUnit) {
            if (lastState && i <= 4 - lastState) {
              // start delimiter overlapping between PES packets
              // strip start delimiter bytes from the end of last NAL unit
              // check if lastUnit had a state different from zero
              if (lastUnit.state) {
                // strip last bytes
                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
              }
            } // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.


            overflow = i - state - 1;

            if (overflow > 0) {
              // logger.log('first NALU found with overflow:' + overflow);
              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
              tmp.set(lastUnit.data, 0);
              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
              lastUnit.data = tmp;
            }
          }
        } // check if we can read unit type


        if (i < len) {
          unitType = array[i] & 0x1f; // logger.log('find NALU @ offset:' + i + ',type:' + unitType);

          lastUnitStart = i;
          lastUnitType = unitType;
          state = 0;
        } else {
          // not enough byte to read unit type. let's read it on next PES parsing
          state = -1;
        }
      } else {
        state = 0;
      }
    }

    if (lastUnitStart >= 0 && state >= 0) {
      unit = {
        data: array.subarray(lastUnitStart, len),
        type: lastUnitType,
        state: state
      };
      units.push(unit); // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
    } // no NALu found


    if (units.length === 0) {
      // append pes.data to previous NAL unit
      var _lastUnit = this._getLastNalUnit();

      if (_lastUnit) {
        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);

        _tmp.set(_lastUnit.data, 0);

        _tmp.set(array, _lastUnit.data.byteLength);

        _lastUnit.data = _tmp;
      }
    }

    track.naluState = state;
    return units;
  }
  /**
   * remove Emulation Prevention bytes from a RBSP
   */
  ;

  _proto.discardEPB = function discardEPB(data) {
    var length = data.byteLength;
    var EPBPositions = [];
    var i = 1; // Find all `Emulation Prevention Bytes`

    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    } // If no Emulation Prevention Bytes were found just return the original
    // array


    if (EPBPositions.length === 0) {
      return data;
    } // Create a new array to hold the NAL unit data


    var newLength = length - EPBPositions.length;
    var newData = new Uint8Array(newLength);
    var sourceIndex = 0;

    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        // Skip this byte
        sourceIndex++; // Remove this position index

        EPBPositions.shift();
      }

      newData[i] = data[sourceIndex];
    }

    return newData;
  };

  _proto._parseAACPES = function _parseAACPES(pes) {
    var startOffset = 0;
    var track = this._audioTrack;
    var aacLastPTS = this.aacLastPTS;
    var aacOverFlow = this.aacOverFlow;
    var data = pes.data;
    var pts = pes.pts;
    var frameIndex;
    var offset;
    var stamp;
    var len;

    if (aacOverFlow) {
      var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
      tmp.set(aacOverFlow, 0);
      tmp.set(data, aacOverFlow.byteLength); // logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);

      data = tmp;
    } // look for ADTS header (0xFFFx)


    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
      if (_adts__WEBPACK_IMPORTED_MODULE_0__["isHeader"](data, offset)) {
        break;
      }
    } // if ADTS header does not start straight from the beginning of the PES payload, raise an error


    if (offset) {
      var reason;
      var fatal;

      if (offset < len - 1) {
        reason = "AAC PES did not start with ADTS header,offset:" + offset;
        fatal = false;
      } else {
        reason = 'no ADTS header found in AAC PES';
        fatal = true;
      }

      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("parsing error:" + reason);
      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorTypes"].MEDIA_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorDetails"].FRAG_PARSING_ERROR,
        fatal: fatal,
        reason: reason
      });

      if (fatal) {
        return;
      }
    }

    _adts__WEBPACK_IMPORTED_MODULE_0__["initTrackConfig"](track, this.observer, data, offset, this.audioCodec);
    frameIndex = 0;
    var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__["getFrameDuration"](track.samplerate); // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
    // first sample PTS should be equal to last sample PTS + frameDuration

    if (aacOverFlow && aacLastPTS) {
      var newPTS = aacLastPTS + frameDuration;

      if (Math.abs(newPTS - pts) > 1) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[tsdemuxer]: AAC: align PTS for overlapping frames by " + Math.round((newPTS - pts) / 90));
        pts = newPTS;
      }
    } // scan for aac samples


    while (offset < len) {
      if (_adts__WEBPACK_IMPORTED_MODULE_0__["isHeader"](data, offset)) {
        if (offset + 5 < len) {
          var frame = _adts__WEBPACK_IMPORTED_MODULE_0__["appendFrame"](track, data, offset, pts, frameIndex);

          if (frame) {
            offset += frame.length;
            stamp = frame.sample.pts;
            frameIndex++;
            continue;
          }
        } // We are at an ADTS header, but do not have enough data for a frame
        // Remaining data will be added to aacOverFlow


        break;
      } else {
        // nothing found, keep looking
        offset++;
      }
    }

    if (offset < len) {
      aacOverFlow = data.subarray(offset, len); // logger.log(`AAC: overflow detected:${len-offset}`);
    } else {
      aacOverFlow = null;
    }

    this.aacOverFlow = aacOverFlow;
    this.aacLastPTS = stamp;
  };

  _proto._parseMPEGPES = function _parseMPEGPES(pes) {
    var data = pes.data;
    var length = data.length;
    var frameIndex = 0;
    var offset = 0;
    var pts = pes.pts;

    while (offset < length) {
      if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__["isHeader"](data, offset)) {
        var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__["appendFrame"](this._audioTrack, data, offset, pts, frameIndex);

        if (frame) {
          offset += frame.length;
          frameIndex++;
        } else {
          // logger.log('Unable to parse Mpeg audio frame');
          break;
        }
      } else {
        // nothing found, keep looking
        offset++;
      }
    }
  };

  _proto._parseID3PES = function _parseID3PES(pes) {
    this._id3Track.samples.push(pes);
  };

  return TSDemuxer;
}();

TSDemuxer.minProbeByteLength = 188;

function createAVCSample(key, pts, dts, debug) {
  return {
    key: key,
    frame: false,
    pts: pts,
    dts: dts,
    units: [],
    debug: debug,
    length: 0
  };
}

function parsePAT(data, offset) {
  // skip the PSI header and parse the first PMT entry
  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11]; // logger.log('PMT PID:'  + this._pmtId);
}

function parsePMT(data, offset, mpegSupported, isSampleAes) {
  var result = {
    audio: -1,
    avc: -1,
    id3: -1,
    isAAC: true
  };
  var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
  var tableEnd = offset + 3 + sectionLength - 4; // to determine where the table is, we have to figure out how
  // long the program info descriptors are

  var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11]; // advance the offset to the first entry in the mapping table

  offset += 12 + programInfoLength;

  while (offset < tableEnd) {
    var pid = (data[offset + 1] & 0x1f) << 8 | data[offset + 2];

    switch (data[offset]) {
      case 0xcf:
        // SAMPLE-AES AAC
        if (!isSampleAes) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream');
          break;
        }

      /* falls through */

      case 0x0f:
        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
        // logger.log('AAC PID:'  + pid);
        if (result.audio === -1) {
          result.audio = pid;
        }

        break;
      // Packetized metadata (ID3)

      case 0x15:
        // logger.log('ID3 PID:'  + pid);
        if (result.id3 === -1) {
          result.id3 = pid;
        }

        break;

      case 0xdb:
        // SAMPLE-AES AVC
        if (!isSampleAes) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('H.264 with AES-128-CBC slice encryption found in unencrypted stream');
          break;
        }

      /* falls through */

      case 0x1b:
        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
        // logger.log('AVC PID:'  + pid);
        if (result.avc === -1) {
          result.avc = pid;
        }

        break;
      // ISO/IEC 11172-3 (MPEG-1 audio)
      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)

      case 0x03:
      case 0x04:
        // logger.log('MPEG PID:'  + pid);
        if (!mpegSupported) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('MPEG audio found, not supported in this browser');
        } else if (result.audio === -1) {
          result.audio = pid;
          result.isAAC = false;
        }

        break;

      case 0x24:
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn('Unsupported HEVC stream type found');
        break;

      default:
        // logger.log('unknown stream type:' + data[offset]);
        break;
    } // move to the next table entry
    // skip past the elementary stream descriptors, if present


    offset += ((data[offset + 3] & 0x0f) << 8 | data[offset + 4]) + 5;
  }

  return result;
}

function parsePES(stream) {
  var i = 0;
  var frag;
  var pesFlags;
  var pesLen;
  var pesHdrLen;
  var pesData;
  var pesPts;
  var pesDts;
  var payloadStartOffset;
  var data = stream.data; // safety check

  if (!stream || stream.size === 0) {
    return null;
  } // we might need up to 19 bytes to read PES header
  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
  // usually only one merge is needed (and this is rare ...)


  while (data[0].length < 19 && data.length > 1) {
    var newData = new Uint8Array(data[0].length + data[1].length);
    newData.set(data[0]);
    newData.set(data[1], data[0].length);
    data[0] = newData;
    data.splice(1, 1);
  } // retrieve PTS/DTS from first fragment


  frag = data[0];
  var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];

  if (pesPrefix === 1) {
    pesLen = (frag[4] << 8) + frag[5]; // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
    // minus 6 : PES header size

    if (pesLen && pesLen > stream.size - 6) {
      return null;
    }

    pesFlags = frag[7];

    if (pesFlags & 0xc0) {
      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
          as Bitwise operators treat their operands as a sequence of 32 bits */
      pesPts = (frag[9] & 0x0e) * 536870912 + // 1 << 29
      (frag[10] & 0xff) * 4194304 + // 1 << 22
      (frag[11] & 0xfe) * 16384 + // 1 << 14
      (frag[12] & 0xff) * 128 + // 1 << 7
      (frag[13] & 0xfe) / 2;

      if (pesFlags & 0x40) {
        pesDts = (frag[14] & 0x0e) * 536870912 + // 1 << 29
        (frag[15] & 0xff) * 4194304 + // 1 << 22
        (frag[16] & 0xfe) * 16384 + // 1 << 14
        (frag[17] & 0xff) * 128 + // 1 << 7
        (frag[18] & 0xfe) / 2;

        if (pesPts - pesDts > 60 * 90000) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn(Math.round((pesPts - pesDts) / 90000) + "s delta between PTS and DTS, align them");
          pesPts = pesDts;
        }
      } else {
        pesDts = pesPts;
      }
    }

    pesHdrLen = frag[8]; // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension

    payloadStartOffset = pesHdrLen + 9;

    if (stream.size <= payloadStartOffset) {
      return null;
    }

    stream.size -= payloadStartOffset; // reassemble PES packet

    pesData = new Uint8Array(stream.size);

    for (var j = 0, dataLen = data.length; j < dataLen; j++) {
      frag = data[j];
      var len = frag.byteLength;

      if (payloadStartOffset) {
        if (payloadStartOffset > len) {
          // trim full frag if PES header bigger than frag
          payloadStartOffset -= len;
          continue;
        } else {
          // trim partial frag if PES header smaller than frag
          frag = frag.subarray(payloadStartOffset);
          len -= payloadStartOffset;
          payloadStartOffset = 0;
        }
      }

      pesData.set(frag, i);
      i += len;
    }

    if (pesLen) {
      // payload size : remove PES header + PES extension
      pesLen -= pesHdrLen + 3;
    }

    return {
      data: pesData,
      pts: pesPts,
      dts: pesDts,
      len: pesLen
    };
  } else {
    return null;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (TSDemuxer);

/***/ }),

/***/ "./src/errors.ts":
/*!***********************!*\
  !*** ./src/errors.ts ***!
  \***********************/
/*! exports provided: ErrorTypes, ErrorDetails */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorTypes", function() { return ErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorDetails", function() { return ErrorDetails; });
var ErrorTypes;
/**
 * @enum {ErrorDetails}
 * @typedef {string} ErrorDetail
 */

(function (ErrorTypes) {
  ErrorTypes["NETWORK_ERROR"] = "networkError";
  ErrorTypes["MEDIA_ERROR"] = "mediaError";
  ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
  ErrorTypes["MUX_ERROR"] = "muxError";
  ErrorTypes["OTHER_ERROR"] = "otherError";
})(ErrorTypes || (ErrorTypes = {}));

var ErrorDetails;

(function (ErrorDetails) {
  ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
  ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
  ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
  ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
  ErrorDetails["KEY_SYSTEM_NO_INIT_DATA"] = "keySystemNoInitData";
  ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
  ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
  ErrorDetails["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
  ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
  ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
  ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
  ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
  ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
  ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
  ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
  ErrorDetails["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
  ErrorDetails["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
  ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
  ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
  ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
  ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
  ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
  ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
  ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
  ErrorDetails["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
  ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
  ErrorDetails["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
  ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
  ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
  ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
  ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
  ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
  ErrorDetails["INTERNAL_ABORTED"] = "aborted";
  ErrorDetails["UNKNOWN"] = "unknown";
})(ErrorDetails || (ErrorDetails = {}));

/***/ }),

/***/ "./src/events.ts":
/*!***********************!*\
  !*** ./src/events.ts ***!
  \***********************/
/*! exports provided: Events */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Events", function() { return Events; });
/**
 * @readonly
 * @enum {string}
 */
var Events;

(function (Events) {
  Events["MEDIA_ATTACHING"] = "hlsMediaAttaching";
  Events["MEDIA_ATTACHED"] = "hlsMediaAttached";
  Events["MEDIA_DETACHING"] = "hlsMediaDetaching";
  Events["MEDIA_DETACHED"] = "hlsMediaDetached";
  Events["BUFFER_RESET"] = "hlsBufferReset";
  Events["BUFFER_CODECS"] = "hlsBufferCodecs";
  Events["BUFFER_CREATED"] = "hlsBufferCreated";
  Events["BUFFER_APPENDING"] = "hlsBufferAppending";
  Events["BUFFER_APPENDED"] = "hlsBufferAppended";
  Events["BUFFER_EOS"] = "hlsBufferEos";
  Events["BUFFER_FLUSHING"] = "hlsBufferFlushing";
  Events["BUFFER_FLUSHED"] = "hlsBufferFlushed";
  Events["MANIFEST_LOADING"] = "hlsManifestLoading";
  Events["MANIFEST_LOADED"] = "hlsManifestLoaded";
  Events["MANIFEST_PARSED"] = "hlsManifestParsed";
  Events["LEVEL_SWITCHING"] = "hlsLevelSwitching";
  Events["LEVEL_SWITCHED"] = "hlsLevelSwitched";
  Events["LEVEL_LOADING"] = "hlsLevelLoading";
  Events["LEVEL_LOADED"] = "hlsLevelLoaded";
  Events["LEVEL_UPDATED"] = "hlsLevelUpdated";
  Events["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
  Events["LEVELS_UPDATED"] = "hlsLevelsUpdated";
  Events["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
  Events["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
  Events["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
  Events["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
  Events["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
  Events["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
  Events["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
  Events["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
  Events["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
  Events["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
  Events["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
  Events["CUES_PARSED"] = "hlsCuesParsed";
  Events["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
  Events["INIT_PTS_FOUND"] = "hlsInitPtsFound";
  Events["FRAG_LOADING"] = "hlsFragLoading";
  Events["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
  Events["FRAG_LOADED"] = "hlsFragLoaded";
  Events["FRAG_DECRYPTED"] = "hlsFragDecrypted";
  Events["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
  Events["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
  Events["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
  Events["FRAG_PARSED"] = "hlsFragParsed";
  Events["FRAG_BUFFERED"] = "hlsFragBuffered";
  Events["FRAG_CHANGED"] = "hlsFragChanged";
  Events["FPS_DROP"] = "hlsFpsDrop";
  Events["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
  Events["ERROR"] = "hlsError";
  Events["DESTROYING"] = "hlsDestroying";
  Events["KEY_LOADING"] = "hlsKeyLoading";
  Events["KEY_LOADED"] = "hlsKeyLoaded";
  Events["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
})(Events || (Events = {}));

/***/ }),

/***/ "./src/hls.ts":
/*!********************!*\
  !*** ./src/hls.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Hls; });
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "./src/errors.ts");
/* harmony import */ var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader/playlist-loader */ "./src/loader/playlist-loader.ts");
/* harmony import */ var _loader_key_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader/key-loader */ "./src/loader/key-loader.ts");
/* harmony import */ var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controller/fragment-tracker */ "./src/controller/fragment-tracker.ts");
/* harmony import */ var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controller/stream-controller */ "./src/controller/stream-controller.ts");
/* harmony import */ var _controller_level_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controller/level-controller */ "./src/controller/level-controller.ts");
/* harmony import */ var _is_supported__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./is-supported */ "./src/is-supported.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./config */ "./src/config.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./events */ "./src/events.ts");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./controller/id3-track-controller */ "./src/controller/id3-track-controller.ts");
/* harmony import */ var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./controller/latency-controller */ "./src/controller/latency-controller.ts");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
















/**
 * @module Hls
 * @class
 * @constructor
 */
var Hls = /*#__PURE__*/function () {
  Hls.isSupported = function isSupported() {
    return Object(_is_supported__WEBPACK_IMPORTED_MODULE_7__["isSupported"])();
  };

  _createClass(Hls, null, [{
    key: "version",
    get: function get() {
      return undefined;
    }
  }, {
    key: "Events",
    get: function get() {
      return _events__WEBPACK_IMPORTED_MODULE_10__["Events"];
    }
  }, {
    key: "ErrorTypes",
    get: function get() {
      return _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"];
    }
  }, {
    key: "ErrorDetails",
    get: function get() {
      return _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"];
    }
  }, {
    key: "DefaultConfig",
    get: function get() {
      if (!Hls.defaultConfig) {
        return _config__WEBPACK_IMPORTED_MODULE_9__["hlsDefaultConfig"];
      }

      return Hls.defaultConfig;
    }
    /**
     * @type {HlsConfig}
     */
    ,
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
    /**
     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
     *
     * @constructs Hls
     * @param {HlsConfig} config
     */

  }]);

  function Hls(userConfig) {
    var _this = this;

    if (userConfig === void 0) {
      userConfig = {};
    }

    this.config = void 0;
    this.userConfig = void 0;
    this.coreComponents = void 0;
    this.networkControllers = void 0;
    this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
    this._autoLevelCapping = void 0;
    this.abrController = void 0;
    this.capLevelController = void 0;
    this.latencyController = void 0;
    this.levelController = void 0;
    this.streamController = void 0;
    this.audioTrackController = void 0;
    this.subtitleTrackController = void 0;
    this.emeController = void 0;
    this._media = null;
    this.url = null;
    var config = this.config = Object(_config__WEBPACK_IMPORTED_MODULE_9__["mergeConfig"])(Hls.DefaultConfig, userConfig);
    this.userConfig = userConfig;
    Object(_utils_logger__WEBPACK_IMPORTED_MODULE_8__["enableLogs"])(config.debug);
    this._autoLevelCapping = -1;

    if (config.progressive) {
      Object(_config__WEBPACK_IMPORTED_MODULE_9__["enableStreamingMode"])(config);
    } // core controllers and network loaders


    var abrController = this.abrController = new config.abrController(this); // eslint-disable-line new-cap

    var bufferController = new config.bufferController(this); // eslint-disable-line new-cap

    var capLevelController = this.capLevelController = new config.capLevelController(this); // eslint-disable-line new-cap

    var fpsController = new config.fpsController(this); // eslint-disable-line new-cap

    var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_2__["default"](this);
    var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_12__["default"](this); // network controllers

    var levelController = this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_6__["default"](this); // FragmentTracker must be defined before StreamController because the order of event handling is important

    var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentTracker"](this);
    var streamController = this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_5__["default"](this, fragmentTracker); // Level Controller initiates loading after all controllers have received MANIFEST_PARSED

    levelController.onParsedComplete = function () {
      if (config.autoStartLoad || streamController.forceStartLoad) {
        _this.startLoad(config.startPosition);
      }
    }; // Cap level controller uses streamController to flush the buffer


    capLevelController.setStreamController(streamController); // fpsController uses streamController to switch when frames are being dropped

    fpsController.setStreamController(streamController);
    var networkControllers = [levelController, streamController];
    this.networkControllers = networkControllers;
    var coreComponents = [playListLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
    this.audioTrackController = this.createController(config.audioTrackController, null, networkControllers);
    this.createController(config.audioStreamController, fragmentTracker, networkControllers); // subtitleTrackController must be defined before  because the order of event handling is important

    this.subtitleTrackController = this.createController(config.subtitleTrackController, null, networkControllers);
    this.createController(config.subtitleStreamController, fragmentTracker, networkControllers);
    this.createController(config.timelineController, null, coreComponents);
    this.emeController = this.createController(config.emeController, null, coreComponents);
    this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_13__["default"], null, coreComponents);
    this.coreComponents = coreComponents;
  }

  var _proto = Hls.prototype;

  _proto.createController = function createController(ControllerClass, fragmentTracker, components) {
    if (ControllerClass) {
      var controllerInstance = fragmentTracker ? new ControllerClass(this, fragmentTracker) : new ControllerClass(this);

      if (components) {
        components.push(controllerInstance);
      }

      return controllerInstance;
    }

    return null;
  } // Delegate the EventEmitter through the public API of Hls.js
  ;

  _proto.on = function on(event, listener, context) {
    var hlsjs = this;

    this._emitter.on(event, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (hlsjs.config.debug) {
        listener.apply(this, args);
      } else {
        try {
          listener.apply(this, args);
        } catch (e) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].error('An internal error happened while handling event ' + event + '. Error message: "' + e.message + '". Here is a stacktrace:', e);
          hlsjs.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].ERROR, {
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].OTHER_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_EXCEPTION,
            fatal: false,
            event: event,
            error: e
          });
        }
      }
    }, context);
  };

  _proto.once = function once(event, listener, context) {
    var hlsjs = this;

    this._emitter.once(event, function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (hlsjs.config.debug) {
        listener.apply(this, args);
      } else {
        try {
          listener.apply(this, args);
        } catch (e) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].error('An internal error happened while handling event ' + event + '. Error message: "' + e.message + '". Here is a stacktrace:', e);
          hlsjs.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].ERROR, {
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].OTHER_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_EXCEPTION,
            fatal: false,
            event: event,
            error: e
          });
        }
      }
    }, context);
  };

  _proto.removeAllListeners = function removeAllListeners(event) {
    this._emitter.removeAllListeners(event);
  };

  _proto.off = function off(event, listener, context, once) {
    this._emitter.off(event, listener, context, once);
  };

  _proto.listeners = function listeners(event) {
    return this._emitter.listeners(event);
  };

  _proto.emit = function emit(event, name, eventObject) {
    return this._emitter.emit(event, name, eventObject);
  };

  _proto.trigger = function trigger(event, eventObject) {
    return this._emitter.emit(event, event, eventObject);
  };

  _proto.listenerCount = function listenerCount(event) {
    return this._emitter.listenerCount(event);
  }
  /**
   * Dispose of the instance
   */
  ;

  _proto.destroy = function destroy() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('destroy');
    this.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].DESTROYING, undefined);
    this.detachMedia();
    this.networkControllers.forEach(function (component) {
      return component.destroy();
    });
    this.coreComponents.forEach(function (component) {
      return component.destroy();
    });
    this.url = null;
    this.removeAllListeners();
    this._autoLevelCapping = -1;
  }
  /**
   * Attaches Hls.js to a media element
   * @param {HTMLMediaElement} media
   */
  ;

  _proto.attachMedia = function attachMedia(media) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('attachMedia');
    this._media = media;
    this.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].MEDIA_ATTACHING, {
      media: media
    });
  }
  /**
   * Detach Hls.js from the media
   */
  ;

  _proto.detachMedia = function detachMedia() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('detachMedia');
    this.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].MEDIA_DETACHING, undefined);
    this._media = null;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   * @param {string} url
   */
  ;

  _proto.loadSource = function loadSource(url) {
    this.stopLoad();
    var media = this.media;

    if (media && this.url) {
      this.detachMedia();
      this.attachMedia(media);
    }

    url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__["buildAbsoluteURL"](self.location.href, url, {
      alwaysNormalize: true
    });
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("loadSource:" + url);
    this.url = url; // when attaching to a source URL, trigger a playlist load

    this.trigger(_events__WEBPACK_IMPORTED_MODULE_10__["Events"].MANIFEST_LOADING, {
      url: url
    });
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param {number} startPosition Set the start position to stream from
   * @default -1 None (from earliest point)
   */
  ;

  _proto.startLoad = function startLoad(startPosition) {
    if (startPosition === void 0) {
      startPosition = -1;
    }

    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("startLoad(" + startPosition + ")");
    this.networkControllers.forEach(function (controller) {
      controller.startLoad(startPosition);
    });
  }
  /**
   * Stop loading of any stream data.
   */
  ;

  _proto.stopLoad = function stopLoad() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('stopLoad');
    this.networkControllers.forEach(function (controller) {
      controller.stopLoad();
    });
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  ;

  _proto.swapAudioCodec = function swapAudioCodec() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('swapAudioCodec');
    this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  ;

  _proto.recoverMediaError = function recoverMediaError() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log('recoverMediaError');
    var media = this._media;
    this.detachMedia();

    if (media) {
      this.attachMedia(media);
    }
  };

  _proto.removeLevel = function removeLevel(levelIndex, urlId) {
    if (urlId === void 0) {
      urlId = 0;
    }

    this.levelController.removeLevel(levelIndex, urlId);
  }
  /**
   * @type {Level[]}
   */
  ;

  _createClass(Hls, [{
    key: "levels",
    get: function get() {
      return this.levelController.levels ? this.levelController.levels : [];
    }
    /**
     * Index of quality level currently played
     * @type {number}
     */

  }, {
    key: "currentLevel",
    get: function get() {
      return this.streamController.currentLevel;
    }
    /**
     * Set quality level index immediately .
     * This will flush the current buffer to replace the quality asap.
     * That means playback will interrupt at least shortly to re-buffer and re-sync eventually.
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set currentLevel:" + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }
    /**
     * Index of next quality level loaded as scheduled by stream controller.
     * @type {number}
     */

  }, {
    key: "nextLevel",
    get: function get() {
      return this.streamController.nextLevel;
    }
    /**
     * Set quality level index for next loaded data.
     * This will switch the video quality asap, without interrupting playback.
     * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
     * @type {number} -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set nextLevel:" + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }
    /**
     * Return the quality level of the currently or last (of none is loaded currently) segment
     * @type {number}
     */

  }, {
    key: "loadLevel",
    get: function get() {
      return this.levelController.level;
    }
    /**
     * Set quality level index for next loaded data in a conservative way.
     * This will switch the quality without flushing, but interrupt current loading.
     * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
     * @type {number} newLevel -1 for automatic level selection
     */
    ,
    set: function set(newLevel) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set loadLevel:" + newLevel);
      this.levelController.manualLevel = newLevel;
    }
    /**
     * get next quality level loaded
     * @type {number}
     */

  }, {
    key: "nextLoadLevel",
    get: function get() {
      return this.levelController.nextLoadLevel;
    }
    /**
     * Set quality level of next loaded segment in a fully "non-destructive" way.
     * Same as `loadLevel` but will wait for next switch (until current loading is done).
     * @type {number} level
     */
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }
    /**
     * Return "first level": like a default level, if not set,
     * falls back to index of first level referenced in manifest
     * @type {number}
     */

  }, {
    key: "firstLevel",
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }
    /**
     * Sets "first-level", see getter.
     * @type {number}
     */
    ,
    set: function set(newLevel) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set firstLevel:" + newLevel);
      this.levelController.firstLevel = newLevel;
    }
    /**
     * Return start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number}
     */

  }, {
    key: "startLevel",
    get: function get() {
      return this.levelController.startLevel;
    }
    /**
     * set  start level (level of first fragment that will be played back)
     * if not overrided by user, first level appearing in manifest will be used as start level
     * if -1 : automatic start level selection, playback will start from level matching download bandwidth
     * (determined from download of first segment)
     * @type {number} newLevel
     */
    ,
    set: function set(newLevel) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set startLevel:" + newLevel); // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel

      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, this.minAutoLevel);
      }

      this.levelController.startLevel = newLevel;
    }
    /**
     * Get the current setting for capLevelToPlayerSize
     *
     * @type {boolean}
     */

  }, {
    key: "capLevelToPlayerSize",
    get: function get() {
      return this.config.capLevelToPlayerSize;
    }
    /**
     * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)
     *
     * @type {boolean}
     */
    ,
    set: function set(shouldStartCapping) {
      var newCapLevelToPlayerSize = !!shouldStartCapping;

      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
        if (newCapLevelToPlayerSize) {
          this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.
        } else {
          this.capLevelController.stopCapping();
          this.autoLevelCapping = -1;
          this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.
        }

        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
      }
    }
    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */

  }, {
    key: "autoLevelCapping",
    get: function get() {
      return this._autoLevelCapping;
    }
    /**
     * get bandwidth estimate
     * @type {number}
     */
    ,

    /**
     * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
     * @type {number}
     */
    set: function set(newLevel) {
      if (this._autoLevelCapping !== newLevel) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_8__["logger"].log("set autoLevelCapping:" + newLevel);
        this._autoLevelCapping = newLevel;
      }
    }
    /**
     * True when automatic level selection enabled
     * @type {boolean}
     */

  }, {
    key: "bandwidthEstimate",
    get: function get() {
      return this.abrController.bwEstimator.getEstimate();
    }
  }, {
    key: "autoLevelEnabled",
    get: function get() {
      return this.levelController.manualLevel === -1;
    }
    /**
     * Level set manually (if any)
     * @type {number}
     */

  }, {
    key: "manualLevel",
    get: function get() {
      return this.levelController.manualLevel;
    }
    /**
     * min level selectable in auto mode according to config.minAutoBitrate
     * @type {number}
     */

  }, {
    key: "minAutoLevel",
    get: function get() {
      var levels = this.levels,
          minAutoBitrate = this.config.minAutoBitrate;
      if (!levels) return 0;
      var len = levels.length;

      for (var i = 0; i < len; i++) {
        if (levels[i].maxBitrate > minAutoBitrate) {
          return i;
        }
      }

      return 0;
    }
    /**
     * max level selectable in auto mode according to autoLevelCapping
     * @type {number}
     */

  }, {
    key: "maxAutoLevel",
    get: function get() {
      var levels = this.levels,
          autoLevelCapping = this.autoLevelCapping;
      var maxAutoLevel;

      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }

      return maxAutoLevel;
    }
    /**
     * next automatically selected quality level
     * @type {number}
     */

  }, {
    key: "nextAutoLevel",
    get: function get() {
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
    }
    /**
     * this setter is used to force next auto level.
     * this is useful to force a switch down in auto mode:
     * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
     * forced value is valid for one fragment. upon succesful frag loading at forced level,
     * this value will be resetted to -1 by ABR controller.
     * @type {number}
     */
    ,
    set: function set(nextLevel) {
      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
    }
    /**
     * @type {AudioTrack[]}
     */

  }, {
    key: "audioTracks",
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }
    /**
     * index of the selected audio track (index in audio track lists)
     * @type {number}
     */

  }, {
    key: "audioTrack",
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }
    /**
     * selects an audio track, based on its index in audio track lists
     * @type {number}
     */
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;

      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
    /**
     * get alternate subtitle tracks list from playlist
     * @type {MediaPlaylist[]}
     */

  }, {
    key: "subtitleTracks",
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }
    /**
     * index of the selected subtitle track (index in subtitle track lists)
     * @type {number}
     */

  }, {
    key: "subtitleTrack",
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    },

    /**
     * select an subtitle track, based on its index in subtitle track lists
     * @type {number}
     */
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;

      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
    /**
     * @type {boolean}
     */

  }, {
    key: "media",
    get: function get() {
      return this._media;
    }
  }, {
    key: "subtitleDisplay",
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }
    /**
     * Enable/disable subtitle display rendering
     * @type {boolean}
     */
    ,
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;

      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
    /**
     * get mode for Low-Latency HLS loading
     * @type {boolean}
     */

  }, {
    key: "lowLatencyMode",
    get: function get() {
      return this.config.lowLatencyMode;
    }
    /**
     * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
     * @type {boolean}
     */
    ,
    set: function set(mode) {
      this.config.lowLatencyMode = mode;
    }
    /**
     * position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
     * @type {number}
     */

  }, {
    key: "liveSyncPosition",
    get: function get() {
      return this.latencyController.liveSyncPosition;
    }
    /**
     * estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
     * returns 0 before first playlist is loaded
     * @type {number}
     */

  }, {
    key: "latency",
    get: function get() {
      return this.latencyController.latency;
    }
    /**
     * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
     * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
     * returns 0 before first playlist is loaded
     * @type {number}
     */

  }, {
    key: "maxLatency",
    get: function get() {
      return this.latencyController.maxLatency;
    }
    /**
     * target distance from the edge as calculated by the latency controller
     * @type {number}
     */

  }, {
    key: "targetLatency",
    get: function get() {
      return this.latencyController.targetLatency;
    }
  }]);

  return Hls;
}();

Hls.defaultConfig = void 0;


/***/ }),

/***/ "./src/is-supported.ts":
/*!*****************************!*\
  !*** ./src/is-supported.ts ***!
  \*****************************/
/*! exports provided: isSupported, changeTypeSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSupported", function() { return isSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "changeTypeSupported", function() { return changeTypeSupported; });
/* harmony import */ var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/mediasource-helper */ "./src/utils/mediasource-helper.ts");


function getSourceBuffer() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}

function isSupported() {
  var mediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__["getMediaSource"])();

  if (!mediaSource) {
    return false;
  }

  var sourceBuffer = getSourceBuffer();
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'); // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible

  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}
function changeTypeSupported() {
  var _sourceBuffer$prototy;

  var sourceBuffer = getSourceBuffer();
  return typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) === 'function';
}

/***/ }),

/***/ "./src/loader/fragment-loader.ts":
/*!***************************************!*\
  !*** ./src/loader/fragment-loader.ts ***!
  \***************************************/
/*! exports provided: default, LoadError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FragmentLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadError", function() { return LoadError; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");



function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb

var FragmentLoader = /*#__PURE__*/function () {
  function FragmentLoader(config) {
    this.config = void 0;
    this.loader = null;
    this.partLoadTimeout = -1;
    this.config = config;
  }

  var _proto = FragmentLoader.prototype;

  _proto.abort = function abort() {
    if (this.loader) {
      // Abort the loader for current fragment. Only one may load at any given time
      this.loader.abort();
    }
  };

  _proto.load = function load(frag, _onProgress) {
    var _this = this;

    var url = frag.url;

    if (!url) {
      return Promise.reject(new LoadError({
        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR,
        fatal: false,
        frag: frag,
        networkDetails: null
      }, "Fragment does not have a " + (url ? 'part list' : 'url')));
    }

    this.abort();
    var config = this.config;
    var FragmentILoader = config.fLoader;
    var DefaultILoader = config.loader;
    return new Promise(function (resolve, reject) {
      var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      var loaderContext = createLoaderContext(frag);
      var loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
        highWaterMark: MIN_CHUNK_SIZE
      }; // Assign frag stats to the loader's stats reference

      frag.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: function onSuccess(response, stats, context, networkDetails) {
          _this.resetLoader(frag, loader);

          resolve({
            frag: frag,
            part: null,
            payload: response.data,
            networkDetails: networkDetails
          });
        },
        onError: function onError(response, context, networkDetails) {
          _this.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR,
            fatal: false,
            frag: frag,
            response: response,
            networkDetails: networkDetails
          }));
        },
        onAbort: function onAbort(stats, context, networkDetails) {
          _this.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_ABORTED,
            fatal: false,
            frag: frag,
            networkDetails: networkDetails
          }));
        },
        onTimeout: function onTimeout(response, context, networkDetails) {
          _this.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag: frag,
            networkDetails: networkDetails
          }));
        },
        onProgress: function onProgress(stats, context, data, networkDetails) {
          if (_onProgress) {
            _onProgress({
              frag: frag,
              part: null,
              payload: data,
              networkDetails: networkDetails
            });
          }
        }
      });
    });
  };

  _proto.loadPart = function loadPart(frag, part, onProgress) {
    var _this2 = this;

    this.abort();
    var config = this.config;
    var FragmentILoader = config.fLoader;
    var DefaultILoader = config.loader;
    return new Promise(function (resolve, reject) {
      var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      var loaderContext = createLoaderContext(frag, part);
      var loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
        highWaterMark: MIN_CHUNK_SIZE
      }; // Assign part stats to the loader's stats reference

      part.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: function onSuccess(response, stats, context, networkDetails) {
          _this2.resetLoader(frag, loader);

          _this2.updateStatsFromPart(frag, part);

          var partLoadedData = {
            frag: frag,
            part: part,
            payload: response.data,
            networkDetails: networkDetails
          };
          onProgress(partLoadedData);
          resolve(partLoadedData);
        },
        onError: function onError(response, context, networkDetails) {
          _this2.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR,
            fatal: false,
            frag: frag,
            part: part,
            response: response,
            networkDetails: networkDetails
          }));
        },
        onAbort: function onAbort(stats, context, networkDetails) {
          frag.stats.aborted = part.stats.aborted;

          _this2.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_ABORTED,
            fatal: false,
            frag: frag,
            part: part,
            networkDetails: networkDetails
          }));
        },
        onTimeout: function onTimeout(response, context, networkDetails) {
          _this2.resetLoader(frag, loader);

          reject(new LoadError({
            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag: frag,
            part: part,
            networkDetails: networkDetails
          }));
        }
      });
    });
  };

  _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
    var fragStats = frag.stats;
    var partStats = part.stats;
    var partTotal = partStats.total;
    fragStats.loaded += partStats.loaded;

    if (partTotal) {
      var estTotalParts = Math.round(frag.duration / part.duration);
      var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
      var estRemainingParts = estTotalParts - estLoadedParts;
      var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
      fragStats.total = fragStats.loaded + estRemainingBytes;
    } else {
      fragStats.total = Math.max(fragStats.loaded, fragStats.total);
    }

    var fragLoading = fragStats.loading;
    var partLoading = partStats.loading;

    if (fragLoading.start) {
      // add to fragment loader latency
      fragLoading.first += partLoading.first - partLoading.start;
    } else {
      fragLoading.start = partLoading.start;
      fragLoading.first = partLoading.first;
    }

    fragLoading.end = partLoading.end;
  };

  _proto.resetLoader = function resetLoader(frag, loader) {
    frag.loader = null;

    if (this.loader === loader) {
      self.clearTimeout(this.partLoadTimeout);
      this.loader = null;
    }
  };

  return FragmentLoader;
}();



function createLoaderContext(frag, part) {
  if (part === void 0) {
    part = null;
  }

  var segment = part || frag;
  var loaderContext = {
    frag: frag,
    part: part,
    responseType: 'arraybuffer',
    url: segment.url,
    rangeStart: 0,
    rangeEnd: 0
  };
  var start = segment.byteRangeStartOffset;
  var end = segment.byteRangeEndOffset;

  if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(start) && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(end)) {
    loaderContext.rangeStart = start;
    loaderContext.rangeEnd = end;
  }

  return loaderContext;
}

var LoadError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(LoadError, _Error);

  function LoadError(data) {
    var _this3;

    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }

    _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;
    _this3.data = void 0;
    _this3.data = data;
    return _this3;
  }

  return LoadError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/***/ }),

/***/ "./src/loader/fragment.ts":
/*!********************************!*\
  !*** ./src/loader/fragment.ts ***!
  \********************************/
/*! exports provided: ElementaryStreamTypes, BaseSegment, default, Part */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ElementaryStreamTypes", function() { return ElementaryStreamTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseSegment", function() { return BaseSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Part", function() { return Part; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.ts");
/* harmony import */ var _load_stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./load-stats */ "./src/loader/load-stats.ts");



function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var ElementaryStreamTypes;

(function (ElementaryStreamTypes) {
  ElementaryStreamTypes["AUDIO"] = "audio";
  ElementaryStreamTypes["VIDEO"] = "video";
  ElementaryStreamTypes["AUDIOVIDEO"] = "audiovideo";
})(ElementaryStreamTypes || (ElementaryStreamTypes = {}));

var BaseSegment = /*#__PURE__*/function () {
  // baseurl is the URL to the playlist
  // relurl is the portion of the URL that comes from inside the playlist.
  // Holds the types of data this fragment supports
  function BaseSegment(baseurl) {
    var _this$elementaryStrea;

    this._byteRange = null;
    this._url = null;
    this.baseurl = void 0;
    this.relurl = void 0;
    this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);
    this.baseurl = baseurl;
  } // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array


  var _proto = BaseSegment.prototype;

  _proto.setByteRange = function setByteRange(value, previous) {
    var params = value.split('@', 2);
    var byteRange = [];

    if (params.length === 1) {
      byteRange[0] = previous ? previous.byteRangeEndOffset : 0;
    } else {
      byteRange[0] = parseInt(params[1]);
    }

    byteRange[1] = parseInt(params[0]) + byteRange[0];
    this._byteRange = byteRange;
  };

  _createClass(BaseSegment, [{
    key: "byteRange",
    get: function get() {
      if (!this._byteRange) {
        return [];
      }

      return this._byteRange;
    }
  }, {
    key: "byteRangeStartOffset",
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: "byteRangeEndOffset",
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: "url",
    get: function get() {
      if (!this._url && this.baseurl && this.relurl) {
        this._url = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_1__["buildAbsoluteURL"])(this.baseurl, this.relurl, {
          alwaysNormalize: true
        });
      }

      return this._url || '';
    },
    set: function set(value) {
      this._url = value;
    }
  }]);

  return BaseSegment;
}();

var Fragment = /*#__PURE__*/function (_BaseSegment) {
  _inheritsLoose(Fragment, _BaseSegment);

  // EXTINF has to be present for a m38 to be considered valid
  // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'
  // levelkey is the EXT-X-KEY that applies to this segment for decryption
  // core difference from the private field _decryptdata is the lack of the initialized IV
  // _decryptdata will set the IV for this segment based on the segment number in the fragment
  // A string representing the fragment type
  // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading
  // The level/track index to which the fragment belongs
  // The continuity counter of the fragment
  // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.
  // The latest Presentation Time Stamp (PTS) appended to the buffer.
  // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.
  // The start time of the fragment, as listed in the manifest. Updated after transmux complete.
  // Set by `updateFragPTSDTS` in level-helper
  // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.
  // Load/parse timing information
  // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered
  // #EXTINF  segment title
  function Fragment(type, baseurl) {
    var _this;

    _this = _BaseSegment.call(this, baseurl) || this;
    _this._decryptdata = null;
    _this.rawProgramDateTime = null;
    _this.programDateTime = null;
    _this.tagList = [];
    _this.duration = 0;
    _this.sn = 0;
    _this.levelkey = void 0;
    _this.type = void 0;
    _this.loader = null;
    _this.level = -1;
    _this.cc = 0;
    _this.startPTS = void 0;
    _this.endPTS = void 0;
    _this.appendedPTS = void 0;
    _this.startDTS = void 0;
    _this.endDTS = void 0;
    _this.start = 0;
    _this.deltaPTS = void 0;
    _this.maxStartPTS = void 0;
    _this.minEndPTS = void 0;
    _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__["default"]();
    _this.urlId = 0;
    _this.data = void 0;
    _this.bitrateTest = false;
    _this.title = null;
    _this.type = type;
    return _this;
  }

  var _proto2 = Fragment.prototype;

  /**
   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
   * @param {number} segmentNumber - segment number to generate IV with
   * @returns {Uint8Array}
   */
  _proto2.createInitializationVector = function createInitializationVector(segmentNumber) {
    var uint8View = new Uint8Array(16);

    for (var i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
    }

    return uint8View;
  }
  /**
   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
   * @param levelkey - a playlist's encryption info
   * @param segmentNumber - the fragment's segment number
   * @returns {LevelKey} - an object to be applied as a fragment's decryptdata
   */
  ;

  _proto2.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(levelkey, segmentNumber) {
    var decryptdata = levelkey;

    if ((levelkey === null || levelkey === void 0 ? void 0 : levelkey.method) === 'AES-128' && levelkey.uri && !levelkey.iv) {
      decryptdata = _level_key__WEBPACK_IMPORTED_MODULE_3__["default"].fromURI(levelkey.uri);
      decryptdata.method = levelkey.method;
      decryptdata.iv = this.createInitializationVector(segmentNumber);
      decryptdata.keyFormat = 'identity';
    }

    return decryptdata;
  };

  _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
    if (partial === void 0) {
      partial = false;
    }

    var elementaryStreams = this.elementaryStreams;
    var info = elementaryStreams[type];

    if (!info) {
      elementaryStreams[type] = {
        startPTS: startPTS,
        endPTS: endPTS,
        startDTS: startDTS,
        endDTS: endDTS,
        partial: partial
      };
      return;
    }

    info.startPTS = Math.min(info.startPTS, startPTS);
    info.endPTS = Math.max(info.endPTS, endPTS);
    info.startDTS = Math.min(info.startDTS, startDTS);
    info.endDTS = Math.max(info.endDTS, endDTS);
  };

  _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
    var elementaryStreams = this.elementaryStreams;
    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
  };

  _createClass(Fragment, [{
    key: "decryptdata",
    get: function get() {
      if (!this.levelkey && !this._decryptdata) {
        return null;
      }

      if (!this._decryptdata && this.levelkey) {
        var sn = this.sn;

        if (typeof sn !== 'number') {
          // We are fetching decryption data for a initialization segment
          // If the segment was encrypted with AES-128
          // It must have an IV defined. We cannot substitute the Segment Number in.
          if (this.levelkey && this.levelkey.method === 'AES-128' && !this.levelkey.iv) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("missing IV for initialization segment with method=\"" + this.levelkey.method + "\" - compliance issue");
          }
          /*
          Be converted to a Number.
          'initSegment' will become NaN.
          NaN, which when converted through ToInt32() -> +0.
          ---
          Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.
          */


          sn = 0;
        }

        this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, sn);
      }

      return this._decryptdata;
    }
  }, {
    key: "end",
    get: function get() {
      return this.start + this.duration;
    }
  }, {
    key: "endProgramDateTime",
    get: function get() {
      if (this.programDateTime === null) {
        return null;
      }

      if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.programDateTime)) {
        return null;
      }

      var duration = !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.duration) ? 0 : this.duration;
      return this.programDateTime + duration * 1000;
    }
  }, {
    key: "encrypted",
    get: function get() {
      var _this$decryptdata;

      // At the m3u8-parser level we need to add support for manifest signalled keyformats
      // when we want the fragment to start reporting that it is encrypted.
      // Currently, keyFormat will only be set for identity keys
      if ((_this$decryptdata = this.decryptdata) !== null && _this$decryptdata !== void 0 && _this$decryptdata.keyFormat && this.decryptdata.uri) {
        return true;
      }

      return false;
    }
  }]);

  return Fragment;
}(BaseSegment);


var Part = /*#__PURE__*/function (_BaseSegment2) {
  _inheritsLoose(Part, _BaseSegment2);

  function Part(partAttrs, frag, baseurl, index, previous) {
    var _this2;

    _this2 = _BaseSegment2.call(this, baseurl) || this;
    _this2.fragOffset = 0;
    _this2.duration = 0;
    _this2.gap = false;
    _this2.independent = false;
    _this2.relurl = void 0;
    _this2.fragment = void 0;
    _this2.index = void 0;
    _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__["default"]();
    _this2.duration = partAttrs.decimalFloatingPoint('DURATION');
    _this2.gap = partAttrs.bool('GAP');
    _this2.independent = partAttrs.INDEPENDENT ? partAttrs.bool('INDEPENDENT') : true;
    _this2.relurl = partAttrs.enumeratedString('URI');
    _this2.fragment = frag;
    _this2.index = index;
    var byteRange = partAttrs.enumeratedString('BYTERANGE');

    if (byteRange) {
      _this2.setByteRange(byteRange, previous);
    }

    if (previous) {
      _this2.fragOffset = previous.fragOffset + previous.duration;
    }

    return _this2;
  }

  _createClass(Part, [{
    key: "start",
    get: function get() {
      return this.fragment.start + this.fragOffset;
    }
  }, {
    key: "end",
    get: function get() {
      return this.start + this.duration;
    }
  }, {
    key: "loaded",
    get: function get() {
      var elementaryStreams = this.elementaryStreams;
      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
    }
  }]);

  return Part;
}(BaseSegment);

/***/ }),

/***/ "./src/loader/key-loader.ts":
/*!**********************************!*\
  !*** ./src/loader/key-loader.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyLoader; });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * Decrypt key Loader
 */




var KeyLoader = /*#__PURE__*/function () {
  function KeyLoader(hls) {
    this.hls = void 0;
    this.loaders = {};
    this.decryptkey = null;
    this.decrypturl = null;
    this.hls = hls;

    this._registerListeners();
  }

  var _proto = KeyLoader.prototype;

  _proto._registerListeners = function _registerListeners() {
    this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADING, this.onKeyLoading, this);
  };

  _proto._unregisterListeners = function _unregisterListeners() {
    this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADING, this.onKeyLoading);
  };

  _proto.destroy = function destroy() {
    this._unregisterListeners();

    for (var loaderName in this.loaders) {
      var loader = this.loaders[loaderName];

      if (loader) {
        loader.destroy();
      }
    }

    this.loaders = {};
  };

  _proto.onKeyLoading = function onKeyLoading(event, data) {
    var frag = data.frag;
    var type = frag.type;
    var loader = this.loaders[type];

    if (!frag.decryptdata) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('Missing decryption data on fragment in onKeyLoading');
      return;
    } // Load the key if the uri is different from previous one, or if the decrypt key has not yet been retrieved


    var uri = frag.decryptdata.uri;

    if (uri !== this.decrypturl || this.decryptkey === null) {
      var config = this.hls.config;

      if (loader) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("abort previous key loader for type:" + type);
        loader.abort();
      }

      if (!uri) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('key uri is falsy');
        return;
      }

      var Loader = config.loader;
      console.log(config);
      var fragLoader = frag.loader = this.loaders[type] = new Loader( // config
      _objectSpread(_objectSpread({}, config), config.keyRequest));
      this.decrypturl = uri;
      this.decryptkey = null;
      var loaderContext = {
        url: uri,
        frag: frag,
        responseType: 'arraybuffer'
      }; // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,
      // key-loader will trigger an error and rely on stream-controller to handle retry logic.
      // this will also align retry logic with fragment-loader

      var loaderConfig = {
        timeout: config.fragLoadingTimeOut,
        maxRetry: 0,
        retryDelay: config.fragLoadingRetryDelay,
        maxRetryDelay: config.fragLoadingMaxRetryTimeout,
        highWaterMark: 0
      };
      var loaderCallbacks = {
        onSuccess: this.loadsuccess.bind(this),
        onError: this.loaderror.bind(this),
        onTimeout: this.loadtimeout.bind(this)
      };
      console.log('data', loaderConfig, loaderContext);
      fragLoader.load(loaderContext, loaderConfig, loaderCallbacks);
    } else if (this.decryptkey) {
      // Return the key if it's already been loaded
      frag.decryptdata.key = this.decryptkey;
      this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADED, {
        frag: frag
      });
    }
  };

  _proto.loadsuccess = function loadsuccess(response, stats, context) {
    var frag = context.frag;

    if (!frag.decryptdata) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('after key load, decryptdata unset');
      return;
    }

    this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data); // detach fragment loader on load success

    frag.loader = null;
    delete this.loaders[frag.type];
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADED, {
      frag: frag
    });
  };

  _proto.loaderror = function loaderror(response, context) {
    var frag = context.frag;
    var loader = frag.loader;

    if (loader) {
      loader.abort();
    }

    delete this.loaders[frag.type];
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
      type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
      details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_LOAD_ERROR,
      fatal: false,
      frag: frag,
      response: response
    });
  };

  _proto.loadtimeout = function loadtimeout(stats, context) {
    var frag = context.frag;
    var loader = frag.loader;

    if (loader) {
      loader.abort();
    }

    delete this.loaders[frag.type];
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
      type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
      details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_LOAD_TIMEOUT,
      fatal: false,
      frag: frag
    });
  };

  return KeyLoader;
}();



/***/ }),

/***/ "./src/loader/level-details.ts":
/*!*************************************!*\
  !*** ./src/loader/level-details.ts ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelDetails; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULT_TARGET_DURATION = 10;

var LevelDetails = /*#__PURE__*/function () {
  // Manifest reload synchronization
  function LevelDetails(baseUrl) {
    this.PTSKnown = false;
    this.alignedSliding = false;
    this.averagetargetduration = void 0;
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = void 0;
    this.fragmentHint = void 0;
    this.partList = null;
    this.initSegment = null;
    this.live = true;
    this.ageHeader = 0;
    this.advancedDateTime = void 0;
    this.updated = true;
    this.advanced = true;
    this.availabilityDelay = void 0;
    this.misses = 0;
    this.needSidxRanges = false;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = void 0;
    this.m3u8 = '';
    this.version = null;
    this.canBlockReload = false;
    this.canSkipUntil = 0;
    this.canSkipDateRanges = false;
    this.skippedSegments = 0;
    this.recentlyRemovedDateranges = void 0;
    this.partHoldBack = 0;
    this.holdBack = 0;
    this.partTarget = 0;
    this.preloadHint = void 0;
    this.renditionReports = void 0;
    this.tuneInGoal = 0;
    this.deltaUpdateFailed = void 0;
    this.fragments = [];
    this.url = baseUrl;
  }

  var _proto = LevelDetails.prototype;

  _proto.reloaded = function reloaded(previous) {
    if (!previous) {
      this.advanced = true;
      this.updated = true;
      return;
    }

    var partSnDiff = this.lastPartSn - previous.lastPartSn;
    var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;
    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;

    if (this.updated || this.advanced) {
      this.misses = Math.floor(previous.misses * 0.6);
    } else {
      this.misses = previous.misses + 1;
    }

    this.availabilityDelay = previous.availabilityDelay;
  };

  _createClass(LevelDetails, [{
    key: "hasProgramDateTime",
    get: function get() {
      if (this.fragments.length) {
        return Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.fragments[this.fragments.length - 1].programDateTime);
      }

      return false;
    }
  }, {
    key: "levelTargetDuration",
    get: function get() {
      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
    }
  }, {
    key: "edge",
    get: function get() {
      return this.partEnd || this.fragmentEnd;
    }
  }, {
    key: "partEnd",
    get: function get() {
      var _this$partList;

      if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {
        return this.partList[this.partList.length - 1].end;
      }

      return this.fragmentEnd;
    }
  }, {
    key: "fragmentEnd",
    get: function get() {
      var _this$fragments;

      if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {
        return this.fragments[this.fragments.length - 1].end;
      }

      return 0;
    }
  }, {
    key: "age",
    get: function get() {
      if (this.advancedDateTime) {
        return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;
      }

      return 0;
    }
  }, {
    key: "lastPartIndex",
    get: function get() {
      var _this$partList2;

      if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {
        return this.partList[this.partList.length - 1].index;
      }

      return -1;
    }
  }, {
    key: "lastPartSn",
    get: function get() {
      var _this$partList3;

      if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {
        return this.partList[this.partList.length - 1].fragment.sn;
      }

      return this.endSN;
    }
  }]);

  return LevelDetails;
}();



/***/ }),

/***/ "./src/loader/level-key.ts":
/*!*********************************!*\
  !*** ./src/loader/level-key.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LevelKey; });
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var LevelKey = /*#__PURE__*/function () {
  LevelKey.fromURL = function fromURL(baseUrl, relativeUrl) {
    return new LevelKey(baseUrl, relativeUrl);
  };

  LevelKey.fromURI = function fromURI(uri) {
    return new LevelKey(uri);
  };

  function LevelKey(absoluteOrBaseURI, relativeURL) {
    this._uri = null;
    this.method = null;
    this.keyFormat = null;
    this.keyFormatVersions = null;
    this.keyID = null;
    this.key = null;
    this.iv = null;

    if (relativeURL) {
      this._uri = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_0__["buildAbsoluteURL"])(absoluteOrBaseURI, relativeURL, {
        alwaysNormalize: true
      });
    } else {
      this._uri = absoluteOrBaseURI;
    }
  }

  _createClass(LevelKey, [{
    key: "uri",
    get: function get() {
      return this._uri;
    }
  }]);

  return LevelKey;
}();



/***/ }),

/***/ "./src/loader/load-stats.ts":
/*!**********************************!*\
  !*** ./src/loader/load-stats.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LoadStats; });
var LoadStats = function LoadStats() {
  this.aborted = false;
  this.loaded = 0;
  this.retry = 0;
  this.total = 0;
  this.chunkCount = 0;
  this.bwEstimate = 0;
  this.loading = {
    start: 0,
    first: 0,
    end: 0
  };
  this.parsing = {
    start: 0,
    end: 0
  };
  this.buffering = {
    start: 0,
    first: 0,
    end: 0
  };
};



/***/ }),

/***/ "./src/loader/m3u8-parser.ts":
/*!***********************************!*\
  !*** ./src/loader/m3u8-parser.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return M3U8Parser; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url-toolkit */ "./node_modules/url-toolkit/src/url-toolkit.js");
/* harmony import */ var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _fragment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragment */ "./src/loader/fragment.ts");
/* harmony import */ var _level_details__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./level-details */ "./src/loader/level-details.ts");
/* harmony import */ var _level_key__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./level-key */ "./src/loader/level-key.ts");
/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/attr-list */ "./src/utils/attr-list.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_codecs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/codecs */ "./src/utils/codecs.ts");











// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/(?!#) *(\S[\S ]*)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/#.*/.source // All other non-segment oriented tags will match with all groups empty
].join('|'), 'g');
var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\s*(\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join('|'));
var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;

var M3U8Parser = /*#__PURE__*/function () {
  function M3U8Parser() {}

  M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {
    for (var i = 0; i < groups.length; i++) {
      var group = groups[i];

      if (group.id === mediaGroupId) {
        return group;
      }
    }
  };

  M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
    var avcdata = codec.split('.');
    var result;

    if (avcdata.length > 2) {
      result = avcdata.shift() + '.';
      result += parseInt(avcdata.shift()).toString(16);
      result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
    } else {
      result = codec;
    }

    return result;
  };

  M3U8Parser.resolve = function resolve(url, baseUrl) {
    return url_toolkit__WEBPACK_IMPORTED_MODULE_1__["buildAbsoluteURL"](baseUrl, url, {
      alwaysNormalize: true
    });
  };

  M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
    var levels = [];
    var sessionData = {};
    var hasSessionData = false;
    MASTER_PLAYLIST_REGEX.lastIndex = 0;
    var result;

    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
      if (result[1]) {
        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1
        var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](result[1]);
        var level = {
          attrs: attrs,
          bitrate: attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH'),
          name: attrs.NAME,
          url: M3U8Parser.resolve(result[2], baseurl)
        };
        var resolution = attrs.decimalResolution('RESOLUTION');

        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }

        setCodecs((attrs.CODECS || '').split(/[ ,]+/).filter(function (c) {
          return c;
        }), level);

        if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
          level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
        }

        levels.push(level);
      } else if (result[3]) {
        // '#EXT-X-SESSION-DATA' is found, parse session data in group 3
        var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](result[3]);

        if (sessionAttrs['DATA-ID']) {
          hasSessionData = true;
          sessionData[sessionAttrs['DATA-ID']] = sessionAttrs;
        }
      }
    }

    return {
      levels: levels,
      sessionData: hasSessionData ? sessionData : null
    };
  };

  M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {
    if (groups === void 0) {
      groups = [];
    }

    var result;
    var medias = [];
    var id = 0;
    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;

    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
      var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](result[1]);

      if (attrs.TYPE === type) {
        var media = {
          attrs: attrs,
          bitrate: 0,
          id: id++,
          groupId: attrs['GROUP-ID'],
          instreamId: attrs['INSTREAM-ID'],
          name: attrs.NAME || attrs.LANGUAGE || '',
          type: type,
          default: attrs.bool('DEFAULT'),
          autoselect: attrs.bool('AUTOSELECT'),
          forced: attrs.bool('FORCED'),
          lang: attrs.LANGUAGE,
          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''
        };

        if (groups.length) {
          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track
          // If we don't find the track signalled, lets use the first audio groups codec we have
          // Acting as a best guess
          var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
          assignCodec(media, groupCodec, 'audioCodec');
          assignCodec(media, groupCodec, 'textCodec');
        }

        medias.push(media);
      }
    }

    return medias;
  };

  M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
    var level = new _level_details__WEBPACK_IMPORTED_MODULE_3__["default"](baseurl);
    var fragments = level.fragments;
    var currentSN = 0;
    var currentPart = 0;
    var totalduration = 0;
    var discontinuityCounter = 0;
    var prevFrag = null;
    var frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__["default"](type, baseurl);
    var result;
    var i;
    var levelkey;
    var firstPdtIndex = -1;
    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
    level.m3u8 = string;

    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      var duration = result[1];

      if (duration) {
        // INF
        frag.duration = parseFloat(duration); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939

        var title = (' ' + result[2]).slice(1);
        frag.title = title || null;
        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
      } else if (result[3]) {
        // url
        if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.duration)) {
          frag.start = totalduration;

          if (levelkey) {
            frag.levelkey = levelkey;
          }

          frag.sn = currentSN;
          frag.level = id;
          frag.cc = discontinuityCounter;
          frag.urlId = levelUrlId;
          fragments.push(frag); // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939

          frag.relurl = (' ' + result[3]).slice(1);
          assignProgramDateTime(frag, prevFrag);
          prevFrag = frag;
          totalduration += frag.duration;
          currentSN++;
          currentPart = 0;
          frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__["default"](type, baseurl); // setup the next fragment for part loading

          frag.start = totalduration;
          frag.sn = currentSN;
          frag.cc = discontinuityCounter;
          frag.level = id;
        }
      } else if (result[4]) {
        // X-BYTERANGE
        var data = (' ' + result[4]).slice(1);

        if (prevFrag) {
          frag.setByteRange(data, prevFrag);
        } else {
          frag.setByteRange(data);
        }
      } else if (result[5]) {
        // PROGRAM-DATE-TIME
        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        frag.rawProgramDateTime = (' ' + result[5]).slice(1);
        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);

        if (firstPdtIndex === -1) {
          firstPdtIndex = fragments.length;
        }
      } else {
        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);

        if (!result) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn('No matches on slow regex match for level playlist!');
          continue;
        }

        for (i = 1; i < result.length; i++) {
          if (typeof result[i] !== 'undefined') {
            break;
          }
        } // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939


        var tag = (' ' + result[i]).slice(1);
        var value1 = (' ' + result[i + 1]).slice(1);
        var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';

        switch (tag) {
          case 'PLAYLIST-TYPE':
            level.type = value1.toUpperCase();
            break;

          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(value1);
            break;

          case 'SKIP':
            {
              var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');

              if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(skippedSegments)) {
                level.skippedSegments = skippedSegments; // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`

                for (var _i = skippedSegments; _i--;) {
                  fragments.unshift(null);
                }

                currentSN += skippedSegments;
              }

              var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');

              if (recentlyRemovedDateranges) {
                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\t');
              }

              break;
            }

          case 'TARGETDURATION':
            level.targetduration = parseFloat(value1);
            break;

          case 'VERSION':
            level.version = parseInt(value1);
            break;

          case 'EXTM3U':
            break;

          case 'ENDLIST':
            level.live = false;
            break;

          case '#':
            if (value1 || value2) {
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
            }

            break;

          case 'DIS':
            discontinuityCounter++;

          /* falls through */

          case 'GAP':
            frag.tagList.push([tag]);
            break;

          case 'BITRATE':
            frag.tagList.push([tag, value1]);
            break;

          case 'DISCONTINUITY-SEQ':
            discontinuityCounter = parseInt(value1);
            break;

          case 'KEY':
            {
              var _keyAttrs$enumeratedS;

              // https://tools.ietf.org/html/rfc8216#section-4.3.2.4
              var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              var decryptmethod = keyAttrs.enumeratedString('METHOD');
              var decrypturi = keyAttrs.URI;
              var decryptiv = keyAttrs.hexadecimalInteger('IV');
              var decryptkeyformatversions = keyAttrs.enumeratedString('KEYFORMATVERSIONS');
              var decryptkeyid = keyAttrs.enumeratedString('KEYID'); // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of "identity".

              var decryptkeyformat = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString('KEYFORMAT')) != null ? _keyAttrs$enumeratedS : 'identity';
              var unsupportedKnownKeyformatsInManifest = ['com.apple.streamingkeydelivery', 'com.microsoft.playready', 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed', // widevine (v2)
              'com.widevine' // earlier widevine (v1)
              ];

              if (unsupportedKnownKeyformatsInManifest.indexOf(decryptkeyformat) > -1) {
                _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("Keyformat " + decryptkeyformat + " is not supported from the manifest");
                continue;
              } else if (decryptkeyformat !== 'identity') {
                // We are supposed to skip keys we don't understand.
                // As we currently only officially support identity keys
                // from the manifest we shouldn't save any other key.
                continue;
              } // TODO: multiple keys can be defined on a fragment, and we need to support this
              // for clients that support both playready and widevine


              if (decryptmethod) {
                // TODO: need to determine if the level key is actually a relative URL
                // if it isn't, then we should instead construct the LevelKey using fromURI.
                levelkey = _level_key__WEBPACK_IMPORTED_MODULE_4__["default"].fromURL(baseurl, decrypturi);

                if (decrypturi && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(decryptmethod) >= 0) {
                  levelkey.method = decryptmethod;
                  levelkey.keyFormat = decryptkeyformat;

                  if (decryptkeyid) {
                    levelkey.keyID = decryptkeyid;
                  }

                  if (decryptkeyformatversions) {
                    levelkey.keyFormatVersions = decryptkeyformatversions;
                  } // Initialization Vector (IV)


                  levelkey.iv = decryptiv;
                }
              }

              break;
            }

          case 'START':
            {
              var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET'); // TIME-OFFSET can be 0

              if (Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(startTimeOffset)) {
                level.startTimeOffset = startTimeOffset;
              }

              break;
            }

          case 'MAP':
            {
              var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              frag.relurl = mapAttrs.URI;

              if (mapAttrs.BYTERANGE) {
                frag.setByteRange(mapAttrs.BYTERANGE);
              }

              frag.level = id;
              frag.sn = 'initSegment';

              if (levelkey) {
                frag.levelkey = levelkey;
              }

              level.initSegment = frag;
              frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__["default"](type, baseurl);
              frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
              break;
            }

          case 'SERVER-CONTROL':
            {
              var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');
              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);
              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');
              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);
              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);
              break;
            }

          case 'PART-INF':
            {
              var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');
              break;
            }

          case 'PART':
            {
              var partList = level.partList;

              if (!partList) {
                partList = level.partList = [];
              }

              var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
              var index = currentPart++;
              var part = new _fragment__WEBPACK_IMPORTED_MODULE_2__["Part"](new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1), frag, baseurl, index, previousFragmentPart);
              partList.push(part);
              frag.duration += part.duration;
              break;
            }

          case 'PRELOAD-HINT':
            {
              var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              level.preloadHint = preloadHintAttrs;
              break;
            }

          case 'RENDITION-REPORT':
            {
              var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_5__["default"](value1);
              level.renditionReports = level.renditionReports || [];
              level.renditionReports.push(renditionReportAttrs);
              break;
            }

          default:
            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("line parsed but not handled: " + result);
            break;
        }
      }
    }

    if (prevFrag && !prevFrag.relurl) {
      fragments.pop();
      totalduration -= prevFrag.duration;
      level.fragmentHint = prevFrag;
    } else {
      level.fragmentHint = frag;
    }

    var fragmentLength = fragments.length;
    var firstFragment = fragments[0];
    var lastFragment = fragments[fragmentLength - 1];
    totalduration += level.skippedSegments * level.targetduration;

    if (totalduration > 0 && fragmentLength && lastFragment) {
      level.averagetargetduration = totalduration / fragmentLength;
      var lastSn = lastFragment.sn;
      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;

      if (firstFragment) {
        level.startCC = firstFragment.cc;

        if (!level.initSegment) {
          // this is a bit lurky but HLS really has no other way to tell us
          // if the fragments are TS or MP4, except if we download them :/
          // but this is to be able to handle SIDX.
          if (level.fragments.every(function (frag) {
            return MP4_REGEX_SUFFIX.test(frag.relurl);
          })) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX');
            frag = new _fragment__WEBPACK_IMPORTED_MODULE_2__["default"](type, baseurl);
            frag.relurl = lastFragment.relurl;
            frag.level = id;
            frag.sn = 'initSegment';
            level.initSegment = frag;
            level.needSidxRanges = true;
          }
        }
      }
    } else {
      level.endSN = 0;
      level.startCC = 0;
    }

    if (level.partList) {
      totalduration += level.fragmentHint.duration;
    }

    level.totalduration = totalduration;
    level.endCC = discontinuityCounter;
    /**
     * Backfill any missing PDT values
     * "If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after
     * one or more Media Segment URIs, the client SHOULD extrapolate
     * backward from that tag (using EXTINF durations and/or media
     * timestamps) to associate dates with those segments."
     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs
     * computed.
     */

    if (firstPdtIndex > 0) {
      backfillProgramDateTimes(fragments, firstPdtIndex);
    }

    return level;
  };

  return M3U8Parser;
}();



function setCodecs(codecs, level) {
  ['video', 'audio', 'text'].forEach(function (type) {
    var filtered = codecs.filter(function (codec) {
      return Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_7__["isCodecType"])(codec, type);
    });

    if (filtered.length) {
      var preferred = filtered.filter(function (codec) {
        return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
      });
      level[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0]; // remove from list

      codecs = codecs.filter(function (codec) {
        return filtered.indexOf(codec) === -1;
      });
    }
  });
  level.unknownCodecs = codecs;
}

function assignCodec(media, groupItem, codecProperty) {
  var codecValue = groupItem[codecProperty];

  if (codecValue) {
    media[codecProperty] = codecValue;
  }
}

function backfillProgramDateTimes(fragments, firstPdtIndex) {
  var fragPrev = fragments[firstPdtIndex];

  for (var i = firstPdtIndex; i--;) {
    var frag = fragments[i]; // Exit on delta-playlist skipped segments

    if (!frag) {
      return;
    }

    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}

function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }

  if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}

/***/ }),

/***/ "./src/loader/playlist-loader.ts":
/*!***************************************!*\
  !*** ./src/loader/playlist-loader.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./m3u8-parser */ "./src/loader/m3u8-parser.ts");
/* harmony import */ var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../types/loader */ "./src/types/loader.ts");
/* harmony import */ var _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/attr-list */ "./src/utils/attr-list.ts");



/**
 * PlaylistLoader - delegate for media manifest/playlist loading tasks. Takes care of parsing media to internal data-models.
 *
 * Once loaded, dispatches events with parsed data-models of manifest/levels/audio/subtitle tracks.
 *
 * Uses loader(s) set in config to do actual internal loading of resource tasks.
 *
 * @module
 *
 */








function mapContextToLevelType(context) {
  var type = context.type;

  switch (type) {
    case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
      return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO;

    case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
      return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].SUBTITLE;

    default:
      return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN;
  }
}

function getResponseUrl(response, context) {
  var url = response.url; // responseURL not supported on some browsers (it is used to detect URL redirection)
  // data-uri mode also not supported (but no need to detect redirection)

  if (url === undefined || url.indexOf('data:') === 0) {
    // fallback to initial URL
    url = context.url;
  }

  return url;
}

var PlaylistLoader = /*#__PURE__*/function () {
  function PlaylistLoader(hls) {
    this.hls = void 0;
    this.loaders = Object.create(null);
    this.checkAgeHeader = true;
    this.hls = hls;
    this.registerListeners();
  }

  var _proto = PlaylistLoader.prototype;

  _proto.registerListeners = function registerListeners() {
    var hls = this.hls;
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  };

  _proto.unregisterListeners = function unregisterListeners() {
    var hls = this.hls;
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  ;

  _proto.createInternalLoader = function createInternalLoader(context) {
    var config = this.hls.config;
    var PLoader = config.pLoader;
    var Loader = config.loader;
    var InternalLoader = PLoader || Loader;
    var loader = new InternalLoader(config);
    context.loader = loader;
    this.loaders[context.type] = loader;
    return loader;
  };

  _proto.getInternalLoader = function getInternalLoader(context) {
    return this.loaders[context.type];
  };

  _proto.resetInternalLoader = function resetInternalLoader(contextType) {
    if (this.loaders[contextType]) {
      delete this.loaders[contextType];
    }
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  ;

  _proto.destroyInternalLoaders = function destroyInternalLoaders() {
    for (var contextType in this.loaders) {
      var loader = this.loaders[contextType];

      if (loader) {
        loader.destroy();
      }

      this.resetInternalLoader(contextType);
    }
  };

  _proto.destroy = function destroy() {
    this.unregisterListeners();
    this.destroyInternalLoaders();
  };

  _proto.onManifestLoading = function onManifestLoading(event, data) {
    var url = data.url;
    this.checkAgeHeader = true;
    this.load({
      id: null,
      groupId: null,
      level: 0,
      responseType: 'text',
      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST,
      url: url,
      deliveryDirectives: null
    });
  };

  _proto.onLevelLoading = function onLevelLoading(event, data) {
    var id = data.id,
        level = data.level,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
    this.load({
      id: id,
      groupId: null,
      level: level,
      responseType: 'text',
      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL,
      url: url,
      deliveryDirectives: deliveryDirectives
    });
  };

  _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
    var id = data.id,
        groupId = data.groupId,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
    this.load({
      id: id,
      groupId: groupId,
      level: null,
      responseType: 'text',
      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK,
      url: url,
      deliveryDirectives: deliveryDirectives
    });
  };

  _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
    var id = data.id,
        groupId = data.groupId,
        url = data.url,
        deliveryDirectives = data.deliveryDirectives;
    this.load({
      id: id,
      groupId: groupId,
      level: null,
      responseType: 'text',
      type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK,
      url: url,
      deliveryDirectives: deliveryDirectives
    });
  };

  _proto.load = function load(context) {
    var _context$deliveryDire;

    var config = this.hls.config; // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);
    // Check if a loader for this context already exists

    var loader = this.getInternalLoader(context);

    if (loader) {
      var loaderContext = loader.context;

      if (loaderContext && loaderContext.url === context.url) {
        // same URL can't overlap
        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].trace('[playlist-loader]: playlist request ongoing');
        return;
      }

      _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[playlist-loader]: aborting previous loader for type: " + context.type);
      loader.abort();
    }

    var maxRetry;
    var timeout;
    var retryDelay;
    var maxRetryDelay; // apply different configs for retries depending on
    // context (manifest, level, audio/subs playlist)

    switch (context.type) {
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
        maxRetry = config.manifestLoadingMaxRetry;
        timeout = config.manifestLoadingTimeOut;
        retryDelay = config.manifestLoadingRetryDelay;
        maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
        // Manage retries in Level/Track Controller
        maxRetry = 0;
        timeout = config.levelLoadingTimeOut;
        break;

      default:
        maxRetry = config.levelLoadingMaxRetry;
        timeout = config.levelLoadingTimeOut;
        retryDelay = config.levelLoadingRetryDelay;
        maxRetryDelay = config.levelLoadingMaxRetryTimeout;
        break;
    }

    loader = this.createInternalLoader(context); // Override level/track timeout for LL-HLS requests
    // (the default of 10000ms is counter productive to blocking playlist reload requests)

    if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {
      var levelDetails;

      if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL && context.level !== null) {
        levelDetails = this.hls.levels[context.level].details;
      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK && context.id !== null) {
        levelDetails = this.hls.audioTracks[context.id].details;
      } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK && context.id !== null) {
        levelDetails = this.hls.subtitleTracks[context.id].details;
      }

      if (levelDetails) {
        var partTarget = levelDetails.partTarget;
        var targetDuration = levelDetails.targetduration;

        if (partTarget && targetDuration) {
          timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1000, timeout);
        }
      }
    }

    var loaderConfig = {
      timeout: timeout,
      maxRetry: maxRetry,
      retryDelay: retryDelay,
      maxRetryDelay: maxRetryDelay,
      highWaterMark: 0
    };
    var loaderCallbacks = {
      onSuccess: this.loadsuccess.bind(this),
      onError: this.loaderror.bind(this),
      onTimeout: this.loadtimeout.bind(this)
    }; // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);

    loader.load(context, loaderConfig, loaderCallbacks);
  };

  _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {
    if (networkDetails === void 0) {
      networkDetails = null;
    }

    if (context.isSidxRequest) {
      this.handleSidxRequest(response, context);
      this.handlePlaylistLoaded(response, stats, context, networkDetails);
      return;
    }

    this.resetInternalLoader(context.type);
    var string = response.data; // Validate if it is an M3U8 at all

    if (string.indexOf('#EXTM3U') !== 0) {
      this.handleManifestParsingError(response, context, 'no EXTM3U delimiter', networkDetails);
      return;
    }

    stats.parsing.start = performance.now(); // Check if chunk-list or master. handle empty chunk list case (first EXTINF not signaled, but TARGETDURATION present)

    if (string.indexOf('#EXTINF:') > 0 || string.indexOf('#EXT-X-TARGETDURATION:') > 0) {
      this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
    } else {
      this.handleMasterPlaylist(response, stats, context, networkDetails);
    }
  };

  _proto.loaderror = function loaderror(response, context, networkDetails) {
    if (networkDetails === void 0) {
      networkDetails = null;
    }

    this.handleNetworkError(context, networkDetails, false, response);
  };

  _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {
    if (networkDetails === void 0) {
      networkDetails = null;
    }

    this.handleNetworkError(context, networkDetails, true);
  };

  _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
    var hls = this.hls;
    var string = response.data;
    var url = getResponseUrl(response, context);

    var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylist(string, url),
        levels = _M3U8Parser$parseMast.levels,
        sessionData = _M3U8Parser$parseMast.sessionData;

    if (!levels.length) {
      this.handleManifestParsingError(response, context, 'no level found in manifest', networkDetails);
      return;
    } // multi level playlist, parse level info


    var audioGroups = levels.map(function (level) {
      return {
        id: level.attrs.AUDIO,
        audioCodec: level.audioCodec
      };
    });
    var subtitleGroups = levels.map(function (level) {
      return {
        id: level.attrs.SUBTITLES,
        textCodec: level.textCodec
      };
    });
    var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
    var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, 'SUBTITLES', subtitleGroups);
    var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, 'CLOSED-CAPTIONS');

    if (audioTracks.length) {
      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
      var embeddedAudioFound = audioTracks.some(function (audioTrack) {
        return !audioTrack.url;
      }); // if no embedded audio track defined, but audio codec signaled in quality level,
      // we need to signal this main audio track this could happen with playlists with
      // alt audio rendition in which quality levels (main)
      // contains both audio+video. but with mixed audio track not signaled

      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');
        audioTracks.unshift({
          type: 'main',
          name: 'main',
          default: false,
          autoselect: false,
          forced: false,
          id: -1,
          attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__["default"]({}),
          bitrate: 0,
          url: ''
        });
      }
    }

    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, {
      levels: levels,
      audioTracks: audioTracks,
      subtitles: subtitles,
      captions: captions,
      url: url,
      stats: stats,
      networkDetails: networkDetails,
      sessionData: sessionData
    });
  };

  _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
    var hls = this.hls;
    var id = context.id,
        level = context.level,
        type = context.type;
    var url = getResponseUrl(response, context);
    var levelUrlId = Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(id) ? id : 0;
    var levelId = Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(level) ? level : levelUrlId;
    var levelType = mapContextToLevelType(context);
    var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);

    if (!levelDetails.fragments.length) {
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_EMPTY_ERROR,
        fatal: false,
        url: url,
        reason: 'no fragments found in level',
        level: typeof context.level === 'number' ? context.level : undefined
      });
      return;
    } // We have done our first request (Manifest-type) and receive
    // not a master playlist but a chunk-list (track/level)
    // We fire the manifest-loaded event anyway with the parsed level-details
    // by creating a single-level structure for it.


    if (type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST) {
      var singleLevel = {
        attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__["default"]({}),
        bitrate: 0,
        details: levelDetails,
        name: '',
        url: url
      };
      hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, {
        levels: [singleLevel],
        audioTracks: [],
        url: url,
        stats: stats,
        networkDetails: networkDetails,
        sessionData: null
      });
    } // save parsing time


    stats.parsing.end = performance.now(); // in case we need SIDX ranges
    // return early after calling load for
    // the SIDX box.

    if (levelDetails.needSidxRanges) {
      var sidxUrl = levelDetails.initSegment.url;
      this.load({
        url: sidxUrl,
        isSidxRequest: true,
        type: type,
        level: level,
        levelDetails: levelDetails,
        id: id,
        groupId: null,
        rangeStart: 0,
        rangeEnd: 2048,
        responseType: 'arraybuffer',
        deliveryDirectives: null
      });
      return;
    } // extend the context with the new levelDetails property


    context.levelDetails = levelDetails;
    this.handlePlaylistLoaded(response, stats, context, networkDetails);
  };

  _proto.handleSidxRequest = function handleSidxRequest(response, context) {
    var sidxInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["parseSegmentIndex"])(new Uint8Array(response.data)); // if provided fragment does not contain sidx, early return

    if (!sidxInfo) {
      return;
    }

    var sidxReferences = sidxInfo.references;
    var levelDetails = context.levelDetails;
    sidxReferences.forEach(function (segmentRef, index) {
      var segRefInfo = segmentRef.info;
      var frag = levelDetails.fragments[index];

      if (frag.byteRange.length === 0) {
        frag.setByteRange(String(1 + segRefInfo.end - segRefInfo.start) + '@' + String(segRefInfo.start));
      }
    });
    levelDetails.initSegment.setByteRange(String(sidxInfo.moovEndOffset) + '@0');
  };

  _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {
    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
      type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR,
      details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_PARSING_ERROR,
      fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST,
      url: response.url,
      reason: reason,
      response: response,
      context: context,
      networkDetails: networkDetails
    });
  };

  _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {
    if (timeout === void 0) {
      timeout = false;
    }

    _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("[playlist-loader]: A network " + (timeout ? 'timeout' : 'error') + " occurred while loading " + context.type + " level: " + context.level + " id: " + context.id + " group-id: \"" + context.groupId + "\"");
    var details = _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].UNKNOWN;
    var fatal = false;
    var loader = this.getInternalLoader(context);

    switch (context.type) {
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_LOAD_ERROR;
        fatal = true;
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_ERROR;
        fatal = false;
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR;
        fatal = false;
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
        details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].SUBTITLE_LOAD_ERROR;
        fatal = false;
        break;
    }

    if (loader) {
      this.resetInternalLoader(context.type);
    }

    var errorData = {
      type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR,
      details: details,
      fatal: fatal,
      url: context.url,
      loader: loader,
      context: context,
      networkDetails: networkDetails
    };

    if (response) {
      errorData.response = response;
    }

    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, errorData);
  };

  _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {
    var type = context.type,
        level = context.level,
        id = context.id,
        groupId = context.groupId,
        loader = context.loader,
        levelDetails = context.levelDetails,
        deliveryDirectives = context.deliveryDirectives;

    if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {
      this.handleManifestParsingError(response, context, 'invalid target duration', networkDetails);
      return;
    }

    if (!loader) {
      return;
    } // Avoid repeated browser error log `Refused to get unsafe header "age"` when unnecessary or past attempts failed


    var checkAgeHeader = this.checkAgeHeader && levelDetails.live;
    var ageHeader = checkAgeHeader ? loader.getResponseHeader('age') : null;
    levelDetails.ageHeader = ageHeader ? parseFloat(ageHeader) : 0;
    this.checkAgeHeader = !!ageHeader;

    switch (type) {
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, {
          details: levelDetails,
          level: level || 0,
          id: id || 0,
          stats: stats,
          networkDetails: networkDetails,
          deliveryDirectives: deliveryDirectives
        });
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || '',
          stats: stats,
          networkDetails: networkDetails,
          deliveryDirectives: deliveryDirectives
        });
        break;

      case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || '',
          stats: stats,
          networkDetails: networkDetails,
          deliveryDirectives: deliveryDirectives
        });
        break;
    }
  };

  return PlaylistLoader;
}();

/* harmony default export */ __webpack_exports__["default"] = (PlaylistLoader);

/***/ }),

/***/ "./src/polyfills/number.ts":
/*!*********************************!*\
  !*** ./src/polyfills/number.ts ***!
  \*********************************/
/*! exports provided: isFiniteNumber, MAX_SAFE_INTEGER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFiniteNumber", function() { return isFiniteNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_SAFE_INTEGER", function() { return MAX_SAFE_INTEGER; });
var isFiniteNumber = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value);
};
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

/***/ }),

/***/ "./src/remux/aac-helper.ts":
/*!*********************************!*\
  !*** ./src/remux/aac-helper.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 *  AAC helper
 */
var AAC = /*#__PURE__*/function () {
  function AAC() {}

  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {
    switch (codec) {
      case 'mp4a.40.2':
        if (channelCount === 1) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
        } else if (channelCount === 2) {
          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
        } else if (channelCount === 3) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
        } else if (channelCount === 4) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
        } else if (channelCount === 5) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
        } else if (channelCount === 6) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
        }

        break;
      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)

      default:
        if (channelCount === 1) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 2) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 3) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        }

        break;
    }

    return undefined;
  };

  return AAC;
}();

/* harmony default export */ __webpack_exports__["default"] = (AAC);

/***/ }),

/***/ "./src/remux/mp4-generator.ts":
/*!************************************!*\
  !*** ./src/remux/mp4-generator.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Generate MP4 Box
 */
var UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = /*#__PURE__*/function () {
  function MP4() {}

  MP4.init = function init() {
    MP4.types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      '.mp3': [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    var i;

    for (i in MP4.types) {
      if (MP4.types.hasOwnProperty(i)) {
        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }

    var videoHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
    ]);
    var audioHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
    ]);
    MP4.HDLR_TYPES = {
      video: videoHdlr,
      audio: audioHdlr
    };
    var dref = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01, // entry_count
    0x00, 0x00, 0x00, 0x0c, // entry_size
    0x75, 0x72, 0x6c, 0x20, // 'url' type
    0x00, // version 0
    0x00, 0x00, 0x01 // entry_flags
    ]);
    var stco = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00 // entry_count
    ]);
    MP4.STTS = MP4.STSC = MP4.STCO = stco;
    MP4.STSZ = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // sample_size
    0x00, 0x00, 0x00, 0x00 // sample_count
    ]);
    MP4.VMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x01, // flags
    0x00, 0x00, // graphicsmode
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
    ]);
    MP4.SMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, // balance
    0x00, 0x00 // reserved
    ]);
    MP4.STSD = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01]); // entry_count

    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom

    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1

    var minorVersion = new Uint8Array([0, 0, 0, 1]);
    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
  };

  MP4.box = function box(type) {
    var size = 8;

    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      payload[_key - 1] = arguments[_key];
    }

    var i = payload.length;
    var len = i; // calculate the total size we need to allocate

    while (i--) {
      size += payload[i].byteLength;
    }

    var result = new Uint8Array(size);
    result[0] = size >> 24 & 0xff;
    result[1] = size >> 16 & 0xff;
    result[2] = size >> 8 & 0xff;
    result[3] = size & 0xff;
    result.set(type, 4); // copy the payload into the result

    for (i = 0, size = 8; i < len; i++) {
      // copy payload[i] array @ offset size
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }

    return result;
  };

  MP4.hdlr = function hdlr(type) {
    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
  };

  MP4.mdat = function mdat(data) {
    return MP4.box(MP4.types.mdat, data);
  };

  MP4.mdhd = function mdhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4, // 'und' language (undetermined)
    0x00, 0x00]));
  };

  MP4.mdia = function mdia(track) {
    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
  };

  MP4.mfhd = function mfhd(sequenceNumber) {
    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number
    ]));
  };

  MP4.minf = function minf(track) {
    if (track.type === 'audio') {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
    } else {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
    }
  };

  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
  }
  /**
   * @param tracks... (optional) {array} the tracks associated with this movie
   */
  ;

  MP4.moov = function moov(tracks) {
    var i = tracks.length;
    var boxes = [];

    while (i--) {
      boxes[i] = MP4.trak(tracks[i]);
    }

    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
  };

  MP4.mvex = function mvex(tracks) {
    var i = tracks.length;
    var boxes = [];

    while (i--) {
      boxes[i] = MP4.trex(tracks[i]);
    }

    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
  };

  MP4.mvhd = function mvhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    var bytes = new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
    0x01, 0x00, // 1.0 volume
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    0xff, 0xff, 0xff, 0xff // next_track_ID
    ]);
    return MP4.box(MP4.types.mvhd, bytes);
  };

  MP4.sdtp = function sdtp(track) {
    var samples = track.samples || [];
    var bytes = new Uint8Array(4 + samples.length);
    var i;
    var flags; // leave the full box header (4 bytes) all zero
    // write the sample table

    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }

    return MP4.box(MP4.types.sdtp, bytes);
  };

  MP4.stbl = function stbl(track) {
    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
  };

  MP4.avc1 = function avc1(track) {
    var sps = [];
    var pps = [];
    var i;
    var data;
    var len; // assemble the SPSs

    for (i = 0; i < track.sps.length; i++) {
      data = track.sps[i];
      len = data.byteLength;
      sps.push(len >>> 8 & 0xff);
      sps.push(len & 0xff); // SPS

      sps = sps.concat(Array.prototype.slice.call(data));
    } // assemble the PPSs


    for (i = 0; i < track.pps.length; i++) {
      data = track.pps[i];
      len = data.byteLength;
      pps.push(len >>> 8 & 0xff);
      pps.push(len & 0xff);
      pps = pps.concat(Array.prototype.slice.call(data));
    }

    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
    sps[3], // profile
    sps[4], // profile compat
    sps[5], // level
    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
    ]).concat(pps))); // "PPS"

    var width = track.width;
    var height = track.height;
    var hSpacing = track.pixelRatio[0];
    var vSpacing = track.pixelRatio[1];
    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, // pre_defined
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    width >> 8 & 0xff, width & 0xff, // width
    height >> 8 & 0xff, height & 0xff, // height
    0x00, 0x48, 0x00, 0x00, // horizresolution
    0x00, 0x48, 0x00, 0x00, // vertresolution
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // frame_count
    0x12, 0x64, 0x61, 0x69, 0x6c, // dailymotion/hls.js
    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
    0x00, 0x18, // depth = 24
    0x11, 0x11]), // pre_defined = -1
    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
    0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24, // vSpacing
    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));
  };

  MP4.esds = function esds(track) {
    var configlen = track.config.length;
    return new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x03, // descriptor_type
    0x17 + configlen, // length
    0x00, 0x01, // es_id
    0x00, // stream_priority
    0x04, // descriptor_type
    0x0f + configlen, // length
    0x40, // codec : mpeg4_audio
    0x15, // stream_type
    0x00, 0x00, 0x00, // buffer_size
    0x00, 0x00, 0x00, 0x00, // maxBitrate
    0x00, 0x00, 0x00, 0x00, // avgBitrate
    0x05 // descriptor_type
    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
  };

  MP4.mp4a = function mp4a(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xff, samplerate & 0xff, //
    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
  };

  MP4.mp3 = function mp3(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xff, samplerate & 0xff, //
    0x00, 0x00]));
  };

  MP4.stsd = function stsd(track) {
    if (track.type === 'audio') {
      if (!track.isAAC && track.codec === 'mp3') {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
      }

      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
    } else {
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
    }
  };

  MP4.tkhd = function tkhd(track) {
    var id = track.id;
    var duration = track.duration * track.timescale;
    var width = track.width;
    var height = track.height;
    var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x07, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID
    0x00, 0x00, 0x00, 0x00, // reserved
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, // layer
    0x00, 0x00, // alternate_group
    0x00, 0x00, // non-audio track volume
    0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    width >> 8 & 0xff, width & 0xff, 0x00, 0x00, // width
    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height
    ]));
  };

  MP4.traf = function traf(track, baseMediaDecodeTime) {
    var sampleDependencyTable = MP4.sdtp(track);
    var id = track.id;
    var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
    var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID
    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8), // mdat header
    sampleDependencyTable);
  }
  /**
   * Generate a track box.
   * @param track {object} a track definition
   * @return {Uint8Array} the track box
   */
  ;

  MP4.trak = function trak(track) {
    track.duration = track.duration || 0xffffffff;
    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
  };

  MP4.trex = function trex(track) {
    var id = track.id;
    return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff, // track_ID
    0x00, 0x00, 0x00, 0x01, // default_sample_description_index
    0x00, 0x00, 0x00, 0x00, // default_sample_duration
    0x00, 0x00, 0x00, 0x00, // default_sample_size
    0x00, 0x01, 0x00, 0x01 // default_sample_flags
    ]));
  };

  MP4.trun = function trun(track, offset) {
    var samples = track.samples || [];
    var len = samples.length;
    var arraylen = 12 + 16 * len;
    var array = new Uint8Array(arraylen);
    var i;
    var sample;
    var duration;
    var size;
    var flags;
    var cts;
    offset += 8 + arraylen;
    array.set([0x00, // version 0
    0x00, 0x0f, 0x01, // flags
    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff, // sample_count
    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset
    ], 0);

    for (i = 0; i < len; i++) {
      sample = samples[i];
      duration = sample.duration;
      size = sample.size;
      flags = sample.flags;
      cts = sample.cts;
      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff, // sample_duration
      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff, // sample_size
      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f, // sample_flags
      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset
      ], 12 + 16 * i);
    }

    return MP4.box(MP4.types.trun, array);
  };

  MP4.initSegment = function initSegment(tracks) {
    if (!MP4.types) {
      MP4.init();
    }

    var movie = MP4.moov(tracks);
    var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
    result.set(MP4.FTYP);
    result.set(movie, MP4.FTYP.byteLength);
    return result;
  };

  return MP4;
}();

MP4.types = void 0;
MP4.HDLR_TYPES = void 0;
MP4.STTS = void 0;
MP4.STSC = void 0;
MP4.STCO = void 0;
MP4.STSZ = void 0;
MP4.VMHD = void 0;
MP4.SMHD = void 0;
MP4.STSD = void 0;
MP4.FTYP = void 0;
MP4.DINF = void 0;
/* harmony default export */ __webpack_exports__["default"] = (MP4);

/***/ }),

/***/ "./src/remux/mp4-remuxer.ts":
/*!**********************************!*\
  !*** ./src/remux/mp4-remuxer.ts ***!
  \**********************************/
/*! exports provided: default, PTSNormalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MP4Remuxer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PTSNormalize", function() { return PTSNormalize; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aac-helper */ "./src/remux/aac-helper.ts");
/* harmony import */ var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mp4-generator */ "./src/remux/mp4-generator.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events */ "./src/events.ts");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors */ "./src/errors.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/timescale-conversion */ "./src/utils/timescale-conversion.ts");


function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }







var MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds

var AAC_SAMPLES_PER_FRAME = 1024;
var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
var chromeVersion = null;
var safariWebkitVersion = null;
var requiresPositiveDts = false;

var MP4Remuxer = /*#__PURE__*/function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    if (vendor === void 0) {
      vendor = '';
    }

    this.observer = void 0;
    this.config = void 0;
    this.typeSupported = void 0;
    this.ISGenerated = false;
    this._initPTS = void 0;
    this._initDTS = void 0;
    this.nextAvcDts = null;
    this.nextAudioPts = null;
    this.isAudioContiguous = false;
    this.isVideoContiguous = false;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.ISGenerated = false;

    if (chromeVersion === null) {
      var userAgent = navigator.userAgent || '';
      var result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion = result ? parseInt(result[1]) : 0;
    }

    if (safariWebkitVersion === null) {
      var _result = navigator.userAgent.match(/Safari\/(\d+)/i);

      safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
    }

    requiresPositiveDts = !!chromeVersion && chromeVersion < 75 || !!safariWebkitVersion && safariWebkitVersion < 600;
  }

  var _proto = MP4Remuxer.prototype;

  _proto.destroy = function destroy() {};

  _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('[mp4-remuxer]: initPTS & initDTS reset');
    this._initPTS = this._initDTS = defaultTimeStamp;
  };

  _proto.resetNextTimestamp = function resetNextTimestamp() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('[mp4-remuxer]: reset next timestamp');
    this.isVideoContiguous = false;
    this.isAudioContiguous = false;
  };

  _proto.resetInitSegment = function resetInitSegment() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('[mp4-remuxer]: ISGenerated flag reset');
    this.ISGenerated = false;
  };

  _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
    var rolloverDetected = false;
    var startPTS = videoSamples.reduce(function (minPTS, sample) {
      var delta = sample.pts - minPTS;

      if (delta < -4294967296) {
        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation
        rolloverDetected = true;
        return PTSNormalize(minPTS, sample.pts);
      } else if (delta > 0) {
        return minPTS;
      } else {
        return sample.pts;
      }
    }, videoSamples[0].pts);

    if (rolloverDetected) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].debug('PTS rollover detected');
    }

    return startPTS;
  };

  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush) {
    var video;
    var audio;
    var initSegment;
    var text;
    var id3;
    var independent;
    var audioTimeOffset = timeOffset;
    var videoTimeOffset = timeOffset; // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.
    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the "pid"
    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.
    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),
    // then we can remux one track without waiting for the other.

    var hasAudio = audioTrack.pid > -1;
    var hasVideo = videoTrack.pid > -1;
    var enoughAudioSamples = audioTrack.samples.length > 0;
    var enoughVideoSamples = videoTrack.samples.length > 1;
    var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;

    if (canRemuxAvc) {
      if (!this.ISGenerated) {
        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
      }

      var isVideoContiguous = this.isVideoContiguous;

      if (enoughVideoSamples && !isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
        var length = videoTrack.samples.length;
        var firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
        independent = true;

        if (firstKeyFrameIndex > 0) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
          var startPTS = this.getVideoStartPts(videoTrack.samples);
          videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
          videoTrack.dropped += firstKeyFrameIndex;
          videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / (videoTrack.timescale || 90000);
        } else if (firstKeyFrameIndex === -1) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
          independent = false;
        }
      }

      if (this.ISGenerated) {
        if (enoughAudioSamples && enoughVideoSamples) {
          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
          // if first audio DTS is not aligned with first video DTS then we need to take that into account
          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
          // drift between audio and video streams
          var _startPTS = this.getVideoStartPts(videoTrack.samples);

          var tsDelta = PTSNormalize(audioTrack.samples[0].pts, _startPTS) - _startPTS;

          var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
        } // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.


        if (enoughAudioSamples) {
          // if initSegment was generated without audio samples, regenerate it again
          if (!audioTrack.samplerate) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn('[mp4-remuxer]: regenerate InitSegment as audio detected');
            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
            delete initSegment.video;
          }

          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, enoughVideoSamples ? videoTimeOffset : undefined);

          if (enoughVideoSamples) {
            var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0; // if initSegment was generated without video samples, regenerate it again

            if (!videoTrack.inputTimeScale) {
              _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn('[mp4-remuxer]: regenerate InitSegment as video detected');
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
            }

            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
          }
        } else if (enoughVideoSamples) {
          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
        }

        if (video && independent !== undefined) {
          video.independent = independent;
        }
      }
    } // Allow ID3 and text to remux, even if more audio/video samples are required


    if (this.ISGenerated) {
      if (id3Track.samples.length) {
        id3 = this.remuxID3(id3Track, timeOffset);
      }

      if (textTrack.samples.length) {
        text = this.remuxText(textTrack, timeOffset);
      }
    }

    return {
      audio: audio,
      video: video,
      initSegment: initSegment,
      independent: independent,
      text: text,
      id3: id3
    };
  };

  _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
    var audioSamples = audioTrack.samples;
    var videoSamples = videoTrack.samples;
    var typeSupported = this.typeSupported;
    var tracks = {};
    var computePTSDTS = !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this._initPTS);
    var container = 'audio/mp4';
    var initPTS;
    var initDTS;
    var timescale;

    if (computePTSDTS) {
      initPTS = initDTS = Infinity;
    }

    if (audioTrack.config && audioSamples.length) {
      // let's use audio sampling rate as MP4 time scale.
      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
      // using audio sampling rate here helps having an integer MP4 frame duration
      // this avoids potential rounding issue and AV sync issue
      audioTrack.timescale = audioTrack.samplerate;
      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: audio sampling rate : " + audioTrack.samplerate);

      if (!audioTrack.isAAC) {
        if (typeSupported.mpeg) {
          // Chrome and Safari
          container = 'audio/mpeg';
          audioTrack.codec = '';
        } else if (typeSupported.mp3) {
          // Firefox
          audioTrack.codec = 'mp3';
        }
      }

      tracks.audio = {
        id: 'audio',
        container: container,
        codec: audioTrack.codec,
        initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([audioTrack]),
        metadata: {
          channelCount: audioTrack.channelCount
        }
      };

      if (computePTSDTS) {
        timescale = audioTrack.inputTimeScale; // remember first PTS of this demuxing context. for audio, PTS = DTS

        initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
      }
    }

    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
      // let's use input time scale as MP4 video timescale
      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
      videoTrack.timescale = videoTrack.inputTimeScale;
      tracks.video = {
        id: 'main',
        container: 'video/mp4',
        codec: videoTrack.codec,
        initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([videoTrack]),
        metadata: {
          width: videoTrack.width,
          height: videoTrack.height
        }
      };

      if (computePTSDTS) {
        timescale = videoTrack.inputTimeScale;
        var startPTS = this.getVideoStartPts(videoSamples);
        var startOffset = Math.round(timescale * timeOffset);
        initDTS = Math.min(initDTS, PTSNormalize(videoSamples[0].dts, startPTS) - startOffset);
        initPTS = Math.min(initPTS, startPTS - startOffset);
      }
    }

    if (Object.keys(tracks).length) {
      this.ISGenerated = true;

      if (computePTSDTS) {
        this._initPTS = initPTS;
        this._initDTS = initDTS;
      }

      return {
        tracks: tracks,
        initPTS: initPTS,
        timescale: timescale
      };
    }
  };

  _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
    var timeScale = track.inputTimeScale;
    var inputSamples = track.samples;
    var outputSamples = [];
    var nbSamples = inputSamples.length;
    var initPTS = this._initPTS;
    var nextAvcDts = this.nextAvcDts;
    var offset = 8;
    var mp4SampleDuration;
    var firstDTS;
    var lastDTS;
    var minPTS = Number.POSITIVE_INFINITY;
    var maxPTS = Number.NEGATIVE_INFINITY;
    var ptsDtsShift = 0;
    var sortSamples = false; // if parsed fragment is contiguous with last one, let's use last DTS value as reference

    if (!contiguous || nextAvcDts === null) {
      var pts = timeOffset * timeScale;
      var cts = inputSamples[0].pts - PTSNormalize(inputSamples[0].dts, inputSamples[0].pts); // if not contiguous, let's use target timeOffset

      nextAvcDts = pts - cts;
    } // PTS is coded on 33bits, and can loop from -2^32 to 2^32
    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value


    for (var i = 0; i < nbSamples; i++) {
      var sample = inputSamples[i];
      sample.pts = PTSNormalize(sample.pts - initPTS, nextAvcDts);
      sample.dts = PTSNormalize(sample.dts - initPTS, nextAvcDts);

      if (sample.dts > sample.pts) {
        var PTS_DTS_SHIFT_TOLERANCE_90KHZ = 90000 * 0.2;
        ptsDtsShift = Math.max(Math.min(ptsDtsShift, sample.pts - sample.dts), -1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ);
      }

      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
        sortSamples = true;
      }
    } // sort video samples by DTS then PTS then demux id order


    if (sortSamples) {
      inputSamples.sort(function (a, b) {
        var deltadts = a.dts - b.dts;
        var deltapts = a.pts - b.pts;
        return deltadts || deltapts;
      });
    } // Get first/last DTS


    firstDTS = inputSamples[0].dts;
    lastDTS = inputSamples[inputSamples.length - 1].dts; // on Safari let's signal the same sample duration for all samples
    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
    // set this constant duration as being the avg delta between consecutive DTS.

    var averageSampleDuration = Math.round((lastDTS - firstDTS) / (nbSamples - 1)); // handle broken streams with PTS < DTS, tolerance up 0.2 seconds

    if (ptsDtsShift < 0) {
      if (ptsDtsShift < averageSampleDuration * -2) {
        // Fix for "CNN special report, with CC" in test-streams (including Safari browser)
        // With large PTS < DTS errors such as this, we want to correct CTS while maintaining increasing DTS values
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("PTS < DTS detected in video samples, offsetting DTS from PTS by " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(-averageSampleDuration, true) + " ms");
        var lastDts = ptsDtsShift;

        for (var _i = 0; _i < nbSamples; _i++) {
          inputSamples[_i].dts = lastDts = Math.max(lastDts, inputSamples[_i].pts - averageSampleDuration);
          inputSamples[_i].pts = Math.max(lastDts, inputSamples[_i].pts);
        }
      } else {
        // Fix for "Custom IV with bad PTS DTS" in test-streams
        // With smaller PTS < DTS errors we can simply move all DTS back. This increases CTS without causing buffer gaps or decode errors in Safari
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("PTS < DTS detected in video samples, shifting DTS by " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(ptsDtsShift, true) + " ms to overcome this issue");

        for (var _i2 = 0; _i2 < nbSamples; _i2++) {
          inputSamples[_i2].dts = inputSamples[_i2].dts + ptsDtsShift;
        }
      }

      firstDTS = inputSamples[0].dts;
      lastDTS = inputSamples[nbSamples - 1].dts;
    } // if fragment are contiguous, detect hole/overlapping between fragments


    if (contiguous) {
      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)
      var delta = firstDTS - nextAvcDts;
      var foundHole = delta > averageSampleDuration;
      var foundOverlap = delta < -1;

      if (foundHole || foundOverlap) {
        if (foundHole) {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("AVC: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(delta, true) + " ms (" + delta + "dts) hole between fragments detected, filling it");
        } else {
          _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("AVC: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected");
        }

        firstDTS = nextAvcDts;
        var firstPTS = inputSamples[0].pts - delta;
        inputSamples[0].dts = firstDTS;
        inputSamples[0].pts = firstPTS;
        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("Video: First PTS/DTS adjusted: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(firstPTS, true) + "/" + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(firstDTS, true) + ", delta: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_6__["toMsFromMpegTsClock"])(delta, true) + " ms");
      }
    }

    if (requiresPositiveDts) {
      firstDTS = Math.max(0, firstDTS);
    }

    var nbNalu = 0;
    var naluLen = 0;

    for (var _i3 = 0; _i3 < nbSamples; _i3++) {
      // compute total/avc sample length and nb of NAL units
      var _sample = inputSamples[_i3];
      var units = _sample.units;
      var nbUnits = units.length;
      var sampleLen = 0;

      for (var j = 0; j < nbUnits; j++) {
        sampleLen += units[j].data.length;
      }

      naluLen += sampleLen;
      nbNalu += nbUnits;
      _sample.length = sampleLen; // normalize PTS/DTS
      // ensure sample monotonic DTS

      _sample.dts = Math.max(_sample.dts, firstDTS); // ensure that computed value is greater or equal than sample DTS

      _sample.pts = Math.max(_sample.pts, _sample.dts, 0);
      minPTS = Math.min(_sample.pts, minPTS);
      maxPTS = Math.max(_sample.pts, maxPTS);
    }

    lastDTS = inputSamples[nbSamples - 1].dts;
    /* concatenate the video data and construct the mdat in place
      (need 8 more bytes to fill length and mpdat type) */

    var mdatSize = naluLen + 4 * nbNalu + 8;
    var mdat;

    try {
      mdat = new Uint8Array(mdatSize);
    } catch (err) {
      this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, {
        type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].MUX_ERROR,
        details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].REMUX_ALLOC_ERROR,
        fatal: false,
        bytes: mdatSize,
        reason: "fail allocating video mdat " + mdatSize
      });
      return;
    }

    var view = new DataView(mdat.buffer);
    view.setUint32(0, mdatSize);
    mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);

    for (var _i4 = 0; _i4 < nbSamples; _i4++) {
      var avcSample = inputSamples[_i4];
      var avcSampleUnits = avcSample.units;
      var mp4SampleLength = 0; // convert NALU bitstream to MP4 format (prepend NALU with size field)

      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
        var unit = avcSampleUnits[_j];
        var unitData = unit.data;
        var unitDataLen = unit.data.byteLength;
        view.setUint32(offset, unitDataLen);
        offset += 4;
        mdat.set(unitData, offset);
        offset += unitDataLen;
        mp4SampleLength += 4 + unitDataLen;
      } // expected sample duration is the Decoding Timestamp diff of consecutive samples


      if (_i4 < nbSamples - 1) {
        mp4SampleDuration = inputSamples[_i4 + 1].dts - avcSample.dts;
      } else {
        var config = this.config;
        var lastFrameDuration = avcSample.dts - inputSamples[_i4 > 0 ? _i4 - 1 : _i4].dts;

        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
          // In some cases, a segment's audio track duration may exceed the video track duration.
          // Since we've already remuxed audio, and we know how long the audio track is, we look to
          // see if the delta to the next segment is longer than maxBufferHole.
          // If so, playback would potentially get stuck, so we artificially inflate
          // the duration of the last frame to minimize any potential gap between segments.
          var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
          var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;

          if (deltaToFrameEnd > gapTolerance) {
            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.
            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;

            if (mp4SampleDuration < 0) {
              mp4SampleDuration = lastFrameDuration;
            }

            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        } else {
          mp4SampleDuration = lastFrameDuration;
        }
      }

      var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
      outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
    }

    if (outputSamples.length && chromeVersion && chromeVersion < 70) {
      // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue
      // https://code.google.com/p/chromium/issues/detail?id=229412
      var flags = outputSamples[0].flags;
      flags.dependsOn = 2;
      flags.isNonSync = 0;
    }

    console.assert(mp4SampleDuration !== undefined, 'mp4SampleDuration must be computed'); // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)

    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
    this.isVideoContiguous = true;
    var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
      samples: outputSamples
    }));
    var type = 'video';
    var data = {
      data1: moof,
      data2: mdat,
      startPTS: minPTS / timeScale,
      endPTS: (maxPTS + mp4SampleDuration) / timeScale,
      startDTS: firstDTS / timeScale,
      endDTS: nextAvcDts / timeScale,
      type: type,
      hasAudio: false,
      hasVideo: true,
      nb: outputSamples.length,
      dropped: track.dropped
    };
    track.samples = [];
    track.dropped = 0;
    console.assert(mdat.length, 'MDAT length must not be zero');
    return data;
  };

  _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
    var inputTimeScale = track.inputTimeScale;
    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    var scaleFactor = inputTimeScale / mp4timeScale;
    var mp4SampleDuration = track.isAAC ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;
    var inputSampleDuration = mp4SampleDuration * scaleFactor;
    var initPTS = this._initPTS;
    var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
    var outputSamples = [];
    var inputSamples = track.samples;
    var offset = rawMPEG ? 0 : 8;
    var fillFrame;
    var nextAudioPts = this.nextAudioPts || -1; // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);
    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
    // for sake of clarity:
    // consecutive fragments are frags with
    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
    //  - less than 20 audio frames distance
    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
    // this helps ensuring audio continuity
    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame

    var timeOffsetMpegTS = timeOffset * inputTimeScale;
    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(PTSNormalize(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration); // compute normalized PTS

    inputSamples.forEach(function (sample) {
      sample.pts = sample.dts = PTSNormalize(sample.pts - initPTS, timeOffsetMpegTS);
    });

    if (!contiguous || nextAudioPts < 0) {
      // filter out sample with negative PTS that are not playable anyway
      // if we don't remove these negative samples, they will shift all audio samples forward.
      // leading to audio overlap between current / next fragment
      inputSamples = inputSamples.filter(function (sample) {
        return sample.pts >= 0;
      }); // in case all samples have negative PTS, and have been filtered out, return now

      if (!inputSamples.length) {
        return;
      }

      if (videoTimeOffset === 0) {
        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence
        nextAudioPts = 0;
      } else if (accurateTimeOffset) {
        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS
        nextAudioPts = Math.max(0, timeOffsetMpegTS);
      } else {
        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
        nextAudioPts = inputSamples[0].pts;
      }
    } // If the audio track is missing samples, the frames seem to get "left-shifted" within the
    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
    // In an effort to prevent this from happening, we inject frames here where there are gaps.
    // When possible, we inject a silent frame; when that's not possible, we duplicate the last
    // frame.


    if (track.isAAC) {
      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;

      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
        // First, let's see how far off this frame is from where we expect it to be
        var sample = inputSamples[i];
        var pts = sample.pts;
        var delta = pts - nextPts;
        var duration = Math.abs(1000 * delta / inputTimeScale); // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync

        if (delta <= -maxAudioFramesDrift * inputSampleDuration && videoTimeOffset !== undefined) {
          if (contiguous || i > 0) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: Dropping 1 audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(duration) + " ms overlap.");
            inputSamples.splice(i, 1); // Don't touch nextPtsNorm or i
          } else {
            // When changing qualities we can't trust that audio has been appended up to nextAudioPts
            // Warn about the overlap but do not drop samples as that can introduce buffer gaps
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1000 * delta / inputTimeScale) + " ms.");
            nextPts = pts + inputSampleDuration;
            i++;
          }
        } // eslint-disable-line brace-style
        // Insert missing frames if:
        // 1: We're more than maxAudioFramesDrift frame away
        // 2: Not more than MAX_SILENT_FRAME_DURATION away
        // 3: currentTime (aka nextPtsNorm) is not 0
        // 4: remuxing with video (videoTimeOffset !== undefined)
        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && videoTimeOffset !== undefined) {
            var missing = Math.floor(delta / inputSampleDuration); // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from
            // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.

            nextPts = pts - missing * inputSampleDuration;
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1000 * delta / inputTimeScale) + " ms gap.");

            for (var j = 0; j < missing; j++) {
              var newStamp = Math.max(nextPts, 0);
              fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

              if (!fillFrame) {
                _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.subarray();
              }

              inputSamples.splice(i, 0, {
                unit: fillFrame,
                pts: newStamp,
                dts: newStamp
              });
              nextPts += inputSampleDuration;
              i++;
            } // Adjust sample to next expected pts


            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          } else {
            // Otherwise, just adjust pts
            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          }
      }
    }

    var firstPTS = null;
    var lastPTS = null;
    var mdat;
    var mdatSize = 0;
    var sampleLength = inputSamples.length;

    while (sampleLength--) {
      mdatSize += inputSamples[sampleLength].unit.byteLength;
    }

    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
      var audioSample = inputSamples[_j2];
      var unit = audioSample.unit;
      var _pts = audioSample.pts;

      if (lastPTS !== null) {
        // If we have more than one sample, set the duration of the sample to the "real" duration; the PTS diff with
        // the previous sample
        var prevSample = outputSamples[_j2 - 1];
        prevSample.duration = Math.round((_pts - lastPTS) / scaleFactor);
      } else {
        var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale);

        var numMissingFrames = 0; // if fragment are contiguous, detect hole/overlapping between fragments
        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)

        if (contiguous && track.isAAC) {
          if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
            numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: " + _delta + " ms hole between AAC samples detected,filling it");

            if (numMissingFrames > 0) {
              fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

              if (!fillFrame) {
                fillFrame = unit.subarray();
              }

              mdatSize += numMissingFrames * fillFrame.length;
            } // if we have frame overlap, overlapping for more than half a frame duraion

          } else if (_delta < -12) {
            // drop overlapping audio frames... browser will deal with it
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: drop overlapping AAC sample, expected/parsed/delta:" + (nextAudioPts / inputTimeScale).toFixed(3) + "s/" + (_pts / inputTimeScale).toFixed(3) + "s/" + -_delta + "ms");
            mdatSize -= unit.byteLength;
            continue;
          } // set PTS/DTS to expected PTS/DTS


          _pts = nextAudioPts;
        } // remember first PTS of our audioSamples


        firstPTS = _pts;

        if (mdatSize > 0) {
          /* concatenate the audio data and construct the mdat in place
            (need 8 more bytes to fill length and mdat type) */
          mdatSize += offset;

          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, {
              type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].MUX_ERROR,
              details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].REMUX_ALLOC_ERROR,
              fatal: false,
              bytes: mdatSize,
              reason: "fail allocating audio mdat " + mdatSize
            });
            return;
          }

          if (!rawMPEG) {
            var view = new DataView(mdat.buffer);
            view.setUint32(0, mdatSize);
            mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);
          }
        } else {
          // no audio samples
          return;
        }

        for (var _i5 = 0; _i5 < numMissingFrames; _i5++) {
          fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

          if (!fillFrame) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating the current frame instead');
            fillFrame = unit.subarray();
          }

          mdat.set(fillFrame, offset);
          offset += fillFrame.byteLength;
          outputSamples.push(new Mp4Sample(true, AAC_SAMPLES_PER_FRAME, fillFrame.byteLength, 0));
        }
      }

      mdat.set(unit, offset);
      var unitLen = unit.byteLength;
      offset += unitLen; // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG
      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration
      // becomes the PTS diff with the previous sample

      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
      lastPTS = _pts;
    } // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones


    var nbSamples = outputSamples.length;

    if (!nbSamples) {
      return;
    } // The next audio sample PTS should be equal to last sample PTS + duration


    var lastSample = outputSamples[outputSamples.length - 1];
    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration; // Set the track samples from inputSamples to outputSamples before remuxing

    var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
      samples: outputSamples
    })); // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared

    track.samples = [];
    var start = firstPTS / inputTimeScale;
    var end = nextAudioPts / inputTimeScale;
    var type = 'audio';
    var audioData = {
      data1: moof,
      data2: mdat,
      startPTS: start,
      endPTS: end,
      startDTS: start,
      endDTS: end,
      type: type,
      hasAudio: true,
      hasVideo: false,
      nb: nbSamples
    };
    console.assert(mdat.length, 'MDAT length must not be zero');
    return audioData;
  };

  _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
    var inputTimeScale = track.inputTimeScale;
    var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    var scaleFactor = inputTimeScale / mp4timeScale;
    var nextAudioPts = this.nextAudioPts; // sync with video's timestamp

    var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;
    var endDTS = videoData.endDTS * inputTimeScale + this._initDTS; // one sample's duration value

    var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME; // samples count of this segment's duration

    var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration); // silent frame

    var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn('[mp4-remuxer]: remux empty Audio'); // Can't remux if we can't generate a silent frame...

    if (!silentFrame) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');
      return;
    }

    var samples = [];

    for (var i = 0; i < nbSamples; i++) {
      var stamp = startDTS + i * frameDuration;
      samples.push({
        unit: silentFrame,
        pts: stamp,
        dts: stamp
      });
    }

    track.samples = samples;
    return this.remuxAudio(track, timeOffset, contiguous, false);
  };

  _proto.remuxID3 = function remuxID3(track, timeOffset) {
    var length = track.samples.length;

    if (!length) {
      return;
    }

    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;
    var initDTS = this._initDTS;

    for (var index = 0; index < length; index++) {
      var sample = track.samples[index]; // setting id3 pts, dts to relative time
      // using this._initPTS and this._initDTS to calculate relative time

      sample.pts = PTSNormalize(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
      sample.dts = PTSNormalize(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;
    }

    var samples = track.samples;
    track.samples = [];
    return {
      samples: samples
    };
  };

  _proto.remuxText = function remuxText(track, timeOffset) {
    var length = track.samples.length;

    if (!length) {
      return;
    }

    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;

    for (var index = 0; index < length; index++) {
      var sample = track.samples[index]; // setting text pts, dts to relative time
      // using this._initPTS and this._initDTS to calculate relative time

      sample.pts = PTSNormalize(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
    }

    track.samples.sort(function (a, b) {
      return a.pts - b.pts;
    });
    var samples = track.samples;
    track.samples = [];
    return {
      samples: samples
    };
  };

  return MP4Remuxer;
}();


function PTSNormalize(value, reference) {
  var offset;

  if (reference === null) {
    return value;
  }

  if (reference < value) {
    // - 2^33
    offset = -8589934592;
  } else {
    // + 2^33
    offset = 8589934592;
  }
  /* PTS is 33bit (from 0 to 2^33 -1)
    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
    PTS looping occured. fill the gap */


  while (Math.abs(value - reference) > 4294967296) {
    value += offset;
  }

  return value;
}

function findKeyframeIndex(samples) {
  for (var i = 0; i < samples.length; i++) {
    if (samples[i].key) {
      return i;
    }
  }

  return -1;
}

var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {
  this.size = void 0;
  this.duration = void 0;
  this.cts = void 0;
  this.flags = void 0;
  this.duration = duration;
  this.size = size;
  this.cts = cts;
  this.flags = new Mp4SampleFlags(isKeyframe);
};

var Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {
  this.isLeading = 0;
  this.isDependedOn = 0;
  this.hasRedundancy = 0;
  this.degradPrio = 0;
  this.dependsOn = 1;
  this.isNonSync = 1;
  this.dependsOn = isKeyframe ? 2 : 1;
  this.isNonSync = isKeyframe ? 0 : 1;
};

/***/ }),

/***/ "./src/remux/passthrough-remuxer.ts":
/*!******************************************!*\
  !*** ./src/remux/passthrough-remuxer.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");





var PassThroughRemuxer = /*#__PURE__*/function () {
  function PassThroughRemuxer() {
    this.emitInitSegment = false;
    this.audioCodec = void 0;
    this.videoCodec = void 0;
    this.initData = void 0;
    this.initPTS = void 0;
    this.initTracks = void 0;
    this.lastEndDTS = null;
  }

  var _proto = PassThroughRemuxer.prototype;

  _proto.destroy = function destroy() {};

  _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
    this.initPTS = defaultInitPTS;
    this.lastEndDTS = null;
  };

  _proto.resetNextTimestamp = function resetNextTimestamp() {
    this.lastEndDTS = null;
  };

  _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec) {
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this.generateInitSegment(initSegment);
    this.emitInitSegment = true;
  };

  _proto.generateInitSegment = function generateInitSegment(initSegment) {
    var audioCodec = this.audioCodec,
        videoCodec = this.videoCodec;

    if (!initSegment || !initSegment.byteLength) {
      this.initTracks = undefined;
      this.initData = undefined;
      return;
    }

    var initData = this.initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__["parseInitSegment"])(initSegment); // default audio codec if nothing specified
    // TODO : extract that from initSegment

    if (!audioCodec) {
      audioCodec = 'mp4a.40.5';
    }

    if (!videoCodec) {
      videoCodec = 'avc1.42e01e';
    }

    var tracks = {};

    if (initData.audio && initData.video) {
      tracks.audiovideo = {
        container: 'video/mp4',
        codec: audioCodec + ',' + videoCodec,
        initSegment: initSegment,
        id: 'main'
      };
    } else if (initData.audio) {
      tracks.audio = {
        container: 'audio/mp4',
        codec: audioCodec,
        initSegment: initSegment,
        id: 'audio'
      };
    } else if (initData.video) {
      tracks.video = {
        container: 'video/mp4',
        codec: videoCodec,
        initSegment: initSegment,
        id: 'main'
      };
    } else {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');
    }

    this.initTracks = tracks;
  };

  _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {
    var initPTS = this.initPTS,
        lastEndDTS = this.lastEndDTS;
    var result = {
      audio: undefined,
      video: undefined,
      text: textTrack,
      id3: id3Track,
      initSegment: undefined
    }; // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the
    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update
    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(lastEndDTS)) {
      lastEndDTS = this.lastEndDTS = timeOffset || 0;
    } // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only
    // audio or video (or both); adding it to video was an arbitrary choice.


    var data = videoTrack.samples;

    if (!data || !data.length) {
      return result;
    }

    var initSegment = {
      initPTS: undefined,
      timescale: 1
    };
    var initData = this.initData;

    if (!initData || !initData.length) {
      this.generateInitSegment(data);
      initData = this.initData;
    }

    if (!initData || !initData.length) {
      // We can't remux if the initSegment could not be generated
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');
      return result;
    }

    if (this.emitInitSegment) {
      initSegment.tracks = this.initTracks;
      this.emitInitSegment = false;
    }

    if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS)) {
      this.initPTS = initSegment.initPTS = initPTS = computeInitPTS(initData, data, lastEndDTS);
    }

    var duration = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__["getDuration"])(data, initData);
    var startDTS = lastEndDTS;
    var endDTS = duration + startDTS;
    Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__["offsetStartDTS"])(initData, data, initPTS);

    if (duration > 0) {
      this.lastEndDTS = endDTS;
    } else {
      _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('Duration parsed from mp4 should be greater than zero');
      this.resetNextTimestamp();
    }

    var hasAudio = !!initData.audio;
    var hasVideo = !!initData.video;
    var type = '';

    if (hasAudio) {
      type += 'audio';
    }

    if (hasVideo) {
      type += 'video';
    }

    var track = {
      data1: data,
      startPTS: startDTS,
      startDTS: startDTS,
      endPTS: endDTS,
      endDTS: endDTS,
      type: type,
      hasAudio: hasAudio,
      hasVideo: hasVideo,
      nb: 1,
      dropped: 0
    };
    result.audio = track.type === 'audio' ? track : undefined;
    result.video = track.type !== 'audio' ? track : undefined;
    result.text = textTrack;
    result.id3 = id3Track;
    result.initSegment = initSegment;
    return result;
  };

  return PassThroughRemuxer;
}();

var computeInitPTS = function computeInitPTS(initData, data, timeOffset) {
  return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_1__["getStartDTS"])(initData, data) - timeOffset;
};

/* harmony default export */ __webpack_exports__["default"] = (PassThroughRemuxer);

/***/ }),

/***/ "./src/task-loop.ts":
/*!**************************!*\
  !*** ./src/task-loop.ts ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TaskLoop; });
/**
 * Sub-class specialization of EventHandler base class.
 *
 * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,
 * scheduled asynchroneously, avoiding recursive calls in the same tick.
 *
 * The task itself is implemented in `doTick`. It can be requested and called for single execution
 * using the `tick` method.
 *
 * It will be assured that the task execution method (`tick`) only gets called once per main loop "tick",
 * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.
 *
 * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,
 * and cancelled with `clearNextTick`.
 *
 * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).
 *
 * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.
 *
 * Further explanations:
 *
 * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously
 * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.
 *
 * When the task execution (`tick` method) is called in re-entrant way this is detected and
 * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further
 * task processing on the next main loop iteration (also known as "next tick" in the Node/JS runtime lingo).
 */
var TaskLoop = /*#__PURE__*/function () {
  function TaskLoop() {
    this._boundTick = void 0;
    this._tickTimer = null;
    this._tickInterval = null;
    this._tickCallCount = 0;
    this._boundTick = this.tick.bind(this);
  }

  var _proto = TaskLoop.prototype;

  _proto.destroy = function destroy() {
    this.onHandlerDestroying();
    this.onHandlerDestroyed();
  };

  _proto.onHandlerDestroying = function onHandlerDestroying() {
    // clear all timers before unregistering from event bus
    this.clearNextTick();
    this.clearInterval();
  };

  _proto.onHandlerDestroyed = function onHandlerDestroyed() {}
  /**
   * @returns {boolean}
   */
  ;

  _proto.hasInterval = function hasInterval() {
    return !!this._tickInterval;
  }
  /**
   * @returns {boolean}
   */
  ;

  _proto.hasNextTick = function hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param {number} millis Interval time (ms)
   * @returns {boolean} True when interval has been scheduled, false when already scheduled (no effect)
   */
  ;

  _proto.setInterval = function setInterval(millis) {
    if (!this._tickInterval) {
      this._tickInterval = self.setInterval(this._boundTick, millis);
      return true;
    }

    return false;
  }
  /**
   * @returns {boolean} True when interval was cleared, false when none was set (no effect)
   */
  ;

  _proto.clearInterval = function clearInterval() {
    if (this._tickInterval) {
      self.clearInterval(this._tickInterval);
      this._tickInterval = null;
      return true;
    }

    return false;
  }
  /**
   * @returns {boolean} True when timeout was cleared, false when none was set (no effect)
   */
  ;

  _proto.clearNextTick = function clearNextTick() {
    if (this._tickTimer) {
      self.clearTimeout(this._tickTimer);
      this._tickTimer = null;
      return true;
    }

    return false;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  ;

  _proto.tick = function tick() {
    this._tickCallCount++;

    if (this._tickCallCount === 1) {
      this.doTick(); // re-entrant call to tick from previous doTick call stack
      // -> schedule a call on the next main loop iteration to process this task processing request

      if (this._tickCallCount > 1) {
        // make sure only one timer exists at any time at max
        this.clearNextTick();
        this._tickTimer = self.setTimeout(this._boundTick, 0);
      }

      this._tickCallCount = 0;
    }
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  ;

  _proto.doTick = function doTick() {};

  return TaskLoop;
}();



/***/ }),

/***/ "./src/types/level.ts":
/*!****************************!*\
  !*** ./src/types/level.ts ***!
  \****************************/
/*! exports provided: HlsSkip, getSkipValue, HlsUrlParameters, Level */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HlsSkip", function() { return HlsSkip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSkipValue", function() { return getSkipValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HlsUrlParameters", function() { return HlsUrlParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Level", function() { return Level; });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var HlsSkip;

(function (HlsSkip) {
  HlsSkip["No"] = "";
  HlsSkip["Yes"] = "YES";
  HlsSkip["v2"] = "v2";
})(HlsSkip || (HlsSkip = {}));

function getSkipValue(details, msn) {
  var canSkipUntil = details.canSkipUntil,
      canSkipDateRanges = details.canSkipDateRanges,
      endSN = details.endSN;
  var snChangeGoal = msn - endSN;

  if (canSkipUntil && snChangeGoal < canSkipUntil) {
    if (canSkipDateRanges) {
      return HlsSkip.v2;
    }

    return HlsSkip.Yes;
  }

  return HlsSkip.No;
}
var HlsUrlParameters = /*#__PURE__*/function () {
  function HlsUrlParameters(msn, part, skip) {
    this.msn = void 0;
    this.part = void 0;
    this.skip = void 0;
    this.msn = msn;
    this.part = part;
    this.skip = skip;
  }

  var _proto = HlsUrlParameters.prototype;

  _proto.addDirectives = function addDirectives(uri) {
    var url = new self.URL(uri);
    var searchParams = url.searchParams;
    searchParams.set('_HLS_msn', this.msn.toString());

    if (this.part !== undefined) {
      searchParams.set('_HLS_part', this.part.toString());
    }

    if (this.skip) {
      searchParams.set('_HLS_skip', this.skip);
    }

    searchParams.sort();
    url.search = searchParams.toString();
    return url.toString();
  };

  return HlsUrlParameters;
}();
var Level = /*#__PURE__*/function () {
  function Level(data) {
    this.attrs = void 0;
    this.audioCodec = void 0;
    this.bitrate = void 0;
    this.codecSet = void 0;
    this.height = void 0;
    this.id = void 0;
    this.name = void 0;
    this.videoCodec = void 0;
    this.width = void 0;
    this.unknownCodecs = void 0;
    this.audioGroupIds = void 0;
    this.details = void 0;
    this.fragmentError = false;
    this.loadError = 0;
    this.loaded = void 0;
    this.realBitrate = 0;
    this.textGroupIds = void 0;
    this.url = void 0;
    this._urlId = 0;
    this.url = [data.url];
    this.attrs = data.attrs;
    this.bitrate = data.bitrate;

    if (data.details) {
      this.details = data.details;
    }

    this.id = data.id || 0;
    this.name = data.name;
    this.width = data.width || 0;
    this.height = data.height || 0;
    this.audioCodec = data.audioCodec;
    this.videoCodec = data.videoCodec;
    this.unknownCodecs = data.unknownCodecs;
    this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {
      return c;
    }).join(',').replace(/\.[^.,]+/g, '');
  }

  _createClass(Level, [{
    key: "maxBitrate",
    get: function get() {
      return Math.max(this.realBitrate, this.bitrate);
    }
  }, {
    key: "uri",
    get: function get() {
      return this.url[this._urlId] || '';
    }
  }, {
    key: "urlId",
    get: function get() {
      return this._urlId;
    },
    set: function set(value) {
      var newValue = value % this.url.length;

      if (this._urlId !== newValue) {
        this.details = undefined;
        this._urlId = newValue;
      }
    }
  }]);

  return Level;
}();

/***/ }),

/***/ "./src/types/loader.ts":
/*!*****************************!*\
  !*** ./src/types/loader.ts ***!
  \*****************************/
/*! exports provided: PlaylistContextType, PlaylistLevelType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaylistContextType", function() { return PlaylistContextType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaylistLevelType", function() { return PlaylistLevelType; });
var PlaylistContextType;

(function (PlaylistContextType) {
  PlaylistContextType["MANIFEST"] = "manifest";
  PlaylistContextType["LEVEL"] = "level";
  PlaylistContextType["AUDIO_TRACK"] = "audioTrack";
  PlaylistContextType["SUBTITLE_TRACK"] = "subtitleTrack";
})(PlaylistContextType || (PlaylistContextType = {}));

var PlaylistLevelType;

(function (PlaylistLevelType) {
  PlaylistLevelType["MAIN"] = "main";
  PlaylistLevelType["AUDIO"] = "audio";
  PlaylistLevelType["SUBTITLE"] = "subtitle";
})(PlaylistLevelType || (PlaylistLevelType = {}));

/***/ }),

/***/ "./src/types/transmuxer.ts":
/*!*********************************!*\
  !*** ./src/types/transmuxer.ts ***!
  \*********************************/
/*! exports provided: ChunkMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkMetadata", function() { return ChunkMetadata; });
var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {
  if (size === void 0) {
    size = 0;
  }

  if (part === void 0) {
    part = -1;
  }

  if (partial === void 0) {
    partial = false;
  }

  this.level = void 0;
  this.sn = void 0;
  this.part = void 0;
  this.id = void 0;
  this.size = void 0;
  this.partial = void 0;
  this.transmuxing = getNewPerformanceTiming();
  this.buffering = {
    audio: getNewPerformanceTiming(),
    video: getNewPerformanceTiming(),
    audiovideo: getNewPerformanceTiming()
  };
  this.level = level;
  this.sn = sn;
  this.id = id;
  this.size = size;
  this.part = part;
  this.partial = partial;
};

function getNewPerformanceTiming() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}

/***/ }),

/***/ "./src/utils/attr-list.ts":
/*!********************************!*\
  !*** ./src/utils/attr-list.ts ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/; // eslint-disable-line no-useless-escape

var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; // eslint-disable-line no-useless-escape
// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = /*#__PURE__*/function () {
  function AttrList(attrs) {
    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }

    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  var _proto = AttrList.prototype;

  _proto.decimalInteger = function decimalInteger(attrName) {
    var intValue = parseInt(this[attrName], 10);

    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }

    return intValue;
  };

  _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
    if (this[attrName]) {
      var stringValue = (this[attrName] || '0x').slice(2);
      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;
      var value = new Uint8Array(stringValue.length / 2);

      for (var i = 0; i < stringValue.length / 2; i++) {
        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
      }

      return value;
    } else {
      return null;
    }
  };

  _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
    var intValue = parseInt(this[attrName], 16);

    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }

    return intValue;
  };

  _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
    return parseFloat(this[attrName]);
  };

  _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
    var value = this[attrName];
    return value ? parseFloat(value) : defaultValue;
  };

  _proto.enumeratedString = function enumeratedString(attrName) {
    return this[attrName];
  };

  _proto.bool = function bool(attrName) {
    return this[attrName] === 'YES';
  };

  _proto.decimalResolution = function decimalResolution(attrName) {
    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);

    if (res === null) {
      return undefined;
    }

    return {
      width: parseInt(res[1], 10),
      height: parseInt(res[2], 10)
    };
  };

  AttrList.parseAttrList = function parseAttrList(input) {
    var match;
    var attrs = {};
    var quote = '"';
    ATTR_LIST_REGEX.lastIndex = 0;

    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
      var value = match[2];

      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
        value = value.slice(1, -1);
      }

      attrs[match[1]] = value;
    }

    return attrs;
  };

  return AttrList;
}();

/* harmony default export */ __webpack_exports__["default"] = (AttrList);

/***/ }),

/***/ "./src/utils/binary-search.ts":
/*!************************************!*\
  !*** ./src/utils/binary-search.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var BinarySearch = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param {Array<T>} list The array to search.
   * @param {BinarySearchComparison<T>} comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @return {T | null} The object if it is found or null otherwise.
   */
  search: function search(list, comparisonFn) {
    var minIndex = 0;
    var maxIndex = list.length - 1;
    var currentIndex = null;
    var currentElement = null;

    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];
      var comparisonResult = comparisonFn(currentElement);

      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }

    return null;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (BinarySearch);

/***/ }),

/***/ "./src/utils/buffer-helper.ts":
/*!************************************!*\
  !*** ./src/utils/buffer-helper.ts ***!
  \************************************/
/*! exports provided: BufferHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferHelper", function() { return BufferHelper; });
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/**
 * @module BufferHelper
 *
 * Providing methods dealing with buffer length retrieval for example.
 *
 * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.
 *
 * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered
 */

var noopBuffered = {
  length: 0,
  start: function start() {
    return 0;
  },
  end: function end() {
    return 0;
  }
};
var BufferHelper = /*#__PURE__*/function () {
  function BufferHelper() {}

  /**
   * Return true if `media`'s buffered include `position`
   * @param {Bufferable} media
   * @param {number} position
   * @returns {boolean}
   */
  BufferHelper.isBuffered = function isBuffered(media, position) {
    try {
      if (media) {
        var buffered = BufferHelper.getBuffered(media);

        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
    } catch (error) {// this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }

    return false;
  };

  BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
    try {
      if (media) {
        var vbuffered = BufferHelper.getBuffered(media);
        var buffered = [];
        var i;

        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({
            start: vbuffered.start(i),
            end: vbuffered.end(i)
          });
        }

        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      }
    } catch (error) {// this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }

    return {
      len: 0,
      start: pos,
      end: pos,
      nextStart: undefined
    };
  };

  BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;

      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    var buffered2 = [];

    if (maxHoleDuration) {
      // there might be some small holes between buffer time range
      // consider that holes smaller than maxHoleDuration are irrelevant and build another
      // buffer time range representations that discards those holes
      for (var i = 0; i < buffered.length; i++) {
        var buf2len = buffered2.length;

        if (buf2len) {
          var buf2end = buffered2[buf2len - 1].end; // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)

          if (buffered[i].start - buf2end < maxHoleDuration) {
            // merge overlapping time ranges
            // update lastRange.end only if smaller than item.end
            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            // big hole
            buffered2.push(buffered[i]);
          }
        } else {
          // first value
          buffered2.push(buffered[i]);
        }
      }
    } else {
      buffered2 = buffered;
    }

    var bufferLen = 0; // bufferStartNext can possibly be undefined based on the conditional logic below

    var bufferStartNext; // bufferStart and bufferEnd are buffer boundaries around current video position

    var bufferStart = pos;
    var bufferEnd = pos;

    for (var _i = 0; _i < buffered2.length; _i++) {
      var start = buffered2[_i].start;
      var end = buffered2[_i].end; // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));

      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }

    return {
      len: bufferLen,
      start: bufferStart || 0,
      end: bufferEnd || 0,
      nextStart: bufferStartNext
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  ;

  BufferHelper.getBuffered = function getBuffered(media) {
    try {
      return media.buffered;
    } catch (e) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log('failed to get media.buffered', e);
      return noopBuffered;
    }
  };

  return BufferHelper;
}();

/***/ }),

/***/ "./src/utils/cea-608-parser.ts":
/*!*************************************!*\
  !*** ./src/utils/cea-608-parser.ts ***!
  \*************************************/
/*! exports provided: Row, CaptionScreen, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Row", function() { return Row; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CaptionScreen", function() { return CaptionScreen; });
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
  0x2a: 0xe1,
  // lowercase a, acute accent
  0x5c: 0xe9,
  // lowercase e, acute accent
  0x5e: 0xed,
  // lowercase i, acute accent
  0x5f: 0xf3,
  // lowercase o, acute accent
  0x60: 0xfa,
  // lowercase u, acute accent
  0x7b: 0xe7,
  // lowercase c with cedilla
  0x7c: 0xf7,
  // division symbol
  0x7d: 0xd1,
  // uppercase N tilde
  0x7e: 0xf1,
  // lowercase n tilde
  0x7f: 0x2588,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  0x80: 0xae,
  // Registered symbol (R)
  0x81: 0xb0,
  // degree sign
  0x82: 0xbd,
  // 1/2 symbol
  0x83: 0xbf,
  // Inverted (open) question mark
  0x84: 0x2122,
  // Trademark symbol (TM)
  0x85: 0xa2,
  // Cents symbol
  0x86: 0xa3,
  // Pounds sterling
  0x87: 0x266a,
  // Music 8'th note
  0x88: 0xe0,
  // lowercase a, grave accent
  0x89: 0x20,
  // transparent space (regular)
  0x8a: 0xe8,
  // lowercase e, grave accent
  0x8b: 0xe2,
  // lowercase a, circumflex accent
  0x8c: 0xea,
  // lowercase e, circumflex accent
  0x8d: 0xee,
  // lowercase i, circumflex accent
  0x8e: 0xf4,
  // lowercase o, circumflex accent
  0x8f: 0xfb,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  0x90: 0xc1,
  // capital letter A with acute
  0x91: 0xc9,
  // capital letter E with acute
  0x92: 0xd3,
  // capital letter O with acute
  0x93: 0xda,
  // capital letter U with acute
  0x94: 0xdc,
  // capital letter U with diaresis
  0x95: 0xfc,
  // lowercase letter U with diaeresis
  0x96: 0x2018,
  // opening single quote
  0x97: 0xa1,
  // inverted exclamation mark
  0x98: 0x2a,
  // asterisk
  0x99: 0x2019,
  // closing single quote
  0x9a: 0x2501,
  // box drawings heavy horizontal
  0x9b: 0xa9,
  // copyright sign
  0x9c: 0x2120,
  // Service mark
  0x9d: 0x2022,
  // (round) bullet
  0x9e: 0x201c,
  // Left double quotation mark
  0x9f: 0x201d,
  // Right double quotation mark
  0xa0: 0xc0,
  // uppercase A, grave accent
  0xa1: 0xc2,
  // uppercase A, circumflex
  0xa2: 0xc7,
  // uppercase C with cedilla
  0xa3: 0xc8,
  // uppercase E, grave accent
  0xa4: 0xca,
  // uppercase E, circumflex
  0xa5: 0xcb,
  // capital letter E with diaresis
  0xa6: 0xeb,
  // lowercase letter e with diaresis
  0xa7: 0xce,
  // uppercase I, circumflex
  0xa8: 0xcf,
  // uppercase I, with diaresis
  0xa9: 0xef,
  // lowercase i, with diaresis
  0xaa: 0xd4,
  // uppercase O, circumflex
  0xab: 0xd9,
  // uppercase U, grave accent
  0xac: 0xf9,
  // lowercase u, grave accent
  0xad: 0xdb,
  // uppercase U, circumflex
  0xae: 0xab,
  // left-pointing double angle quotation mark
  0xaf: 0xbb,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  0xb0: 0xc3,
  // Uppercase A, tilde
  0xb1: 0xe3,
  // Lowercase a, tilde
  0xb2: 0xcd,
  // Uppercase I, acute accent
  0xb3: 0xcc,
  // Uppercase I, grave accent
  0xb4: 0xec,
  // Lowercase i, grave accent
  0xb5: 0xd2,
  // Uppercase O, grave accent
  0xb6: 0xf2,
  // Lowercase o, grave accent
  0xb7: 0xd5,
  // Uppercase O, tilde
  0xb8: 0xf5,
  // Lowercase o, tilde
  0xb9: 0x7b,
  // Open curly brace
  0xba: 0x7d,
  // Closing curly brace
  0xbb: 0x5c,
  // Backslash
  0xbc: 0x5e,
  // Caret
  0xbd: 0x5f,
  // Underscore
  0xbe: 0x7c,
  // Pipe (vertical line)
  0xbf: 0x223c,
  // Tilde operator
  0xc0: 0xc4,
  // Uppercase A, umlaut
  0xc1: 0xe4,
  // Lowercase A, umlaut
  0xc2: 0xd6,
  // Uppercase O, umlaut
  0xc3: 0xf6,
  // Lowercase o, umlaut
  0xc4: 0xdf,
  // Esszett (sharp S)
  0xc5: 0xa5,
  // Yen symbol
  0xc6: 0xa4,
  // Generic currency sign
  0xc7: 0x2503,
  // Box drawings heavy vertical
  0xc8: 0xc5,
  // Uppercase A, ring
  0xc9: 0xe5,
  // Lowercase A, ring
  0xca: 0xd8,
  // Uppercase O, stroke
  0xcb: 0xf8,
  // Lowercase o, strok
  0xcc: 0x250f,
  // Box drawings heavy down and right
  0xcd: 0x2513,
  // Box drawings heavy down and left
  0xce: 0x2517,
  // Box drawings heavy up and right
  0xcf: 0x251b // Box drawings heavy up and left

};
/**
 * Utils
 */

var getCharForByte = function getCharForByte(_byte) {
  var charCode = _byte;

  if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
    charCode = specialCea608CharsCodes[_byte];
  }

  return String.fromCharCode(charCode);
};

var NR_ROWS = 15;
var NR_COLS = 100; // Tables to look up row from PAC data

var rowsLowCh1 = {
  0x11: 1,
  0x12: 3,
  0x15: 5,
  0x16: 7,
  0x17: 9,
  0x10: 11,
  0x13: 12,
  0x14: 14
};
var rowsHighCh1 = {
  0x11: 2,
  0x12: 4,
  0x15: 6,
  0x16: 8,
  0x17: 10,
  0x13: 13,
  0x14: 15
};
var rowsLowCh2 = {
  0x19: 1,
  0x1a: 3,
  0x1d: 5,
  0x1e: 7,
  0x1f: 9,
  0x18: 11,
  0x1b: 12,
  0x1c: 14
};
var rowsHighCh2 = {
  0x19: 2,
  0x1a: 4,
  0x1d: 6,
  0x1e: 8,
  0x1f: 10,
  0x1b: 13,
  0x1c: 15
};
var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];
var VerboseLevel;

(function (VerboseLevel) {
  VerboseLevel[VerboseLevel["ERROR"] = 0] = "ERROR";
  VerboseLevel[VerboseLevel["TEXT"] = 1] = "TEXT";
  VerboseLevel[VerboseLevel["WARNING"] = 2] = "WARNING";
  VerboseLevel[VerboseLevel["INFO"] = 2] = "INFO";
  VerboseLevel[VerboseLevel["DEBUG"] = 3] = "DEBUG";
  VerboseLevel[VerboseLevel["DATA"] = 3] = "DATA";
})(VerboseLevel || (VerboseLevel = {}));

var CaptionsLogger = /*#__PURE__*/function () {
  function CaptionsLogger() {
    this.time = null;
    this.verboseLevel = VerboseLevel.ERROR;
  }

  var _proto = CaptionsLogger.prototype;

  _proto.log = function log(severity, msg) {
    if (this.verboseLevel >= severity) {
      _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log(this.time + " [" + severity + "] " + msg);
    }
  };

  return CaptionsLogger;
}();

var numArrayToHexArray = function numArrayToHexArray(numArray) {
  var hexArray = [];

  for (var j = 0; j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }

  return hexArray;
};

var PenState = /*#__PURE__*/function () {
  function PenState(foreground, underline, italics, background, flash) {
    this.foreground = void 0;
    this.underline = void 0;
    this.italics = void 0;
    this.background = void 0;
    this.flash = void 0;
    this.foreground = foreground || 'white';
    this.underline = underline || false;
    this.italics = italics || false;
    this.background = background || 'black';
    this.flash = flash || false;
  }

  var _proto2 = PenState.prototype;

  _proto2.reset = function reset() {
    this.foreground = 'white';
    this.underline = false;
    this.italics = false;
    this.background = 'black';
    this.flash = false;
  };

  _proto2.setStyles = function setStyles(styles) {
    var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];

    for (var i = 0; i < attribs.length; i++) {
      var style = attribs[i];

      if (styles.hasOwnProperty(style)) {
        this[style] = styles[style];
      }
    }
  };

  _proto2.isDefault = function isDefault() {
    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
  };

  _proto2.equals = function equals(other) {
    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
  };

  _proto2.copy = function copy(newPenState) {
    this.foreground = newPenState.foreground;
    this.underline = newPenState.underline;
    this.italics = newPenState.italics;
    this.background = newPenState.background;
    this.flash = newPenState.flash;
  };

  _proto2.toString = function toString() {
    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
  };

  return PenState;
}();
/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = /*#__PURE__*/function () {
  function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
    this.uchar = void 0;
    this.penState = void 0;
    this.uchar = uchar || ' '; // unicode character

    this.penState = new PenState(foreground, underline, italics, background, flash);
  }

  var _proto3 = StyledUnicodeChar.prototype;

  _proto3.reset = function reset() {
    this.uchar = ' ';
    this.penState.reset();
  };

  _proto3.setChar = function setChar(uchar, newPenState) {
    this.uchar = uchar;
    this.penState.copy(newPenState);
  };

  _proto3.setPenState = function setPenState(newPenState) {
    this.penState.copy(newPenState);
  };

  _proto3.equals = function equals(other) {
    return this.uchar === other.uchar && this.penState.equals(other.penState);
  };

  _proto3.copy = function copy(newChar) {
    this.uchar = newChar.uchar;
    this.penState.copy(newChar.penState);
  };

  _proto3.isEmpty = function isEmpty() {
    return this.uchar === ' ' && this.penState.isDefault();
  };

  return StyledUnicodeChar;
}();
/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = /*#__PURE__*/function () {
  function Row(logger) {
    this.chars = void 0;
    this.pos = void 0;
    this.currPenState = void 0;
    this.cueStartTime = void 0;
    this.logger = void 0;
    this.chars = [];

    for (var i = 0; i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar());
    }

    this.logger = logger;
    this.pos = 0;
    this.currPenState = new PenState();
  }

  var _proto4 = Row.prototype;

  _proto4.equals = function equals(other) {
    var equal = true;

    for (var i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].equals(other.chars[i])) {
        equal = false;
        break;
      }
    }

    return equal;
  };

  _proto4.copy = function copy(other) {
    for (var i = 0; i < NR_COLS; i++) {
      this.chars[i].copy(other.chars[i]);
    }
  };

  _proto4.isEmpty = function isEmpty() {
    var empty = true;

    for (var i = 0; i < NR_COLS; i++) {
      if (!this.chars[i].isEmpty()) {
        empty = false;
        break;
      }
    }

    return empty;
  }
  /**
   *  Set the cursor to a valid column.
   */
  ;

  _proto4.setCursor = function setCursor(absPos) {
    if (this.pos !== absPos) {
      this.pos = absPos;
    }

    if (this.pos < 0) {
      this.logger.log(VerboseLevel.DEBUG, 'Negative cursor position ' + this.pos);
      this.pos = 0;
    } else if (this.pos > NR_COLS) {
      this.logger.log(VerboseLevel.DEBUG, 'Too large cursor position ' + this.pos);
      this.pos = NR_COLS;
    }
  }
  /**
   * Move the cursor relative to current position.
   */
  ;

  _proto4.moveCursor = function moveCursor(relPos) {
    var newPos = this.pos + relPos;

    if (relPos > 1) {
      for (var i = this.pos + 1; i < newPos + 1; i++) {
        this.chars[i].setPenState(this.currPenState);
      }
    }

    this.setCursor(newPos);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  ;

  _proto4.backSpace = function backSpace() {
    this.moveCursor(-1);
    this.chars[this.pos].setChar(' ', this.currPenState);
  };

  _proto4.insertChar = function insertChar(_byte2) {
    if (_byte2 >= 0x90) {
      // Extended char
      this.backSpace();
    }

    var _char = getCharForByte(_byte2);

    if (this.pos >= NR_COLS) {
      this.logger.log(VerboseLevel.ERROR, 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + this.pos + '. Skipping it!');
      return;
    }

    this.chars[this.pos].setChar(_char, this.currPenState);
    this.moveCursor(1);
  };

  _proto4.clearFromPos = function clearFromPos(startPos) {
    var i;

    for (i = startPos; i < NR_COLS; i++) {
      this.chars[i].reset();
    }
  };

  _proto4.clear = function clear() {
    this.clearFromPos(0);
    this.pos = 0;
    this.currPenState.reset();
  };

  _proto4.clearToEndOfRow = function clearToEndOfRow() {
    this.clearFromPos(this.pos);
  };

  _proto4.getTextString = function getTextString() {
    var chars = [];
    var empty = true;

    for (var i = 0; i < NR_COLS; i++) {
      var _char2 = this.chars[i].uchar;

      if (_char2 !== ' ') {
        empty = false;
      }

      chars.push(_char2);
    }

    if (empty) {
      return '';
    } else {
      return chars.join('');
    }
  };

  _proto4.setPenStyles = function setPenStyles(styles) {
    this.currPenState.setStyles(styles);
    var currChar = this.chars[this.pos];
    currChar.setPenState(this.currPenState);
  };

  return Row;
}();
/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
 */

var CaptionScreen = /*#__PURE__*/function () {
  function CaptionScreen(logger) {
    this.rows = void 0;
    this.currRow = void 0;
    this.nrRollUpRows = void 0;
    this.lastOutputScreen = void 0;
    this.logger = void 0;
    this.rows = [];

    for (var i = 0; i < NR_ROWS; i++) {
      this.rows.push(new Row(logger));
    } // Note that we use zero-based numbering (0-14)


    this.logger = logger;
    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.lastOutputScreen = null;
    this.reset();
  }

  var _proto5 = CaptionScreen.prototype;

  _proto5.reset = function reset() {
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows[i].clear();
    }

    this.currRow = NR_ROWS - 1;
  };

  _proto5.equals = function equals(other) {
    var equal = true;

    for (var i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].equals(other.rows[i])) {
        equal = false;
        break;
      }
    }

    return equal;
  };

  _proto5.copy = function copy(other) {
    for (var i = 0; i < NR_ROWS; i++) {
      this.rows[i].copy(other.rows[i]);
    }
  };

  _proto5.isEmpty = function isEmpty() {
    var empty = true;

    for (var i = 0; i < NR_ROWS; i++) {
      if (!this.rows[i].isEmpty()) {
        empty = false;
        break;
      }
    }

    return empty;
  };

  _proto5.backSpace = function backSpace() {
    var row = this.rows[this.currRow];
    row.backSpace();
  };

  _proto5.clearToEndOfRow = function clearToEndOfRow() {
    var row = this.rows[this.currRow];
    row.clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  ;

  _proto5.insertChar = function insertChar(_char3) {
    var row = this.rows[this.currRow];
    row.insertChar(_char3);
  };

  _proto5.setPen = function setPen(styles) {
    var row = this.rows[this.currRow];
    row.setPenStyles(styles);
  };

  _proto5.moveCursor = function moveCursor(relPos) {
    var row = this.rows[this.currRow];
    row.moveCursor(relPos);
  };

  _proto5.setCursor = function setCursor(absPos) {
    this.logger.log(VerboseLevel.INFO, 'setCursor: ' + absPos);
    var row = this.rows[this.currRow];
    row.setCursor(absPos);
  };

  _proto5.setPAC = function setPAC(pacData) {
    this.logger.log(VerboseLevel.INFO, 'pacData = ' + JSON.stringify(pacData));
    var newRow = pacData.row - 1;

    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
      newRow = this.nrRollUpRows - 1;
    } // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows


    if (this.nrRollUpRows && this.currRow !== newRow) {
      // clear all rows first
      for (var i = 0; i < NR_ROWS; i++) {
        this.rows[i].clear();
      } // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
      // topRowIndex - the start of rows to copy (inclusive index)


      var topRowIndex = this.currRow + 1 - this.nrRollUpRows; // We only copy if the last position was already shown.
      // We use the cueStartTime value to check this.

      var lastOutputScreen = this.lastOutputScreen;

      if (lastOutputScreen) {
        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
        var time = this.logger.time;

        if (prevLineTime && time !== null && prevLineTime < time) {
          for (var _i = 0; _i < this.nrRollUpRows; _i++) {
            this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
          }
        }
      }
    }

    this.currRow = newRow;
    var row = this.rows[this.currRow];

    if (pacData.indent !== null) {
      var indent = pacData.indent;
      var prevPos = Math.max(indent - 1, 0);
      row.setCursor(pacData.indent);
      pacData.color = row.chars[prevPos].penState.foreground;
    }

    var styles = {
      foreground: pacData.color,
      underline: pacData.underline,
      italics: pacData.italics,
      background: 'black',
      flash: false
    };
    this.setPen(styles);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  ;

  _proto5.setBkgData = function setBkgData(bkgData) {
    this.logger.log(VerboseLevel.INFO, 'bkgData = ' + JSON.stringify(bkgData));
    this.backSpace();
    this.setPen(bkgData);
    this.insertChar(0x20); // Space
  };

  _proto5.setRollUpRows = function setRollUpRows(nrRows) {
    this.nrRollUpRows = nrRows;
  };

  _proto5.rollUp = function rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(VerboseLevel.DEBUG, 'roll_up but nrRollUpRows not set yet');
      return; // Not properly setup
    }

    this.logger.log(VerboseLevel.TEXT, this.getDisplayText());
    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
    var topRow = this.rows.splice(topRowIndex, 1)[0];
    topRow.clear();
    this.rows.splice(this.currRow, 0, topRow);
    this.logger.log(VerboseLevel.INFO, 'Rolling up'); // this.logger.log(VerboseLevel.TEXT, this.get_display_text())
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  ;

  _proto5.getDisplayText = function getDisplayText(asOneRow) {
    asOneRow = asOneRow || false;
    var displayText = [];
    var text = '';
    var rowNr = -1;

    for (var i = 0; i < NR_ROWS; i++) {
      var rowText = this.rows[i].getTextString();

      if (rowText) {
        rowNr = i + 1;

        if (asOneRow) {
          displayText.push('Row ' + rowNr + ": '" + rowText + "'");
        } else {
          displayText.push(rowText.trim());
        }
      }
    }

    if (displayText.length > 0) {
      if (asOneRow) {
        text = '[' + displayText.join(' | ') + ']';
      } else {
        text = displayText.join('\n');
      }
    }

    return text;
  };

  _proto5.getTextAndFormat = function getTextAndFormat() {
    return this.rows;
  };

  return CaptionScreen;
}(); // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = /*#__PURE__*/function () {
  function Cea608Channel(channelNumber, outputFilter, logger) {
    this.chNr = void 0;
    this.outputFilter = void 0;
    this.mode = void 0;
    this.verbose = void 0;
    this.displayedMemory = void 0;
    this.nonDisplayedMemory = void 0;
    this.lastOutputScreen = void 0;
    this.currRollUpRow = void 0;
    this.writeScreen = void 0;
    this.cueStartTime = void 0;
    this.logger = void 0;
    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen(logger);
    this.nonDisplayedMemory = new CaptionScreen(logger);
    this.lastOutputScreen = new CaptionScreen(logger);
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null; // Keeps track of where a cue started.

    this.logger = logger;
  }

  var _proto6 = Cea608Channel.prototype;

  _proto6.reset = function reset() {
    this.mode = null;
    this.displayedMemory.reset();
    this.nonDisplayedMemory.reset();
    this.lastOutputScreen.reset();
    this.outputFilter.reset();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
  };

  _proto6.getHandler = function getHandler() {
    return this.outputFilter;
  };

  _proto6.setHandler = function setHandler(newHandler) {
    this.outputFilter = newHandler;
  };

  _proto6.setPAC = function setPAC(pacData) {
    this.writeScreen.setPAC(pacData);
  };

  _proto6.setBkgData = function setBkgData(bkgData) {
    this.writeScreen.setBkgData(bkgData);
  };

  _proto6.setMode = function setMode(newMode) {
    if (newMode === this.mode) {
      return;
    }

    this.mode = newMode;
    this.logger.log(VerboseLevel.INFO, 'MODE=' + newMode);

    if (this.mode === 'MODE_POP-ON') {
      this.writeScreen = this.nonDisplayedMemory;
    } else {
      this.writeScreen = this.displayedMemory;
      this.writeScreen.reset();
    }

    if (this.mode !== 'MODE_ROLL-UP') {
      this.displayedMemory.nrRollUpRows = null;
      this.nonDisplayedMemory.nrRollUpRows = null;
    }

    this.mode = newMode;
  };

  _proto6.insertChars = function insertChars(chars) {
    for (var i = 0; i < chars.length; i++) {
      this.writeScreen.insertChar(chars[i]);
    }

    var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
    this.logger.log(VerboseLevel.INFO, screen + ': ' + this.writeScreen.getDisplayText(true));

    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
      this.logger.log(VerboseLevel.TEXT, 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
      this.outputDataUpdate();
    }
  };

  _proto6.ccRCL = function ccRCL() {
    // Resume Caption Loading (switch mode to Pop On)
    this.logger.log(VerboseLevel.INFO, 'RCL - Resume Caption Loading');
    this.setMode('MODE_POP-ON');
  };

  _proto6.ccBS = function ccBS() {
    // BackSpace
    this.logger.log(VerboseLevel.INFO, 'BS - BackSpace');

    if (this.mode === 'MODE_TEXT') {
      return;
    }

    this.writeScreen.backSpace();

    if (this.writeScreen === this.displayedMemory) {
      this.outputDataUpdate();
    }
  };

  _proto6.ccAOF = function ccAOF() {// Reserved (formerly Alarm Off)
  };

  _proto6.ccAON = function ccAON() {// Reserved (formerly Alarm On)
  };

  _proto6.ccDER = function ccDER() {
    // Delete to End of Row
    this.logger.log(VerboseLevel.INFO, 'DER- Delete to End of Row');
    this.writeScreen.clearToEndOfRow();
    this.outputDataUpdate();
  };

  _proto6.ccRU = function ccRU(nrRows) {
    // Roll-Up Captions-2,3,or 4 Rows
    this.logger.log(VerboseLevel.INFO, 'RU(' + nrRows + ') - Roll Up');
    this.writeScreen = this.displayedMemory;
    this.setMode('MODE_ROLL-UP');
    this.writeScreen.setRollUpRows(nrRows);
  };

  _proto6.ccFON = function ccFON() {
    // Flash On
    this.logger.log(VerboseLevel.INFO, 'FON - Flash On');
    this.writeScreen.setPen({
      flash: true
    });
  };

  _proto6.ccRDC = function ccRDC() {
    // Resume Direct Captioning (switch mode to PaintOn)
    this.logger.log(VerboseLevel.INFO, 'RDC - Resume Direct Captioning');
    this.setMode('MODE_PAINT-ON');
  };

  _proto6.ccTR = function ccTR() {
    // Text Restart in text mode (not supported, however)
    this.logger.log(VerboseLevel.INFO, 'TR');
    this.setMode('MODE_TEXT');
  };

  _proto6.ccRTD = function ccRTD() {
    // Resume Text Display in Text mode (not supported, however)
    this.logger.log(VerboseLevel.INFO, 'RTD');
    this.setMode('MODE_TEXT');
  };

  _proto6.ccEDM = function ccEDM() {
    // Erase Displayed Memory
    this.logger.log(VerboseLevel.INFO, 'EDM - Erase Displayed Memory');
    this.displayedMemory.reset();
    this.outputDataUpdate(true);
  };

  _proto6.ccCR = function ccCR() {
    // Carriage Return
    this.logger.log(VerboseLevel.INFO, 'CR - Carriage Return');
    this.writeScreen.rollUp();
    this.outputDataUpdate(true);
  };

  _proto6.ccENM = function ccENM() {
    // Erase Non-Displayed Memory
    this.logger.log(VerboseLevel.INFO, 'ENM - Erase Non-displayed Memory');
    this.nonDisplayedMemory.reset();
  };

  _proto6.ccEOC = function ccEOC() {
    // End of Caption (Flip Memories)
    this.logger.log(VerboseLevel.INFO, 'EOC - End Of Caption');

    if (this.mode === 'MODE_POP-ON') {
      var tmp = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory;
      this.nonDisplayedMemory = tmp;
      this.writeScreen = this.nonDisplayedMemory;
      this.logger.log(VerboseLevel.TEXT, 'DISP: ' + this.displayedMemory.getDisplayText());
    }

    this.outputDataUpdate(true);
  };

  _proto6.ccTO = function ccTO(nrCols) {
    // Tab Offset 1,2, or 3 columns
    this.logger.log(VerboseLevel.INFO, 'TO(' + nrCols + ') - Tab Offset');
    this.writeScreen.moveCursor(nrCols);
  };

  _proto6.ccMIDROW = function ccMIDROW(secondByte) {
    // Parse MIDROW command
    var styles = {
      flash: false
    };
    styles.underline = secondByte % 2 === 1;
    styles.italics = secondByte >= 0x2e;

    if (!styles.italics) {
      var colorIndex = Math.floor(secondByte / 2) - 0x10;
      var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
      styles.foreground = colors[colorIndex];
    } else {
      styles.foreground = 'white';
    }

    this.logger.log(VerboseLevel.INFO, 'MIDROW: ' + JSON.stringify(styles));
    this.writeScreen.setPen(styles);
  };

  _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
    if (dispatch === void 0) {
      dispatch = false;
    }

    var time = this.logger.time;

    if (time === null) {
      return;
    }

    if (this.outputFilter) {
      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
        // Start of a new cue
        this.cueStartTime = time;
      } else {
        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);

          if (dispatch && this.outputFilter.dispatchCue) {
            this.outputFilter.dispatchCue();
          }

          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
        }
      }

      this.lastOutputScreen.copy(this.displayedMemory);
    }
  };

  _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
    if (this.outputFilter) {
      if (!this.displayedMemory.isEmpty()) {
        if (this.outputFilter.newCue) {
          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
        }

        this.cueStartTime = t;
      }
    }
  };

  return Cea608Channel;
}();

var Cea608Parser = /*#__PURE__*/function () {
  function Cea608Parser(field, out1, out2) {
    this.channels = void 0;
    this.currentChannel = 0;
    this.cmdHistory = void 0;
    this.logger = void 0;
    var logger = new CaptionsLogger();
    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];
    this.cmdHistory = createCmdHistory();
    this.logger = logger;
  }

  var _proto7 = Cea608Parser.prototype;

  _proto7.getHandler = function getHandler(channel) {
    return this.channels[channel].getHandler();
  };

  _proto7.setHandler = function setHandler(channel, newHandler) {
    this.channels[channel].setHandler(newHandler);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  ;

  _proto7.addData = function addData(time, byteList) {
    var cmdFound;
    var a;
    var b;
    var charsFound = false;
    this.logger.time = time;

    for (var i = 0; i < byteList.length; i += 2) {
      a = byteList[i] & 0x7f;
      b = byteList[i + 1] & 0x7f;

      if (a === 0 && b === 0) {
        continue;
      } else {
        this.logger.log(VerboseLevel.DATA, '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
      }

      cmdFound = this.parseCmd(a, b);

      if (!cmdFound) {
        cmdFound = this.parseMidrow(a, b);
      }

      if (!cmdFound) {
        cmdFound = this.parsePAC(a, b);
      }

      if (!cmdFound) {
        cmdFound = this.parseBackgroundAttributes(a, b);
      }

      if (!cmdFound) {
        charsFound = this.parseChars(a, b);

        if (charsFound) {
          var currChNr = this.currentChannel;

          if (currChNr && currChNr > 0) {
            var channel = this.channels[currChNr];
            channel.insertChars(charsFound);
          } else {
            this.logger.log(VerboseLevel.WARNING, 'No channel found yet. TEXT-MODE?');
          }
        }
      }

      if (!cmdFound && !charsFound) {
        this.logger.log(VerboseLevel.WARNING, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
      }
    }
  }
  /**
   * Parse Command.
   * @returns {Boolean} Tells if a command was found
   */
  ;

  _proto7.parseCmd = function parseCmd(a, b) {
    var cmdHistory = this.cmdHistory;
    var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;
    var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;

    if (!(cond1 || cond2)) {
      return false;
    }

    if (hasCmdRepeated(a, b, cmdHistory)) {
      setLastCmd(null, null, cmdHistory);
      this.logger.log(VerboseLevel.DEBUG, 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
      return true;
    }

    var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;
    var channel = this.channels[chNr];

    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {
      if (b === 0x20) {
        channel.ccRCL();
      } else if (b === 0x21) {
        channel.ccBS();
      } else if (b === 0x22) {
        channel.ccAOF();
      } else if (b === 0x23) {
        channel.ccAON();
      } else if (b === 0x24) {
        channel.ccDER();
      } else if (b === 0x25) {
        channel.ccRU(2);
      } else if (b === 0x26) {
        channel.ccRU(3);
      } else if (b === 0x27) {
        channel.ccRU(4);
      } else if (b === 0x28) {
        channel.ccFON();
      } else if (b === 0x29) {
        channel.ccRDC();
      } else if (b === 0x2a) {
        channel.ccTR();
      } else if (b === 0x2b) {
        channel.ccRTD();
      } else if (b === 0x2c) {
        channel.ccEDM();
      } else if (b === 0x2d) {
        channel.ccCR();
      } else if (b === 0x2e) {
        channel.ccENM();
      } else if (b === 0x2f) {
        channel.ccEOC();
      }
    } else {
      // a == 0x17 || a == 0x1F
      channel.ccTO(b - 0x20);
    }

    setLastCmd(a, b, cmdHistory);
    this.currentChannel = chNr;
    return true;
  }
  /**
   * Parse midrow styling command
   * @returns {Boolean}
   */
  ;

  _proto7.parseMidrow = function parseMidrow(a, b) {
    var chNr = 0;

    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {
      if (a === 0x11) {
        chNr = 1;
      } else {
        chNr = 2;
      }

      if (chNr !== this.currentChannel) {
        this.logger.log(VerboseLevel.ERROR, 'Mismatch channel in midrow parsing');
        return false;
      }

      var channel = this.channels[chNr];

      if (!channel) {
        return false;
      }

      channel.ccMIDROW(b);
      this.logger.log(VerboseLevel.DEBUG, 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
      return true;
    }

    return false;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  ;

  _proto7.parsePAC = function parsePAC(a, b) {
    var row;
    var cmdHistory = this.cmdHistory;
    var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;
    var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;

    if (!(case1 || case2)) {
      return false;
    }

    if (hasCmdRepeated(a, b, cmdHistory)) {
      setLastCmd(null, null, cmdHistory);
      return true; // Repeated commands are dropped (once)
    }

    var chNr = a <= 0x17 ? 1 : 2;

    if (b >= 0x40 && b <= 0x5f) {
      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
    } else {
      // 0x60 <= b <= 0x7F
      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
    }

    var channel = this.channels[chNr];

    if (!channel) {
      return false;
    }

    channel.setPAC(this.interpretPAC(row, b));
    setLastCmd(a, b, cmdHistory);
    this.currentChannel = chNr;
    return true;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns {Object} pacData with style parameters.
   */
  ;

  _proto7.interpretPAC = function interpretPAC(row, _byte3) {
    var pacIndex = _byte3;
    var pacData = {
      color: null,
      italics: false,
      indent: null,
      underline: false,
      row: row
    };

    if (_byte3 > 0x5f) {
      pacIndex = _byte3 - 0x60;
    } else {
      pacIndex = _byte3 - 0x40;
    }

    pacData.underline = (pacIndex & 1) === 1;

    if (pacIndex <= 0xd) {
      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
    } else if (pacIndex <= 0xf) {
      pacData.italics = true;
      pacData.color = 'white';
    } else {
      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
    }

    return pacData; // Note that row has zero offset. The spec uses 1.
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  ;

  _proto7.parseChars = function parseChars(a, b) {
    var channelNr;
    var charCodes = null;
    var charCode1 = null;

    if (a >= 0x19) {
      channelNr = 2;
      charCode1 = a - 8;
    } else {
      channelNr = 1;
      charCode1 = a;
    }

    if (charCode1 >= 0x11 && charCode1 <= 0x13) {
      // Special character
      var oneCode = b;

      if (charCode1 === 0x11) {
        oneCode = b + 0x50;
      } else if (charCode1 === 0x12) {
        oneCode = b + 0x70;
      } else {
        oneCode = b + 0x90;
      }

      this.logger.log(VerboseLevel.INFO, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
      charCodes = [oneCode];
    } else if (a >= 0x20 && a <= 0x7f) {
      charCodes = b === 0 ? [a] : [a, b];
    }

    if (charCodes) {
      var hexCodes = numArrayToHexArray(charCodes);
      this.logger.log(VerboseLevel.DEBUG, 'Char codes =  ' + hexCodes.join(','));
      setLastCmd(a, b, this.cmdHistory);
    }

    return charCodes;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns {Boolean} Tells if background attributes are found
   */
  ;

  _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
    var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;
    var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;

    if (!(case1 || case2)) {
      return false;
    }

    var index;
    var bkgData = {};

    if (a === 0x10 || a === 0x18) {
      index = Math.floor((b - 0x20) / 2);
      bkgData.background = backgroundColors[index];

      if (b % 2 === 1) {
        bkgData.background = bkgData.background + '_semi';
      }
    } else if (b === 0x2d) {
      bkgData.background = 'transparent';
    } else {
      bkgData.foreground = 'black';

      if (b === 0x2f) {
        bkgData.underline = true;
      }
    }

    var chNr = a <= 0x17 ? 1 : 2;
    var channel = this.channels[chNr];
    channel.setBkgData(bkgData);
    setLastCmd(a, b, this.cmdHistory);
    return true;
  }
  /**
   * Reset state of parser and its channels.
   */
  ;

  _proto7.reset = function reset() {
    for (var i = 0; i < Object.keys(this.channels).length; i++) {
      var channel = this.channels[i];

      if (channel) {
        channel.reset();
      }
    }

    this.cmdHistory = createCmdHistory();
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  ;

  _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
    for (var i = 0; i < this.channels.length; i++) {
      var channel = this.channels[i];

      if (channel) {
        channel.cueSplitAtTime(t);
      }
    }
  };

  return Cea608Parser;
}();

function setLastCmd(a, b, cmdHistory) {
  cmdHistory.a = a;
  cmdHistory.b = b;
}

function hasCmdRepeated(a, b, cmdHistory) {
  return cmdHistory.a === a && cmdHistory.b === b;
}

function createCmdHistory() {
  return {
    a: null,
    b: null
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Cea608Parser);

/***/ }),

/***/ "./src/utils/codecs.ts":
/*!*****************************!*\
  !*** ./src/utils/codecs.ts ***!
  \*****************************/
/*! exports provided: isCodecType, isCodecSupportedInMp4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCodecType", function() { return isCodecType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCodecSupportedInMp4", function() { return isCodecSupportedInMp4; });
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
  audio: {
    a3ds: true,
    'ac-3': true,
    'ac-4': true,
    alac: true,
    alaw: true,
    dra1: true,
    'dts+': true,
    'dts-': true,
    dtsc: true,
    dtse: true,
    dtsh: true,
    'ec-3': true,
    enca: true,
    g719: true,
    g726: true,
    m4ae: true,
    mha1: true,
    mha2: true,
    mhm1: true,
    mhm2: true,
    mlpa: true,
    mp4a: true,
    'raw ': true,
    Opus: true,
    samr: true,
    sawb: true,
    sawp: true,
    sevc: true,
    sqcp: true,
    ssmv: true,
    twos: true,
    ulaw: true
  },
  video: {
    avc1: true,
    avc2: true,
    avc3: true,
    avc4: true,
    avcp: true,
    drac: true,
    dvav: true,
    dvhe: true,
    encv: true,
    hev1: true,
    hvc1: true,
    mjp2: true,
    mp4v: true,
    mvc1: true,
    mvc2: true,
    mvc3: true,
    mvc4: true,
    resv: true,
    rv60: true,
    s263: true,
    svc1: true,
    svc2: true,
    'vc-1': true,
    vp08: true,
    vp09: true
  },
  text: {
    stpp: true,
    wvtt: true
  }
};

function isCodecType(codec, type) {
  var typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
  return MediaSource.isTypeSupported((type || 'video') + "/mp4;codecs=\"" + codec + "\"");
}



/***/ }),

/***/ "./src/utils/cues.ts":
/*!***************************!*\
  !*** ./src/utils/cues.ts ***!
  \***************************/
/*! exports provided: newCue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newCue", function() { return newCue; });
/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");

var WHITESPACE_CHAR = /\s/;
function newCue(track, startTime, endTime, captionScreen) {
  var result = [];
  var row; // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers

  var cue;
  var indenting;
  var indent;
  var text;
  var Cue = self.VTTCue || self.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      } // To be used for cleaning-up orphaned roll-up captions


      row.cueStartTime = startTime; // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE

      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new Cue(startTime, endTime, Object(_vttparser__WEBPACK_IMPORTED_MODULE_0__["fixLineBreaks"])(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      cue.line = r + 1;
      cue.align = 'left'; // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)
      // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608
      // Firefox throws an exception and captions break with out of bounds 0-100 values

      cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
      result.push(cue);
    }
  }

  if (track && result.length) {
    // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome
    var sortedCues = result.sort(function (cueA, cueB) {
      if (cueA.line === 'auto' || cueB.line === 'auto') {
        return 0;
      }

      if (cueA.line > 8 && cueB.line > 8) {
        return cueB.line - cueA.line;
      }

      return cueA.line - cueB.line;
    });

    for (var i = 0; i < sortedCues.length; i++) {
      track.addCue(sortedCues[i]);
    }
  }

  return result;
}

/***/ }),

/***/ "./src/utils/discontinuities.ts":
/*!**************************************!*\
  !*** ./src/utils/discontinuities.ts ***!
  \**************************************/
/*! exports provided: findFirstFragWithCC, shouldAlignOnDiscontinuities, findDiscontinuousReferenceFrag, adjustSlidingStart, alignStream, alignPDT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFirstFragWithCC", function() { return findFirstFragWithCC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shouldAlignOnDiscontinuities", function() { return shouldAlignOnDiscontinuities; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDiscontinuousReferenceFrag", function() { return findDiscontinuousReferenceFrag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjustSlidingStart", function() { return adjustSlidingStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alignStream", function() { return alignStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alignPDT", function() { return alignPDT; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./src/utils/logger.ts");
/* harmony import */ var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controller/level-helper */ "./src/controller/level-helper.ts");



function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0, len = fragments.length; i < len; i++) {
    var currentFrag = fragments[i];

    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}
function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  if (lastLevel.details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      return true;
    }
  }

  return false;
} // Find the first frag in the previous level which matches the CC of the first frag of the new level

function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustFragmentStart(frag, sliding) {
  if (frag) {
    var start = frag.start + sliding;
    frag.start = frag.startPTS = start;
    frag.endPTS = start + frag.duration;
  }
}

function adjustSlidingStart(sliding, details) {
  // Update segments
  var fragments = details.fragments;

  for (var i = 0, len = fragments.length; i < len; i++) {
    adjustFragmentStart(fragments[i], sliding);
  } // Update LL-HLS parts at the end of the playlist


  if (details.fragmentHint) {
    adjustFragmentStart(details.fragmentHint, sliding);
  }

  details.alignedSliding = true;
}
/**
 * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a
 * contiguous stream with the last fragments.
 * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to
 * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time
 * and an extra download.
 * @param lastFrag
 * @param lastLevel
 * @param details
 */

function alignStream(lastFrag, lastLevel, details) {
  if (!lastLevel) {
    return;
  }

  alignDiscontinuities(lastFrag, details, lastLevel);

  if (!details.alignedSliding && lastLevel.details) {
    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.
    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same
    // discontinuity sequence.
    alignPDT(details, lastLevel.details);
  }

  if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {
    // Try to align on sn so that we pick a better start fragment.
    // Do not perform this on playlists with delta updates as this is only to align levels on switch
    // and adjustSliding only adjusts fragments after skippedSegments.
    Object(_controller_level_helper__WEBPACK_IMPORTED_MODULE_2__["adjustSliding"])(lastLevel.details, details);
  }
}
/**
 * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same
 * discontinuity sequence.
 * @param lastFrag - The last Fragment which shares the same discontinuity sequence
 * @param lastLevel - The details of the last loaded level
 * @param details - The details of the new level
 */

function alignDiscontinuities(lastFrag, details, lastLevel) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);

    if (referenceFrag !== null && referenceFrag !== void 0 && referenceFrag.start) {
      _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("Adjusting PTS using last level due to CC increase within current level " + details.url);
      adjustSlidingStart(referenceFrag.start, details);
    }
  }
}
/**
 * Computes the PTS of a new level's fragments using the difference in Program Date Time from the last level.
 * @param details - The details of the new level
 * @param lastDetails - The details of the last loaded level
 */


function alignPDT(details, lastDetails) {
  // This check protects the unsafe "!" usage below for null program date time access.
  if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
    return;
  } // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
  // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
  // then we can deduce that playlist B sliding is 1000+8 = 1008s


  var lastPDT = lastDetails.fragments[0].programDateTime; // hasProgramDateTime check above makes this safe.

  var newPDT = details.fragments[0].programDateTime; // date diff is in ms. frag.start is in seconds

  var sliding = (newPDT - lastPDT) / 1000 + lastDetails.fragments[0].start;

  if (sliding && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(sliding)) {
    _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("Adjusting PTS using programDateTime delta " + (newPDT - lastPDT) + "ms, sliding:" + sliding.toFixed(3) + " " + details.url + " ");
    adjustSlidingStart(sliding, details);
  }
}

/***/ }),

/***/ "./src/utils/ewma-bandwidth-estimator.ts":
/*!***********************************************!*\
  !*** ./src/utils/ewma-bandwidth-estimator.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ewma */ "./src/utils/ewma.ts");
/*
 * EWMA Bandwidth Estimator
 *  - heavily inspired from shaka-player
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 */


var EwmaBandWidthEstimator = /*#__PURE__*/function () {
  function EwmaBandWidthEstimator(slow, fast, defaultEstimate) {
    this.defaultEstimate_ = void 0;
    this.minWeight_ = void 0;
    this.minDelayMs_ = void 0;
    this.slow_ = void 0;
    this.fast_ = void 0;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow);
    this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast);
  }

  var _proto = EwmaBandWidthEstimator.prototype;

  _proto.update = function update(slow, fast) {
    var slow_ = this.slow_,
        fast_ = this.fast_;

    if (this.slow_.halfLife !== slow) {
      this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow, slow_.getEstimate(), slow_.getTotalWeight());
    }

    if (this.fast_.halfLife !== fast) {
      this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast, fast_.getEstimate(), fast_.getTotalWeight());
    }
  };

  _proto.sample = function sample(durationMs, numBytes) {
    durationMs = Math.max(durationMs, this.minDelayMs_);
    var numBits = 8 * numBytes; // weight is duration in seconds

    var durationS = durationMs / 1000; // value is bandwidth in bits/s

    var bandwidthInBps = numBits / durationS;
    this.fast_.sample(durationS, bandwidthInBps);
    this.slow_.sample(durationS, bandwidthInBps);
  };

  _proto.canEstimate = function canEstimate() {
    var fast = this.fast_;
    return fast && fast.getTotalWeight() >= this.minWeight_;
  };

  _proto.getEstimate = function getEstimate() {
    if (this.canEstimate()) {
      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
      // Take the minimum of these two estimates.  This should have the effect of
      // adapting down quickly, but up more slowly.
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    } else {
      return this.defaultEstimate_;
    }
  };

  _proto.destroy = function destroy() {};

  return EwmaBandWidthEstimator;
}();

/* harmony default export */ __webpack_exports__["default"] = (EwmaBandWidthEstimator);

/***/ }),

/***/ "./src/utils/ewma.ts":
/*!***************************!*\
  !*** ./src/utils/ewma.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */
var EWMA = /*#__PURE__*/function () {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife, estimate, weight) {
    if (estimate === void 0) {
      estimate = 0;
    }

    if (weight === void 0) {
      weight = 0;
    }

    this.halfLife = void 0;
    this.alpha_ = void 0;
    this.estimate_ = void 0;
    this.totalWeight_ = void 0;
    this.halfLife = halfLife; // Larger values of alpha expire historical data more slowly.

    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = estimate;
    this.totalWeight_ = weight;
  }

  var _proto = EWMA.prototype;

  _proto.sample = function sample(weight, value) {
    var adjAlpha = Math.pow(this.alpha_, weight);
    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
    this.totalWeight_ += weight;
  };

  _proto.getTotalWeight = function getTotalWeight() {
    return this.totalWeight_;
  };

  _proto.getEstimate = function getEstimate() {
    if (this.alpha_) {
      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);

      if (zeroFactor) {
        return this.estimate_ / zeroFactor;
      }
    }

    return this.estimate_;
  };

  return EWMA;
}();

/* harmony default export */ __webpack_exports__["default"] = (EWMA);

/***/ }),

/***/ "./src/utils/fetch-loader.ts":
/*!***********************************!*\
  !*** ./src/utils/fetch-loader.ts ***!
  \***********************************/
/*! exports provided: fetchSupported, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchSupported", function() { return fetchSupported; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader/load-stats */ "./src/loader/load-stats.ts");
/* harmony import */ var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../demux/chunk-cache */ "./src/demux/chunk-cache.ts");



function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



function fetchSupported() {
  if (self.fetch && self.AbortController && self.ReadableStream && self.Request) {
    try {
      new self.ReadableStream({}); // eslint-disable-line no-new

      return true;
    } catch (e) {
      /* noop */
    }
  }

  return false;
}

var FetchLoader = /*#__PURE__*/function () {
  function FetchLoader(config
  /* HlsConfig */
  ) {
    this.fetchSetup = void 0;
    this.requestTimeout = void 0;
    this.request = void 0;
    this.response = void 0;
    this.controller = void 0;
    this.context = void 0;
    this.config = null;
    this.callbacks = null;
    this.stats = void 0;
    this.loader = null;
    this.fetchSetup = config.fetchSetup || getRequest;
    this.controller = new self.AbortController();
    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  var _proto = FetchLoader.prototype;

  _proto.destroy = function destroy() {
    this.loader = this.callbacks = null;
    this.abortInternal();
  };

  _proto.abortInternal = function abortInternal() {
    this.stats.aborted = true;
    this.controller.abort();
  };

  _proto.abort = function abort() {
    var _this$callbacks;

    this.abortInternal();

    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.response);
    }
  };

  _proto.load = function load(context, config, callbacks) {
    var _this = this;

    var stats = this.stats;

    if (stats.loading.start) {
      throw new Error('Loader can only be used once.');
    }

    stats.loading.start = self.performance.now();
    var initParams = getRequestParameters(context, this.controller.signal);
    var onProgress = callbacks.onProgress;
    var isArrayBuffer = context.responseType === 'arraybuffer';
    var LENGTH = isArrayBuffer ? 'byteLength' : 'length';
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.request = this.fetchSetup(context, initParams);
    self.clearTimeout(this.requestTimeout);
    this.requestTimeout = self.setTimeout(function () {
      _this.abortInternal();

      callbacks.onTimeout(stats, context, _this.response);
    }, config.timeout);
    self.fetch(this.request).then(function (response) {
      _this.response = _this.loader = response;

      if (!response.ok) {
        var status = response.status,
            statusText = response.statusText;
        throw new FetchError(statusText || 'fetch, bad network response', status, response);
      }

      stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
      stats.total = parseInt(response.headers.get('Content-Length') || '0');

      if (onProgress && Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(config.highWaterMark)) {
        _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
      }

      if (isArrayBuffer) {
        return response.arrayBuffer();
      }

      return response.text();
    }).then(function (responseData) {
      var response = _this.response;
      self.clearTimeout(_this.requestTimeout);
      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
      stats.loaded = stats.total = responseData[LENGTH];
      var loaderResponse = {
        url: response.url,
        data: responseData
      };

      if (onProgress && !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(config.highWaterMark)) {
        onProgress(stats, context, responseData, response);
      }

      callbacks.onSuccess(loaderResponse, stats, context, response);
    }).catch(function (error) {
      self.clearTimeout(_this.requestTimeout);

      if (stats.aborted) {
        return;
      } // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior


      var code = error.code || 0;
      callbacks.onError({
        code: code,
        text: error.message
      }, context, error.details);
    });
  };

  _proto.getResponseHeader = function getResponseHeader(name) {
    if (this.response) {
      try {
        return this.response.headers.get(name);
      } catch (error) {
        /* Could not get header */
      }
    }

    return null;
  };

  _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
    if (highWaterMark === void 0) {
      highWaterMark = 0;
    }

    var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__["default"]();
    var reader = response.clone().body.getReader();

    var pump = function pump() {
      reader.read().then(function (data) {
        if (data.done) {
          if (chunkCache.dataLength) {
            onProgress(stats, context, chunkCache.flush(), response);
          }

          return;
        }

        var chunk = data.value;
        var len = chunk.length;
        stats.loaded += len;

        if (len < highWaterMark || chunkCache.dataLength) {
          // The current chunk is too small to to be emitted or the cache already has data
          // Push it to the cache
          chunkCache.push(chunk);

          if (chunkCache.dataLength >= highWaterMark) {
            // flush in order to join the typed arrays
            onProgress(stats, context, chunkCache.flush(), response);
          }
        } else {
          // If there's nothing cached already, and the chache is large enough
          // just emit the progress event
          onProgress(stats, context, chunk, response);
        }

        pump();
      }).catch(function () {
        /* aborted */
      });
    };

    pump();
  };

  return FetchLoader;
}();

function getRequestParameters(context, signal) {
  var initParams = {
    method: 'GET',
    mode: 'cors',
    credentials: 'same-origin',
    signal: signal
  };

  if (context.rangeEnd) {
    initParams.headers = new self.Headers({
      Range: 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1)
    });
  }

  return initParams;
}

function getRequest(context, initParams) {
  return new self.Request(context.url, initParams);
}

var FetchError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(FetchError, _Error);

  function FetchError(message, code, details) {
    var _this2;

    _this2 = _Error.call(this, message) || this;
    _this2.code = void 0;
    _this2.details = void 0;
    _this2.code = code;
    _this2.details = details;
    return _this2;
  }

  return FetchError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/* harmony default export */ __webpack_exports__["default"] = (FetchLoader);

/***/ }),

/***/ "./src/utils/imsc1-ttml-parser.ts":
/*!****************************************!*\
  !*** ./src/utils/imsc1-ttml-parser.ts ***!
  \****************************************/
/*! exports provided: IMSC1_CODEC, parseIMSC1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMSC1_CODEC", function() { return IMSC1_CODEC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseIMSC1", function() { return parseIMSC1; });
/* harmony import */ var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mp4-tools */ "./src/utils/mp4-tools.ts");
/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vttcue */ "./src/utils/vttcue.ts");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./timescale-conversion */ "./src/utils/timescale-conversion.ts");
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }






var IMSC1_CODEC = 'stpp.ttml.im1t'; // Time format: h:m:s:frames(.subframes)

var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/; // Time format: hours, minutes, seconds, milliseconds, frames, ticks

var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
function parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {
  var results = Object(_mp4_tools__WEBPACK_IMPORTED_MODULE_0__["findBox"])(new Uint8Array(payload), ['mdat']);

  if (results.length === 0) {
    errorCallBack(new Error('Could not parse IMSC1 mdat'));
    return;
  }

  var mdat = results[0];
  var ttml = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_3__["utf8ArrayToStr"])(new Uint8Array(payload, mdat.start, mdat.end - mdat.start));
  var syncTime = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_4__["toTimescaleFromScale"])(initPTS, 1, timescale);

  try {
    callBack(parseTTML(ttml, syncTime));
  } catch (error) {
    errorCallBack(error);
  }
}

function parseTTML(ttml, syncTime) {
  var parser = new DOMParser();
  var xmlDoc = parser.parseFromString(ttml, 'text/xml');
  var tt = xmlDoc.getElementsByTagName('tt')[0];

  if (!tt) {
    throw new Error('Invalid ttml');
  }

  var defaultRateInfo = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  };
  var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {
    result[key] = tt.getAttribute("ttp:" + key) || defaultRateInfo[key];
    return result;
  }, {});
  var trim = tt.getAttribute('xml:space') !== 'preserve';
  var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));
  var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));
  var cueElements = getElementCollection(tt, 'body', '[begin]');
  return [].map.call(cueElements, function (cueElement) {
    var cueText = getTextContent(cueElement, trim);

    if (!cueText || !cueElement.hasAttribute('begin')) {
      return null;
    }

    var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);
    var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);
    var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);

    if (startTime === null) {
      throw timestampParsingError(cueElement);
    }

    if (endTime === null) {
      if (duration === null) {
        throw timestampParsingError(cueElement);
      }

      endTime = startTime + duration;
    }

    var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__["default"](startTime - syncTime, endTime - syncTime, cueText);
    var region = regionElements[cueElement.getAttribute('region')];
    var style = styleElements[cueElement.getAttribute('style')]; // TODO: Add regions to track and cue (origin and extend)
    // These values are hard-coded (for now) to simulate region settings in the demo

    cue.position = 10;
    cue.size = 80; // Apply styles to cue

    var styles = getTtmlStyles(region, style);
    var textAlign = styles.textAlign;

    if (textAlign) {
      // cue.positionAlign not settable in FF~2016
      cue.lineAlign = {
        left: 'start',
        center: 'center',
        right: 'end',
        start: 'start',
        end: 'end'
      }[textAlign];
      cue.align = textAlign;
    }

    _extends(cue, styles);

    return cue;
  }).filter(function (cue) {
    return cue !== null;
  });
}

function getElementCollection(fromElement, parentName, childName) {
  var parent = fromElement.getElementsByTagName(parentName)[0];

  if (parent) {
    return [].slice.call(parent.querySelectorAll(childName));
  }

  return [];
}

function collectionToDictionary(elementsWithId) {
  return elementsWithId.reduce(function (dict, element) {
    var id = element.getAttribute('xml:id');

    if (id) {
      dict[id] = element;
    }

    return dict;
  }, {});
}

function getTextContent(element, trim) {
  return [].slice.call(element.childNodes).reduce(function (str, node, i) {
    var _node$childNodes;

    if (node.nodeName === 'br' && i) {
      return str + '\n';
    }

    if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {
      return getTextContent(node, trim);
    } else if (trim) {
      return str + node.textContent.trim().replace(/\s+/g, ' ');
    }

    return str + node.textContent;
  }, '');
}

function getTtmlStyles(region, style) {
  var ttsNs = 'http://www.w3.org/ns/ttml#styling';
  var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily' // 'fontWeight',
  // 'lineHeight',
  // 'wrapOption',
  // 'fontStyle',
  // 'direction',
  // 'writingMode'
  ];
  return styleAttributes.reduce(function (styles, name) {
    var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name);

    if (value) {
      styles[name] = value;
    }

    return styles;
  }, {});
}

function getAttributeNS(element, ns, name) {
  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
}

function timestampParsingError(node) {
  return new Error("Could not parse ttml timestamp " + node);
}

function parseTtmlTime(timeAttributeValue, rateInfo) {
  if (!timeAttributeValue) {
    return null;
  }

  var seconds = Object(_vttparser__WEBPACK_IMPORTED_MODULE_1__["parseTimeStamp"])(timeAttributeValue);

  if (seconds === null) {
    if (HMSF_REGEX.test(timeAttributeValue)) {
      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
      seconds = parseTimeUnits(timeAttributeValue, rateInfo);
    }
  }

  return seconds;
}

function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
  var m = HMSF_REGEX.exec(timeAttributeValue);
  var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
}

function parseTimeUnits(timeAttributeValue, rateInfo) {
  var m = TIME_UNIT_REGEX.exec(timeAttributeValue);
  var value = Number(m[1]);
  var unit = m[2];

  switch (unit) {
    case 'h':
      return value * 3600;

    case 'm':
      return value * 60;

    case 'ms':
      return value * 1000;

    case 'f':
      return value / rateInfo.frameRate;

    case 't':
      return value / rateInfo.tickRate;
  }

  return value;
}

/***/ }),

/***/ "./src/utils/logger.ts":
/*!*****************************!*\
  !*** ./src/utils/logger.ts ***!
  \*****************************/
/*! exports provided: enableLogs, logger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableLogs", function() { return enableLogs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return logger; });
var noop = function noop() {};

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};
var exportedLogger = fakeLogger; // let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function consolePrintFn(type) {
  var func = self.console[type];

  if (func) {
    return func.bind(self.console, "[" + type + "] >");
  }

  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    functions[_key - 1] = arguments[_key];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

function enableLogs(debugConfig) {
  // check that console is available
  if (self.console && debugConfig === true || typeof debugConfig === 'object') {
    exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level
    // 'trace',
    'debug', 'log', 'info', 'warn', 'error'); // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed

    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
}
var logger = exportedLogger;

/***/ }),

/***/ "./src/utils/mediakeys-helper.ts":
/*!***************************************!*\
  !*** ./src/utils/mediakeys-helper.ts ***!
  \***************************************/
/*! exports provided: KeySystems, requestMediaKeySystemAccess */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeySystems", function() { return KeySystems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestMediaKeySystemAccess", function() { return requestMediaKeySystemAccess; });
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess
 */
var KeySystems;

(function (KeySystems) {
  KeySystems["WIDEVINE"] = "com.widevine.alpha";
  KeySystems["PLAYREADY"] = "com.microsoft.playready";
})(KeySystems || (KeySystems = {}));

var requestMediaKeySystemAccess = function () {
  if (typeof self !== 'undefined' && self.navigator && self.navigator.requestMediaKeySystemAccess) {
    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
  } else {
    return null;
  }
}();



/***/ }),

/***/ "./src/utils/mediasource-helper.ts":
/*!*****************************************!*\
  !*** ./src/utils/mediasource-helper.ts ***!
  \*****************************************/
/*! exports provided: getMediaSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMediaSource", function() { return getMediaSource; });
/**
 * MediaSource helper
 */
function getMediaSource() {
  return self.MediaSource || self.WebKitMediaSource;
}

/***/ }),

/***/ "./src/utils/mp4-tools.ts":
/*!********************************!*\
  !*** ./src/utils/mp4-tools.ts ***!
  \********************************/
/*! exports provided: bin2str, readUint16, readUint32, writeUint32, findBox, parseSegmentIndex, parseInitSegment, getStartDTS, getDuration, computeRawDurationFromSamples, offsetStartDTS, segmentValidRange, appendUint8Array */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bin2str", function() { return bin2str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readUint16", function() { return readUint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readUint32", function() { return readUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeUint32", function() { return writeUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBox", function() { return findBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSegmentIndex", function() { return parseSegmentIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInitSegment", function() { return parseInitSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStartDTS", function() { return getStartDTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDuration", function() { return getDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeRawDurationFromSamples", function() { return computeRawDurationFromSamples; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offsetStartDTS", function() { return offsetStartDTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentValidRange", function() { return segmentValidRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendUint8Array", function() { return appendUint8Array; });
/* harmony import */ var _typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typed-array */ "./src/utils/typed-array.ts");
/* harmony import */ var _loader_fragment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader/fragment */ "./src/loader/fragment.ts");


var UINT32_MAX = Math.pow(2, 32) - 1;
var push = [].push;
function bin2str(buffer) {
  return String.fromCharCode.apply(null, buffer);
}
function readUint16(buffer, offset) {
  if ('data' in buffer) {
    offset += buffer.start;
    buffer = buffer.data;
  }

  var val = buffer[offset] << 8 | buffer[offset + 1];
  return val < 0 ? 65536 + val : val;
}
function readUint32(buffer, offset) {
  if ('data' in buffer) {
    offset += buffer.start;
    buffer = buffer.data;
  }

  var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
  return val < 0 ? 4294967296 + val : val;
}
function writeUint32(buffer, offset, value) {
  if ('data' in buffer) {
    offset += buffer.start;
    buffer = buffer.data;
  }

  buffer[offset] = value >> 24;
  buffer[offset + 1] = value >> 16 & 0xff;
  buffer[offset + 2] = value >> 8 & 0xff;
  buffer[offset + 3] = value & 0xff;
} // Find the data for a box specified by its path

function findBox(input, path) {
  var results = [];

  if (!path.length) {
    // short-circuit the search for empty paths
    return results;
  }

  var data;
  var start;
  var end;

  if ('data' in input) {
    data = input.data;
    start = input.start;
    end = input.end;
  } else {
    data = input;
    start = 0;
    end = data.byteLength;
  }

  for (var i = start; i < end;) {
    var size = readUint32(data, i);
    var type = bin2str(data.subarray(i + 4, i + 8));
    var endbox = size > 1 ? i + size : end;

    if (type === path[0]) {
      if (path.length === 1) {
        // this is the end of the path and we've found the box we were
        // looking for
        results.push({
          data: data,
          start: i + 8,
          end: endbox
        });
      } else {
        // recursively search for the next box along the path
        var subresults = findBox({
          data: data,
          start: i + 8,
          end: endbox
        }, path.slice(1));

        if (subresults.length) {
          push.apply(results, subresults);
        }
      }
    }

    i = endbox;
  } // we've finished searching all of data


  return results;
}
function parseSegmentIndex(initSegment) {
  var moovBox = findBox(initSegment, ['moov']);
  var moov = moovBox ? moovBox[0] : null;
  var moovEndOffset = moov ? moov.end : null; // we need this in case we need to chop of garbage of the end of current data

  var sidxBox = findBox(initSegment, ['sidx']);

  if (!sidxBox || !sidxBox[0]) {
    return null;
  }

  var references = [];
  var sidx = sidxBox[0];
  var version = sidx.data[0]; // set initial offset, we skip the reference ID (not needed)

  var index = version === 0 ? 8 : 16;
  var timescale = readUint32(sidx, index);
  index += 4; // TODO: parse earliestPresentationTime and firstOffset
  // usually zero in our case

  var earliestPresentationTime = 0;
  var firstOffset = 0;

  if (version === 0) {
    index += 8;
  } else {
    index += 16;
  } // skip reserved


  index += 2;
  var startByte = sidx.end + firstOffset;
  var referencesCount = readUint16(sidx, index);
  index += 2;

  for (var i = 0; i < referencesCount; i++) {
    var referenceIndex = index;
    var referenceInfo = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    var referenceSize = referenceInfo & 0x7fffffff;
    var referenceType = (referenceInfo & 0x80000000) >>> 31;

    if (referenceType === 1) {
      // eslint-disable-next-line no-console
      console.warn('SIDX has hierarchical references (not supported)');
      return null;
    }

    var subsegmentDuration = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    references.push({
      referenceSize: referenceSize,
      subsegmentDuration: subsegmentDuration,
      // unscaled
      info: {
        duration: subsegmentDuration / timescale,
        start: startByte,
        end: startByte + referenceSize - 1
      }
    });
    startByte += referenceSize; // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits
    // for |sapDelta|.

    referenceIndex += 4; // skip to next ref

    index = referenceIndex;
  }

  return {
    earliestPresentationTime: earliestPresentationTime,
    timescale: timescale,
    version: version,
    referencesCount: referencesCount,
    references: references,
    moovEndOffset: moovEndOffset
  };
}
/**
 * Parses an MP4 initialization segment and extracts stream type and
 * timescale values for any declared tracks. Timescale values indicate the
 * number of clock ticks per second to assume for time-based values
 * elsewhere in the MP4.
 *
 * To determine the start time of an MP4, you need two pieces of
 * information: the timescale unit and the earliest base media decode
 * time. Multiple timescales can be specified within an MP4 but the
 * base media decode time is always expressed in the timescale from
 * the media header box for the track:
 * ```
 * moov > trak > mdia > mdhd.timescale
 * moov > trak > mdia > hdlr
 * ```
 * @param initSegment {Uint8Array} the bytes of the init segment
 * @return {InitData} a hash of track type to timescale values or null if
 * the init segment is malformed.
 */

function parseInitSegment(initSegment) {
  var result = [];
  var traks = findBox(initSegment, ['moov', 'trak']);

  for (var i = 0; i < traks.length; i++) {
    var trak = traks[i];
    var tkhd = findBox(trak, ['tkhd'])[0];

    if (tkhd) {
      var version = tkhd.data[tkhd.start];

      var _index = version === 0 ? 12 : 20;

      var trackId = readUint32(tkhd, _index);
      var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];

      if (mdhd) {
        version = mdhd.data[mdhd.start];
        _index = version === 0 ? 12 : 20;
        var timescale = readUint32(mdhd, _index);
        var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];

        if (hdlr) {
          var hdlrType = bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
          var type = {
            soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].AUDIO,
            vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].VIDEO
          }[hdlrType];

          if (type) {
            // TODO: Parse codec details to be able to build MIME type.
            var codexBoxes = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
            var codec = void 0;

            if (codexBoxes.length) {
              var codecBox = codexBoxes[0];
              codec = bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
            }

            result[trackId] = {
              timescale: timescale,
              type: type
            };
            result[type] = {
              timescale: timescale,
              id: trackId,
              codec: codec
            };
          }
        }
      }
    }
  }

  var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);
  trex.forEach(function (trex) {
    var trackId = readUint32(trex, 4);
    var track = result[trackId];

    if (track) {
      track.default = {
        duration: readUint32(trex, 12),
        flags: readUint32(trex, 20)
      };
    }
  });
  return result;
}
/**
 * Determine the base media decode start time, in seconds, for an MP4
 * fragment. If multiple fragments are specified, the earliest time is
 * returned.
 *
 * The base media decode time can be parsed from track fragment
 * metadata:
 * ```
 * moof > traf > tfdt.baseMediaDecodeTime
 * ```
 * It requires the timescale value from the mdhd to interpret.
 *
 * @param initData {InitData} a hash of track type to timescale values
 * @param fmp4 {Uint8Array} the bytes of the mp4 fragment
 * @return {number} the earliest base media decode start time for the
 * fragment, in seconds
 */

function getStartDTS(initData, fmp4) {
  // we need info from two children of each track fragment box
  return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {
    var tfdt = findBox(traf, ['tfdt'])[0];
    var version = tfdt.data[tfdt.start];
    var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {
      // get the track id from the tfhd
      var id = readUint32(tfhd, 4);
      var track = initData[id];

      if (track) {
        var baseTime = readUint32(tfdt, 4);

        if (version === 1) {
          baseTime *= Math.pow(2, 32);
          baseTime += readUint32(tfdt, 8);
        } // assume a 90kHz clock if no timescale was specified


        var scale = track.timescale || 90e3; // convert base time to seconds

        var startTime = baseTime / scale;

        if (isFinite(startTime) && (result === null || startTime < result)) {
          return startTime;
        }
      }

      return result;
    }, null);

    if (start !== null && isFinite(start) && (result === null || start < result)) {
      return start;
    }

    return result;
  }, null) || 0;
}
/*
  For Reference:
  aligned(8) class TrackFragmentHeaderBox
           extends FullBox(tfhd, 0, tf_flags){
     unsigned int(32)  track_ID;
     // all the following are optional fields
     unsigned int(64)  base_data_offset;
     unsigned int(32)  sample_description_index;
     unsigned int(32)  default_sample_duration;
     unsigned int(32)  default_sample_size;
     unsigned int(32)  default_sample_flags
  }
 */

function getDuration(data, initData) {
  var rawDuration = 0;
  var videoDuration = 0;
  var audioDuration = 0;
  var trafs = findBox(data, ['moof', 'traf']);

  for (var i = 0; i < trafs.length; i++) {
    var traf = trafs[i]; // There is only one tfhd & trun per traf
    // This is true for CMAF style content, and we should perhaps check the ftyp
    // and only look for a single trun then, but for ISOBMFF we should check
    // for multiple track runs.

    var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd

    var id = readUint32(tfhd, 4);
    var track = initData[id];

    if (!track) {
      continue;
    }

    var trackDefault = track.default;
    var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);
    var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;

    if (tfhdFlags & 0x000008) {
      // 0x000008 indicates the presence of the default_sample_duration field
      if (tfhdFlags & 0x000002) {
        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration
        // If present, the default_sample_duration exists at byte offset 12
        sampleDuration = readUint32(tfhd, 12);
      } else {
        // Otherwise, the duration is at byte offset 8
        sampleDuration = readUint32(tfhd, 8);
      }
    } // assume a 90kHz clock if no timescale was specified


    var timescale = track.timescale || 90e3;
    var truns = findBox(traf, ['trun']);

    for (var j = 0; j < truns.length; j++) {
      if (sampleDuration) {
        var sampleCount = readUint32(truns[j], 4);
        rawDuration = sampleDuration * sampleCount;
      } else {
        rawDuration = computeRawDurationFromSamples(truns[j]);
      }

      if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].VIDEO) {
        videoDuration += rawDuration / timescale;
      } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].AUDIO) {
        audioDuration += rawDuration / timescale;
      }
    }
  }

  if (videoDuration === 0 && audioDuration === 0) {
    // If duration samples are not available in the traf use sidx subsegment_duration
    var sidx = parseSegmentIndex(data);

    if (sidx !== null && sidx !== void 0 && sidx.references) {
      return sidx.references.reduce(function (dur, ref) {
        return dur + ref.info.duration || 0;
      }, 0);
    }
  }

  if (videoDuration) {
    return videoDuration;
  }

  return audioDuration;
}
/*
  For Reference:
  aligned(8) class TrackRunBox
           extends FullBox(trun, version, tr_flags) {
     unsigned int(32)  sample_count;
     // the following are optional fields
     signed int(32) data_offset;
     unsigned int(32)  first_sample_flags;
     // all fields in the following array are optional
     {
        unsigned int(32)  sample_duration;
        unsigned int(32)  sample_size;
        unsigned int(32)  sample_flags
        if (version == 0)
           { unsigned int(32)
        else
           { signed int(32)
     }[ sample_count ]
  }
 */

function computeRawDurationFromSamples(trun) {
  var flags = readUint32(trun, 0); // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.
  // Each field is an int32, which is 4 bytes

  var offset = 8; // data-offset-present flag

  if (flags & 0x000001) {
    offset += 4;
  } // first-sample-flags-present flag


  if (flags & 0x000004) {
    offset += 4;
  }

  var duration = 0;
  var sampleCount = readUint32(trun, 4);

  for (var i = 0; i < sampleCount; i++) {
    // sample-duration-present flag
    if (flags & 0x000100) {
      var sampleDuration = readUint32(trun, offset);
      duration += sampleDuration;
      offset += 4;
    } // sample-size-present flag


    if (flags & 0x000200) {
      offset += 4;
    } // sample-flags-present flag


    if (flags & 0x000400) {
      offset += 4;
    } // sample-composition-time-offsets-present flag


    if (flags & 0x000800) {
      offset += 4;
    }
  }

  return duration;
}
function offsetStartDTS(initData, fmp4, timeOffset) {
  findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {
    findBox(traf, ['tfhd']).forEach(function (tfhd) {
      // get the track id from the tfhd
      var id = readUint32(tfhd, 4);
      var track = initData[id];

      if (!track) {
        return;
      } // assume a 90kHz clock if no timescale was specified


      var timescale = track.timescale || 90e3; // get the base media decode time from the tfdt

      findBox(traf, ['tfdt']).forEach(function (tfdt) {
        var version = tfdt.data[tfdt.start];
        var baseMediaDecodeTime = readUint32(tfdt, 4);

        if (version === 0) {
          writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
        } else {
          baseMediaDecodeTime *= Math.pow(2, 32);
          baseMediaDecodeTime += readUint32(tfdt, 8);
          baseMediaDecodeTime -= timeOffset * timescale;
          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
          writeUint32(tfdt, 4, upper);
          writeUint32(tfdt, 8, lower);
        }
      });
    });
  });
} // TODO: Check if the last moof+mdat pair is part of the valid range

function segmentValidRange(data) {
  var segmentedRange = {
    valid: null,
    remainder: null
  };
  var moofs = findBox(data, ['moof']);

  if (!moofs) {
    return segmentedRange;
  } else if (moofs.length < 2) {
    segmentedRange.remainder = data;
    return segmentedRange;
  }

  var last = moofs[moofs.length - 1]; // Offset by 8 bytes; findBox offsets the start by as much

  segmentedRange.valid = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(data, 0, last.start - 8);
  segmentedRange.remainder = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(data, last.start - 8);
  return segmentedRange;
}
function appendUint8Array(data1, data2) {
  var temp = new Uint8Array(data1.length + data2.length);
  temp.set(data1);
  temp.set(data2, data1.length);
  return temp;
}

/***/ }),

/***/ "./src/utils/output-filter.ts":
/*!************************************!*\
  !*** ./src/utils/output-filter.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OutputFilter; });
var OutputFilter = /*#__PURE__*/function () {
  function OutputFilter(timelineController, trackName) {
    this.timelineController = void 0;
    this.cueRanges = [];
    this.trackName = void 0;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
    this.timelineController = timelineController;
    this.trackName = trackName;
  }

  var _proto = OutputFilter.prototype;

  _proto.dispatchCue = function dispatchCue() {
    if (this.startTime === null) {
      return;
    }

    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
    this.startTime = null;
  };

  _proto.newCue = function newCue(startTime, endTime, screen) {
    if (this.startTime === null || this.startTime > startTime) {
      this.startTime = startTime;
    }

    this.endTime = endTime;
    this.screen = screen;
    this.timelineController.createCaptionsTrack(this.trackName);
  };

  _proto.reset = function reset() {
    this.cueRanges = [];
  };

  return OutputFilter;
}();



/***/ }),

/***/ "./src/utils/texttrack-utils.ts":
/*!**************************************!*\
  !*** ./src/utils/texttrack-utils.ts ***!
  \**************************************/
/*! exports provided: sendAddTrackEvent, clearCurrentCues, getCuesInRange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sendAddTrackEvent", function() { return sendAddTrackEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearCurrentCues", function() { return clearCurrentCues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCuesInRange", function() { return getCuesInRange; });
function sendAddTrackEvent(track, videoEl) {
  var event;

  try {
    event = new Event('addtrack');
  } catch (err) {
    // for IE11
    event = document.createEvent('Event');
    event.initEvent('addtrack', false, false);
  }

  event.track = track;
  videoEl.dispatchEvent(event);
}
function clearCurrentCues(track) {
  if (track !== null && track !== void 0 && track.cues) {
    // When track.mode is disabled, track.cues will be null.
    // To guarantee the removal of cues, we need to temporarily
    // change the mode to hidden
    if (track.mode === 'disabled') {
      track.mode = 'hidden';
    }

    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
} // Find first cue starting after given time.
// Modified version of binary search O(log(n)).

function getFirstCueIndexAfterTime(cues, time) {
  // If first cue starts after time, start there
  if (time < cues[0].startTime) {
    return 0;
  } // If the last cue ends before time there is no overlap


  if (time > cues[cues.length - 1].endTime) {
    return -1;
  }

  var left = 0;
  var right = cues.length - 1;

  while (left <= right) {
    var mid = Math.floor((right + left) / 2);

    if (time < cues[mid].startTime) {
      right = mid - 1;
    } else if (time > cues[mid].startTime) {
      left = mid + 1;
    } else {
      // If it's not lower or higher, it must be equal.
      return mid;
    }
  } // At this point, left and right have swapped.
  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.


  return cues[left].startTime - time < time - cues[right].startTime ? left : right;
}

function getCuesInRange(cues, start, end) {
  var cuesFound = [];
  var firstCueInRange = getFirstCueIndexAfterTime(cues, start);

  if (firstCueInRange > -1) {
    for (var i = firstCueInRange, len = cues.length; i < len; i++) {
      var cue = cues[i];

      if (cue.startTime >= start && cue.endTime <= end) {
        cuesFound.push(cue);
      } else if (cue.startTime > end) {
        return cuesFound;
      }
    }
  }

  return cuesFound;
}

/***/ }),

/***/ "./src/utils/time-ranges.ts":
/*!**********************************!*\
  !*** ./src/utils/time-ranges.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 *  TimeRanges to string helper
 */
var TimeRanges = {
  toString: function toString(r) {
    var log = '';
    var len = r.length;

    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }

    return log;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (TimeRanges);

/***/ }),

/***/ "./src/utils/timescale-conversion.ts":
/*!*******************************************!*\
  !*** ./src/utils/timescale-conversion.ts ***!
  \*******************************************/
/*! exports provided: toTimescaleFromBase, toTimescaleFromScale, toMsFromMpegTsClock, toMpegTsClockFromTimescale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toTimescaleFromBase", function() { return toTimescaleFromBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toTimescaleFromScale", function() { return toTimescaleFromScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toMsFromMpegTsClock", function() { return toMsFromMpegTsClock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toMpegTsClockFromTimescale", function() { return toMpegTsClockFromTimescale; });
var MPEG_TS_CLOCK_FREQ_HZ = 90000;
function toTimescaleFromBase(value, destScale, srcBase, round) {
  if (srcBase === void 0) {
    srcBase = 1;
  }

  if (round === void 0) {
    round = false;
  }

  var result = value * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`

  return round ? Math.round(result) : result;
}
function toTimescaleFromScale(value, destScale, srcScale, round) {
  if (srcScale === void 0) {
    srcScale = 1;
  }

  if (round === void 0) {
    round = false;
  }

  return toTimescaleFromBase(value, destScale, 1 / srcScale, round);
}
function toMsFromMpegTsClock(value, round) {
  if (round === void 0) {
    round = false;
  }

  return toTimescaleFromBase(value, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
}
function toMpegTsClockFromTimescale(value, srcScale) {
  if (srcScale === void 0) {
    srcScale = 1;
  }

  return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
}

/***/ }),

/***/ "./src/utils/typed-array.ts":
/*!**********************************!*\
  !*** ./src/utils/typed-array.ts ***!
  \**********************************/
/*! exports provided: sliceUint8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sliceUint8", function() { return sliceUint8; });
function sliceUint8(array, start, end) {
  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.
  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.
  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
}

/***/ }),

/***/ "./src/utils/vttcue.ts":
/*!*****************************!*\
  !*** ./src/utils/vttcue.ts ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* harmony default export */ __webpack_exports__["default"] = ((function () {
  if (typeof self !== 'undefined' && self.VTTCue) {
    return self.VTTCue;
  }

  var AllowedDirections = ['', 'lr', 'rl'];
  var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];

  function isAllowedValue(allowed, value) {
    if (typeof value !== 'string') {
      return false;
    } // necessary for assuring the generic conforms to the Array interface


    if (!Array.isArray(allowed)) {
      return false;
    } // reset the type so that the next narrowing works well


    var lcValue = value.toLowerCase(); // use the allow list to narrow the type to a specific subset of strings

    if (~allowed.indexOf(lcValue)) {
      return lcValue;
    }

    return false;
  }

  function findDirectionSetting(value) {
    return isAllowedValue(AllowedDirections, value);
  }

  function findAlignSetting(value) {
    return isAllowedValue(AllowedAlignments, value);
  }

  function extend(obj) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    var i = 1;

    for (; i < arguments.length; i++) {
      var cobj = arguments[i];

      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var baseObj = {
      enumerable: true
    };
    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */
    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.

    cue.hasBeenReset = false;
    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';
    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));
    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));
    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }

        _startTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }

        _endTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    })); // todo: implement VTTRegion polyfill?

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value); // Have to check for false because the setting an be an empty string.

        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== 'auto') {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }

        _line = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);

        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }

        _position = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);

        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }

        _size = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);

        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }

        _align = setting;
        this.hasBeenReset = true;
      }
    }));
    /**
     * Other <track> spec defined properties
     */
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state

    cue.displayState = undefined;
  }
  /**
   * VTTCue methods
   */


  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = self.WebVTT;
    return WebVTT.convertCueToDOMTree(self, this.text);
  }; // this is a polyfill hack


  return VTTCue;
})());

/***/ }),

/***/ "./src/utils/vttparser.js":
/*!********************************!*\
  !*** ./src/utils/vttparser.js ***!
  \********************************/
/*! exports provided: parseTimeStamp, fixLineBreaks, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTimeStamp", function() { return parseTimeStamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fixLineBreaks", function() { return fixLineBreaks; });
/* harmony import */ var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vttcue */ "./src/utils/vttcue.ts");
/*
 * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
 */


var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }

      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }

      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

function VTTParser() {
  this.window = self;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
} // Try to parse input as a time stamp.


function parseTimeStamp(input) {
  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);
  }

  var m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);

  if (!m) {
    return null;
  }

  if (m[2] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[2], m[3], 0, m[4]);
  } // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]


  return computeSeconds(m[1], m[2], m[3], m[4]);
} // A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.

function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }

    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
      var percent = parseFloat(v);

      if (percent >= 0 && percent <= 100) {
        this.set(k, percent);
        return true;
      }
    }

    return false;
  }
}; // Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.

function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];

  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }

    var kv = groups[i].split(keyValueDelim);

    if (kv.length !== 2) {
      continue;
    }

    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, 0); // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.

var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input; // 4.1 WebVTT timestamp

  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);

    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    } // Remove time stamp from input.


    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  } // 4.4.2 WebVTT cue settings


  function consumeCueSettings(input, cue) {
    var settings = new Settings();
    parseOptions(input, function (k, v) {
      var vals;

      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }

          break;

        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;

        case 'line':
          vals = v.split(',');
          settings.integer(k, vals[0]);

          if (settings.percent(k, vals[0])) {
            settings.set('snapToLines', false);
          }

          settings.alt(k, vals[0], ['auto']);

          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }

          break;

        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);

          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }

          break;

        case 'size':
          settings.percent(k, v);
          break;

        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/); // Apply default values for any missing fields.

    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');

    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }

    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');

    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }

    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  } // 4.1 WebVTT cue timings.


  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time

  skipWhitespace();

  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
  }

  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time
  // 4.1 WebVTT cue settings list.

  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var _this = this; // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.


    if (data) {
      // Try to decode the data that we received.
      _this.buffer += _this.decoder.decode(data, {
        stream: true
      });
    }

    function collectNextLine() {
      var buffer = _this.buffer;
      var pos = 0;
      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }

      var line = buffer.substr(0, pos); // Advance the buffer early in case we fail below.

      if (buffer[pos] === '\r') {
        ++pos;
      }

      if (buffer[pos] === '\n') {
        ++pos;
      }

      _this.buffer = buffer.substr(pos);
      return line;
    } // 3.2 WebVTT metadata header syntax


    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            // console.log('parse region', v);
            // parseRegion(v);
            break;
        }
      }, /:/);
    } // 5.1 WebVTT file parsing.


    try {
      var line;

      if (_this.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }

        line = collectNextLine(); // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8

        var m = line.match(/^()?WEBVTT([ \t].*)?$/);

        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        _this.state = 'HEADER';
      }

      var alreadyCollectedLine = false;

      while (_this.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (_this.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              _this.state = 'ID';
            }

            continue;

          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              _this.state = 'ID';
            }

            continue;

          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              _this.state = 'NOTE';
              break;
            } // 19-29 - Allow any number of line terminators, then initialize new cue values.


            if (!line) {
              continue;
            }

            _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, '');
            _this.state = 'CUE'; // 30-39 - Check if self line contains an optional identifier or timing data.

            if (line.indexOf('-->') === -1) {
              _this.cue.id = line;
              continue;
            }

          // Process line as start of a cue.

          /* falls through */

          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, _this.cue, _this.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              _this.cue = null;
              _this.state = 'BADCUE';
              continue;
            }

            _this.state = 'CUETEXT';
            continue;

          case 'CUETEXT':
            {
              var hasSubstring = line.indexOf('-->') !== -1; // 34 - If we have an empty line then report the cue.
              // 35 - If we have the special substring '-->' then report the cue,
              // but do not collect the line as we need to process the current
              // one as a new cue.

              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                // We are done parsing self cue.
                if (_this.oncue) {
                  _this.oncue(_this.cue);
                }

                _this.cue = null;
                _this.state = 'ID';
                continue;
              }

              if (_this.cue.text) {
                _this.cue.text += '\n';
              }

              _this.cue.text += line;
            }
            continue;

          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              _this.state = 'ID';
            }

            continue;
        }
      }
    } catch (e) {
      // If we are currently parsing a cue, report what we have.
      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {
        _this.oncue(_this.cue);
      }

      _this.cue = null; // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.

      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }

    return this;
  },
  flush: function flush() {
    var _this = this;

    try {
      // Finish decoding the stream.
      _this.buffer += _this.decoder.decode(); // Synthesize the end of the current cue or region.

      if (_this.cue || _this.state === 'HEADER') {
        _this.buffer += '\n\n';

        _this.parse();
      } // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.


      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      if (_this.onparsingerror) {
        _this.onparsingerror(e);
      }
    }

    if (_this.onflush) {
      _this.onflush();
    }

    return this;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (VTTParser);

/***/ }),

/***/ "./src/utils/webvtt-parser.ts":
/*!************************************!*\
  !*** ./src/utils/webvtt-parser.ts ***!
  \************************************/
/*! exports provided: parseWebVTT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWebVTT", function() { return parseWebVTT; });
/* harmony import */ var _Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/polyfills/number */ "./src/polyfills/number.ts");
/* harmony import */ var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vttparser */ "./src/utils/vttparser.js");
/* harmony import */ var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../demux/id3 */ "./src/demux/id3.ts");
/* harmony import */ var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timescale-conversion */ "./src/utils/timescale-conversion.ts");
/* harmony import */ var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../remux/mp4-remuxer */ "./src/remux/mp4-remuxer.ts");








var LINEBREAKS = /\r\n|\n\r|\n|\r/g; // String.prototype.startsWith is not supported in IE11

var startsWith = function startsWith(inputString, searchString, position) {
  if (position === void 0) {
    position = 0;
  }

  return inputString.substr(position, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
  var ts = parseInt(timeString.substr(-3));
  var secs = parseInt(timeString.substr(-6, 2));
  var mins = parseInt(timeString.substr(-9, 2));
  var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

  if (!Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(ts) || !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(secs) || !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mins) || !Object(_Users_artemmyznikov_projects_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(hours)) {
    throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
  }

  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;
  return ts;
}; // From https://github.com/darkskyapp/string-hash


var hash = function hash(text) {
  var hash = 5381;
  var i = text.length;

  while (i) {
    hash = hash * 33 ^ text.charCodeAt(--i);
  }

  return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
  var currCC = vttCCs[cc];
  var prevCC = vttCCs[currCC.prevCC]; // This is the first discontinuity or cues have been processed since the last discontinuity
  // Offset = current discontinuity time

  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  } // There have been discontinuities since cues were last parsed.
  // Offset = time elapsed


  while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {
    var _prevCC;

    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }

  vttCCs.presentationOffset = presentationTime;
};

function parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {
  var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__["default"](); // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
  // Uint8Array.prototype.reduce is not implemented in IE11

  var vttLines = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__["utf8ArrayToStr"])(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\n').split('\n');
  var cues = [];
  var initPTS90Hz = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_3__["toMpegTsClockFromTimescale"])(initPTS, timescale);
  var cueTime = '00:00.000';
  var timestampMapMPEGTS = 0;
  var timestampMapLOCAL = 0;
  var parsingError;
  var inHeader = true;
  var timestampMap = false;

  parser.oncue = function (cue) {
    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
    var currCC = vttCCs[cc];
    var cueOffset = vttCCs.ccOffset; // Calculate subtitle PTS offset

    var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 90000; // Update offsets for new discontinuities

    if (currCC !== null && currCC !== void 0 && currCC.new) {
      if (timestampMapLOCAL !== undefined) {
        // When local time is provided, offset = discontinuity start time - local time
        cueOffset = vttCCs.ccOffset = currCC.start;
      } else {
        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
      }
    }

    if (webVttMpegTsMapOffset) {
      // If we have MPEGTS, offset = presentation time + discontinuity offset
      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
    }

    if (timestampMap) {
      var duration = cue.endTime - cue.startTime;
      var startTime = Object(_remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__["PTSNormalize"])((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;
      cue.startTime = startTime;
      cue.endTime = startTime + duration;
    } // If the cue was not assigned an id from the VTT file (line above the content),
    // then create a unique hash id for a cue based on start/end times.
    // This helps timeline-controller to avoid showing repeated captions.


    if (!cue.id) {
      cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);
    } // Fix encoding of special characters


    cue.text = decodeURIComponent(encodeURIComponent(cue.text));

    if (cue.endTime > 0) {
      cues.push(cue);
    }
  };

  parser.onparsingerror = function (error) {
    parsingError = error;
  };

  parser.onflush = function () {
    if (parsingError && errorCallBack) {
      errorCallBack(parsingError);
      return;
    }

    callBack(cues);
  }; // Go through contents line by line.


  vttLines.forEach(function (line) {
    if (inHeader) {
      // Look for X-TIMESTAMP-MAP in header.
      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
        // Once found, no more are allowed anyway, so stop searching.
        inHeader = false;
        timestampMap = true; // Extract LOCAL and MPEGTS.

        line.substr(16).split(',').forEach(function (timestamp) {
          if (startsWith(timestamp, 'LOCAL:')) {
            cueTime = timestamp.substr(6);
          } else if (startsWith(timestamp, 'MPEGTS:')) {
            timestampMapMPEGTS = parseInt(timestamp.substr(7));
          }
        });

        try {
          // Convert cue time to seconds
          timestampMapLOCAL = cueString2millis(cueTime) / 1000;
        } catch (error) {
          timestampMap = false;
          parsingError = error;
        } // Return without parsing X-TIMESTAMP-MAP line.


        return;
      } else if (line === '') {
        inHeader = false;
      }
    } // Parse line by default.


    parser.parse(line + '\n');
  });
  parser.flush();
}

/***/ }),

/***/ "./src/utils/xhr-loader.ts":
/*!*********************************!*\
  !*** ./src/utils/xhr-loader.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
/* harmony import */ var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loader/load-stats */ "./src/loader/load-stats.ts");



var XhrLoader = /*#__PURE__*/function () {
  function XhrLoader(config
  /* HlsConfig */
  ) {
    this.xhrSetup = void 0;
    this.requestTimeout = void 0;
    this.retryTimeout = void 0;
    this.retryDelay = void 0;
    this.config = null;
    this.callbacks = null;
    this.context = void 0;
    this.loader = null;
    this.stats = void 0;
    this.xhrSetup = config ? config.xhrSetup : null;
    this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.retryDelay = 0;
  }

  var _proto = XhrLoader.prototype;

  _proto.destroy = function destroy() {
    this.callbacks = null;
    this.abortInternal();
    this.loader = null;
    this.config = null;
  };

  _proto.abortInternal = function abortInternal() {
    var loader = this.loader;

    if (loader && loader.readyState !== 4) {
      this.stats.aborted = true;
      loader.abort();
    }

    self.clearTimeout(this.requestTimeout);
    self.clearTimeout(this.retryTimeout);
  };

  _proto.abort = function abort() {
    var _this$callbacks;

    this.abortInternal();

    if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.loader);
    }
  };

  _proto.load = function load(context, config, callbacks) {
    if (this.stats.loading.start) {
      throw new Error('Loader can only be used once.');
    }

    this.stats.loading.start = self.performance.now();
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.retryDelay = config.retryDelay;
    this.loadInternal();
  };

  _proto.loadInternal = function loadInternal() {
    var config = this.config,
        context = this.context;

    if (!config) {
      return;
    }

    var xhr = this.loader = new self.XMLHttpRequest();
    var stats = this.stats;
    stats.loading.first = 0;
    stats.loaded = 0;
    var xhrSetup = this.xhrSetup;

    try {
      if (xhrSetup) {
        try {
          xhrSetup(xhr, context.url);
        } catch (e) {
          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
          xhr.open('GET', context.url, true);
          xhrSetup(xhr, context.url);
        }
      }

      if (!xhr.readyState) {
        xhr.open('GET', context.url, true);
      }
    } catch (e) {
      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
      this.callbacks.onError({
        code: xhr.status,
        text: e.message
      }, context, xhr);
      return;
    }

    if (context.rangeEnd) {
      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
    }

    xhr.onreadystatechange = this.readystatechange.bind(this);
    xhr.onprogress = this.loadprogress.bind(this);
    xhr.responseType = context.responseType; // setup timeout before we perform request

    self.clearTimeout(this.requestTimeout);
    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
    xhr.send();
  };

  _proto.readystatechange = function readystatechange() {
    var context = this.context,
        xhr = this.loader,
        stats = this.stats;

    if (!context || !xhr) {
      return;
    }

    var readyState = xhr.readyState;
    var config = this.config; // don't proceed if xhr has been aborted

    if (stats.aborted) {
      return;
    } // >= HEADERS_RECEIVED


    if (readyState >= 2) {
      // clear xhr timeout and rearm it if readyState less than 4
      self.clearTimeout(this.requestTimeout);

      if (stats.loading.first === 0) {
        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
      }

      if (readyState === 4) {
        var status = xhr.status; // http status between 200 to 299 are all successful

        if (status >= 200 && status < 300) {
          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
          var data;
          var len;

          if (context.responseType === 'arraybuffer') {
            data = xhr.response;
            len = data.byteLength;
          } else {
            data = xhr.responseText;
            len = data.length;
          }

          stats.loaded = stats.total = len;
          var onProgress = this.callbacks.onProgress;

          if (onProgress) {
            onProgress(stats, context, data, xhr);
          }

          var response = {
            url: xhr.responseURL,
            data: data
          };
          this.callbacks.onSuccess(response, stats, context, xhr);
        } else {
          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
            _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].error(status + " while loading " + context.url);
            this.callbacks.onError({
              code: status,
              text: xhr.statusText
            }, context, xhr);
          } else {
            // retry
            _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn(status + " while loading " + context.url + ", retrying in " + this.retryDelay + "..."); // abort and reset internal state

            this.abortInternal();
            this.loader = null; // schedule retry

            self.clearTimeout(this.retryTimeout);
            this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay); // set exponential backoff

            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
            stats.retry++;
          }
        }
      } else {
        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
        self.clearTimeout(this.requestTimeout);
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
      }
    }
  };

  _proto.loadtimeout = function loadtimeout() {
    _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn("timeout while loading " + this.context.url);
    var callbacks = this.callbacks;

    if (callbacks) {
      this.abortInternal();
      callbacks.onTimeout(this.stats, this.context, this.loader);
    }
  };

  _proto.loadprogress = function loadprogress(event) {
    var stats = this.stats;
    stats.loaded = event.loaded;

    if (event.lengthComputable) {
      stats.total = event.total;
    }
  };

  _proto.getResponseHeader = function getResponseHeader(name) {
    if (this.loader) {
      try {
        return this.loader.getResponseHeader(name);
      } catch (error) {
        /* Could not get headers */
      }
    }

    return null;
  };

  return XhrLoader;
}();

/* harmony default export */ __webpack_exports__["default"] = (XhrLoader);

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=hls.js.map

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/base/base_object.js":
/*!*********************************!*\
  !*** ./src/base/base_object.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _events = __webpack_require__(/*! ./events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class BaseObject
 * @constructor
 * @extends Events
 * @module base
 */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var BaseObject = function (_Events) {
  (0, _inherits3.default)(BaseObject, _Events);
  (0, _createClass3.default)(BaseObject, [{
    key: 'options',

    /**
     * returns the object options
     * @property options
     * @type Object
     */
    get: function get() {
      return this._options;
    }

    /**
     * @method constructor
     * @param {Object} options
     */

  }]);

  function BaseObject() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, BaseObject);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Events.call(this, options));

    _this._options = options;
    _this.uniqueId = (0, _utils.uniqueId)('o');
    return _this;
  }
  /**
  * a unique id prefixed with `'o'`, `o1, o232`
  *
  * @property uniqueId
  * @type String
  */


  return BaseObject;
}(_events2.default);

exports.default = BaseObject;
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/container_plugin.js":
/*!**************************************!*\
  !*** ./src/base/container_plugin.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _base_object = __webpack_require__(/*! ./base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _error_mixin = __webpack_require__(/*! ./error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base class for a container plugin
 * @class ContainerPlugin
 * @constructor
 * @extends BaseObject
 * @module base
 */
var ContainerPlugin = function (_BaseObject) {
  (0, _inherits3.default)(ContainerPlugin, _BaseObject);
  (0, _createClass3.default)(ContainerPlugin, [{
    key: 'playerError',
    get: function get() {
      return this.container.playerError;
    }
  }]);

  function ContainerPlugin(container) {
    (0, _classCallCheck3.default)(this, ContainerPlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, container.options));

    _this.container = container;
    _this.enabled = true;
    _this.bindEvents();
    return _this;
  }

  ContainerPlugin.prototype.enable = function enable() {
    if (!this.enabled) {
      this.bindEvents();
      this.enabled = true;
    }
  };

  ContainerPlugin.prototype.disable = function disable() {
    if (this.enabled) {
      this.stopListening();
      this.enabled = false;
    }
  };

  ContainerPlugin.prototype.bindEvents = function bindEvents() {};

  ContainerPlugin.prototype.destroy = function destroy() {
    this.stopListening();
  };

  return ContainerPlugin;
}(_base_object2.default);

exports.default = ContainerPlugin;


(0, _assign2.default)(ContainerPlugin.prototype, _error_mixin2.default);

ContainerPlugin.extend = function (properties) {
  return (0, _utils.extend)(ContainerPlugin, properties);
};

ContainerPlugin.type = 'container';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/core_plugin.js":
/*!*********************************!*\
  !*** ./src/base/core_plugin.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _base_object = __webpack_require__(/*! ./base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _error_mixin = __webpack_require__(/*! ./error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CorePlugin = function (_BaseObject) {
  (0, _inherits3.default)(CorePlugin, _BaseObject);
  (0, _createClass3.default)(CorePlugin, [{
    key: 'playerError',
    get: function get() {
      return this.core.playerError;
    }
  }]);

  function CorePlugin(core) {
    (0, _classCallCheck3.default)(this, CorePlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, core.options));

    _this.core = core;
    _this.enabled = true;
    _this.bindEvents();
    return _this;
  }

  CorePlugin.prototype.bindEvents = function bindEvents() {};

  CorePlugin.prototype.enable = function enable() {
    if (!this.enabled) {
      this.bindEvents();
      this.enabled = true;
    }
  };

  CorePlugin.prototype.disable = function disable() {
    if (this.enabled) {
      this.stopListening();
      this.enabled = false;
    }
  };

  CorePlugin.prototype.getExternalInterface = function getExternalInterface() {
    return {};
  };

  CorePlugin.prototype.destroy = function destroy() {
    this.stopListening();
  };

  return CorePlugin;
}(_base_object2.default);

exports.default = CorePlugin;


(0, _assign2.default)(CorePlugin.prototype, _error_mixin2.default);

CorePlugin.extend = function (properties) {
  return (0, _utils.extend)(CorePlugin, properties);
};

CorePlugin.type = 'core';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/error_mixin.js":
/*!*********************************!*\
  !*** ./src/base/error_mixin.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _log = __webpack_require__(/*! ../plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

var _error = __webpack_require__(/*! ../components/error */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ErrorMixin = {
  /**
   * creates an error.
   * @method createError
   * @param {Object} error should be an object with code, description, level and raw error.
   * @return {Object} Object with formatted error data including origin and scope
   */
  createError: function createError(error) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { useCodePrefix: true };

    var scope = this.constructor && this.constructor.type || '';
    var origin = this.name || scope;
    var i18n = this.i18n || this.core && this.core.i18n || this.container && this.container.i18n;

    var prefixedCode = origin + ':' + (error && error.code || 'unknown');
    var defaultError = {
      description: '',
      level: _error2.default.Levels.FATAL,
      origin: origin,
      scope: scope,
      raw: {}
    };

    var errorData = (0, _assign2.default)({}, defaultError, error, {
      code: options.useCodePrefix ? prefixedCode : error.code
    });

    if (i18n && errorData.level == _error2.default.Levels.FATAL && !errorData.UI) {
      var defaultUI = {
        title: i18n.t('default_error_title'),
        message: i18n.t('default_error_message')
      };
      errorData.UI = defaultUI;
    }

    if (this.playerError) this.playerError.createError(errorData);else _log2.default.warn(origin, 'PlayerError is not defined. Error: ', errorData);

    return errorData;
  }
};

exports.default = ErrorMixin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/events.js":
/*!****************************!*\
  !*** ./src/base/events.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _log = __webpack_require__(/*! ../plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var slice = Array.prototype.slice;

var eventSplitter = /\s+/;

var eventsApi = function eventsApi(obj, action, name, rest) {
  if (!name) return true;

  // Handle event maps.
  if ((typeof name === 'undefined' ? 'undefined' : (0, _typeof3.default)(name)) === 'object') {
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }return false;
  }

  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }return false;
  }

  return true;
};

var triggerEvents = function triggerEvents(events, args, klass, name) {
  var ev = void 0,
      i = -1;
  var l = events.length,
      a1 = args[0],
      a2 = args[1],
      a3 = args[2];
  run();

  function run() {
    try {
      switch (args.length) {
        /* eslint-disable curly */
        case 0:
          while (++i < l) {
            (ev = events[i]).callback.call(ev.ctx);
          }return;
        case 1:
          while (++i < l) {
            (ev = events[i]).callback.call(ev.ctx, a1);
          }return;
        case 2:
          while (++i < l) {
            (ev = events[i]).callback.call(ev.ctx, a1, a2);
          }return;
        case 3:
          while (++i < l) {
            (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
          }return;
        default:
          while (++i < l) {
            (ev = events[i]).callback.apply(ev.ctx, args);
          }return;
      }
    } catch (exception) {
      _log2.default.error.apply(_log2.default, [klass, 'error on event', name, 'trigger', '-', exception]);
      run();
    }
  }
};

/**
 * @class Events
 * @constructor
 * @module base
 */

var Events = function () {
  function Events() {
    (0, _classCallCheck3.default)(this, Events);
  }

  /**
   * listen to an event indefinitely, if you want to stop you need to call `off`
   * @method on
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */
  Events.prototype.on = function on(name, callback, context) {
    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
    this._events || (this._events = {});
    var events = this._events[name] || (this._events[name] = []);
    events.push({ callback: callback, context: context, ctx: context || this });
    return this;
  };

  /**
   * listen to an event only once
   * @method once
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */


  Events.prototype.once = function once(name, callback, context) {
    var _this = this;

    var _once = void 0;
    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
    var off = function off() {
      return _this.off(name, _once);
    };
    _once = function once() {
      off(name, _once);
      callback.apply(this, arguments);
    };
    return this.on(name, _once, context);
  };

  /**
   * stop listening to an event
   * @method off
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */


  Events.prototype.off = function off(name, callback, context) {
    var retain = void 0,
        ev = void 0,
        events = void 0,
        names = void 0,
        i = void 0,
        l = void 0,
        j = void 0,
        k = void 0;
    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
    if (!name && !callback && !context) {
      this._events = void 0;
      return this;
    }
    names = name ? [name] : (0, _keys2.default)(this._events);
    // jshint maxdepth:5
    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];
      events = this._events[name];
      if (events) {
        this._events[name] = retain = [];
        if (callback || context) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];
            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) retain.push(ev);
          }
        }
        if (!retain.length) delete this._events[name];
      }
    }
    return this;
  };

  /**
   * triggers an event given its `name`
   * @method trigger
   * @param {String} name
   */


  Events.prototype.trigger = function trigger(name) {
    var klass = this.name || this.constructor.name;
    _log2.default.debug.apply(_log2.default, [klass].concat(Array.prototype.slice.call(arguments)));
    if (!this._events) return this;
    var args = slice.call(arguments, 1);
    if (!eventsApi(this, 'trigger', name, args)) return this;
    var events = this._events[name];
    var allEvents = this._events.all;
    if (events) triggerEvents(events, args, klass, name);
    if (allEvents) triggerEvents(allEvents, arguments, klass, name);
    return this;
  };

  /**
   * stop listening an event for a given object
   * @method stopListening
   * @param {Object} obj
   * @param {String} name
   * @param {Function} callback
   */


  Events.prototype.stopListening = function stopListening(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;
    var remove = !name && !callback;
    if (!callback && (typeof name === 'undefined' ? 'undefined' : (0, _typeof3.default)(name)) === 'object') callback = this;
    if (obj) (listeningTo = {})[obj._listenId] = obj;
    for (var id in listeningTo) {
      obj = listeningTo[id];
      obj.off(name, callback, this);
      if (remove || (0, _keys2.default)(obj._events).length === 0) delete this._listeningTo[id];
    }
    return this;
  };

  Events.register = function register(eventName) {
    Events.Custom || (Events.Custom = {});
    var property = typeof eventName === 'string' && eventName.toUpperCase().trim();

    if (property && !Events.Custom[property]) {
      Events.Custom[property] = property.toLowerCase().split('_').map(function (value, index) {
        return index === 0 ? value : value = value[0].toUpperCase() + value.slice(1);
      }).join('');
    } else _log2.default.error('Events', 'Error when register event: ' + eventName);
  };

  Events.listAvailableCustomEvents = function listAvailableCustomEvents() {
    Events.Custom || (Events.Custom = {});
    return (0, _keys2.default)(Events.Custom).filter(function (property) {
      return typeof Events.Custom[property] === 'string';
    });
  };

  return Events;
}();

/**
 * listen to an event indefinitely for a given `obj`
 * @method listenTo
 * @param {Object} obj
 * @param {String} name
 * @param {Function} callback
 * @param {Object} context
 * @example
 * ```javascript
 * this.listenTo(this.core.playback, Events.PLAYBACK_PAUSE, this.callback)
 * ```
 */
/**
 * listen to an event once for a given `obj`
 * @method listenToOnce
 * @param {Object} obj
 * @param {String} name
 * @param {Function} callback
 * @param {Object} context
 * @example
 * ```javascript
 * this.listenToOnce(this.core.playback, Events.PLAYBACK_PAUSE, this.callback)
 * ```
 */


exports.default = Events;
var listenMethods = { listenTo: 'on', listenToOnce: 'once' };

(0, _keys2.default)(listenMethods).forEach(function (method) {
  Events.prototype[method] = function (obj, name, callback) {
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var id = obj._listenId || (obj._listenId = (0, _utils.uniqueId)('l'));
    listeningTo[id] = obj;
    if (!callback && (typeof name === 'undefined' ? 'undefined' : (0, _typeof3.default)(name)) === 'object') callback = this;
    obj[listenMethods[method]](name, callback, this);
    return this;
  };
});

// PLAYER EVENTS
/**
 * Fired when the player is ready on startup
 *
 * @event PLAYER_READY
 */
Events.PLAYER_READY = 'ready';
/**
 * Fired when player resizes
 *
 * @event PLAYER_RESIZE
 * @param {Object} currentSize an object with the current size
 */
Events.PLAYER_RESIZE = 'resize';
/**
 * Fired when player changes its fullscreen state
 *
 * @event PLAYER_FULLSCREEN
 * @param {Boolean} whether or not the player is on fullscreen mode
 */
Events.PLAYER_FULLSCREEN = 'fullscreen';
/**
 * Fired when player starts to play
 *
 * @event PLAYER_PLAY
 */
Events.PLAYER_PLAY = 'play';
/**
 * Fired when player pauses
 *
 * @event PLAYER_PAUSE
 */
Events.PLAYER_PAUSE = 'pause';
/**
 * Fired when player stops
 *
 * @event PLAYER_STOP
 */
Events.PLAYER_STOP = 'stop';
/**
 * Fired when player ends the video
 *
 * @event PLAYER_ENDED
 */
Events.PLAYER_ENDED = 'ended';
/**
 * Fired when player seeks the video
 *
 * @event PLAYER_SEEK
 * @param {Number} time the current time in seconds
 */
Events.PLAYER_SEEK = 'seek';
/**
 * Fired when player receives an error
 *
 * @event PLAYER_ERROR
 * @param {Object} error the error
 */
Events.PLAYER_ERROR = 'playererror';
/**
 * Fired when there is an error
 *
 * @event ERROR
 * @param {Object} error
 * the error with the following format `{code, description, level, raw, origin, scope}`
 * @param {String} [options.code]
 * error's code: code to identify error in the following format: origin:code
 * @param {String} [options.description]
 * error's description: description of the error
 * @param {String} [options.level]
 * error's level: FATAL or WARN.
 * @param {String} [options.origin]
 * error's origin. Example: hls, html5, etc
 * @param {String} [options.scope]
 * error's scope. Example: playback, container, etc
 * @param {String} [options.raw]
 * raw error: the initial error received
 */
Events.ERROR = 'error';
/**
 * Fired when the time is updated on player
 *
 * @event PLAYER_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time (in seconds)
 * @param {Number} [progress.total]
 * total time (in seconds)
 */
Events.PLAYER_TIMEUPDATE = 'timeupdate';
/**
 * Fired when player updates its volume
 *
 * @event PLAYER_VOLUMEUPDATE
 * @param {Number} volume the current volume
 */
Events.PLAYER_VOLUMEUPDATE = 'volumeupdate';

/**
 * Fired when subtitle is available
 *
 * @event PLAYER_SUBTITLE_AVAILABLE
 */
Events.PLAYER_SUBTITLE_AVAILABLE = 'subtitleavailable';

// Playback Events
/**
 * Fired when the playback is downloading the media
 *
 * @event PLAYBACK_PROGRESS
 * @param progress {Object}
 * Data progress object
 * @param [progress.start] {Number}
 * start position of buffered content at current position
 * @param [progress.current] {Number}
 * end position of buffered content at current position
 * @param [progress.total] {Number}
 * total content to be downloaded
 * @param buffered {Array}
 * array of buffered segments ({start, end}). [Only for supported playbacks]
 */
Events.PLAYBACK_PROGRESS = 'playback:progress';
/**
 * Fired when the time is updated on playback
 *
 * @event PLAYBACK_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time (in seconds)
 * @param {Number} [progress.total]
 * total time (in seconds)
 */
Events.PLAYBACK_TIMEUPDATE = 'playback:timeupdate';
/**
 * Fired when playback is ready
 *
 * @event PLAYBACK_READY
 */
Events.PLAYBACK_READY = 'playback:ready';
/**
 * Fired when the playback starts having to buffer because
 * playback can currently not be smooth.
 *
 * This corresponds to the playback `buffering` property being
 * `true`.
 *
 * @event PLAYBACK_BUFFERING
 */
Events.PLAYBACK_BUFFERING = 'playback:buffering';
/**
 * Fired when the playback has enough in the buffer to be
 * able to play smoothly, after previously being unable to
 * do this.
 *
 * This corresponds to the playback `buffering` property being
 * `false`.
 *
 * @event PLAYBACK_BUFFERFULL
 */
Events.PLAYBACK_BUFFERFULL = 'playback:bufferfull';
/**
 * Fired when playback changes any settings (volume, seek and etc)
 *
 * @event PLAYBACK_SETTINGSUPDATE
 */
Events.PLAYBACK_SETTINGSUPDATE = 'playback:settingsupdate';
/**
 * Fired when playback loaded its metadata
 *
 * @event PLAYBACK_LOADEDMETADATA
 * @param {Object} metadata Data
 * settings object
 * @param {Number} [metadata.duration]
 * the playback duration
 * @param {Object} [metadata.data]
 * extra meta data
 */
Events.PLAYBACK_LOADEDMETADATA = 'playback:loadedmetadata';
/**
 * Fired when playback updates its video quality
 *
 * @event PLAYBACK_HIGHDEFINITIONUPDATE
 * @param {Boolean} isHD
 * true when is on HD, false otherwise
 */
Events.PLAYBACK_HIGHDEFINITIONUPDATE = 'playback:highdefinitionupdate';
/**
 * Fired when playback updates its bitrate
 *
 * @event PLAYBACK_BITRATE
 * @param {Object} bitrate Data
 * bitrate object
 * @param {Number} [bitrate.bandwidth]
 * bitrate bandwidth when it's available
 * @param {Number} [bitrate.width]
 * playback width (ex: 720, 640, 1080)
 * @param {Number} [bitrate.height]
 * playback height (ex: 240, 480, 720)
 * @param {Number} [bitrate.level]
 * playback level when it's available, it could be just a map for width (0 => 240, 1 => 480, 2 => 720)
 */
Events.PLAYBACK_BITRATE = 'playback:bitrate';
/**
 * Fired when the playback has its levels
 *
 * @event PLAYBACK_LEVELS_AVAILABLE
 * @param {Array} levels
 * the ordered levels, each one with the following format `{id: 1, label: '500kbps'}` ps: id should be a number >= 0
 * @param {Number} initial
 * the initial level otherwise -1 (AUTO)
 */
Events.PLAYBACK_LEVELS_AVAILABLE = 'playback:levels:available';
/**
 * Fired first level, which play right now
 *
 * @event PLAYBACK_FIRST_LEVEL
 *
 */
Events.PLAYBACK_FIRST_LEVEL = 'playback:first:level';
/**
 * Fired when the playback starts to switch level
 *
 * @event PLAYBACK_LEVEL_SWITCH_START
 *
 */
Events.PLAYBACK_LEVEL_SWITCH_START = 'playback:levels:switch:start';
/**
 * Fired when the playback ends the level switch
 *
 * @event PLAYBACK_LEVEL_SWITCH_END
 *
 */
Events.PLAYBACK_LEVEL_SWITCH_END = 'playback:levels:switch:end';

/**
 * Fired when playback internal state changes
 *
 * @event PLAYBACK_PLAYBACKSTATE
 * @param {Object} state Data
 * state object
 * @param {String} [state.type]
 * the playback type
 */
Events.PLAYBACK_PLAYBACKSTATE = 'playback:playbackstate';
/**
 * Fired when DVR becomes enabled/disabled.
 *
 * @event PLAYBACK_DVR
 * @param {boolean} state true if dvr enabled
 */
Events.PLAYBACK_DVR = 'playback:dvr';
// TODO doc
Events.PLAYBACK_MEDIACONTROL_DISABLE = 'playback:mediacontrol:disable';
// TODO doc
Events.PLAYBACK_MEDIACONTROL_ENABLE = 'playback:mediacontrol:enable';
/**
 * Fired when the media for a playback ends.
 *
 * @event PLAYBACK_ENDED
 * @param {String} name the name of the playback
 */
Events.PLAYBACK_ENDED = 'playback:ended';
/**
 * Fired when user requests `play()`
 *
 * @event PLAYBACK_PLAY_INTENT
 */
Events.PLAYBACK_PLAY_INTENT = 'playback:play:intent';
/**
 * Fired when user requests `play()`, but firstly we gotta request preroll. it's advisable if user use iframeAPI
 *
 * @event PLAYBACK_PREROLL_REQUEST
 */
Events.PLAYBACK_PREROLL_REQUEST = 'playback:preroll:request';
/**
 * Fired when the media for a playback starts playing.
 * This is not necessarily when the user requests `play()`
 * The media may have to buffer first.
 * I.e. `isPlaying()` might return `true` before this event is fired,
 * because `isPlaying()` represents the intended state.
 *
 * @event PLAYBACK_PLAY
 */
Events.PLAYBACK_PLAY = 'playback:play';
/**
 * Fired when the media for a playback pauses.
 *
 * @event PLAYBACK_PAUSE
 */
Events.PLAYBACK_PAUSE = 'playback:pause';
/**
 * Fired when the media for a playback is seeking.
 *
 * @event PLAYBACK_SEEK
 */
Events.PLAYBACK_SEEK = 'playback:seek';
/**
 * Fired when the media for a playback is seeked.
 *
 * @event PLAYBACK_SEEKED
 */
Events.PLAYBACK_SEEKED = 'playback:seeked';
/**
 * Fired when the media for a playback is stopped.
 *
 * @event PLAYBACK_STOP
 */
Events.PLAYBACK_STOP = 'playback:stop';
/**
 * Fired if an error occurs in the playback.
 *
 * @event PLAYBACK_ERROR
 * @param {Object} error An object containing the error details
 * @param {String} name Playback name
 */
Events.PLAYBACK_ERROR = 'playback:error';
// TODO doc
Events.PLAYBACK_STATS_ADD = 'playback:stats:add';
// TODO doc
Events.PLAYBACK_FRAGMENT_LOADED = 'playback:fragment:loaded';
// TODO doc
Events.PLAYBACK_LEVEL_SWITCH = 'playback:level:switch';
/**
 * Fired when subtitle is available on playback for display
 *
 * @event PLAYBACK_SUBTITLE_AVAILABLE
 */
Events.PLAYBACK_SUBTITLE_AVAILABLE = 'playback:subtitle:available';
/**
 * Fired when playback subtitle track has changed
 *
 * @event CONTAINER_SUBTITLE_CHANGED
 * @param {Object} track Data
 * track object
 * @param {Number} [track.id]
 * selected track id
 */
Events.PLAYBACK_SUBTITLE_CHANGED = 'playback:subtitle:changed';

// Core Events
/**
 * Fired when the containers are created
 *
 * @event CORE_CONTAINERS_CREATED
 */
Events.CORE_CONTAINERS_CREATED = 'core:containers:created';
/**
 * Fired when the active container changed
 *
 * @event CORE_ACTIVE_CONTAINER_CHANGED
 */
Events.CORE_ACTIVE_CONTAINER_CHANGED = 'core:active:container:changed';
/**
 * Fired when the options were changed for the core
 *
 * @event CORE_OPTIONS_CHANGE
 * @param {Object} new options provided to configure() method
 */
Events.CORE_OPTIONS_CHANGE = 'core:options:change';
/**
 * Fired after creating containers, when the core is ready
 *
 * @event CORE_READY
 */
Events.CORE_READY = 'core:ready';
/**
 * Fired when the fullscreen state change
 *
 * @event CORE_FULLSCREEN
 * @param {Boolean} whether or not the player is on fullscreen mode
 */
Events.CORE_FULLSCREEN = 'core:fullscreen';
/**
 * Fired when core updates size
 *
 * @event CORE_RESIZE
 * @param {Object} currentSize an object with the current size
 */
Events.CORE_RESIZE = 'core:resize';
/**
 * Fired when the screen orientation has changed.
 * This event is trigger only for mobile devices.
 *
 * @event CORE_SCREEN_ORIENTATION_CHANGED
 * @param {Object} screen An object with screen orientation
 * screen object
 * @param {Object} [screen.event]
 * window resize event object
 * @param {String} [screen.orientation]
 * screen orientation (ie: 'landscape' or 'portrait')
 */
Events.CORE_SCREEN_ORIENTATION_CHANGED = 'core:screen:orientation:changed';
/**
 * Fired when occurs mouse move event on core element
 *
 * @event CORE_MOUSE_MOVE
 * @param {Object} event a DOM event
 */
Events.CORE_MOUSE_MOVE = 'core:mousemove';
/**
 * Fired when occurs mouse leave event on core element
 *
 * @event CORE_MOUSE_LEAVE
 * @param {Object} event a DOM event
 */
Events.CORE_MOUSE_LEAVE = 'core:mouseleave';

// Container Events
/**
 * Fired when the container internal state changes
 *
 * @event CONTAINER_PLAYBACKSTATE
 * @param {Object} state Data
 * state object
 * @param {String} [state.type]
 * the playback type
 */
Events.CONTAINER_PLAYBACKSTATE = 'container:playbackstate';
Events.CONTAINER_PLAYBACKDVRSTATECHANGED = 'container:dvr';
/**
 * Fired when the container updates its bitrate
 *
 * @event CONTAINER_BITRATE
 * @param {Object} bitrate Data
 * bitrate object
 * @param {Number} [bitrate.bandwidth]
 * bitrate bandwidth when it's available
 * @param {Number} [bitrate.width]
 * playback width (ex: 720, 640, 1080)
 * @param {Number} [bitrate.height]
 * playback height (ex: 240, 480, 720)
 * @param {Number} [bitrate.level]
 * playback level when it's available, it could be just a map for width (0 => 240, 1 => 480, 2 => 720)
 */
Events.CONTAINER_BITRATE = 'container:bitrate';
Events.CONTAINER_STATS_REPORT = 'container:stats:report';
Events.CONTAINER_DESTROYED = 'container:destroyed';
/**
 * Fired when the container is ready
 *
 * @event CONTAINER_READY
 */
Events.CONTAINER_READY = 'container:ready';
Events.CONTAINER_ERROR = 'container:error';
/**
 * Fired when the container loaded its metadata
 *
 * @event CONTAINER_LOADEDMETADATA
 * @param {Object} metadata Data
 * settings object
 * @param {Number} [metadata.duration]
 * the playback duration
 * @param {Object} [metadata.data]
 * extra meta data
 */
Events.CONTAINER_LOADEDMETADATA = 'container:loadedmetadata';

/**
 * Fired when subtitle is available on container for display
 *
 * @event CONTAINER_SUBTITLE_AVAILABLE
 */
Events.CONTAINER_SUBTITLE_AVAILABLE = 'container:subtitle:available';
/**
 * Fired when subtitle track has changed
 *
 * @event CONTAINER_SUBTITLE_CHANGED
 * @param {Object} track Data
 * track object
 * @param {Number} [track.id]
 * selected track id
 */
Events.CONTAINER_SUBTITLE_CHANGED = 'container:subtitle:changed';

/**
 * Fired when the time is updated on container
 *
 * @event CONTAINER_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time (in seconds)
 * @param {Number} [progress.total]
 * total time (in seconds)
 */
Events.CONTAINER_TIMEUPDATE = 'container:timeupdate';
/**
 * Fired when the container is downloading the media
 *
 * @event CONTAINER_PROGRESS
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.start]
 * initial downloaded content
 * @param {Number} [progress.current]
 * current dowloaded content
 * @param {Number} [progress.total]
 * total content to be downloaded
 */
Events.CONTAINER_PROGRESS = 'container:progress';
Events.CONTAINER_PLAY = 'container:play';
Events.CONTAINER_STOP = 'container:stop';
Events.CONTAINER_PAUSE = 'container:pause';
Events.CONTAINER_ENDED = 'container:ended';
Events.CONTAINER_CLICK = 'container:click';
Events.CONTAINER_DBLCLICK = 'container:dblclick';
Events.CONTAINER_CONTEXTMENU = 'container:contextmenu';
Events.CONTAINER_MOUSE_ENTER = 'container:mouseenter';
Events.CONTAINER_MOUSE_LEAVE = 'container:mouseleave';
/**
 * Fired when the container seeks the video
 *
 * @event CONTAINER_SEEK
 * @param {Number} time the current time in seconds
 */
Events.CONTAINER_SEEK = 'container:seek';
/**
 * Fired when the container was finished the seek video
 *
 * @event CONTAINER_SEEKED
 * @param {Number} time the current time in seconds
 */
Events.CONTAINER_SEEKED = 'container:seeked';
Events.CONTAINER_VOLUME = 'container:volume';
Events.CONTAINER_FULLSCREEN = 'container:fullscreen';
/**
 * Fired when container is buffering
 *
 * @event CONTAINER_STATE_BUFFERING
 */
Events.CONTAINER_STATE_BUFFERING = 'container:state:buffering';
/**
 * Fired when the container filled the buffer
 *
 * @event CONTAINER_STATE_BUFFERFULL
 */
Events.CONTAINER_STATE_BUFFERFULL = 'container:state:bufferfull';
/**
 * Fired when the container changes any settings (volume, seek and etc)
 *
 * @event CONTAINER_SETTINGSUPDATE
 */
Events.CONTAINER_SETTINGSUPDATE = 'container:settingsupdate';
/**
 * Fired when container updates its video quality
 *
 * @event CONTAINER_HIGHDEFINITIONUPDATE
 * @param {Boolean} isHD
 * true when is on HD, false otherwise
 */
Events.CONTAINER_HIGHDEFINITIONUPDATE = 'container:highdefinitionupdate';

/**
 * Fired when the media control shows
 *
 * @event CONTAINER_MEDIACONTROL_SHOW
 */
Events.CONTAINER_MEDIACONTROL_SHOW = 'container:mediacontrol:show';
/**
 * Fired when the media control hides
 *
 * @event CONTAINER_MEDIACONTROL_HIDE
 */
Events.CONTAINER_MEDIACONTROL_HIDE = 'container:mediacontrol:hide';

Events.CONTAINER_MEDIACONTROL_DISABLE = 'container:mediacontrol:disable';
Events.CONTAINER_MEDIACONTROL_ENABLE = 'container:mediacontrol:enable';
Events.CONTAINER_STATS_ADD = 'container:stats:add';
/**
 * Fired when the options were changed for the container
 *
 * @event CONTAINER_OPTIONS_CHANGE
 */
Events.CONTAINER_OPTIONS_CHANGE = 'container:options:change';

// MediaControl Events
Events.MEDIACONTROL_RENDERED = 'mediacontrol:rendered';
/**
 * Fired when the player enters/exit on fullscreen
 *
 * @event MEDIACONTROL_FULLSCREEN
 */
Events.MEDIACONTROL_FULLSCREEN = 'mediacontrol:fullscreen';
/**
 * Fired when the media control shows
 *
 * @event MEDIACONTROL_SHOW
 */
Events.MEDIACONTROL_SHOW = 'mediacontrol:show';
/**
 * Fired when the media control hides
 *
 * @event MEDIACONTROL_HIDE
 */
Events.MEDIACONTROL_HIDE = 'mediacontrol:hide';
/**
 * Fired when mouse enters on the seekbar
 *
 * @event MEDIACONTROL_MOUSEMOVE_SEEKBAR
 * @param {Object} event
 * the javascript event
 */
Events.MEDIACONTROL_MOUSEMOVE_SEEKBAR = 'mediacontrol:mousemove:seekbar';
/**
 * Fired when mouse leaves the seekbar
 *
 * @event MEDIACONTROL_MOUSELEAVE_SEEKBAR
 * @param {Object} event
 * the javascript event
 */
Events.MEDIACONTROL_MOUSELEAVE_SEEKBAR = 'mediacontrol:mouseleave:seekbar';
/**
 * Fired when the media is being played
 *
 * @event MEDIACONTROL_PLAYING
 */
Events.MEDIACONTROL_PLAYING = 'mediacontrol:playing';
/**
 * Fired when the media is not being played
 *
 * @event MEDIACONTROL_NOTPLAYING
 */
Events.MEDIACONTROL_NOTPLAYING = 'mediacontrol:notplaying';
/**
 * Fired when the container was changed
 *
 * @event MEDIACONTROL_CONTAINERCHANGED
 */
Events.MEDIACONTROL_CONTAINERCHANGED = 'mediacontrol:containerchanged';
/**
 * Fired when the options were changed for the mediacontrol
 *
 * @event MEDIACONTROL_OPTIONS_CHANGE
 */
Events.MEDIACONTROL_OPTIONS_CHANGE = 'mediacontrol:options:change';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/media.js":
/*!***************************!*\
  !*** ./src/base/media.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// https://github.com/mathiasbynens/small
var mp4 = exports.mp4 = 'data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAC721kYXQhEAUgpBv/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCEQBSCkG//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAsJtb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAB7HRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAIAAAAAAAAALwAAAAAAAAAAAAAAAQEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAAC8AAAAAAAEAAAAAAWRtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAKxEAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAc291bgAAAAAAAAAAAAAAAFNvdW5kSGFuZGxlcgAAAAEPbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAADTc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAAKxEAAAAAAAzZXNkcwAAAAADgICAIgACAASAgIAUQBUAAAAAAfQAAAHz+QWAgIACEhAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAIAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAFzAAABdAAAABRzdGNvAAAAAAAAAAEAAAAsAAAAYnVkdGEAAABabWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAtaWxzdAAAACWpdG9vAAAAHWRhdGEAAAABAAAAAExhdmY1Ni40MC4xMDE=';

exports.default = {
  mp4: mp4
};

/***/ }),

/***/ "./src/base/playback.js":
/*!******************************!*\
  !*** ./src/base/playback.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _ui_object = __webpack_require__(/*! ./ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _error_mixin = __webpack_require__(/*! ./error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An abstraction to represent a generic playback, it's like an interface to be implemented by subclasses.
 * @class Playback
 * @constructor
 * @extends UIObject
 * @module base
 */
var Playback = function (_UIObject) {
  (0, _inherits3.default)(Playback, _UIObject);
  (0, _createClass3.default)(Playback, [{
    key: 'isAudioOnly',

    /**
    * Determine if the playback does not contain video/has video but video should be ignored.
    * @property isAudioOnly
    * @type Boolean
    */
    get: function get() {
      return false;
    }
  }, {
    key: 'isAdaptive',
    get: function get() {
      return false;
    }

    /**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */

  }, {
    key: 'ended',
    get: function get() {
      return false;
    }

    /**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */

  }, {
    key: 'i18n',
    get: function get() {
      return this._i18n;
    }

    /**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */

  }, {
    key: 'buffering',
    get: function get() {
      return false;
    }

    /**
     * Determine if the playback has user consent.
     * @property consented
     * @type Boolean
     */

  }, {
    key: 'consented',
    get: function get() {
      return this._consented;
    }

    /**
     * @method constructor
     * @param {Object} options the options object
     * @param {Strings} i18n the internationalization component
     */

  }]);

  function Playback(options, i18n, playerError) {
    (0, _classCallCheck3.default)(this, Playback);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIObject.call(this, options));

    _this.settings = {};
    _this._i18n = i18n;
    _this.playerError = playerError;
    _this._consented = false;
    return _this;
  }

  /**
   * Gives user consent to playback (mobile devices).
   * @method consent
   */


  Playback.prototype.consent = function consent() {
    this._consented = true;
  };

  /**
   * plays the playback.
   * @method play
   */


  Playback.prototype.play = function play() {};

  /**
   * pauses the playback.
   * @method pause
   */


  Playback.prototype.pause = function pause() {};

  /**
   * stops the playback.
   * @method stop
   */


  Playback.prototype.stop = function stop() {};

  /**
   * seeks the playback to a given `time` in seconds
   * @method seek
   * @param {Number} time should be a number between 0 and the video duration
   */


  Playback.prototype.seek = function seek(time) {}; // eslint-disable-line no-unused-vars

  /**
   * seeks the playback to a given `percentage` in percentage
   * @method seekPercentage
   * @param {Number} time should be a number between 0 and 100
   */


  Playback.prototype.seekPercentage = function seekPercentage(percentage) {}; // eslint-disable-line no-unused-vars

  /**
   * The time that "0" now represents relative to when playback started.
   * For a stream with a sliding window this will increase as content is
   * removed from the beginning.
   * @method getStartTimeOffset
   * @return {Number} time (in seconds) that time "0" represents.
   */


  Playback.prototype.getStartTimeOffset = function getStartTimeOffset() {
    return 0;
  };

  /**
   * gets the duration in seconds
   * @method getDuration
   * @return {Number} duration (in seconds) of the current source
   */


  Playback.prototype.getDuration = function getDuration() {
    return 0;
  };

  /**
   * checks if the playback is playing.
   * @method isPlaying
   * @return {Boolean} `true` if the current playback is playing, otherwise `false`
   */


  Playback.prototype.isPlaying = function isPlaying() {
    return false;
  };

  /**
   * checks if the playback is ready.
   * @property isReady
   * @type {Boolean} `true` if the current playback is ready, otherwise `false`
   */


  // eslint-disable-line no-unused-vars

  /**
   * gets the playback type (`'vod', 'live', 'aod'`)
   * @method getPlaybackType
   * @return {String} you should write the playback type otherwise it'll assume `'no_op'`
   * @example
   * ```javascript
   * html5VideoPlayback.getPlaybackType() //vod
   * html5AudioPlayback.getPlaybackType() //aod
   * html5VideoPlayback.getPlaybackType() //live
   * flashHlsPlayback.getPlaybackType() //live
   * ```
   */
  Playback.prototype.getPlaybackType = function getPlaybackType() {
    return Playback.NO_OP;
  };

  /**
   * checks if the playback is in HD.
   * @method isHighDefinitionInUse
   * @return {Boolean} `true` if the playback is playing in HD, otherwise `false`
   */


  Playback.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
    return false;
  };

  /**
   * sets the volume for the playback
   * @method volume
   * @param {Number} value a number between 0 (`muted`) to 100 (`max`)
   */


  Playback.prototype.volume = function volume(value) {}; // eslint-disable-line no-unused-vars

  /**
   * enables to configure the playback after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */


  Playback.prototype.configure = function configure(options) {
    this._options = _clapprZepto2.default.extend(this._options, options);
  };

  /**
   * attempt to autoplays the playback.
   * @method attemptAutoPlay
   */


  Playback.prototype.attemptAutoPlay = function attemptAutoPlay() {
    var _this2 = this;

    this.canAutoPlay(function (result, error) {
      // eslint-disable-line no-unused-vars
      result && _this2.play();
    });
  };

  /**
   * checks if the playback can autoplay.
   * @method canAutoPlay
   * @param {Function} callback function where first param is Boolean and second param is playback Error or null
   */


  Playback.prototype.canAutoPlay = function canAutoPlay(cb) {
    cb(true, null); // Assume playback can autoplay by default
  };

  (0, _createClass3.default)(Playback, [{
    key: 'isReady',
    get: function get() {
      return false;
    }

    /**
     * checks if the playback has closed caption tracks.
     * @property hasClosedCaptionsTracks
     * @type {Boolean}
     */

  }, {
    key: 'hasClosedCaptionsTracks',
    get: function get() {
      return this.closedCaptionsTracks.length > 0;
    }

    /**
     * gets the playback available closed caption tracks.
     * @property closedCaptionsTracks
     * @type {Array} an array of objects with at least 'id' and 'name' properties
     */

  }, {
    key: 'closedCaptionsTracks',
    get: function get() {
      return [];
    }

    /**
     * gets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */

  }, {
    key: 'closedCaptionsTrackId',
    get: function get() {
      return -1;
    }

    /**
     * sets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */
    ,
    set: function set(trackId) {}
  }]);
  return Playback;
}(_ui_object2.default);

exports.default = Playback;


(0, _assign2.default)(Playback.prototype, _error_mixin2.default);

Playback.extend = function (properties) {
  return (0, _utils.extend)(Playback, properties);
};

/**
 * checks if the playback can play a given `source`
 * If a mimeType is provided then this will be used instead of inferring the mimetype
 * from the source extension.
 * @method canPlay
 * @static
 * @param {String} source the given source ex: `http://example.com/play.mp4`
 * @param {String} [mimeType] the given mime type, ex: `'application/vnd.apple.mpegurl'`
 * @return {Boolean} `true` if the playback is playable, otherwise `false`
 */
Playback.canPlay = function (source, mimeType) {
  // eslint-disable-line no-unused-vars
  return false;
};

/**
 * a playback type for video on demand
 *
 * @property VOD
 * @static
 * @type String
 */
Playback.VOD = 'vod';
/**
 * a playback type for audio on demand
 *
 * @property AOD
 * @static
 * @type String
 */
Playback.AOD = 'aod';
/**
 * a playback type for live video
 *
 * @property LIVE
 * @static
 * @type String
 */
Playback.LIVE = 'live';
/**
 * a default playback type
 *
 * @property NO_OP
 * @static
 * @type String
 */
Playback.NO_OP = 'no_op';
/**
 * the plugin type
 *
 * @property type
 * @static
 * @type String
 */
Playback.type = 'playback';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/polyfills.js":
/*!*******************************!*\
  !*** ./src/base/polyfills.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/**
 * Array.prototype.find
 *
 * Original source : https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * See also : https://tc39.github.io/ecma262/#sec-array.prototype.find
 */
if (!Array.prototype.find) {
  // eslint-disable-next-line
  Object.defineProperty(Array.prototype, 'find', {
    // Note: ES6 arrow function syntax is not used on purpose to avoid this to be undefined
    value: function value(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) throw new TypeError('"this" is null or not defined');

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') throw new TypeError('predicate must be a function');

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) return kValue;

        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}

/***/ }),

/***/ "./src/base/styler.js":
/*!****************************!*\
  !*** ./src/base/styler.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _template = __webpack_require__(/*! ./template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var Styler = {
  getStyleFor: function getStyleFor(style) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { baseUrl: '' };

    return (0, _clapprZepto2.default)('<style class="clappr-style"></style>').html((0, _template2.default)(style.toString())(options));
  }
};

exports.default = Styler;
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/svg_icons.js":
/*!*******************************!*\
  !*** ./src/base/svg_icons.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.volumeMute = exports.volume = exports.stop = exports.reload = exports.play = exports.pause = exports.hd = exports.fullscreen = exports.exitFullscreen = exports.cc = undefined;

var _play = __webpack_require__(/*! ../icons/01-play.svg */ "./src/icons/01-play.svg");

var _play2 = _interopRequireDefault(_play);

var _pause = __webpack_require__(/*! ../icons/02-pause.svg */ "./src/icons/02-pause.svg");

var _pause2 = _interopRequireDefault(_pause);

var _stop = __webpack_require__(/*! ../icons/03-stop.svg */ "./src/icons/03-stop.svg");

var _stop2 = _interopRequireDefault(_stop);

var _volume = __webpack_require__(/*! ../icons/04-volume.svg */ "./src/icons/04-volume.svg");

var _volume2 = _interopRequireDefault(_volume);

var _mute = __webpack_require__(/*! ../icons/05-mute.svg */ "./src/icons/05-mute.svg");

var _mute2 = _interopRequireDefault(_mute);

var _expand = __webpack_require__(/*! ../icons/06-expand.svg */ "./src/icons/06-expand.svg");

var _expand2 = _interopRequireDefault(_expand);

var _shrink = __webpack_require__(/*! ../icons/07-shrink.svg */ "./src/icons/07-shrink.svg");

var _shrink2 = _interopRequireDefault(_shrink);

var _hd = __webpack_require__(/*! ../icons/08-hd.svg */ "./src/icons/08-hd.svg");

var _hd2 = _interopRequireDefault(_hd);

var _cc = __webpack_require__(/*! ../icons/09-cc.svg */ "./src/icons/09-cc.svg");

var _cc2 = _interopRequireDefault(_cc);

var _reload = __webpack_require__(/*! ../icons/10-reload.svg */ "./src/icons/10-reload.svg");

var _reload2 = _interopRequireDefault(_reload);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var cc = exports.cc = _cc2.default;
var exitFullscreen = exports.exitFullscreen = _shrink2.default;
var fullscreen = exports.fullscreen = _expand2.default;
var hd = exports.hd = _hd2.default;
var pause = exports.pause = _pause2.default;
var play = exports.play = _play2.default;
var reload = exports.reload = _reload2.default;
var stop = exports.stop = _stop2.default;
var volume = exports.volume = _volume2.default;
var volumeMute = exports.volumeMute = _mute2.default;

exports.default = {
  cc: _cc2.default,
  exitFullscreen: _shrink2.default,
  fullscreen: _expand2.default,
  hd: _hd2.default,
  pause: _pause2.default,
  play: _play2.default,
  reload: _reload2.default,
  stop: _stop2.default,
  volume: _volume2.default,
  volumeMute: _mute2.default
};

/***/ }),

/***/ "./src/base/template.js":
/*!******************************!*\
  !*** ./src/base/template.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable no-var */
// Simple JavaScript Templating
// Paul Miller (http://paulmillr.com)
// http://underscorejs.org
// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors

// By default, Underscore uses ERB-style template delimiters, change the
// following template settings to use alternative delimiters.
var settings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
};var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  '\'': '\'',
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\t': 't',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

// List of HTML entities for escaping.
var htmlEntities = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var entityRe = new RegExp('[&<>"\']', 'g');

var escapeExpr = function escapeExpr(string) {
  if (string === null) return '';
  return ('' + string).replace(entityRe, function (match) {
    return htmlEntities[match];
  });
};

var counter = 0;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
var tmpl = function tmpl(text, data) {
  var render;

  // Combine delimiters into one regular expression via alternation.
  var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = '__p+=\'';
  text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escaper, function (match) {
      return '\\' + escapes[match];
    });

    if (escape) source += '\'+\n((__t=(' + escape + '))==null?\'\':escapeExpr(__t))+\n\'';

    if (interpolate) source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';

    if (evaluate) source += '\';\n' + evaluate + '\n__p+=\'';

    index = offset + match.length;
    return match;
  });
  source += '\';\n';

  // If a variable is not specified, place data values in local scope.
  if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

  source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n//# sourceURL=/microtemplates/source[' + counter++ + ']';

  try {
    /*jshint -W054 */
    // TODO: find a way to avoid eval
    render = new Function(settings.variable || 'obj', 'escapeExpr', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  if (data) return render(data, escapeExpr);
  var template = function template(data) {
    return render.call(this, data, escapeExpr);
  };

  // Provide the compiled function source as a convenience for precompilation.
  template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

  return template;
};
tmpl.settings = settings;

exports.default = tmpl;
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/ui_container_plugin.js":
/*!*****************************************!*\
  !*** ./src/base/ui_container_plugin.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _ui_object = __webpack_require__(/*! ./ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _error_mixin = __webpack_require__(/*! ./error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base class for an ui container plugin
 * @class UIContainerPlugin
 * @constructor
 * @extends UIObject
 * @module base
 */
var UIContainerPlugin = function (_UIObject) {
  (0, _inherits3.default)(UIContainerPlugin, _UIObject);
  (0, _createClass3.default)(UIContainerPlugin, [{
    key: 'playerError',
    get: function get() {
      return this.container.playerError;
    }
  }]);

  function UIContainerPlugin(container) {
    (0, _classCallCheck3.default)(this, UIContainerPlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIObject.call(this, container.options));

    _this.container = container;
    _this.enabled = true;
    _this.bindEvents();
    return _this;
  }

  UIContainerPlugin.prototype.enable = function enable() {
    if (!this.enabled) {
      this.bindEvents();
      this.$el.show();
      this.enabled = true;
    }
  };

  UIContainerPlugin.prototype.disable = function disable() {
    this.stopListening();
    this.$el.hide();
    this.enabled = false;
  };

  UIContainerPlugin.prototype.bindEvents = function bindEvents() {};

  return UIContainerPlugin;
}(_ui_object2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = UIContainerPlugin;


(0, _assign2.default)(UIContainerPlugin.prototype, _error_mixin2.default);

UIContainerPlugin.extend = function (properties) {
  return (0, _utils.extend)(UIContainerPlugin, properties);
};

UIContainerPlugin.type = 'container';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/ui_core_plugin.js":
/*!************************************!*\
  !*** ./src/base/ui_core_plugin.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _ui_object = __webpack_require__(/*! ./ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _error_mixin = __webpack_require__(/*! ./error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UICorePlugin = function (_UIObject) {
  (0, _inherits3.default)(UICorePlugin, _UIObject);
  (0, _createClass3.default)(UICorePlugin, [{
    key: 'playerError',
    get: function get() {
      return this.core.playerError;
    }
  }]);

  function UICorePlugin(core) {
    (0, _classCallCheck3.default)(this, UICorePlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIObject.call(this, core.options));

    _this.core = core;
    _this.enabled = true;
    _this.bindEvents();
    _this.render();
    return _this;
  }

  UICorePlugin.prototype.bindEvents = function bindEvents() {};

  UICorePlugin.prototype.getExternalInterface = function getExternalInterface() {
    return {};
  };

  UICorePlugin.prototype.enable = function enable() {
    if (!this.enabled) {
      this.bindEvents();
      this.$el.show();
      this.enabled = true;
    }
  };

  UICorePlugin.prototype.disable = function disable() {
    this.stopListening();
    this.$el.hide();
    this.enabled = false;
  };

  UICorePlugin.prototype.render = function render() {
    return this;
  };

  return UICorePlugin;
}(_ui_object2.default);

exports.default = UICorePlugin;


(0, _assign2.default)(UICorePlugin.prototype, _error_mixin2.default);

UICorePlugin.extend = function (properties) {
  return (0, _utils.extend)(UICorePlugin, properties);
};

UICorePlugin.type = 'core';
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/ui_object.js":
/*!*******************************!*\
  !*** ./src/base/ui_object.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _utils = __webpack_require__(/*! ./utils */ "./src/base/utils.js");

var _base_object = __webpack_require__(/*! ./base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var delegateEventSplitter = /^(\S+)\s*(.*)$/;

/**
 * A base class to create ui object.
 * @class UIObject
 * @constructor
 * @extends BaseObject
 * @module base
 */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var UIObject = function (_BaseObject) {
  (0, _inherits3.default)(UIObject, _BaseObject);
  (0, _createClass3.default)(UIObject, [{
    key: 'tagName',

    /**
     * a unique id prefixed with `'c'`, `c1, c232`
     *
     * @property cid
     * @type String
     */
    /**
     * the dom element itself
     *
     * @property el
     * @type HTMLElement
     */
    /**
     * the dom element wrapped by `$`
     *
     * @property $el
     * @type HTMLElement
     */

    /**
     * gets the tag name for the ui component
     * @method tagName
     * @default div
     * @return {String} tag's name
     */
    get: function get() {
      return 'div';
    }
    /**
     * a literal object mapping element's events to methods
     * @property events
     * @type Object
     * @example
     *
     *```javascript
     *
     * class MyButton extends UIObject {
     *   constructor(options) {
     *     super(options)
     *     this.myId = 0
     *   }
     *   get events() { return { 'click': 'myClick' } }
     *   myClick(){ this.myId = 42 }
     * }
     *
     * // when you click on MyButton the method `myClick` will be called
     *```
     */

  }, {
    key: 'events',
    get: function get() {
      return {};
    }
    /**
     * a literal object mapping attributes and values to the element
     * element's attribute name and the value the attribute value
     * @property attributes
     * @type Object
     * @example
     *
     *```javascript
     *
     * class MyButton extends UIObject {
     *    constructor(options) { super(options) }
     *    get attributes() { return { class: 'my-button'} }
     * }
     *
     * // MyButton.el.className will be 'my-button'
     * ```
     */

  }, {
    key: 'attributes',
    get: function get() {
      return {};
    }

    /**
     * it builds an ui component by:
     *  * creating an id for the component `cid`
     *  * making sure the element is created `$el`
     *  * delegating all `events` to the element
     * @method constructor
     * @param {Object} options the options object
     */

  }]);

  function UIObject(options) {
    (0, _classCallCheck3.default)(this, UIObject);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, options));

    _this.cid = (0, _utils.uniqueId)('c');
    _this._ensureElement();
    _this.delegateEvents();
    return _this;
  }

  /**
   * selects within the component.
   * @method $
   * @param {String} selector a selector to find within the component.
   * @return {HTMLElement} an element, if it exists.
   * @example
   * ```javascript
   * fullScreenBarUIComponent.$('.button-full') //will return only `.button-full` within the component
   * ```
   */


  UIObject.prototype.$ = function $(selector) {
    return this.$el.find(selector);
  };

  /**
   * render the component, usually attach it to a real existent `element`
   * @method render
   * @return {UIObject} itself
   */


  UIObject.prototype.render = function render() {
    return this;
  };

  /**
   * removes the ui component from DOM
   * @method destroy
   * @return {UIObject} itself
   */


  UIObject.prototype.destroy = function destroy() {
    this.$el.remove();
    this.stopListening();
    this.undelegateEvents();
    return this;
  };

  /**
   * set element to `el` and `$el`
   * @method setElement
   * @param {HTMLElement} element
   * @param {Boolean} delegate whether is delegate or not
   * @return {UIObject} itself
   */


  UIObject.prototype.setElement = function setElement(element, delegate) {
    if (this.$el) this.undelegateEvents();
    this.$el = _clapprZepto2.default.zepto.isZ(element) ? element : (0, _clapprZepto2.default)(element);
    this.el = this.$el[0];
    if (delegate !== false) this.delegateEvents();
    return this;
  };

  /**
   * delegates all the original `events` on `element` to its callbacks
   * @method delegateEvents
   * @param {Object} events
   * @return {UIObject} itself
   */


  UIObject.prototype.delegateEvents = function delegateEvents(events) {
    if (!(events || (events = this.events))) return this;
    this.undelegateEvents();
    for (var key in events) {
      var method = events[key];
      if (method && method.constructor !== Function) method = this[events[key]];
      if (!method) continue;

      var match = key.match(delegateEventSplitter);
      var eventName = match[1],
          selector = match[2];
      eventName += '.delegateEvents' + this.cid;
      if (selector === '') this.$el.on(eventName, method.bind(this));else this.$el.on(eventName, selector, method.bind(this));
    }
    return this;
  };

  /**
   * undelegats all the `events`
   * @method undelegateEvents
   * @return {UIObject} itself
   */


  UIObject.prototype.undelegateEvents = function undelegateEvents() {
    this.$el.off('.delegateEvents' + this.cid);
    return this;
  };

  /**
   * ensures the creation of this ui component
   * @method _ensureElement
   * @private
   */


  UIObject.prototype._ensureElement = function _ensureElement() {
    if (!this.el) {
      var attrs = _clapprZepto2.default.extend({}, this.attributes);
      if (this.id) attrs.id = this.id;
      if (this.className) attrs['class'] = this.className;
      var $el = _utils.DomRecycler.create(this.tagName).attr(attrs);
      this.setElement($el, false);
    } else {
      this.setElement(this.el, false);
    }
  };

  return UIObject;
}(_base_object2.default);

exports.default = UIObject;
module.exports = exports['default'];

/***/ }),

/***/ "./src/base/utils.js":
/*!***************************!*\
  !*** ./src/base/utils.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SvgIcons = exports.DoubleEventHandler = exports.DomRecycler = exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.QueryString = exports.Config = exports.Fullscreen = undefined;

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _getOwnPropertyDescriptor = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-descriptor */ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

exports.assign = assign;
exports.extend = extend;
exports.formatTime = formatTime;
exports.seekStringToSeconds = seekStringToSeconds;
exports.uniqueId = uniqueId;
exports.isNumber = isNumber;
exports.currentScriptUrl = currentScriptUrl;
exports.getBrowserLanguage = getBrowserLanguage;
exports.now = now;
exports.removeArrayItem = removeArrayItem;
exports.listContainsIgnoreCase = listContainsIgnoreCase;
exports.canAutoPlayMedia = canAutoPlayMedia;

__webpack_require__(/*! ./polyfills */ "./src/base/polyfills.js");

var _browser = __webpack_require__(/*! ../components/browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _media = __webpack_require__(/*! ./media */ "./src/base/media.js");

var _media2 = _interopRequireDefault(_media);

var _svg_icons = __webpack_require__(/*! ./svg_icons */ "./src/base/svg_icons.js");

var _svg_icons2 = _interopRequireDefault(_svg_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assign(obj, source) {
  if (source) {
    for (var prop in source) {
      var propDescriptor = (0, _getOwnPropertyDescriptor2.default)(source, prop);
      propDescriptor ? (0, _defineProperty2.default)(obj, prop, propDescriptor) : obj[prop] = source[prop];
    }
  }
  return obj;
} // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/*jshint -W079 */

function extend(parent, properties) {
  var Surrogate = function (_parent) {
    (0, _inherits3.default)(Surrogate, _parent);

    function Surrogate() {
      (0, _classCallCheck3.default)(this, Surrogate);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = (0, _possibleConstructorReturn3.default)(this, _parent.call.apply(_parent, [this].concat(args)));

      if (properties.initialize) properties.initialize.apply(_this, args);

      return _this;
    }

    return Surrogate;
  }(parent);

  assign(Surrogate.prototype, properties);
  return Surrogate;
}

function formatTime(time, paddedHours) {
  if (!isFinite(time)) return '--:--';

  time = time * 1000;
  time = parseInt(time / 1000);
  var seconds = time % 60;
  time = parseInt(time / 60);
  var minutes = time % 60;
  time = parseInt(time / 60);
  var hours = time % 24;
  var days = parseInt(time / 24);
  var out = '';
  if (days && days > 0) {
    out += days + ':';
    if (hours < 1) out += '00:';
  }
  if (hours && hours > 0 || paddedHours) out += ('0' + hours).slice(-2) + ':';
  out += ('0' + minutes).slice(-2) + ':';
  out += ('0' + seconds).slice(-2);
  return out.trim();
}

var Fullscreen = exports.Fullscreen = {
  fullscreenElement: function fullscreenElement() {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  },
  requestFullscreen: function requestFullscreen(el) {
    if (el.requestFullscreen) el.requestFullscreen();else if (el.webkitEnterFullScreen) el.webkitEnterFullScreen();else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();else if (el.mozRequestFullScreen) el.mozRequestFullScreen();else if (el.msRequestFullscreen) el.msRequestFullscreen();else if (el.querySelector && el.querySelector('video') && el.querySelector('video').webkitEnterFullScreen) el.querySelector('video').webkitEnterFullScreen();
  },
  cancelFullscreen: function cancelFullscreen() {
    var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

    if (el.exitFullscreen) el.exitFullscreen();else if (el.webkitCancelFullScreen) el.webkitCancelFullScreen();else if (el.webkitExitFullscreen) el.webkitExitFullscreen();else if (el.mozCancelFullScreen) el.mozCancelFullScreen();else if (el.msExitFullscreen) el.msExitFullscreen();
  },
  fullscreenEnabled: function fullscreenEnabled() {
    return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
  }
};

var Config = exports.Config = function () {
  function Config() {
    (0, _classCallCheck3.default)(this, Config);
  }

  Config._defaultConfig = function _defaultConfig() {
    return {
      volume: {
        value: 100,
        parse: parseInt
      }
    };
  };

  Config._defaultValueFor = function _defaultValueFor(key) {
    try {
      return this._defaultConfig()[key].parse(this._defaultConfig()[key].value);
    } catch (e) {
      return undefined;
    }
  };

  Config._createKeyspace = function _createKeyspace(key) {
    return 'clappr.' + document.domain + '.' + key;
  };

  Config.restore = function restore(key) {
    if (_browser2.default.hasLocalstorage && localStorage[this._createKeyspace(key)]) return this._defaultConfig()[key].parse(localStorage[this._createKeyspace(key)]);

    return this._defaultValueFor(key);
  };

  Config.persist = function persist(key, value) {
    if (_browser2.default.hasLocalstorage) {
      try {
        localStorage[this._createKeyspace(key)] = value;
        return true;
      } catch (e) {
        return false;
      }
    }
  };

  return Config;
}();

var QueryString = exports.QueryString = function () {
  function QueryString() {
    (0, _classCallCheck3.default)(this, QueryString);
  }

  QueryString.parse = function parse(paramsString) {
    var match = void 0;
    var pl = /\+/g,
        // Regex for replacing addition symbol with a space
    search = /([^&=]+)=?([^&]*)/g,
        decode = function decode(s) {
      return decodeURIComponent(s.replace(pl, ' '));
    },
        params = {};
    while (match = search.exec(paramsString)) {
      // eslint-disable-line no-cond-assign
      params[decode(match[1]).toLowerCase()] = decode(match[2]);
    }
    return params;
  };

  (0, _createClass3.default)(QueryString, null, [{
    key: 'params',
    get: function get() {
      var query = window.location.search.substring(1);
      if (query !== this.query) {
        this._urlParams = this.parse(query);
        this.query = query;
      }
      return this._urlParams;
    }
  }, {
    key: 'hashParams',
    get: function get() {
      var hash = window.location.hash.substring(1);
      if (hash !== this.hash) {
        this._hashParams = this.parse(hash);
        this.hash = hash;
      }
      return this._hashParams;
    }
  }]);
  return QueryString;
}();

function seekStringToSeconds() {
  var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 't';

  var seconds = 0;
  var seekString = QueryString.params[paramName] || QueryString.hashParams[paramName] || '';
  var parts = seekString.match(/[0-9]+[hms]+/g) || [];
  if (parts.length > 0) {
    var factor = { 'h': 3600, 'm': 60, 's': 1 };
    parts.forEach(function (el) {
      if (el) {
        var suffix = el[el.length - 1];
        var time = parseInt(el.slice(0, el.length - 1), 10);
        seconds += time * factor[suffix];
      }
    });
  } else if (seekString) {
    seconds = parseInt(seekString, 10);
  }

  return seconds;
}

var idsCounter = {};

function uniqueId(prefix) {
  idsCounter[prefix] || (idsCounter[prefix] = 0);
  var id = ++idsCounter[prefix];
  return prefix + id;
}

function isNumber(value) {
  return value - parseFloat(value) + 1 >= 0;
}

function currentScriptUrl() {
  var scripts = document.getElementsByTagName('script');
  return scripts.length ? scripts[scripts.length - 1].src : '';
}

var requestAnimationFrame = exports.requestAnimationFrame = (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
  window.setTimeout(fn, 1000 / 60);
}).bind(window);

var cancelAnimationFrame = exports.cancelAnimationFrame = (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout).bind(window);

function getBrowserLanguage() {
  return window.navigator && window.navigator.language;
}

function now() {
  if (window.performance && window.performance.now) return performance.now();

  return Date.now();
}

// remove the item from the array if it exists in the array
function removeArrayItem(arr, item) {
  var i = arr.indexOf(item);
  if (i >= 0) arr.splice(i, 1);
}

// find an item regardless of its letter case
function listContainsIgnoreCase(item, items) {
  if (item === undefined || items === undefined) return false;
  return items.find(function (itemEach) {
    return item.toLowerCase() === itemEach.toLowerCase();
  }) !== undefined;
}

// https://github.com/video-dev/can-autoplay
function canAutoPlayMedia(cb, options) {
  options = (0, _assign2.default)({
    inline: false,
    muted: false,
    timeout: 250,
    type: 'video',
    source: _media2.default.mp4,
    element: null
  }, options);

  var element = options.element ? options.element : document.createElement(options.type);

  element.muted = options.muted;
  if (options.muted === true) element.setAttribute('muted', 'muted');

  if (options.inline === true) element.setAttribute('playsinline', 'playsinline');

  element.src = options.source;

  var promise = element.play();

  var timeoutId = setTimeout(function () {
    setResult(false, new Error('Timeout ' + options.timeout + ' ms has been reached'));
  }, options.timeout);

  var setResult = function setResult(result) {
    var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    clearTimeout(timeoutId);
    cb(result, error);
  };

  if (promise !== undefined) {
    promise.then(function () {
      return setResult(true);
    }).catch(function (err) {
      return setResult(false, err);
    });
  } else {
    setResult(true);
  }
}

// Simple Zepto element factory with video recycle feature.
var videoStack = [];

var DomRecycler = exports.DomRecycler = function () {
  function DomRecycler() {
    (0, _classCallCheck3.default)(this, DomRecycler);
  }

  DomRecycler.configure = function configure(options) {
    this.options = _clapprZepto2.default.extend(this.options, options);
  };

  DomRecycler.create = function create(name) {
    if (this.options.recycleVideo && name === 'video' && videoStack.length > 0) return videoStack.shift();

    return (0, _clapprZepto2.default)('<' + name + '>');
  };

  DomRecycler.garbage = function garbage($el) {
    // Expect Zepto collection with single element (does not iterate!)
    if (!this.options.recycleVideo || $el[0].tagName.toUpperCase() !== 'VIDEO') return;
    $el.children().remove();
    videoStack.push($el);
  };

  return DomRecycler;
}();

DomRecycler.options = { recycleVideo: false };

var DoubleEventHandler = exports.DoubleEventHandler = function () {
  function DoubleEventHandler() {
    var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
    (0, _classCallCheck3.default)(this, DoubleEventHandler);

    this.delay = delay;
    this.lastTime = 0;
  }

  DoubleEventHandler.prototype.handle = function handle(event, cb) {
    var prevented = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    // Based on http://jsfiddle.net/brettwp/J4djY/
    var currentTime = new Date().getTime();
    var diffTime = currentTime - this.lastTime;

    if (diffTime < this.delay && diffTime > 0) {
      cb();
      prevented && event.preventDefault();
    }

    this.lastTime = currentTime;
  };

  return DoubleEventHandler;
}();

var SvgIcons = exports.SvgIcons = _svg_icons2.default;

exports.default = {
  Config: Config,
  Fullscreen: Fullscreen,
  QueryString: QueryString,
  DomRecycler: DomRecycler,
  extend: extend,
  formatTime: formatTime,
  seekStringToSeconds: seekStringToSeconds,
  uniqueId: uniqueId,
  currentScriptUrl: currentScriptUrl,
  isNumber: isNumber,
  requestAnimationFrame: requestAnimationFrame,
  cancelAnimationFrame: cancelAnimationFrame,
  getBrowserLanguage: getBrowserLanguage,
  now: now,
  removeArrayItem: removeArrayItem,
  canAutoPlayMedia: canAutoPlayMedia,
  Media: _media2.default,
  DoubleEventHandler: DoubleEventHandler,
  SvgIcons: _svg_icons2.default
};

/***/ }),

/***/ "./src/components/browser/browser.js":
/*!*******************************************!*\
  !*** ./src/components/browser/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDevice = exports.getViewportSize = exports.getOsData = exports.getBrowserData = exports.getBrowserInfo = undefined;

var _getIterator2 = __webpack_require__(/*! babel-runtime/core-js/get-iterator */ "./node_modules/babel-runtime/core-js/get-iterator.js");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _browser_data = __webpack_require__(/*! ./browser_data */ "./src/components/browser/browser_data.js");

var _browser_data2 = _interopRequireDefault(_browser_data);

var _os_data = __webpack_require__(/*! ./os_data */ "./src/components/browser/os_data.js");

var _os_data2 = _interopRequireDefault(_os_data);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Browser = {};

var hasLocalstorage = function hasLocalstorage() {
  try {
    localStorage.setItem('clappr', 'clappr');
    localStorage.removeItem('clappr');
    return true;
  } catch (e) {
    return false;
  }
};

var hasFlash = function hasFlash() {
  try {
    var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
    return !!fo;
  } catch (e) {
    return !!(navigator.mimeTypes && navigator.mimeTypes['application/x-shockwave-flash'] !== undefined && navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin);
  }
};

var getBrowserInfo = exports.getBrowserInfo = function getBrowserInfo(ua) {
  var parts = ua.match(/\b(playstation 4|nx|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [],
      extra = void 0;
  if (/trident/i.test(parts[1])) {
    extra = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return {
      name: 'IE',
      version: parseInt(extra[1] || '')
    };
  } else if (parts[1] === 'Chrome') {
    extra = ua.match(/\bOPR\/(\d+)/);
    if (extra != null) return { name: 'Opera', version: parseInt(extra[1]) };

    extra = ua.match(/\bEdge\/(\d+)/);
    if (extra != null) return { name: 'Edge', version: parseInt(extra[1]) };
  } else if (/android/i.test(ua) && (extra = ua.match(/version\/(\d+)/i))) {
    parts.splice(1, 1, 'Android WebView');
    parts.splice(2, 1, extra[1]);
  }
  parts = parts[2] ? [parts[1], parts[2]] : [navigator.appName, navigator.appVersion, '-?'];

  return {
    name: parts[0],
    version: parseInt(parts[1])
  };
};

//  Get browser data
var getBrowserData = exports.getBrowserData = function getBrowserData() {
  var browserObject = {};
  var userAgent = Browser.userAgent.toLowerCase();

  // Check browser type
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(_browser_data2.default), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var browser = _step.value;

      var browserRegExp = new RegExp(browser.identifier.toLowerCase());
      var browserRegExpResult = browserRegExp.exec(userAgent);

      if (browserRegExpResult != null && browserRegExpResult[1]) {
        browserObject.name = browser.name;
        browserObject.group = browser.group;

        // Check version
        if (browser.versionIdentifier) {
          var versionRegExp = new RegExp(browser.versionIdentifier.toLowerCase());
          var versionRegExpResult = versionRegExp.exec(userAgent);

          if (versionRegExpResult != null && versionRegExpResult[1]) setBrowserVersion(versionRegExpResult[1], browserObject);
        } else {
          setBrowserVersion(browserRegExpResult[1], browserObject);
        }
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return browserObject;
};

// Set browser version
var setBrowserVersion = function setBrowserVersion(version, browserObject) {
  var splitVersion = version.split('.', 2);
  browserObject.fullVersion = version;

  // Major version
  if (splitVersion[0]) browserObject.majorVersion = parseInt(splitVersion[0]);

  // Minor version
  if (splitVersion[1]) browserObject.minorVersion = parseInt(splitVersion[1]);
};

//  Get OS data
var getOsData = exports.getOsData = function getOsData() {
  var osObject = {};
  var userAgent = Browser.userAgent.toLowerCase();

  // Check browser type
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(_os_data2.default), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var os = _step2.value;

      var osRegExp = new RegExp(os.identifier.toLowerCase());
      var osRegExpResult = osRegExp.exec(userAgent);

      if (osRegExpResult != null) {
        osObject.name = os.name;
        osObject.group = os.group;

        // Version defined
        if (os.version) {
          setOsVersion(os.version, os.versionSeparator ? os.versionSeparator : '.', osObject);

          // Version detected
        } else if (osRegExpResult[1]) {
          setOsVersion(osRegExpResult[1], os.versionSeparator ? os.versionSeparator : '.', osObject);

          // Version identifier
        } else if (os.versionIdentifier) {
          var versionRegExp = new RegExp(os.versionIdentifier.toLowerCase());
          var versionRegExpResult = versionRegExp.exec(userAgent);

          if (versionRegExpResult != null && versionRegExpResult[1]) setOsVersion(versionRegExpResult[1], os.versionSeparator ? os.versionSeparator : '.', osObject);
        }
        break;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return osObject;
};

// Set OS version
var setOsVersion = function setOsVersion(version, separator, osObject) {
  var finalSeparator = separator.substr(0, 1) == '[' ? new RegExp(separator, 'g') : separator;
  var splitVersion = version.split(finalSeparator, 2);

  if (separator != '.') version = version.replace(new RegExp(separator, 'g'), '.');

  osObject.fullVersion = version;

  // Major version
  if (splitVersion && splitVersion[0]) osObject.majorVersion = parseInt(splitVersion[0]);

  // Minor version
  if (splitVersion && splitVersion[1]) osObject.minorVersion = parseInt(splitVersion[1]);
};

// Set viewport size
var getViewportSize = exports.getViewportSize = function getViewportSize() {
  var viewportObject = {};

  viewportObject.width = (0, _clapprZepto2.default)(window).width();
  viewportObject.height = (0, _clapprZepto2.default)(window).height();

  return viewportObject;
};

// Set viewport orientation
var setViewportOrientation = function setViewportOrientation() {
  switch (window.orientation) {
    case -90:
    case 90:
      Browser.viewport.orientation = 'landscape';
      break;
    default:
      Browser.viewport.orientation = 'portrait';
      break;
  }
};

var getDevice = exports.getDevice = function getDevice(ua) {
  var platformRegExp = /\((iP(?:hone|ad|od))?(?:[^;]*; ){0,2}([^)]+(?=\)))/;
  var matches = platformRegExp.exec(ua);
  var device = matches && (matches[1] || matches[2]) || '';
  return device;
};

var browserInfo = getBrowserInfo(navigator.userAgent);

Browser.isEdge = /edge/i.test(navigator.userAgent);
Browser.isChrome = /chrome|CriOS/i.test(navigator.userAgent) && !Browser.isEdge;
Browser.isSafari = /safari/i.test(navigator.userAgent) && !Browser.isChrome && !Browser.isEdge;
Browser.isFirefox = /firefox/i.test(navigator.userAgent);
Browser.isLegacyIE = !!window.ActiveXObject;
Browser.isIE = Browser.isLegacyIE || /trident.*rv:1\d/i.test(navigator.userAgent);
Browser.isIE11 = /trident.*rv:11/i.test(navigator.userAgent);
Browser.isChromecast = Browser.isChrome && /CrKey/i.test(navigator.userAgent);
Browser.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone|IEMobile|Mobile Safari|Opera Mini/i.test(navigator.userAgent);
Browser.isiOS = /iPad|iPhone|iPod/i.test(navigator.userAgent);
Browser.isAndroid = /Android/i.test(navigator.userAgent);
Browser.isWindowsPhone = /Windows Phone/i.test(navigator.userAgent);
Browser.isWin8App = /MSAppHost/i.test(navigator.userAgent);
Browser.isWiiU = /WiiU/i.test(navigator.userAgent);
Browser.isPS4 = /PlayStation 4/i.test(navigator.userAgent);
Browser.hasLocalstorage = hasLocalstorage();
Browser.hasFlash = hasFlash();

/**
* @deprecated
* This parameter currently exists for retrocompatibility reasons.
* Use Browser.data.name instead.
*/
Browser.name = browserInfo.name;

/**
* @deprecated
* This parameter currently exists for retrocompatibility reasons.
* Use Browser.data.fullVersion instead.
*/
Browser.version = browserInfo.version;

Browser.userAgent = navigator.userAgent;
Browser.data = getBrowserData();
Browser.os = getOsData();
Browser.viewport = getViewportSize();
Browser.device = getDevice(Browser.userAgent);
typeof window.orientation !== 'undefined' && setViewportOrientation();

exports.default = Browser;

/***/ }),

/***/ "./src/components/browser/browser_data.js":
/*!************************************************!*\
  !*** ./src/components/browser/browser_data.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable no-useless-escape */
// The order of the following arrays is important, be careful if you change it.

var BROWSER_DATA = [{
  name: 'Chromium',
  group: 'Chrome',
  identifier: 'Chromium/([0-9\.]*)'
}, {
  name: 'Chrome Mobile',
  group: 'Chrome',
  identifier: 'Chrome/([0-9\.]*) Mobile',
  versionIdentifier: 'Chrome/([0-9\.]*)'
}, {
  name: 'Chrome',
  group: 'Chrome',
  identifier: 'Chrome/([0-9\.]*)'
}, {
  name: 'Chrome for iOS',
  group: 'Chrome',
  identifier: 'CriOS/([0-9\.]*)'
}, {
  name: 'Android Browser',
  group: 'Chrome',
  identifier: 'CrMo/([0-9\.]*)'
}, {
  name: 'Firefox',
  group: 'Firefox',
  identifier: 'Firefox/([0-9\.]*)'
}, {
  name: 'Opera Mini',
  group: 'Opera',
  identifier: 'Opera Mini/([0-9\.]*)'
}, {
  name: 'Opera',
  group: 'Opera',
  identifier: 'Opera ([0-9\.]*)'
}, {
  name: 'Opera',
  group: 'Opera',
  identifier: 'Opera/([0-9\.]*)',
  versionIdentifier: 'Version/([0-9\.]*)'
}, {
  name: 'IEMobile',
  group: 'Explorer',
  identifier: 'IEMobile/([0-9\.]*)'
}, {
  name: 'Internet Explorer',
  group: 'Explorer',
  identifier: 'MSIE ([a-zA-Z0-9\.]*)'
}, {
  name: 'Internet Explorer',
  group: 'Explorer',
  identifier: 'Trident/([0-9\.]*)',
  versionIdentifier: 'rv:([0-9\.]*)'
}, {
  name: 'Spartan',
  group: 'Spartan',
  identifier: 'Edge/([0-9\.]*)',
  versionIdentifier: 'Edge/([0-9\.]*)'
}, {
  name: 'Safari',
  group: 'Safari',
  identifier: 'Safari/([0-9\.]*)',
  versionIdentifier: 'Version/([0-9\.]*)'
}];

exports.default = BROWSER_DATA;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/browser/index.js":
/*!*****************************************!*\
  !*** ./src/components/browser/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _browser = __webpack_require__(/*! ./browser */ "./src/components/browser/browser.js");

var _browser2 = _interopRequireDefault(_browser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _browser2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/browser/os_data.js":
/*!*******************************************!*\
  !*** ./src/components/browser/os_data.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable no-useless-escape */
// The order of the following arrays is important, be careful if you change it.

var OS_DATA = [{
  name: 'Windows 2000',
  group: 'Windows',
  identifier: 'Windows NT 5.0',
  version: '5.0'
}, {
  name: 'Windows XP',
  group: 'Windows',
  identifier: 'Windows NT 5.1',
  version: '5.1'
}, {
  name: 'Windows Vista',
  group: 'Windows',
  identifier: 'Windows NT 6.0',
  version: '6.0'
}, {
  name: 'Windows 7',
  group: 'Windows',
  identifier: 'Windows NT 6.1',
  version: '7.0'
}, {
  name: 'Windows 8',
  group: 'Windows',
  identifier: 'Windows NT 6.2',
  version: '8.0'
}, {
  name: 'Windows 8.1',
  group: 'Windows',
  identifier: 'Windows NT 6.3',
  version: '8.1'
}, {
  name: 'Windows 10',
  group: 'Windows',
  identifier: 'Windows NT 10.0',
  version: '10.0'
}, {
  name: 'Windows Phone',
  group: 'Windows Phone',
  identifier: 'Windows Phone ([0-9\.]*)'
}, {
  name: 'Windows Phone',
  group: 'Windows Phone',
  identifier: 'Windows Phone OS ([0-9\.]*)'
}, {
  name: 'Windows',
  group: 'Windows',
  identifier: 'Windows'
}, {
  name: 'Chrome OS',
  group: 'Chrome OS',
  identifier: 'CrOS'
}, {
  name: 'Android',
  group: 'Android',
  identifier: 'Android',
  versionIdentifier: 'Android ([a-zA-Z0-9\.-]*)'
}, {
  name: 'iPad',
  group: 'iOS',
  identifier: 'iPad',
  versionIdentifier: 'OS ([0-9_]*)',
  versionSeparator: '[_|\.]'
}, {
  name: 'iPod',
  group: 'iOS',
  identifier: 'iPod',
  versionIdentifier: 'OS ([0-9_]*)',
  versionSeparator: '[_|\.]'
}, {
  name: 'iPhone',
  group: 'iOS',
  identifier: 'iPhone OS',
  versionIdentifier: 'OS ([0-9_]*)',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X High Sierra',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])13([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Sierra',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])12([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X El Capitan',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])11([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Yosemite',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])10([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Mavericks',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])9([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Mountain Lion',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])8([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Lion',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])7([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Snow Leopard',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])6([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Leopard',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])5([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Tiger',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])4([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Panther',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])3([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Jaguar',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])2([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Puma',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])1([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS X Cheetah',
  group: 'Mac OS',
  identifier: 'Mac OS X (10([_|\.])0([0-9_\.]*))',
  versionSeparator: '[_|\.]'
}, {
  name: 'Mac OS',
  group: 'Mac OS',
  identifier: 'Mac OS'
}, {
  name: 'Ubuntu',
  group: 'Linux',
  identifier: 'Ubuntu',
  versionIdentifier: 'Ubuntu/([0-9\.]*)'
}, {
  name: 'Debian',
  group: 'Linux',
  identifier: 'Debian'
}, {
  name: 'Gentoo',
  group: 'Linux',
  identifier: 'Gentoo'
}, {
  name: 'Linux',
  group: 'Linux',
  identifier: 'Linux'
}, {
  name: 'BlackBerry',
  group: 'BlackBerry',
  identifier: 'BlackBerry'
}];

exports.default = OS_DATA;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/container/container.js":
/*!***********************************************!*\
  !*** ./src/components/container/container.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_object = __webpack_require__(/*! ../../base/ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _error_mixin = __webpack_require__(/*! ../../base/error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

__webpack_require__(/*! ./public/style.scss */ "./src/components/container/public/style.scss");

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An abstraction to represent a container for a given playback
 * TODO: describe its responsabilities
 * @class Container
 * @constructor
 * @extends UIObject
 * @module base
 */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/**
 * Container is responsible for the video rendering and state
 */

var Container = function (_UIObject) {
  (0, _inherits3.default)(Container, _UIObject);
  (0, _createClass3.default)(Container, [{
    key: 'name',

    /**
     * container's name
     * @method name
     * @default Container
     * @return {String} container's name
     */
    get: function get() {
      return 'Container';
    }
  }, {
    key: 'attributes',
    get: function get() {
      return { class: 'container', 'data-container': '' };
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'click': 'clicked',
        'dblclick': 'dblClicked',
        'touchend': 'dblTap',
        'contextmenu': 'onContextMenu',
        'mouseenter': 'mouseEnter',
        'mouseleave': 'mouseLeave'
      };
    }

    /**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */

  }, {
    key: 'ended',
    get: function get() {
      return this.playback.ended;
    }

    /**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */

  }, {
    key: 'buffering',
    get: function get() {
      return this.playback.buffering;
    }

    /**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */

  }, {
    key: 'i18n',
    get: function get() {
      return this._i18n;
    }

    /**
     * checks if has closed caption tracks.
     * @property hasClosedCaptionsTracks
     * @type {Boolean}
     */

  }, {
    key: 'hasClosedCaptionsTracks',
    get: function get() {
      return this.playback.hasClosedCaptionsTracks;
    }

    /**
     * gets the available closed caption tracks.
     * @property closedCaptionsTracks
     * @type {Array} an array of objects with at least 'id' and 'name' properties
     */

  }, {
    key: 'closedCaptionsTracks',
    get: function get() {
      return this.playback.closedCaptionsTracks;
    }

    /**
     * gets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */

  }, {
    key: 'closedCaptionsTrackId',
    get: function get() {
      return this.playback.closedCaptionsTrackId;
    }

    /**
     * sets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */
    ,
    set: function set(trackId) {
      this.playback.closedCaptionsTrackId = trackId;
    }

    /**
     * it builds a container
     * @method constructor
     * @param {Object} options the options object
     * @param {Strings} i18n the internationalization component
     */

  }]);

  function Container(options, i18n, playerError) {
    (0, _classCallCheck3.default)(this, Container);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIObject.call(this, options));

    _this._i18n = i18n;
    _this.currentTime = 0;
    _this.volume = 100;
    _this.playback = options.playback;
    _this.playerError = playerError;
    _this.settings = _clapprZepto2.default.extend({}, _this.playback.settings);
    _this.isReady = false;
    _this.mediaControlDisabled = false;
    _this.plugins = [_this.playback];
    _this.dblTapHandler = new _utils.DoubleEventHandler(500);
    _this.clickTimer = null;
    _this.clickDelay = 200; // FIXME: could be a player option
    _this.bindEvents();
    return _this;
  }

  /**
   * binds playback events to the methods of the container.
   * it listens to playback's events and triggers them as container events.
   *
   * | Playback |
   * |----------|
   * | progress |
   * | timeupdate |
   * | ready |
   * | buffering |
   * | bufferfull |
   * | settingsupdate |
   * | loadedmetadata |
   * | highdefinitionupdate |
   * | bitrate |
   * | playbackstate |
   * | dvr |
   * | mediacontrol_disable |
   * | mediacontrol_enable |
   * | ended |
   * | play |
   * | pause |
   * | error |
   *
   * ps: the events usually translate from PLABACK_x to CONTAINER_x, you can check all the events at `Event` class.
   *
   * @method bindEvents
   */


  Container.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.playback, _events2.default.PLAYBACK_PROGRESS, this.onProgress);
    this.listenTo(this.playback, _events2.default.PLAYBACK_TIMEUPDATE, this.timeUpdated);
    this.listenTo(this.playback, _events2.default.PLAYBACK_READY, this.ready);
    this.listenTo(this.playback, _events2.default.PLAYBACK_BUFFERING, this.onBuffering);
    this.listenTo(this.playback, _events2.default.PLAYBACK_BUFFERFULL, this.bufferfull);
    this.listenTo(this.playback, _events2.default.PLAYBACK_SETTINGSUPDATE, this.settingsUpdate);
    this.listenTo(this.playback, _events2.default.PLAYBACK_LOADEDMETADATA, this.loadedMetadata);
    this.listenTo(this.playback, _events2.default.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate);
    this.listenTo(this.playback, _events2.default.PLAYBACK_BITRATE, this.updateBitrate);
    this.listenTo(this.playback, _events2.default.PLAYBACK_PLAYBACKSTATE, this.playbackStateChanged);
    this.listenTo(this.playback, _events2.default.PLAYBACK_DVR, this.playbackDvrStateChanged);
    this.listenTo(this.playback, _events2.default.PLAYBACK_MEDIACONTROL_DISABLE, this.disableMediaControl);
    this.listenTo(this.playback, _events2.default.PLAYBACK_MEDIACONTROL_ENABLE, this.enableMediaControl);
    this.listenTo(this.playback, _events2.default.PLAYBACK_SEEKED, this.onSeeked);
    this.listenTo(this.playback, _events2.default.PLAYBACK_ENDED, this.onEnded);
    this.listenTo(this.playback, _events2.default.PLAYBACK_PLAY, this.playing);
    this.listenTo(this.playback, _events2.default.PLAYBACK_PAUSE, this.paused);
    this.listenTo(this.playback, _events2.default.PLAYBACK_STOP, this.stopped);
    this.listenTo(this.playback, _events2.default.PLAYBACK_ERROR, this.error);
    this.listenTo(this.playback, _events2.default.PLAYBACK_SUBTITLE_AVAILABLE, this.subtitleAvailable);
    this.listenTo(this.playback, _events2.default.PLAYBACK_SUBTITLE_CHANGED, this.subtitleChanged);
  };

  Container.prototype.subtitleAvailable = function subtitleAvailable() {
    this.trigger(_events2.default.CONTAINER_SUBTITLE_AVAILABLE);
  };

  Container.prototype.subtitleChanged = function subtitleChanged(track) {
    this.trigger(_events2.default.CONTAINER_SUBTITLE_CHANGED, track);
  };

  Container.prototype.playbackStateChanged = function playbackStateChanged(state) {
    this.trigger(_events2.default.CONTAINER_PLAYBACKSTATE, state);
  };

  Container.prototype.playbackDvrStateChanged = function playbackDvrStateChanged(dvrInUse) {
    this.settings = this.playback.settings;
    this.dvrInUse = dvrInUse;
    this.trigger(_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, dvrInUse);
  };

  Container.prototype.updateBitrate = function updateBitrate(newBitrate) {
    this.trigger(_events2.default.CONTAINER_BITRATE, newBitrate);
  };

  Container.prototype.statsReport = function statsReport(metrics) {
    this.trigger(_events2.default.CONTAINER_STATS_REPORT, metrics);
  };

  Container.prototype.getPlaybackType = function getPlaybackType() {
    return this.playback.getPlaybackType();
  };

  /**
   * returns `true` if DVR is enable otherwise `false`.
   * @method isDvrEnabled
   * @return {Boolean}
   */


  Container.prototype.isDvrEnabled = function isDvrEnabled() {
    return !!this.playback.dvrEnabled;
  };

  /**
   * returns `true` if DVR is in use otherwise `false`.
   * @method isDvrInUse
   * @return {Boolean}
   */


  Container.prototype.isDvrInUse = function isDvrInUse() {
    return !!this.dvrInUse;
  };

  /**
   * destroys the container
   * @method destroy
   */


  Container.prototype.destroy = function destroy() {
    this.trigger(_events2.default.CONTAINER_DESTROYED, this, this.name);
    this.stopListening();
    this.plugins.forEach(function (plugin) {
      return plugin.destroy();
    });
    this.$el.remove();
  };

  Container.prototype.setStyle = function setStyle(style) {
    this.$el.css(style);
  };

  Container.prototype.animate = function animate(style, duration) {
    return this.$el.animate(style, duration).promise();
  };

  Container.prototype.ready = function ready() {
    this.isReady = true;
    this.trigger(_events2.default.CONTAINER_READY, this.name);
  };

  Container.prototype.isPlaying = function isPlaying() {
    return this.playback.isPlaying();
  };

  Container.prototype.getStartTimeOffset = function getStartTimeOffset() {
    return this.playback.getStartTimeOffset();
  };

  Container.prototype.getCurrentTime = function getCurrentTime() {
    return this.currentTime;
  };

  Container.prototype.getDuration = function getDuration() {
    return this.playback.getDuration();
  };

  Container.prototype.error = function error(_error) {
    if (!this.isReady) this.ready();

    this.trigger(_events2.default.CONTAINER_ERROR, _error, this.name);
  };

  Container.prototype.loadedMetadata = function loadedMetadata(metadata) {
    this.trigger(_events2.default.CONTAINER_LOADEDMETADATA, metadata);
  };

  Container.prototype.timeUpdated = function timeUpdated(timeProgress) {
    this.currentTime = timeProgress.current;
    this.trigger(_events2.default.CONTAINER_TIMEUPDATE, timeProgress, this.name);
  };

  Container.prototype.onProgress = function onProgress() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.trigger.apply(this, [_events2.default.CONTAINER_PROGRESS].concat(args, [this.name]));
  };

  Container.prototype.playing = function playing() {
    this.trigger(_events2.default.CONTAINER_PLAY, this.name);
  };

  Container.prototype.paused = function paused() {
    this.trigger(_events2.default.CONTAINER_PAUSE, this.name);
  };

  /**
   * plays the playback
   * @method play
   */


  Container.prototype.play = function play() {
    this.playback.play();
  };

  /**
   * stops the playback
   * @method stop
   */


  Container.prototype.stop = function stop() {
    this.playback.stop();
    this.currentTime = 0;
  };

  /**
   * pauses the playback
   * @method pause
   */


  Container.prototype.pause = function pause() {
    this.playback.pause();
  };

  Container.prototype.onEnded = function onEnded() {
    this.trigger(_events2.default.CONTAINER_ENDED, this, this.name);
    this.currentTime = 0;
  };

  Container.prototype.stopped = function stopped() {
    this.trigger(_events2.default.CONTAINER_STOP);
  };

  Container.prototype.clicked = function clicked() {
    var _this2 = this;

    if (!this.options.chromeless || this.options.allowUserInteraction) {
      // The event is delayed because it can be canceled by a double-click event
      // An example of use is to prevent playback from pausing when switching to full screen
      this.clickTimer = setTimeout(function () {
        _this2.clickTimer && _this2.trigger(_events2.default.CONTAINER_CLICK, _this2, _this2.name);
      }, this.clickDelay);
    }
  };

  Container.prototype.cancelClicked = function cancelClicked() {
    clearTimeout(this.clickTimer);
    this.clickTimer = null;
  };

  Container.prototype.dblClicked = function dblClicked() {
    if ((!this.options.chromeless || this.options.allowUserInteraction) && !this.options.disableDblClickFullscreen) {
      this.cancelClicked();
      this.trigger(_events2.default.CONTAINER_DBLCLICK, this, this.name);
    }
  };

  Container.prototype.dblTap = function dblTap(evt) {
    var _this3 = this;

    if ((!this.options.chromeless || this.options.allowUserInteraction) && !this.options.disableDblClickFullscreen) {
      this.dblTapHandler.handle(evt, function () {
        _this3.cancelClicked();
        _this3.trigger(_events2.default.CONTAINER_DBLCLICK, _this3, _this3.name);
      });
    }
  };

  Container.prototype.onContextMenu = function onContextMenu(event) {
    if (!this.options.chromeless || this.options.allowUserInteraction) this.trigger(_events2.default.CONTAINER_CONTEXTMENU, event, this.name);
  };

  Container.prototype.seek = function seek(time) {
    this.trigger(_events2.default.CONTAINER_SEEK, time, this.name);
    this.playback.seek(time);
  };

  Container.prototype.onSeeked = function onSeeked() {
    this.trigger(_events2.default.CONTAINER_SEEKED, this.name);
  };

  Container.prototype.seekPercentage = function seekPercentage(percentage) {
    var duration = this.getDuration();
    if (percentage >= 0 && percentage <= 100) {
      var time = duration * (percentage / 100);
      this.seek(time);
    }
  };

  Container.prototype.setVolume = function setVolume(value) {
    this.volume = parseFloat(value);
    this.trigger(_events2.default.CONTAINER_VOLUME, this.volume, this.name);
    this.playback.volume(this.volume);
  };

  Container.prototype.fullscreen = function fullscreen() {
    this.trigger(_events2.default.CONTAINER_FULLSCREEN, this.name);
  };

  Container.prototype.onBuffering = function onBuffering() {
    this.trigger(_events2.default.CONTAINER_STATE_BUFFERING, this.name);
  };

  Container.prototype.bufferfull = function bufferfull() {
    this.trigger(_events2.default.CONTAINER_STATE_BUFFERFULL, this.name);
  };

  /**
   * adds plugin to the container
   * @method addPlugin
   * @param {Object} plugin
   */


  Container.prototype.addPlugin = function addPlugin(plugin) {
    this.plugins.push(plugin);
  };

  /**
   * checks if a plugin, given its name, exist
   * @method hasPlugin
   * @param {String} name
   * @return {Boolean}
   */


  Container.prototype.hasPlugin = function hasPlugin(name) {
    return !!this.getPlugin(name);
  };

  /**
   * get the plugin given its name
   * @method getPlugin
   * @param {String} name
   */


  Container.prototype.getPlugin = function getPlugin(name) {
    return this.plugins.filter(function (plugin) {
      return plugin.name === name;
    })[0];
  };

  Container.prototype.mouseEnter = function mouseEnter() {
    if (!this.options.chromeless || this.options.allowUserInteraction) this.trigger(_events2.default.CONTAINER_MOUSE_ENTER);
  };

  Container.prototype.mouseLeave = function mouseLeave() {
    if (!this.options.chromeless || this.options.allowUserInteraction) this.trigger(_events2.default.CONTAINER_MOUSE_LEAVE);
  };

  Container.prototype.settingsUpdate = function settingsUpdate() {
    this.settings = this.playback.settings;
    this.trigger(_events2.default.CONTAINER_SETTINGSUPDATE);
  };

  Container.prototype.highDefinitionUpdate = function highDefinitionUpdate(isHD) {
    this.trigger(_events2.default.CONTAINER_HIGHDEFINITIONUPDATE, isHD);
  };

  Container.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
    return this.playback.isHighDefinitionInUse();
  };

  Container.prototype.disableMediaControl = function disableMediaControl() {
    if (!this.mediaControlDisabled) {
      this.mediaControlDisabled = true;
      this.trigger(_events2.default.CONTAINER_MEDIACONTROL_DISABLE);
    }
  };

  Container.prototype.enableMediaControl = function enableMediaControl() {
    if (this.mediaControlDisabled) {
      this.mediaControlDisabled = false;
      this.trigger(_events2.default.CONTAINER_MEDIACONTROL_ENABLE);
    }
  };

  Container.prototype.updateStyle = function updateStyle() {
    if (!this.options.chromeless || this.options.allowUserInteraction) this.$el.removeClass('chromeless');else this.$el.addClass('chromeless');
  };

  /**
   * enables to configure the container after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */


  Container.prototype.configure = function configure(options) {
    this._options = _clapprZepto2.default.extend(this._options, options);
    this.updateStyle();
    this.playback.configure(this.options);
    this.trigger(_events2.default.CONTAINER_OPTIONS_CHANGE);
  };

  Container.prototype.render = function render() {
    this.$el.append(this.playback.render().el);
    this.updateStyle();
    return this;
  };

  return Container;
}(_ui_object2.default);

exports.default = Container;


(0, _assign2.default)(Container.prototype, _error_mixin2.default);
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/container/index.js":
/*!*******************************************!*\
  !*** ./src/components/container/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _container = __webpack_require__(/*! ./container */ "./src/components/container/container.js");

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _container2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/container/public/style.scss":
/*!****************************************************!*\
  !*** ./src/components/container/public/style.scss ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./style.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/container/public/style.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/components/container_factory/container_factory.js":
/*!***************************************************************!*\
  !*** ./src/components/container_factory/container_factory.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _base_object = __webpack_require__(/*! ../../base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _container = __webpack_require__(/*! ../../components/container */ "./src/components/container/index.js");

var _container2 = _interopRequireDefault(_container);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/**
 * The ContainerFactory is responsible for manage playback bootstrap and create containers.
 */

var ContainerFactory = function (_BaseObject) {
  (0, _inherits3.default)(ContainerFactory, _BaseObject);
  (0, _createClass3.default)(ContainerFactory, [{
    key: 'options',
    get: function get() {
      return this._options;
    },
    set: function set(options) {
      this._options = options;
    }
  }]);

  function ContainerFactory(options, loader, i18n, playerError) {
    (0, _classCallCheck3.default)(this, ContainerFactory);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, options));

    _this._i18n = i18n;
    _this.loader = loader;
    _this.playerError = playerError;
    return _this;
  }

  ContainerFactory.prototype.createContainers = function createContainers() {
    var _this2 = this;

    return _clapprZepto2.default.Deferred(function (promise) {
      promise.resolve(_this2.options.sources.map(function (source) {
        return _this2.createContainer(source);
      }));
    });
  };

  ContainerFactory.prototype.findPlaybackPlugin = function findPlaybackPlugin(source, mimeType) {
    return this.loader.playbackPlugins.filter(function (p) {
      return p.canPlay(source, mimeType);
    })[0];
  };

  ContainerFactory.prototype.createContainer = function createContainer(source) {
    var resolvedSource = null,
        mimeType = this.options.mimeType;
    if ((typeof source === 'undefined' ? 'undefined' : (0, _typeof3.default)(source)) === 'object') {
      resolvedSource = source.source.toString();
      if (source.mimeType) mimeType = source.mimeType;
    } else {
      resolvedSource = source.toString();
    }

    if (resolvedSource.match(/^\/\//)) resolvedSource = window.location.protocol + resolvedSource;

    var options = _clapprZepto2.default.extend({}, this.options, {
      src: resolvedSource,
      mimeType: mimeType
    });
    var playbackPlugin = this.findPlaybackPlugin(resolvedSource, mimeType);
    var playback = new playbackPlugin(options, this._i18n, this.playerError);

    options = _clapprZepto2.default.extend({}, options, { playback: playback });

    var container = new _container2.default(options, this._i18n, this.playerError);
    var defer = _clapprZepto2.default.Deferred();
    defer.promise(container);
    this.addContainerPlugins(container);
    this.listenToOnce(container, _events2.default.CONTAINER_READY, function () {
      return defer.resolve(container);
    });
    return container;
  };

  ContainerFactory.prototype.addContainerPlugins = function addContainerPlugins(container) {
    this.loader.containerPlugins.forEach(function (Plugin) {
      container.addPlugin(new Plugin(container));
    });
  };

  return ContainerFactory;
}(_base_object2.default);

exports.default = ContainerFactory;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/container_factory/index.js":
/*!***************************************************!*\
  !*** ./src/components/container_factory/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _container_factory = __webpack_require__(/*! ./container_factory */ "./src/components/container_factory/container_factory.js");

var _container_factory2 = _interopRequireDefault(_container_factory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _container_factory2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/core/core.js":
/*!*************************************!*\
  !*** ./src/components/core/core.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _styler = __webpack_require__(/*! ../../base/styler */ "./src/base/styler.js");

var _styler2 = _interopRequireDefault(_styler);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_object = __webpack_require__(/*! ../../base/ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _browser = __webpack_require__(/*! ../../components/browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _container_factory = __webpack_require__(/*! ../../components/container_factory */ "./src/components/container_factory/index.js");

var _container_factory2 = _interopRequireDefault(_container_factory);

var _mediator = __webpack_require__(/*! ../../components/mediator */ "./src/components/mediator.js");

var _mediator2 = _interopRequireDefault(_mediator);

var _player_info = __webpack_require__(/*! ../../components/player_info */ "./src/components/player_info.js");

var _player_info2 = _interopRequireDefault(_player_info);

var _error = __webpack_require__(/*! ../../components/error */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

var _error_mixin = __webpack_require__(/*! ../../base/error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

__webpack_require__(/*! ./public/style.scss */ "./src/components/core/public/style.scss");

var _fonts = __webpack_require__(/*! ./public/fonts.css */ "./src/components/core/public/fonts.css");

var _fonts2 = _interopRequireDefault(_fonts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var style = void 0;

/**
 * The Core is responsible to manage Containers, the mediator, MediaControl
 * and the player state.
 * @class Core
 * @constructor
 * @extends UIObject
 * @module components
 */

var Core = function (_UIObject) {
  (0, _inherits3.default)(Core, _UIObject);
  (0, _createClass3.default)(Core, [{
    key: 'events',
    get: function get() {
      return {
        'webkitfullscreenchange': 'handleFullscreenChange',
        'mousemove': 'onMouseMove',
        'mouseleave': 'onMouseLeave'
      };
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'data-player': '',
        tabindex: 9999
      };
    }

    /**
     * checks if the core is ready.
     * @property isReady
     * @type {Boolean} `true` if the core is ready, otherwise `false`
     */

  }, {
    key: 'isReady',
    get: function get() {
      return !!this.ready;
    }

    /**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */

  }, {
    key: 'i18n',
    get: function get() {
      return this.getPlugin('strings') || { t: function t(key) {
          return key;
        } };
    }

    /**
     * @deprecated
     * This property currently exists for retrocompatibility reasons.
     * If you want to access the media control instance, use the method getPlugin('media_control').
     */

  }, {
    key: 'mediaControl',
    get: function get() {
      return this.getPlugin('media_control') || this.dummyMediaControl;
    }
  }, {
    key: 'dummyMediaControl',
    get: function get() {
      if (this._dummyMediaControl) return this._dummyMediaControl;
      this._dummyMediaControl = new _ui_core_plugin2.default(this);
      return this._dummyMediaControl;
    }

    /**
     * gets the active container reference.
     * @property activeContainer
     * @type {Object}
     */

  }, {
    key: 'activeContainer',
    get: function get() {
      return this._activeContainer;
    }

    /**
     * sets the active container reference and trigger a event with the new reference.
     * @property activeContainer
     * @type {Object}
     */
    ,
    set: function set(container) {
      this._activeContainer = container;
      this.trigger(_events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this._activeContainer);
    }

    /**
     * gets the active playback reference.
     * @property activePlayback
     * @type {Object}
     */

  }, {
    key: 'activePlayback',
    get: function get() {
      return this.activeContainer && this.activeContainer.playback;
    }
  }]);

  function Core(options) {
    (0, _classCallCheck3.default)(this, Core);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIObject.call(this, options));

    _this.playerError = new _error2.default(options, _this);
    _this.configureDomRecycler();
    _this.playerInfo = _player_info2.default.getInstance(options.playerId);
    _this.firstResize = true;
    _this.plugins = [];
    _this.containers = [];
    //FIXME fullscreen api sucks
    _this._boundFullscreenHandler = function () {
      return _this.handleFullscreenChange();
    };
    (0, _clapprZepto2.default)(document).bind('fullscreenchange', _this._boundFullscreenHandler);
    (0, _clapprZepto2.default)(document).bind('MSFullscreenChange', _this._boundFullscreenHandler);
    (0, _clapprZepto2.default)(document).bind('mozfullscreenchange', _this._boundFullscreenHandler);
    _browser2.default.isMobile && (0, _clapprZepto2.default)(window).bind('resize', function (o) {
      _this.handleWindowResize(o);
    });
    return _this;
  }

  Core.prototype.configureDomRecycler = function configureDomRecycler() {
    var recycleVideo = this.options && this.options.playback && this.options.playback.recycleVideo;
    _utils.DomRecycler.configure({ recycleVideo: recycleVideo });
  };

  Core.prototype.createContainers = function createContainers(options) {
    this.defer = _clapprZepto2.default.Deferred();
    this.defer.promise(this);
    this.containerFactory = new _container_factory2.default(options, options.loader, this.i18n, this.playerError);
    this.prepareContainers();
  };

  Core.prototype.prepareContainers = function prepareContainers() {
    var _this2 = this;

    this.containerFactory.createContainers().then(function (containers) {
      return _this2.setupContainers(containers);
    }).then(function (containers) {
      return _this2.resolveOnContainersReady(containers);
    });
  };

  Core.prototype.updateSize = function updateSize() {
    this.isFullscreen() ? this.setFullscreen() : this.setPlayerSize();
  };

  Core.prototype.setFullscreen = function setFullscreen() {
    if (!_browser2.default.isiOS) {
      this.$el.addClass('fullscreen');
      this.$el.removeAttr('style');
      this.playerInfo.previousSize = { width: this.options.width, height: this.options.height };
      this.playerInfo.currentSize = { width: (0, _clapprZepto2.default)(window).width(), height: (0, _clapprZepto2.default)(window).height() };
    }
  };

  Core.prototype.setPlayerSize = function setPlayerSize() {
    this.$el.removeClass('fullscreen');
    this.playerInfo.currentSize = this.playerInfo.previousSize;
    this.playerInfo.previousSize = { width: (0, _clapprZepto2.default)(window).width(), height: (0, _clapprZepto2.default)(window).height() };
    this.resize(this.playerInfo.currentSize);
  };

  Core.prototype.resize = function resize(options) {
    if (!(0, _utils.isNumber)(options.height) && !(0, _utils.isNumber)(options.width)) {
      this.el.style.height = '' + options.height;
      this.el.style.width = '' + options.width;
    } else {
      this.el.style.height = options.height + 'px';
      this.el.style.width = options.width + 'px';
    }
    this.playerInfo.previousSize = { width: this.options.width, height: this.options.height };
    this.options.width = options.width;
    this.options.height = options.height;
    this.playerInfo.currentSize = options;
    this.triggerResize(this.playerInfo.currentSize);
  };

  Core.prototype.enableResizeObserver = function enableResizeObserver() {
    var _this3 = this;

    var checkSizeCallback = function checkSizeCallback() {
      _this3.triggerResize({ width: _this3.el.clientWidth, height: _this3.el.clientHeight });
    };
    this.resizeObserverInterval = setInterval(checkSizeCallback, 500);
  };

  Core.prototype.triggerResize = function triggerResize(newSize) {
    var thereWasChange = this.firstResize || this.oldHeight !== newSize.height || this.oldWidth !== newSize.width;
    if (thereWasChange) {
      this.oldHeight = newSize.height;
      this.oldWidth = newSize.width;
      this.playerInfo.computedSize = newSize;
      this.firstResize = false;
      _mediator2.default.trigger(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, newSize);
      this.trigger(_events2.default.CORE_RESIZE, newSize);
    }
  };

  Core.prototype.disableResizeObserver = function disableResizeObserver() {
    this.resizeObserverInterval && clearInterval(this.resizeObserverInterval);
  };

  Core.prototype.resolveOnContainersReady = function resolveOnContainersReady(containers) {
    var _this4 = this;

    _clapprZepto2.default.when.apply(_clapprZepto2.default, containers).done(function () {
      _this4.defer.resolve(_this4);
      _this4.ready = true;
      _this4.trigger(_events2.default.CORE_READY);
    });
  };

  Core.prototype.addPlugin = function addPlugin(plugin) {
    this.plugins.push(plugin);
  };

  Core.prototype.hasPlugin = function hasPlugin(name) {
    return !!this.getPlugin(name);
  };

  Core.prototype.getPlugin = function getPlugin(name) {
    return this.plugins.filter(function (plugin) {
      return plugin.name === name;
    })[0];
  };

  Core.prototype.load = function load(sources, mimeType) {
    this.options.mimeType = mimeType;
    sources = sources && sources.constructor === Array ? sources : [sources];
    this.options.sources = sources;
    this.containers.forEach(function (container) {
      return container.destroy();
    });
    this.containerFactory.options = _clapprZepto2.default.extend(this.options, { sources: sources });
    this.prepareContainers();
  };

  Core.prototype.destroy = function destroy() {
    this.disableResizeObserver();
    this.containers.forEach(function (container) {
      return container.destroy();
    });
    this.plugins.forEach(function (plugin) {
      return plugin.destroy();
    });
    this.$el.remove();
    (0, _clapprZepto2.default)(document).unbind('fullscreenchange', this._boundFullscreenHandler);
    (0, _clapprZepto2.default)(document).unbind('MSFullscreenChange', this._boundFullscreenHandler);
    (0, _clapprZepto2.default)(document).unbind('mozfullscreenchange', this._boundFullscreenHandler);
    this.stopListening();
  };

  Core.prototype.handleFullscreenChange = function handleFullscreenChange() {
    this.trigger(_events2.default.CORE_FULLSCREEN, this.isFullscreen());
    this.updateSize();
  };

  Core.prototype.handleWindowResize = function handleWindowResize(event) {
    var orientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    if (this._screenOrientation === orientation) return;
    this._screenOrientation = orientation;
    this.triggerResize({ width: this.el.clientWidth, height: this.el.clientHeight });
    this.trigger(_events2.default.CORE_SCREEN_ORIENTATION_CHANGED, {
      event: event,
      orientation: this._screenOrientation
    });
  };

  Core.prototype.removeContainer = function removeContainer(container) {
    this.stopListening(container);
    this.containers = this.containers.filter(function (c) {
      return c !== container;
    });
  };

  Core.prototype.setupContainer = function setupContainer(container) {
    this.listenTo(container, _events2.default.CONTAINER_DESTROYED, this.removeContainer);
    this.containers.push(container);
  };

  Core.prototype.setupContainers = function setupContainers(containers) {
    containers.forEach(this.setupContainer.bind(this));
    this.trigger(_events2.default.CORE_CONTAINERS_CREATED);
    this.renderContainers();
    this.activeContainer = containers[0];
    this.render();
    this.appendToParent();
    return this.containers;
  };

  Core.prototype.renderContainers = function renderContainers() {
    var _this5 = this;

    this.containers.forEach(function (container) {
      return _this5.el.appendChild(container.render().el);
    });
  };

  Core.prototype.createContainer = function createContainer(source, options) {
    var container = this.containerFactory.createContainer(source, options);
    this.setupContainer(container);
    this.el.appendChild(container.render().el);
    return container;
  };

  /**
   * @deprecated
   * This method currently exists for retrocompatibility reasons.
   * If you want the current container reference, use the activeContainer getter.
   */


  Core.prototype.getCurrentContainer = function getCurrentContainer() {
    return this.activeContainer;
  };

  /**
   * @deprecated
   * This method currently exists for retrocompatibility reasons.
   * If you want the current playback reference, use the activePlayback getter.
   */


  Core.prototype.getCurrentPlayback = function getCurrentPlayback() {
    return this.activePlayback;
  };

  Core.prototype.getPlaybackType = function getPlaybackType() {
    return this.activeContainer && this.activeContainer.getPlaybackType();
  };

  Core.prototype.isFullscreen = function isFullscreen() {
    // Ensure current instance is in fullscreen mode by checking fullscreen element
    var el = _browser2.default.isiOS ? this.activeContainer && this.activeContainer.el || this.el : this.el;
    return _utils.Fullscreen.fullscreenElement() === el;
  };

  Core.prototype.toggleFullscreen = function toggleFullscreen() {
    if (this.isFullscreen()) {
      _utils.Fullscreen.cancelFullscreen();
      !_browser2.default.isiOS && this.$el.removeClass('fullscreen nocursor');
    } else {
      _utils.Fullscreen.requestFullscreen(_browser2.default.isiOS ? this.activeContainer.el : this.el);
      !_browser2.default.isiOS && this.$el.addClass('fullscreen');
    }
  };

  Core.prototype.onMouseMove = function onMouseMove(event) {
    this.trigger(_events2.default.CORE_MOUSE_MOVE, event);
  };

  Core.prototype.onMouseLeave = function onMouseLeave(event) {
    this.trigger(_events2.default.CORE_MOUSE_LEAVE, event);
  };

  /**
   * enables to configure the container after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */


  Core.prototype.configure = function configure(options) {
    var _this6 = this;

    this._options = _clapprZepto2.default.extend(this._options, options);
    this.configureDomRecycler();

    var sources = options.source || options.sources;
    sources && this.load(sources, options.mimeType || this.options.mimeType);

    this.trigger(_events2.default.CORE_OPTIONS_CHANGE, options); // Trigger with newly provided options
    this.containers.forEach(function (container) {
      return container.configure(_this6.options);
    });
  };

  Core.prototype.appendToParent = function appendToParent() {
    var hasCoreParent = this.$el.parent() && this.$el.parent().length;
    !hasCoreParent && this.$el.appendTo(this.options.parentElement);
  };

  Core.prototype.render = function render() {
    if (!style) style = _styler2.default.getStyleFor(_fonts2.default, { baseUrl: this.options.baseUrl });

    (0, _clapprZepto2.default)('head').append(style);

    this.options.width = this.options.width || this.$el.width();
    this.options.height = this.options.height || this.$el.height();
    var size = { width: this.options.width, height: this.options.height };
    this.playerInfo.previousSize = this.playerInfo.currentSize = this.playerInfo.computedSize = size;
    this.updateSize();

    this.previousSize = { width: this.$el.width(), height: this.$el.height() };

    this.enableResizeObserver();

    return this;
  };

  return Core;
}(_ui_object2.default);

exports.default = Core;


(0, _assign2.default)(Core.prototype, _error_mixin2.default);
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/core/index.js":
/*!**************************************!*\
  !*** ./src/components/core/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = __webpack_require__(/*! ./core */ "./src/components/core/core.js");

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _core2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/core/public/Roboto.ttf":
/*!***********************************************!*\
  !*** ./src/components/core/public/Roboto.ttf ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<%=baseUrl%>/38861cba61c66739c1452c3a71e39852.ttf";

/***/ }),

/***/ "./src/components/core/public/fonts.css":
/*!**********************************************!*\
  !*** ./src/components/core/public/fonts.css ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "@font-face {\n  font-family: \"Roboto\";\n  font-style: normal;\n  font-weight: 400;\n  src: local(\"Roboto\"), local(\"Roboto-Regular\"), url(" + escape(__webpack_require__(/*! ./Roboto.ttf */ "./src/components/core/public/Roboto.ttf")) + ") format(\"truetype\");\n}\n", ""]);

// exports


/***/ }),

/***/ "./src/components/core/public/style.scss":
/*!***********************************************!*\
  !*** ./src/components/core/public/style.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./style.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/components/core/public/style.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/components/core_factory/core_factory.js":
/*!*****************************************************!*\
  !*** ./src/components/core_factory/core_factory.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _base_object = __webpack_require__(/*! ../../base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _core = __webpack_require__(/*! ../core */ "./src/components/core/index.js");

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The Core Factory is responsible for instantiate the core and it's plugins.
 * @class CoreFactory
 * @constructor
 * @extends BaseObject
 * @module components
 */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var CoreFactory = function (_BaseObject) {
  (0, _inherits3.default)(CoreFactory, _BaseObject);
  (0, _createClass3.default)(CoreFactory, [{
    key: 'loader',
    get: function get() {
      return this.player.loader;
    }

    /**
     * it builds the core factory
     * @method constructor
     * @param {Player} player the player object
     */

  }]);

  function CoreFactory(player) {
    (0, _classCallCheck3.default)(this, CoreFactory);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this));

    _this.player = player;
    _this._options = player.options;
    return _this;
  }

  /**
   * creates a core and its plugins
   * @method create
   * @return {Core} created core
   */


  CoreFactory.prototype.create = function create() {
    this.options.loader = this.loader;
    this.core = new _core2.default(this.options);
    this.addCorePlugins();
    this.core.createContainers(this.options);
    return this.core;
  };

  /**
   * given the core plugins (`loader.corePlugins`) it builds each one
   * @method addCorePlugins
   * @return {Core} the core with all plugins
   */


  CoreFactory.prototype.addCorePlugins = function addCorePlugins() {
    var _this2 = this;

    this.loader.corePlugins.forEach(function (Plugin) {
      var plugin = new Plugin(_this2.core);
      _this2.core.addPlugin(plugin);
      _this2.setupExternalInterface(plugin);
    });
    return this.core;
  };

  CoreFactory.prototype.setupExternalInterface = function setupExternalInterface(plugin) {
    var externalFunctions = plugin.getExternalInterface();
    for (var key in externalFunctions) {
      this.player[key] = externalFunctions[key].bind(plugin);
      this.core[key] = externalFunctions[key].bind(plugin);
    }
  };

  return CoreFactory;
}(_base_object2.default);

exports.default = CoreFactory;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/core_factory/index.js":
/*!**********************************************!*\
  !*** ./src/components/core_factory/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core_factory = __webpack_require__(/*! ./core_factory */ "./src/components/core_factory/core_factory.js");

var _core_factory2 = _interopRequireDefault(_core_factory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _core_factory2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/error/error.js":
/*!***************************************!*\
  !*** ./src/components/error/error.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _base_object = __webpack_require__(/*! ../../base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _log = __webpack_require__(/*! ../../plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The PlayerError is responsible to receive and propagate errors.
 * @class PlayerError
 * @constructor
 * @extends BaseObject
 * @module components
 */
var PlayerError = function (_BaseObject) {
  (0, _inherits3.default)(PlayerError, _BaseObject);
  (0, _createClass3.default)(PlayerError, [{
    key: 'name',
    get: function get() {
      return 'error';
    }

    /**
     * @property Levels
     * @type {Object} object with error levels
     */

  }], [{
    key: 'Levels',
    get: function get() {
      return {
        FATAL: 'FATAL',
        WARN: 'WARN',
        INFO: 'INFO'
      };
    }
  }]);

  function PlayerError() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var core = arguments[1];
    (0, _classCallCheck3.default)(this, PlayerError);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, options));

    _this.core = core;
    return _this;
  }

  /**
   * creates and trigger an error.
   * @method createError
   * @param {Object} err should be an object with code, description, level, origin, scope and raw error.
   */


  PlayerError.prototype.createError = function createError(err) {
    if (!this.core) {
      _log2.default.warn(this.name, 'Core is not set. Error: ', err);
      return;
    }
    this.core.trigger(_events2.default.ERROR, err);
  };

  return PlayerError;
}(_base_object2.default);

exports.default = PlayerError;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/error/index.js":
/*!***************************************!*\
  !*** ./src/components/error/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _error = __webpack_require__(/*! ./error */ "./src/components/error/error.js");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _error2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/loader/index.js":
/*!****************************************!*\
  !*** ./src/components/loader/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _loader = __webpack_require__(/*! ./loader */ "./src/components/loader/loader.js");

var _loader2 = _interopRequireDefault(_loader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _loader2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/loader/loader.js":
/*!*****************************************!*\
  !*** ./src/components/loader/loader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _base_object = __webpack_require__(/*! ../../base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _player_info = __webpack_require__(/*! ../player_info */ "./src/components/player_info.js");

var _player_info2 = _interopRequireDefault(_player_info);

var _html5_video = __webpack_require__(/*! ../../playbacks/html5_video */ "./src/playbacks/html5_video/index.js");

var _html5_video2 = _interopRequireDefault(_html5_video);

var _html5_audio = __webpack_require__(/*! ../../playbacks/html5_audio */ "./src/playbacks/html5_audio/index.js");

var _html5_audio2 = _interopRequireDefault(_html5_audio);

var _hls = __webpack_require__(/*! ../../playbacks/hls */ "./src/playbacks/hls/index.js");

var _hls2 = _interopRequireDefault(_hls);

var _html_img = __webpack_require__(/*! ../../playbacks/html_img */ "./src/playbacks/html_img/index.js");

var _html_img2 = _interopRequireDefault(_html_img);

var _no_op = __webpack_require__(/*! ../../playbacks/no_op */ "./src/playbacks/no_op/index.js");

var _no_op2 = _interopRequireDefault(_no_op);

var _spinner_three_bounce = __webpack_require__(/*! ../../plugins/spinner_three_bounce */ "./src/plugins/spinner_three_bounce/index.js");

var _spinner_three_bounce2 = _interopRequireDefault(_spinner_three_bounce);

var _stats = __webpack_require__(/*! ../../plugins/stats */ "./src/plugins/stats/index.js");

var _stats2 = _interopRequireDefault(_stats);

var _watermark = __webpack_require__(/*! ../../plugins/watermark */ "./src/plugins/watermark/index.js");

var _watermark2 = _interopRequireDefault(_watermark);

var _poster = __webpack_require__(/*! ../../plugins/poster */ "./src/plugins/poster/index.js");

var _poster2 = _interopRequireDefault(_poster);

var _google_analytics = __webpack_require__(/*! ../../plugins/google_analytics */ "./src/plugins/google_analytics/index.js");

var _google_analytics2 = _interopRequireDefault(_google_analytics);

var _click_to_pause = __webpack_require__(/*! ../../plugins/click_to_pause */ "./src/plugins/click_to_pause/index.js");

var _click_to_pause2 = _interopRequireDefault(_click_to_pause);

var _media_control = __webpack_require__(/*! ../../plugins/media_control */ "./src/plugins/media_control/index.js");

var _media_control2 = _interopRequireDefault(_media_control);

var _dvr_controls = __webpack_require__(/*! ../../plugins/dvr_controls */ "./src/plugins/dvr_controls/index.js");

var _dvr_controls2 = _interopRequireDefault(_dvr_controls);

var _closed_captions = __webpack_require__(/*! ../../plugins/closed_captions */ "./src/plugins/closed_captions/index.js");

var _closed_captions2 = _interopRequireDefault(_closed_captions);

var _favicon = __webpack_require__(/*! ../../plugins/favicon */ "./src/plugins/favicon/index.js");

var _favicon2 = _interopRequireDefault(_favicon);

var _seek_time = __webpack_require__(/*! ../../plugins/seek_time */ "./src/plugins/seek_time/index.js");

var _seek_time2 = _interopRequireDefault(_seek_time);

var _sources = __webpack_require__(/*! ../../plugins/sources */ "./src/plugins/sources.js");

var _sources2 = _interopRequireDefault(_sources);

var _end_video = __webpack_require__(/*! ../../plugins/end_video */ "./src/plugins/end_video.js");

var _end_video2 = _interopRequireDefault(_end_video);

var _strings = __webpack_require__(/*! ../../plugins/strings */ "./src/plugins/strings.js");

var _strings2 = _interopRequireDefault(_strings);

var _error_screen = __webpack_require__(/*! ../../plugins/error_screen */ "./src/plugins/error_screen/index.js");

var _error_screen2 = _interopRequireDefault(_error_screen);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * It keeps a list of the default plugins (playback, container, core) and it merges external plugins with its internals.
 * @class Loader
 * @constructor
 * @extends BaseObject
 * @module components
 */


/* Playback Plugins */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var Loader = function (_BaseObject) {
  (0, _inherits3.default)(Loader, _BaseObject);

  /**
   * builds the loader
   * @method constructor
   * @param {Object} externalPlugins the external plugins
   * @param {Number} playerId you can embed multiple instances of clappr, therefore this is the unique id of each one.
   */
  function Loader() {
    var externalPlugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var playerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var useOnlyPlainHtml5Plugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    (0, _classCallCheck3.default)(this, Loader);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this));

    _this.playerId = playerId;
    _this.playbackPlugins = [];

    if (!useOnlyPlainHtml5Plugins) {
      _this.playbackPlugins = [].concat((0, _toConsumableArray3.default)(_this.playbackPlugins), [_hls2.default]);
    }

    _this.playbackPlugins = [].concat((0, _toConsumableArray3.default)(_this.playbackPlugins), [_html5_video2.default, _html5_audio2.default]);

    _this.playbackPlugins = [].concat((0, _toConsumableArray3.default)(_this.playbackPlugins), [_html_img2.default, _no_op2.default]);

    _this.containerPlugins = [_spinner_three_bounce2.default, _watermark2.default, _poster2.default, _stats2.default, _google_analytics2.default, _click_to_pause2.default];
    _this.corePlugins = [_media_control2.default, _dvr_controls2.default, _closed_captions2.default, _favicon2.default, _seek_time2.default, _sources2.default, _end_video2.default, _error_screen2.default, _strings2.default];

    if (!Array.isArray(externalPlugins)) _this.validateExternalPluginsType(externalPlugins);

    _this.addExternalPlugins(externalPlugins);
    return _this;
  }

  /**
   * groups by type the external plugins that were passed through `options.plugins` it they're on a flat array
   * @method addExternalPlugins
   * @private
   * @param {Object} an config object or an array of plugins
   * @return {Object} plugins the config object with the plugins separated by type
   */


  Loader.prototype.groupPluginsByType = function groupPluginsByType(plugins) {
    if (Array.isArray(plugins)) {
      plugins = plugins.reduce(function (memo, plugin) {
        memo[plugin.type] || (memo[plugin.type] = []);
        memo[plugin.type].push(plugin);
        return memo;
      }, {});
    }
    return plugins;
  };

  Loader.prototype.removeDups = function removeDups(list) {
    var groupUp = function groupUp(plugins, plugin) {
      plugins[plugin.prototype.name] && delete plugins[plugin.prototype.name];
      plugins[plugin.prototype.name] = plugin;
      return plugins;
    };
    var pluginsMap = list.reduceRight(groupUp, (0, _create2.default)(null));

    var plugins = [];
    for (var key in pluginsMap) {
      plugins.unshift(pluginsMap[key]);
    }return plugins;
  };

  /**
   * adds all the external plugins that were passed through `options.plugins`
   * @method addExternalPlugins
   * @private
   * @param {Object} plugins the config object with all plugins
   */


  Loader.prototype.addExternalPlugins = function addExternalPlugins(plugins) {
    plugins = this.groupPluginsByType(plugins);
    if (plugins.playback) this.playbackPlugins = this.removeDups(plugins.playback.concat(this.playbackPlugins));

    if (plugins.container) this.containerPlugins = this.removeDups(plugins.container.concat(this.containerPlugins));

    if (plugins.core) this.corePlugins = this.removeDups(plugins.core.concat(this.corePlugins));

    _player_info2.default.getInstance(this.playerId).playbackPlugins = this.playbackPlugins;
  };

  /**
   * validate if the external plugins that were passed through `options.plugins` are associated to the correct type
   * @method validateExternalPluginsType
   * @private
   * @param {Object} plugins the config object with all plugins
   */


  Loader.prototype.validateExternalPluginsType = function validateExternalPluginsType(plugins) {
    var plugintypes = ['playback', 'container', 'core'];
    plugintypes.forEach(function (type) {
      (plugins[type] || []).forEach(function (el) {
        var errorMessage = 'external ' + el.type + ' plugin on ' + type + ' array';
        if (el.type !== type) throw new ReferenceError(errorMessage);
      });
    });
  };

  return Loader;
}(_base_object2.default);

/* Core Plugins */


/* Container Plugins */


exports.default = Loader;
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/mediator.js":
/*!************************************!*\
  !*** ./src/components/mediator.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _events = __webpack_require__(/*! ../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var events = new _events2.default(); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/**
 * The mediator is a singleton for handling global events.
 */

var Mediator = function Mediator() {
  (0, _classCallCheck3.default)(this, Mediator);
};

exports.default = Mediator;


Mediator.on = function (name, callback, context) {
  events.on(name, callback, context);
  return;
};

Mediator.once = function (name, callback, context) {
  events.once(name, callback, context);
  return;
};

Mediator.off = function (name, callback, context) {
  events.off(name, callback, context);
  return;
};

Mediator.trigger = function (name) {
  for (var _len = arguments.length, opts = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    opts[_key - 1] = arguments[_key];
  }

  events.trigger.apply(events, [name].concat(opts));
  return;
};

Mediator.stopListening = function (obj, name, callback) {
  events.stopListening(obj, name, callback);
  return;
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/player.js":
/*!**********************************!*\
  !*** ./src/components/player.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../base/utils */ "./src/base/utils.js");

var _base_object = __webpack_require__(/*! ../base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _events = __webpack_require__(/*! ../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _browser = __webpack_require__(/*! ./browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _core_factory = __webpack_require__(/*! ./core_factory */ "./src/components/core_factory/index.js");

var _core_factory2 = _interopRequireDefault(_core_factory);

var _loader = __webpack_require__(/*! ./loader */ "./src/components/loader/index.js");

var _loader2 = _interopRequireDefault(_loader);

var _player_info = __webpack_require__(/*! ./player_info */ "./src/components/player_info.js");

var _player_info2 = _interopRequireDefault(_player_info);

var _error_mixin = __webpack_require__(/*! ../base/error_mixin */ "./src/base/error_mixin.js");

var _error_mixin2 = _interopRequireDefault(_error_mixin);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseUrl = (0, _utils.currentScriptUrl)().replace(/\/[^/]+$/, '');

/**
 * @class Player
 * @constructor
 * @extends BaseObject
 * @module components
 * @example
 * ### Using the Player
 *
 * Add the following script on your HTML:
 * ```html
 * <head>
 *   <script type="text/javascript" src="http://cdn.clappr.io/latest/clappr.min.js"></script>
 * </head>
 * ```
 * Now, create the player:
 * ```html
 * <body>
 *   <div id="player"></div>
 *   <script>
 *     var player = new Clappr.Player({source: "http://your.video/here.mp4", parentId: "#player"});
 *   </script>
 * </body>
 * ```
 */
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var Player = function (_BaseObject) {
  (0, _inherits3.default)(Player, _BaseObject);
  (0, _createClass3.default)(Player, [{
    key: 'loader',
    set: function set(loader) {
      this._loader = loader;
    },
    get: function get() {
      if (!this._loader) this._loader = new _loader2.default(this.options.plugins || {}, this.options.playerId);

      return this._loader;
    }

    /**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */

  }, {
    key: 'ended',
    get: function get() {
      return this.core.activeContainer.ended;
    }

    /**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */

  }, {
    key: 'buffering',
    get: function get() {
      return this.core.activeContainer.buffering;
    }

    /*
     * determine if the player is ready.
     * @property isReady
     * @type {Boolean} `true` if the player is ready. ie PLAYER_READY event has fired
     */

  }, {
    key: 'isReady',
    get: function get() {
      return !!this._ready;
    }

    /**
     * An events map that allows the user to add custom callbacks in player's options.
     * @property eventsMapping
     * @type {Object}
     */

  }, {
    key: 'eventsMapping',
    get: function get() {
      return {
        onReady: _events2.default.PLAYER_READY,
        onResize: _events2.default.PLAYER_RESIZE,
        onPlay: _events2.default.PLAYER_PLAY,
        onPause: _events2.default.PLAYER_PAUSE,
        onStop: _events2.default.PLAYER_STOP,
        onEnded: _events2.default.PLAYER_ENDED,
        onSeek: _events2.default.PLAYER_SEEK,
        onError: _events2.default.PLAYER_ERROR,
        onTimeUpdate: _events2.default.PLAYER_TIMEUPDATE,
        onVolumeUpdate: _events2.default.PLAYER_VOLUMEUPDATE,
        onSubtitleAvailable: _events2.default.PLAYER_SUBTITLE_AVAILABLE
      };
    }

    /**
     * @typedef {Object} PlaybackConfig
     * @prop {boolean} disableContextMenu
     * disables the context menu (right click) on the video element if a HTML5Video playback is used.
     * @prop {boolean} preload
     * video will be preloaded according to `preload` attribute options **default**: `'metadata'`
     * @prop {boolean} controls
     * enabled/disables displaying controls
     * @prop {boolean} crossOrigin
     * enables cross-origin capability for media-resources
     * @prop {boolean} playInline
     * enables in-line video elements
     * @prop {boolean} audioOnly
     * enforce audio-only playback (when possible)
     * @prop {Object} externalTracks
     * pass externaly loaded track to playback
     * @prop {Number} [maxBufferLength]
     * The default behavior for the **HLS playback** is to keep buffering indefinitely, even on VoD.
     * This replicates the behavior for progressive download, which continues buffering when pausing the video, thus making the video available for playback even on slow networks.
     * To change this behavior use `maxBufferLength` where **value is in seconds**.
     * @prop {Number} [maxBackBufferLength]
     * After how much distance of the playhead data should be pruned from the buffer (influences memory consumption
     * of adaptive media-engines like Hls.js or Shaka)
     * @prop {Number} [minBufferLength]
     * After how much data in the buffer at least we attempt to consume it (influences QoS-related behavior
     * of adaptive media-engines like Hls.js or Shaka). If this is too low, and the available bandwidth is varying a lot
     * and too close to the streamed bitrate, we may continuously hit under-runs.
     * @prop {Number} [initialBandwidthEstimate]
     * define an initial bandwidth "guess" (or previously stored/established value) for underlying adaptive-bitreate engines
     * of adaptive playback implementations, like Hls.js or Shaka
     * @prop {Number} [maxAdaptiveBitrate]
     * Limits the streamed bitrate (for adaptive media-engines in underlying playback implementations)
     * @prop {Object} [maxAdaptiveVideoDimensions]
     * Limits the video dimensions in adaptive media-engines. Should be a literal object with `height` and `width`.
     * @prop {Boolean}[enableAutomaticABR] **default**: `true`
     * Allows to enable/disable automatic bitrate switching in adaptive media-engines
     * @prop {String} [preferredTextLanguage] **default**: `'pt-BR'`
     * Allows to set a preferred text language, that may be enabled by the media-engine if available.
     * @prop {String} [preferredAudioLanguage] **default**: `'pt-BR'`
     * Allows to set a preferred audio language, that may be enabled by the media-engine if available.
     */

    /**
     * ## Player's constructor
     *
     * You might pass the options object to build the player.
     * ```javascript
     * var options = {source: "http://example.com/video.mp4", param1: "val1"};
     * var player = new Clappr.Player(options);
     * ```
     *
     * @method constructor
     * @param {Object} options Data
     * options to build a player instance
     * @param {Number} [options.width]
     * player's width **default**: `640`
     * @param {Number} [options.height]
     * player's height **default**: `360`
     * @param {String} [options.parentId]
     * the id of the element on the page that the player should be inserted into
     * @param {Object} [options.parent]
     * a reference to a dom element that the player should be inserted into
     * @param {String} [options.source]
     * The media source URL, or {source: <<source URL>>, mimeType: <<source mime type>>}
     * @param {Object} [options.sources]
     * An array of media source URL's, or an array of {source: <<source URL>>, mimeType: <<source mime type>>}
     * @param {Boolean} [options.autoPlay]
     * automatically play after page load **default**: `false`
     * @param {Boolean} [options.loop]
     * automatically replay after it ends **default**: `false`
     * @param {Boolean} [options.chromeless]
     * player acts in chromeless mode **default**: `false`
     * @param {Boolean} [options.allowUserInteraction]
     * whether or not the player should handle click events when in chromeless mode **default**: `false` on desktops browsers, `true` on mobile.
     * @param {Boolean} [options.disableKeyboardShortcuts]
     * disable keyboard shortcuts. **default**: `false`. `true` if `allowUserInteraction` is `false`.
     * @param {Boolean} [options.mute]
     * start the video muted **default**: `false`
     * @param {String} [options.mimeType]
     * add `mimeType: "application/vnd.apple.mpegurl"` if you need to use a url without extension.
     * @param {Boolean} [options.actualLiveTime]
     * show duration and seek time relative to actual time.
     * @param {String} [options.actualLiveServerTime]
     * specify server time as a string, format: "2015/11/26 06:01:03". This option is meant to be used with actualLiveTime.
     * @param {Boolean} [options.persistConfig]
     * persist player's settings (volume) through the same domain **default**: `true`
     * @param {String} [options.preload] @deprecated
     * video will be preloaded according to `preload` attribute options **default**: `'metadata'`
     * @param {Number} [options.maxBufferLength] @deprecated
     * the default behavior for the **HLS playback** is to keep buffering indefinitely, even on VoD.
     * This replicates the behavior for progressive download, which continues buffering when pausing the video, thus making the video available for playback even on slow networks.
     * To change this behavior use `maxBufferLength` where **value is in seconds**.
     * @param {String} [options.gaAccount]
     * enable Google Analytics events dispatch **(play/pause/stop/buffering/etc)** by adding your `gaAccount`
     * @param {String} [options.gaTrackerName]
     * besides `gaAccount` you can optionally, pass your favorite trackerName as `gaTrackerName`
     * @param {Object} [options.mediacontrol]
     * customize control bar colors, example: `mediacontrol: {seekbar: "#E113D3", buttons: "#66B2FF"}`
     * @param {Boolean} [options.hideMediaControl]
     * control media control auto hide **default**: `true`
     * @param {Boolean} [options.hideVolumeBar]
     * when embedded with width less than 320, volume bar will hide. You can force this behavior for all sizes by adding `true` **default**: `false`
     * @param {String} [options.watermark]
     * put `watermark: 'http://url/img.png'` on your embed parameters to automatically add watermark on your video.
     * You can customize corner position by defining position parameter. Positions can be `bottom-left`, `bottom-right`, `top-left` and `top-right`.
     * @param {String} [options.watermarkLink]
     * `watermarkLink: 'http://example.net/'` - define URL to open when the watermark is clicked. If not provided watermark will not be clickable.
     * @param {Boolean} [options.disableVideoTagContextMenu] @deprecated
     * disables the context menu (right click) on the video element if a HTML5Video playback is used.
     * @param {Boolean} [options.autoSeekFromUrl]
     * Automatically seek to the seconds provided in the url (e.g example.com?t=100) **default**: `true`
     * @param {Boolean} [options.exitFullscreenOnEnd]
     * Automatically exit full screen when the media finishes. **default**: `true`
     * @param {String} [options.poster]
     * define a poster by adding its address `poster: 'http://url/img.png'`. It will appear after video embed, disappear on play and go back when user stops the video.
     * @param {String} [options.playbackNotSupportedMessage]
     * define a custom message to be displayed when a playback is not supported.
     * @param {Object} [options.events]
     * Specify listeners which will be registered with their corresponding player events.
     * E.g. onReady -> "PLAYER_READY", onTimeUpdate -> "PLAYER_TIMEUPDATE"
     * @param {PlaybackConfig} [options.playback]
     * Generic `Playback` component related configuration
     * @param {Boolean} [options.disableErrorScreen]
     * disables the error screen plugin.
     * @param {Number} [options.autoPlayTimeout]
     * autoplay check timeout.
     */

  }]);

  function Player(options) {
    (0, _classCallCheck3.default)(this, Player);

    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseObject.call(this, options));

    var playbackDefaultOptions = { recycleVideo: true };
    var defaultOptions = {
      playerId: (0, _utils.uniqueId)(''),
      persistConfig: true,
      width: 640,
      height: 360,
      baseUrl: baseUrl,
      allowUserInteraction: _browser2.default.isMobile,
      playback: playbackDefaultOptions
    };
    _this._options = _clapprZepto2.default.extend(defaultOptions, options);
    _this.options.sources = _this._normalizeSources(options);
    if (!_this.options.chromeless) {
      // "allowUserInteraction" cannot be false if not in chromeless mode.
      _this.options.allowUserInteraction = true;
    }
    if (!_this.options.allowUserInteraction) {
      // if user iteraction is not allowed ensure keyboard shortcuts are disabled
      _this.options.disableKeyboardShortcuts = true;
    }
    _this._registerOptionEventListeners(_this.options.events);
    _this._coreFactory = new _core_factory2.default(_this);
    _this.playerInfo = _player_info2.default.getInstance(_this.options.playerId);
    _this.playerInfo.currentSize = { width: options.width, height: options.height };
    _this.playerInfo.options = _this.options;
    if (_this.options.parentId) _this.setParentId(_this.options.parentId);else if (_this.options.parent) _this.attachTo(_this.options.parent);

    return _this;
  }

  /**
   * Specify a `parentId` to the player.
   * @method setParentId
   * @param {String} parentId the element parent id.
   * @return {Player} itself
   */


  Player.prototype.setParentId = function setParentId(parentId) {
    var el = document.querySelector(parentId);
    if (el) this.attachTo(el);

    return this;
  };

  /**
   * You can use this method to attach the player to a given element. You don't need to do this when you specify it during the player instantiation passing the `parentId` param.
   * @method attachTo
   * @param {Object} element a given element.
   * @return {Player} itself
   */


  Player.prototype.attachTo = function attachTo(element) {
    this.options.parentElement = element;
    this.core = this._coreFactory.create();
    this._addEventListeners();
    return this;
  };

  Player.prototype._addEventListeners = function _addEventListeners() {
    if (!this.core.isReady) this.listenToOnce(this.core, _events2.default.CORE_READY, this._onReady);else this._onReady();

    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this._containerChanged);
    this.listenTo(this.core, _events2.default.CORE_FULLSCREEN, this._onFullscreenChange);
    this.listenTo(this.core, _events2.default.CORE_RESIZE, this._onResize);
    return this;
  };

  Player.prototype._addContainerEventListeners = function _addContainerEventListeners() {
    var container = this.core.activeContainer;
    if (container) {
      this.listenTo(container, _events2.default.CONTAINER_PLAY, this._onPlay);
      this.listenTo(container, _events2.default.CONTAINER_PAUSE, this._onPause);
      this.listenTo(container, _events2.default.CONTAINER_STOP, this._onStop);
      this.listenTo(container, _events2.default.CONTAINER_ENDED, this._onEnded);
      this.listenTo(container, _events2.default.CONTAINER_SEEK, this._onSeek);
      this.listenTo(container, _events2.default.CONTAINER_ERROR, this._onError);
      this.listenTo(container, _events2.default.CONTAINER_TIMEUPDATE, this._onTimeUpdate);
      this.listenTo(container, _events2.default.CONTAINER_VOLUME, this._onVolumeUpdate);
      this.listenTo(container, _events2.default.CONTAINER_SUBTITLE_AVAILABLE, this._onSubtitleAvailable);
    }
    return this;
  };

  Player.prototype._registerOptionEventListeners = function _registerOptionEventListeners() {
    var _this2 = this;

    var newEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var hasNewEvents = (0, _keys2.default)(newEvents).length > 0;
    hasNewEvents && (0, _keys2.default)(events).forEach(function (userEvent) {
      var eventType = _this2.eventsMapping[userEvent];
      eventType && _this2.off(eventType, events[userEvent]);
    });

    (0, _keys2.default)(newEvents).forEach(function (userEvent) {
      var eventType = _this2.eventsMapping[userEvent];
      if (eventType) {
        var eventFunction = newEvents[userEvent];
        eventFunction = typeof eventFunction === 'function' && eventFunction;
        eventFunction && _this2.on(eventType, eventFunction);
      }
    });
    return this;
  };

  Player.prototype._containerChanged = function _containerChanged() {
    this.stopListening();
    this._addEventListeners();
  };

  Player.prototype._onReady = function _onReady() {
    this._ready = true;
    this._addContainerEventListeners();
    this.trigger(_events2.default.PLAYER_READY);
  };

  Player.prototype._onFullscreenChange = function _onFullscreenChange(fullscreen) {
    this.trigger(_events2.default.PLAYER_FULLSCREEN, fullscreen);
  };

  Player.prototype._onVolumeUpdate = function _onVolumeUpdate(volume) {
    this.trigger(_events2.default.PLAYER_VOLUMEUPDATE, volume);
  };

  Player.prototype._onSubtitleAvailable = function _onSubtitleAvailable() {
    this.trigger(_events2.default.PLAYER_SUBTITLE_AVAILABLE);
  };

  Player.prototype._onResize = function _onResize(size) {
    this.trigger(_events2.default.PLAYER_RESIZE, size);
  };

  Player.prototype._onPlay = function _onPlay() {
    this.trigger(_events2.default.PLAYER_PLAY);
  };

  Player.prototype._onPause = function _onPause() {
    this.trigger(_events2.default.PLAYER_PAUSE);
  };

  Player.prototype._onStop = function _onStop() {
    this.trigger(_events2.default.PLAYER_STOP, this.getCurrentTime());
  };

  Player.prototype._onEnded = function _onEnded() {
    this.trigger(_events2.default.PLAYER_ENDED);
  };

  Player.prototype._onSeek = function _onSeek(time) {
    this.trigger(_events2.default.PLAYER_SEEK, time);
  };

  Player.prototype._onTimeUpdate = function _onTimeUpdate(timeProgress) {
    this.trigger(_events2.default.PLAYER_TIMEUPDATE, timeProgress);
  };

  Player.prototype._onError = function _onError(error) {
    this.trigger(_events2.default.PLAYER_ERROR, error);
  };

  Player.prototype._normalizeSources = function _normalizeSources(options) {
    var sources = options.sources || (options.source !== undefined ? [options.source] : []);
    return sources.length === 0 ? [{ source: '', mimeType: '' }] : sources;
  };

  /**
   * resizes the current player canvas.
   * @method resize
   * @param {Object} size should be a literal object with `height` and `width`.
   * @return {Player} itself
   * @example
   * ```javascript
   * player.resize({height: 360, width: 640})
   * ```
   */


  Player.prototype.resize = function resize(size) {
    this.core.resize(size);
    return this;
  };

  /**
   * loads a new source.
   * @method load
   * @param {Array|String} sources source or sources of video.
   * An array item can be a string or {source: <<source URL>>, mimeType: <<source mime type>>}
   * @param {String} mimeType a mime type, example: `'application/vnd.apple.mpegurl'`
   * @param {Boolean} [autoPlay=false] whether playing should be started immediately
   * @return {Player} itself
   */


  Player.prototype.load = function load(sources, mimeType, autoPlay) {
    if (autoPlay !== undefined) this.configure({ autoPlay: !!autoPlay });

    this.core.load(sources, mimeType);
    return this;
  };

  /**
   * destroys the current player and removes it from the DOM.
   * @method destroy
   * @return {Player} itself
   */


  Player.prototype.destroy = function destroy() {
    this.stopListening();
    this.core.destroy();
    return this;
  };

  /**
   * Gives user consent to playback. Required by mobile device after a click event before Player.load().
   * @method consent
   * @return {Player} itself
   */


  Player.prototype.consent = function consent() {
    this.core.getCurrentPlayback().consent();
    return this;
  };

  /**
   * plays the current video (`source`).
   * @method play
   * @return {Player} itself
   */


  Player.prototype.play = function play() {
    this.core.activeContainer.play();
    return this;
  };

  /**
   * pauses the current video (`source`).
   * @method pause
   * @return {Player} itself
   */


  Player.prototype.pause = function pause() {
    this.core.activeContainer.pause();
    return this;
  };

  /**
   * stops the current video (`source`).
   * @method stop
   * @return {Player} itself
   */


  Player.prototype.stop = function stop() {
    this.core.activeContainer.stop();
    return this;
  };

  /**
   * seeks the current video (`source`). For example, `player.seek(120)` will seek to second 120 (2minutes) of the current video.
   * @method seek
   * @param {Number} time should be a number between 0 and the video duration.
   * @return {Player} itself
   */


  Player.prototype.seek = function seek(time) {
    this.core.activeContainer.seek(time);
    return this;
  };

  /**
   * seeks the current video (`source`). For example, `player.seek(50)` will seek to the middle of the current video.
   * @method seekPercentage
   * @param {Number} time should be a number between 0 and 100.
   * @return {Player} itself
   */


  Player.prototype.seekPercentage = function seekPercentage(percentage) {
    this.core.activeContainer.seekPercentage(percentage);
    return this;
  };

  /**
   * mutes the current video (`source`).
   * @method mute
   * @return {Player} itself
   */


  Player.prototype.mute = function mute() {
    this._mutedVolume = this.getVolume();
    this.setVolume(0);
    return this;
  };

  /**
   * unmutes the current video (`source`).
   * @method unmute
   * @return {Player} itself
   */


  Player.prototype.unmute = function unmute() {
    this.setVolume(typeof this._mutedVolume === 'number' ? this._mutedVolume : 100);
    this._mutedVolume = null;
    return this;
  };

  /**
   * checks if the player is playing.
   * @method isPlaying
   * @return {Boolean} `true` if the current source is playing, otherwise `false`
   */


  Player.prototype.isPlaying = function isPlaying() {
    return this.core.activeContainer.isPlaying();
  };

  /**
   * returns `true` if DVR is enable otherwise `false`.
   * @method isDvrEnabled
   * @return {Boolean}
   */


  Player.prototype.isDvrEnabled = function isDvrEnabled() {
    return this.core.activeContainer.isDvrEnabled();
  };

  /**
   * returns `true` if DVR is in use otherwise `false`.
   * @method isDvrInUse
   * @return {Boolean}
   */


  Player.prototype.isDvrInUse = function isDvrInUse() {
    return this.core.activeContainer.isDvrInUse();
  };

  /**
   * enables to configure a player after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   * @return {Player} itself
   */


  Player.prototype.configure = function configure() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._registerOptionEventListeners(options.events, this.options.events);
    this.core.configure(options);
    return this;
  };

  /**
   * get a plugin by its name.
   * @method getPlugin
   * @param {String} name of the plugin.
   * @return {Object} the plugin instance
   * @example
   * ```javascript
   * var poster = player.getPlugin('poster');
   * poster.hidePlayButton();
   * ```
   */


  Player.prototype.getPlugin = function getPlugin(name) {
    var plugins = this.core.plugins.concat(this.core.activeContainer.plugins);
    return plugins.filter(function (plugin) {
      return plugin.name === name;
    })[0];
  };

  /**
   * the current time in seconds.
   * @method getCurrentTime
   * @return {Number} current time (in seconds) of the current source
   */


  Player.prototype.getCurrentTime = function getCurrentTime() {
    return this.core.activeContainer.getCurrentTime();
  };

  /**
   * The time that "0" now represents relative to when playback started.
   * For a stream with a sliding window this will increase as content is
   * removed from the beginning.
   * @method getStartTimeOffset
   * @return {Number} time (in seconds) that time "0" represents.
   */


  Player.prototype.getStartTimeOffset = function getStartTimeOffset() {
    return this.core.activeContainer.getStartTimeOffset();
  };

  /**
   * the duration time in seconds.
   * @method getDuration
   * @return {Number} duration time (in seconds) of the current source
   */


  Player.prototype.getDuration = function getDuration() {
    return this.core.activeContainer.getDuration();
  };

  return Player;
}(_base_object2.default);

exports.default = Player;


(0, _assign2.default)(Player.prototype, _error_mixin2.default);
module.exports = exports['default'];

/***/ }),

/***/ "./src/components/player_info.js":
/*!***************************************!*\
  !*** ./src/components/player_info.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var PlayerInfo = function PlayerInfo() {
  (0, _classCallCheck3.default)(this, PlayerInfo);

  this.options = {};
  this.playbackPlugins = [];
  this.currentSize = { width: 0, height: 0 };
};

PlayerInfo._players = {};

PlayerInfo.getInstance = function (playerId) {
  return PlayerInfo._players[playerId] || (PlayerInfo._players[playerId] = new PlayerInfo());
};

exports.default = PlayerInfo;
module.exports = exports["default"];

/***/ }),

/***/ "./src/icons/01-play.svg":
/*!*******************************!*\
  !*** ./src/icons/01-play.svg ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/02-pause.svg":
/*!********************************!*\
  !*** ./src/icons/02-pause.svg ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/03-stop.svg":
/*!*******************************!*\
  !*** ./src/icons/03-stop.svg ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/04-volume.svg":
/*!*********************************!*\
  !*** ./src/icons/04-volume.svg ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/05-mute.svg":
/*!*******************************!*\
  !*** ./src/icons/05-mute.svg ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/06-expand.svg":
/*!*********************************!*\
  !*** ./src/icons/06-expand.svg ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/07-shrink.svg":
/*!*********************************!*\
  !*** ./src/icons/07-shrink.svg ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/08-hd.svg":
/*!*****************************!*\
  !*** ./src/icons/08-hd.svg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/09-cc.svg":
/*!*****************************!*\
  !*** ./src/icons/09-cc.svg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/icons/10-reload.svg":
/*!*********************************!*\
  !*** ./src/icons/10-reload.svg ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _player = __webpack_require__(/*! ./components/player */ "./src/components/player.js");

var _player2 = _interopRequireDefault(_player);

var _utils = __webpack_require__(/*! ./base/utils */ "./src/base/utils.js");

var _utils2 = _interopRequireDefault(_utils);

var _events = __webpack_require__(/*! ./base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _playback = __webpack_require__(/*! ./base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _container_plugin = __webpack_require__(/*! ./base/container_plugin */ "./src/base/container_plugin.js");

var _container_plugin2 = _interopRequireDefault(_container_plugin);

var _core_plugin = __webpack_require__(/*! ./base/core_plugin */ "./src/base/core_plugin.js");

var _core_plugin2 = _interopRequireDefault(_core_plugin);

var _ui_core_plugin = __webpack_require__(/*! ./base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _ui_container_plugin = __webpack_require__(/*! ./base/ui_container_plugin */ "./src/base/ui_container_plugin.js");

var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

var _base_object = __webpack_require__(/*! ./base/base_object */ "./src/base/base_object.js");

var _base_object2 = _interopRequireDefault(_base_object);

var _ui_object = __webpack_require__(/*! ./base/ui_object */ "./src/base/ui_object.js");

var _ui_object2 = _interopRequireDefault(_ui_object);

var _browser = __webpack_require__(/*! ./components/browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _container = __webpack_require__(/*! ./components/container */ "./src/components/container/index.js");

var _container2 = _interopRequireDefault(_container);

var _core = __webpack_require__(/*! ./components/core */ "./src/components/core/index.js");

var _core2 = _interopRequireDefault(_core);

var _error = __webpack_require__(/*! ./components/error */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

var _loader = __webpack_require__(/*! ./components/loader */ "./src/components/loader/index.js");

var _loader2 = _interopRequireDefault(_loader);

var _mediator = __webpack_require__(/*! ./components/mediator */ "./src/components/mediator.js");

var _mediator2 = _interopRequireDefault(_mediator);

var _player_info = __webpack_require__(/*! ./components/player_info */ "./src/components/player_info.js");

var _player_info2 = _interopRequireDefault(_player_info);

var _hls = __webpack_require__(/*! ./playbacks/hls */ "./src/playbacks/hls/index.js");

var _hls2 = _interopRequireDefault(_hls);

var _html5_audio = __webpack_require__(/*! ./playbacks/html5_audio */ "./src/playbacks/html5_audio/index.js");

var _html5_audio2 = _interopRequireDefault(_html5_audio);

var _html5_video = __webpack_require__(/*! ./playbacks/html5_video */ "./src/playbacks/html5_video/index.js");

var _html5_video2 = _interopRequireDefault(_html5_video);

var _html_img = __webpack_require__(/*! ./playbacks/html_img */ "./src/playbacks/html_img/index.js");

var _html_img2 = _interopRequireDefault(_html_img);

var _no_op = __webpack_require__(/*! ./playbacks/no_op */ "./src/playbacks/no_op/index.js");

var _no_op2 = _interopRequireDefault(_no_op);

var _media_control = __webpack_require__(/*! ./plugins/media_control */ "./src/plugins/media_control/index.js");

var _media_control2 = _interopRequireDefault(_media_control);

var _click_to_pause = __webpack_require__(/*! ./plugins/click_to_pause */ "./src/plugins/click_to_pause/index.js");

var _click_to_pause2 = _interopRequireDefault(_click_to_pause);

var _dvr_controls = __webpack_require__(/*! ./plugins/dvr_controls */ "./src/plugins/dvr_controls/index.js");

var _dvr_controls2 = _interopRequireDefault(_dvr_controls);

var _favicon = __webpack_require__(/*! ./plugins/favicon */ "./src/plugins/favicon/index.js");

var _favicon2 = _interopRequireDefault(_favicon);

var _log = __webpack_require__(/*! ./plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

var _poster = __webpack_require__(/*! ./plugins/poster */ "./src/plugins/poster/index.js");

var _poster2 = _interopRequireDefault(_poster);

var _spinner_three_bounce = __webpack_require__(/*! ./plugins/spinner_three_bounce */ "./src/plugins/spinner_three_bounce/index.js");

var _spinner_three_bounce2 = _interopRequireDefault(_spinner_three_bounce);

var _watermark = __webpack_require__(/*! ./plugins/watermark */ "./src/plugins/watermark/index.js");

var _watermark2 = _interopRequireDefault(_watermark);

var _styler = __webpack_require__(/*! ./base/styler */ "./src/base/styler.js");

var _styler2 = _interopRequireDefault(_styler);

var _vendor = __webpack_require__(/*! ./vendor */ "./src/vendor/index.js");

var _vendor2 = _interopRequireDefault(_vendor);

var _template = __webpack_require__(/*! ./base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var version = "0.3.12";

exports.default = {
  Player: _player2.default,
  Mediator: _mediator2.default,
  Events: _events2.default,
  Browser: _browser2.default,
  PlayerInfo: _player_info2.default,
  MediaControl: _media_control2.default,
  ContainerPlugin: _container_plugin2.default,
  UIContainerPlugin: _ui_container_plugin2.default,
  CorePlugin: _core_plugin2.default,
  UICorePlugin: _ui_core_plugin2.default,
  Playback: _playback2.default,
  Container: _container2.default,
  Core: _core2.default,
  PlayerError: _error2.default,
  Loader: _loader2.default,
  BaseObject: _base_object2.default,
  UIObject: _ui_object2.default,
  Utils: _utils2.default,
  HLS: _hls2.default,
  HTML5Audio: _html5_audio2.default,
  HTML5Video: _html5_video2.default,
  HTMLImg: _html_img2.default,
  NoOp: _no_op2.default,
  ClickToPausePlugin: _click_to_pause2.default,
  DVRControls: _dvr_controls2.default,
  Favicon: _favicon2.default,
  Log: _log2.default,
  Poster: _poster2.default,
  SpinnerThreeBouncePlugin: _spinner_three_bounce2.default,
  WaterMarkPlugin: _watermark2.default,
  Styler: _styler2.default,
  Vendor: _vendor2.default,
  version: version,
  template: _template2.default,
  $: _clapprZepto2.default
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/hls/hls.js":
/*!**********************************!*\
  !*** ./src/playbacks/hls/hls.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _html5_video = __webpack_require__(/*! ../../playbacks/html5_video */ "./src/playbacks/html5_video/index.js");

var _html5_video2 = _interopRequireDefault(_html5_video);

var _hls = __webpack_require__(/*! ../../../node_modules/hls.js/dist/hls.js */ "./node_modules/hls.js/dist/hls.js");

var _hls2 = _interopRequireDefault(_hls);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _log = __webpack_require__(/*! ../../plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

var _error = __webpack_require__(/*! ../../components/error */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AUTO = -1;
// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var HLS = function (_HTML5VideoPlayback) {
  (0, _inherits3.default)(HLS, _HTML5VideoPlayback);
  (0, _createClass3.default)(HLS, [{
    key: 'name',
    get: function get() {
      return 'hls';
    }
  }, {
    key: 'levels',
    get: function get() {
      return this._levels || [];
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      if (this._currentLevel === null || this._currentLevel === undefined) return AUTO;else return this._currentLevel; //0 is a valid level ID
    },
    set: function set(id) {
      this._currentLevel = id;
      this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_START);
      if (this.options.playback.hlsUseNextLevel) this._hls.nextLevel = this._currentLevel;else this._hls.currentLevel = this._currentLevel;
    }
  }, {
    key: 'isReady',
    get: function get() {
      return this._isReadyState;
    }
  }, {
    key: '_startTime',
    get: function get() {
      if (this._playbackType === _playback2.default.LIVE && this._playlistType !== 'EVENT') return this._extrapolatedStartTime;

      return this._playableRegionStartTime;
    }
  }, {
    key: '_now',
    get: function get() {
      return (0, _utils.now)();
    }

    // the time in the video element which should represent the start of the sliding window
    // extrapolated to increase in real time (instead of jumping as the early segments are removed)

  }, {
    key: '_extrapolatedStartTime',
    get: function get() {
      if (!this._localStartTimeCorrelation) return this._playableRegionStartTime;

      var corr = this._localStartTimeCorrelation;
      var timePassed = this._now - corr.local;
      var extrapolatedWindowStartTime = (corr.remote + timePassed) / 1000;
      // cap at the end of the extrapolated window duration
      return Math.min(extrapolatedWindowStartTime, this._playableRegionStartTime + this._extrapolatedWindowDuration);
    }

    // the time in the video element which should represent the end of the content
    // extrapolated to increase in real time (instead of jumping as segments are added)

  }, {
    key: '_extrapolatedEndTime',
    get: function get() {
      var actualEndTime = this._playableRegionStartTime + this._playableRegionDuration;
      if (!this._localEndTimeCorrelation) return actualEndTime;

      var corr = this._localEndTimeCorrelation;
      var timePassed = this._now - corr.local;
      var extrapolatedEndTime = (corr.remote + timePassed) / 1000;
      return Math.max(actualEndTime - this._extrapolatedWindowDuration, Math.min(extrapolatedEndTime, actualEndTime));
    }
  }, {
    key: '_duration',
    get: function get() {
      return this._extrapolatedEndTime - this._startTime;
    }

    // Returns the duration (seconds) of the window that the extrapolated start time is allowed
    // to move in before being capped.
    // The extrapolated start time should never reach the cap at the end of the window as the
    // window should slide as chunks are removed from the start.
    // This also applies to the extrapolated end time in the same way.
    //
    // If chunks aren't being removed for some reason that the start time will reach and remain fixed at
    // playableRegionStartTime + extrapolatedWindowDuration
    //
    //                                <-- window duration -->
    // I.e   playableRegionStartTime |-----------------------|
    //                               | -->   .       .       .
    //                               .   --> | -->   .       .
    //                               .       .   --> | -->   .
    //                               .       .       .   --> |
    //                               .       .       .       .
    //                                 extrapolatedStartTime

  }, {
    key: '_extrapolatedWindowDuration',
    get: function get() {
      if (this._segmentTargetDuration === null) return 0;

      return this._extrapolatedWindowNumSegments * this._segmentTargetDuration;
    }
  }], [{
    key: 'HLSJS',
    get: function get() {
      return _hls2.default;
    }
  }]);

  function HLS() {
    (0, _classCallCheck3.default)(this, HLS);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // backwards compatibility (TODO: remove on 0.3.0)
    var _this = (0, _possibleConstructorReturn3.default)(this, _HTML5VideoPlayback.call.apply(_HTML5VideoPlayback, [this].concat(args)));

    _this.options.playback = (0, _extends3.default)({}, _this.options, _this.options.playback);
    _this._minDvrSize = typeof _this.options.hlsMinimumDvrSize === 'undefined' ? 60 : _this.options.hlsMinimumDvrSize;
    // The size of the start time extrapolation window measured as a multiple of segments.
    // Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is
    // removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are
    // added/removed every 5.
    _this._extrapolatedWindowNumSegments = !_this.options.playback || typeof _this.options.playback.extrapolatedWindowNumSegments === 'undefined' ? 2 : _this.options.playback.extrapolatedWindowNumSegments;

    _this._playbackType = _this.options.playbackType || _playback2.default.VOD;
    _this._lastTimeUpdate = { current: 0, total: 0 };
    _this._lastDuration = null;
    // for hls streams which have dvr with a sliding window,
    // the content at the start of the playlist is removed as new
    // content is appended at the end.
    // this means the actual playable start time will increase as the
    // start content is deleted
    // For streams with dvr where the entire recording is kept from the
    // beginning this should stay as 0
    _this._playableRegionStartTime = 0;
    // {local, remote} remote is the time in the video element that should represent 0
    //                 local is the system time when the 'remote' measurment took place
    _this._localStartTimeCorrelation = null;
    // {local, remote} remote is the time in the video element that should represents the end
    //                 local is the system time when the 'remote' measurment took place
    _this._localEndTimeCorrelation = null;
    // if content is removed from the beginning then this empty area should
    // be ignored. "playableRegionDuration" excludes the empty area
    _this._playableRegionDuration = 0;
    // #EXT-X-PROGRAM-DATE-TIME
    _this._programDateTime = 0;
    // true when the actual duration is longer than hlsjs's live sync point
    // when this is false playableRegionDuration will be the actual duration
    // when this is true playableRegionDuration will exclude the time after the sync point
    _this._durationExcludesAfterLiveSyncPoint = false;
    // #EXT-X-TARGETDURATION
    _this._segmentTargetDuration = null;
    // #EXT-X-PLAYLIST-TYPE
    _this._playlistType = null;
    _this._recoverAttemptsRemaining = _this.options.hlsRecoverAttempts || 16;
    return _this;
  }

  HLS.prototype._setup = function _setup() {
    var _this2 = this;

    this._ccIsSetup = false;
    this._ccTracksUpdated = false;
    this._hls = new _hls2.default((0, _utils.assign)({}, this.options.playback.hlsjsConfig));
    this._hls.on(_hls2.default.Events.MEDIA_ATTACHED, function () {
      return _this2._hls.loadSource(_this2.options.src);
    });
    this._hls.on(_hls2.default.Events.LEVEL_LOADED, function (evt, data) {
      return _this2._updatePlaybackType(evt, data);
    });
    this._hls.on(_hls2.default.Events.LEVEL_UPDATED, function (evt, data) {
      return _this2._onLevelUpdated(evt, data);
    });
    this._hls.on(_hls2.default.Events.LEVEL_SWITCHING, function (evt, data) {
      return _this2._onLevelSwitch(evt, data);
    });
    this._hls.on(_hls2.default.Events.FRAG_LOADED, function (evt, data) {
      return _this2._onFragmentLoaded(evt, data);
    });
    this._hls.on(_hls2.default.Events.ERROR, function (evt, data) {
      return _this2._onHLSJSError(evt, data);
    });
    this._hls.on(_hls2.default.Events.SUBTITLE_TRACK_LOADED, function (evt, data) {
      return _this2._onSubtitleLoaded(evt, data);
    });
    this._hls.on(_hls2.default.Events.SUBTITLE_TRACKS_UPDATED, function () {
      return _this2._ccTracksUpdated = true;
    });
    this._hls.attachMedia(this.el);
  };

  HLS.prototype.render = function render() {
    this._ready();
    return _HTML5VideoPlayback.prototype.render.call(this);
  };

  HLS.prototype._ready = function _ready() {
    this._isReadyState = true;
    this.trigger(_events2.default.PLAYBACK_READY, this.name);
  };

  HLS.prototype._recover = function _recover(evt, data, error) {
    if (!this._recoveredDecodingError) {
      this._recoveredDecodingError = true;
      this._hls.recoverMediaError();
    } else if (!this._recoveredAudioCodecError) {
      this._recoveredAudioCodecError = true;
      this._hls.swapAudioCodec();
      this._hls.recoverMediaError();
    } else {
      _log2.default.error('hlsjs: failed to recover', { evt: evt, data: data });
      error.level = _error2.default.Levels.FATAL;
      var formattedError = this.createError(error);
      this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
      this.stop();
    }
  };

  // override


  HLS.prototype._setupSrc = function _setupSrc(srcUrl) {// eslint-disable-line no-unused-vars
    // this playback manages the src on the video element itself
  };

  HLS.prototype._startTimeUpdateTimer = function _startTimeUpdateTimer() {
    var _this3 = this;

    if (this._timeUpdateTimer) return;

    this._timeUpdateTimer = setInterval(function () {
      _this3._onDurationChange();
      _this3._onTimeUpdate();
    }, 100);
  };

  HLS.prototype._stopTimeUpdateTimer = function _stopTimeUpdateTimer() {
    if (!this._timeUpdateTimer) return;

    clearInterval(this._timeUpdateTimer);
    this._timeUpdateTimer = null;
  };

  HLS.prototype.getProgramDateTime = function getProgramDateTime() {
    return this._programDateTime;
  };
  // the duration on the video element itself should not be used
  // as this does not necesarily represent the duration of the stream
  // https://github.com/clappr/clappr/issues/668#issuecomment-157036678


  HLS.prototype.getDuration = function getDuration() {
    return this._duration;
  };

  HLS.prototype.getCurrentTime = function getCurrentTime() {
    // e.g. can be < 0 if user pauses near the start
    // eventually they will then be kicked to the end by hlsjs if they run out of buffer
    // before the official start time
    return Math.max(0, this.el.currentTime - this._startTime);
  };

  // the time that "0" now represents relative to when playback started
  // for a stream with a sliding window this will increase as content is
  // removed from the beginning


  HLS.prototype.getStartTimeOffset = function getStartTimeOffset() {
    return this._startTime;
  };

  HLS.prototype.seekPercentage = function seekPercentage(percentage) {
    var seekTo = this._duration;
    if (percentage > 0) seekTo = this._duration * (percentage / 100);

    this.seek(seekTo);
  };

  HLS.prototype.seek = function seek(time) {
    if (time < 0) {
      _log2.default.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.');
      time = this.getDuration();
    }
    // assume live if time within 3 seconds of end of stream
    this.dvrEnabled && this._updateDvr(time < this.getDuration() - 3);
    time += this._startTime;
    _HTML5VideoPlayback.prototype.seek.call(this, time);
  };

  HLS.prototype.seekToLivePoint = function seekToLivePoint() {
    this.seek(this.getDuration());
  };

  HLS.prototype._updateDvr = function _updateDvr(status) {
    this.trigger(_events2.default.PLAYBACK_DVR, status);
    this.trigger(_events2.default.PLAYBACK_STATS_ADD, { 'dvr': status });
  };

  HLS.prototype._updateSettings = function _updateSettings() {
    if (this._playbackType === _playback2.default.VOD) this.settings.left = ['playpause', 'position', 'duration'];else if (this.dvrEnabled) this.settings.left = ['playpause'];else this.settings.left = ['playstop'];

    this.settings.seekEnabled = this.isSeekEnabled();
    this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);
  };

  HLS.prototype._onHLSJSError = function _onHLSJSError(evt, data) {
    var error = {
      code: data.type + '_' + data.details,
      description: this.name + ' error: type: ' + data.type + ', details: ' + data.details,
      raw: data
    };
    var formattedError = void 0;
    if (data.response) error.description += ', response: ' + (0, _stringify2.default)(data.response);
    // only report/handle errors if they are fatal
    // hlsjs should automatically handle non fatal errors
    if (data.fatal) {
      if (this._recoverAttemptsRemaining > 0) {
        this._recoverAttemptsRemaining -= 1;
        switch (data.type) {
          case _hls2.default.ErrorTypes.NETWORK_ERROR:
            switch (data.details) {
              // The following network errors cannot be recovered with HLS.startLoad()
              // For more details, see https://github.com/video-dev/hls.js/blob/master/doc/design.md#error-detection-and-handling
              // For "level load" fatal errors, see https://github.com/video-dev/hls.js/issues/1138
              case _hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR:
              case _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT:
              case _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR:
              case _hls2.default.ErrorDetails.LEVEL_LOAD_ERROR:
              case _hls2.default.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                _log2.default.error('hlsjs: unrecoverable network fatal error.', { evt: evt, data: data });
                formattedError = this.createError(error);
                this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
                this.stop();
                break;
              default:
                _log2.default.warn('hlsjs: trying to recover from network error.', { evt: evt, data: data });
                error.level = _error2.default.Levels.WARN;
                this.createError(error);
                this._hls.startLoad();
                break;
            }
            break;
          case _hls2.default.ErrorTypes.MEDIA_ERROR:
            _log2.default.warn('hlsjs: trying to recover from media error.', { evt: evt, data: data });
            error.level = _error2.default.Levels.WARN;
            this.createError(error);
            this._recover(evt, data, error);
            break;
          default:
            _log2.default.error('hlsjs: could not recover from error.', { evt: evt, data: data });
            formattedError = this.createError(error);
            this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
            this.stop();
            break;
        }
      } else {
        _log2.default.error('hlsjs: could not recover from error after maximum number of attempts.', { evt: evt, data: data });
        formattedError = this.createError(error);
        this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
        this.stop();
      }
    } else {
      // Transforms HLSJS.ErrorDetails.KEY_LOAD_ERROR non-fatal error to
      // playback fatal error if triggerFatalErrorOnResourceDenied playback
      // option is set. HLSJS.ErrorTypes.KEY_SYSTEM_ERROR are fatal errors
      // and therefore already handled.
      if (this.options.playback.triggerFatalErrorOnResourceDenied && this._keyIsDenied(data)) {
        _log2.default.error('hlsjs: could not load decrypt key.', { evt: evt, data: data });
        formattedError = this.createError(error);
        this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
        this.stop();
        return;
      }

      error.level = _error2.default.Levels.WARN;
      this.createError(error);
      _log2.default.warn('hlsjs: non-fatal error occurred', { evt: evt, data: data });
    }
  };

  HLS.prototype._keyIsDenied = function _keyIsDenied(data) {
    return data.type === _hls2.default.ErrorTypes.NETWORK_ERROR && data.details === _hls2.default.ErrorDetails.KEY_LOAD_ERROR && data.response && data.response.code >= 400 || data.details === _hls2.default.ErrorDetails.BUFFER_STALLED_ERROR || data.details === _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR && !this.getCurrentTime();
  };

  HLS.prototype._onTimeUpdate = function _onTimeUpdate() {
    var update = { current: this.getCurrentTime(), total: this.getDuration(), firstFragDateTime: this.getProgramDateTime() };
    var isSame = this._lastTimeUpdate && update.current === this._lastTimeUpdate.current && update.total === this._lastTimeUpdate.total;
    if (isSame) return;

    this._lastTimeUpdate = update;
    this.trigger(_events2.default.PLAYBACK_TIMEUPDATE, update, this.name);
  };

  HLS.prototype._onDurationChange = function _onDurationChange() {
    var duration = this.getDuration();
    if (this._lastDuration === duration) return;

    this._lastDuration = duration;
    _HTML5VideoPlayback.prototype._onDurationChange.call(this);
  };

  HLS.prototype._onProgress = function _onProgress() {
    if (!this.el.buffered.length) return;

    var buffered = [];
    var bufferedPos = 0;
    for (var i = 0; i < this.el.buffered.length; i++) {
      buffered = [].concat((0, _toConsumableArray3.default)(buffered), [{
        // for a stream with sliding window dvr something that is buffered my slide off the start of the timeline
        start: Math.max(0, this.el.buffered.start(i) - this._playableRegionStartTime),
        end: Math.max(0, this.el.buffered.end(i) - this._playableRegionStartTime)
      }]);
      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end) bufferedPos = i;
    }
    var progress = {
      start: buffered[bufferedPos].start,
      current: buffered[bufferedPos].end,
      total: this.getDuration()
    };
    this.trigger(_events2.default.PLAYBACK_PROGRESS, progress, buffered);
  };

  HLS.prototype.play = function play() {
    try {
      // && JSON.stringify(this.options.plugins).indexOf('VastAds') > -1
      var lib = !!(window.google && window.google.ima) || !!(window.ya && window.ya.videoAd);
      if (lib && this.options.plugins && this.options.VastAds.preroll && this.options.VastAds.preroll.data.length > 0) {
        this.trigger(_events2.default.PLAYBACK_PREROLL_REQUEST);
        return;
      }
    } catch (e) {}

    if (!this._hls) this._setup();

    _HTML5VideoPlayback.prototype.play.call(this);
    this._startTimeUpdateTimer();
  };

  HLS.prototype.pause = function pause() {
    if (!this._hls) return;

    _HTML5VideoPlayback.prototype.pause.call(this);
    if (this.dvrEnabled) this._updateDvr(true);
  };

  HLS.prototype.stop = function stop() {
    this._stopTimeUpdateTimer();
    if (this._hls) {
      _HTML5VideoPlayback.prototype.stop.call(this);
      this._hls.destroy();
      delete this._hls;
    }
  };

  HLS.prototype.destroy = function destroy() {
    this._stopTimeUpdateTimer();
    if (this._hls) {
      this._hls.destroy();
      delete this._hls;
    }
    _HTML5VideoPlayback.prototype.destroy.call(this);
  };

  HLS.prototype._updatePlaybackType = function _updatePlaybackType(evt, data) {
    this._playbackType = data.details.live ? _playback2.default.LIVE : _playback2.default.VOD;
    this._onLevelUpdated(evt, data);

    // Live stream subtitle tracks detection hack (may not immediately available)
    if (this._ccTracksUpdated && this._playbackType === _playback2.default.LIVE && this.hasClosedCaptionsTracks) this._onSubtitleLoaded();
  };

  HLS.prototype._fillLevels = function _fillLevels() {
    this._levels = this._hls.levels.map(function (level, index) {
      return { id: index, level: level, label: level.bitrate / 1000 + 'Kbps' };
    });
    this.trigger(_events2.default.PLAYBACK_LEVELS_AVAILABLE, this._levels);
  };

  HLS.prototype._onLevelUpdated = function _onLevelUpdated(evt, data) {
    this._segmentTargetDuration = data.details.targetduration;
    this._playlistType = data.details.type || null;

    var startTimeChanged = false;
    var durationChanged = false;
    var fragments = data.details.fragments;
    var previousPlayableRegionStartTime = this._playableRegionStartTime;
    var previousPlayableRegionDuration = this._playableRegionDuration;

    if (fragments.length === 0) return;

    // #EXT-X-PROGRAM-DATE-TIME
    if (fragments[0].rawProgramDateTime) this._programDateTime = fragments[0].rawProgramDateTime;

    if (this._playableRegionStartTime !== fragments[0].start) {
      startTimeChanged = true;
      this._playableRegionStartTime = fragments[0].start;
    }

    if (startTimeChanged) {
      if (!this._localStartTimeCorrelation) {
        // set the correlation to map to middle of the extrapolation window
        this._localStartTimeCorrelation = {
          local: this._now,
          remote: (fragments[0].start + this._extrapolatedWindowDuration / 2) * 1000
        };
      } else {
        // check if the correlation still works
        var corr = this._localStartTimeCorrelation;
        var timePassed = this._now - corr.local;
        // this should point to a time within the extrapolation window
        var startTime = (corr.remote + timePassed) / 1000;
        if (startTime < fragments[0].start) {
          // our start time is now earlier than the first chunk
          // (maybe the chunk was removed early)
          // reset correlation so that it sits at the beginning of the first available chunk
          this._localStartTimeCorrelation = {
            local: this._now,
            remote: fragments[0].start * 1000
          };
        } else if (startTime > previousPlayableRegionStartTime + this._extrapolatedWindowDuration) {
          // start time was past the end of the old extrapolation window (so would have been capped)
          // see if now that time would be inside the window, and if it would be set the correlation
          // so that it resumes from the time it was at at the end of the old window
          // update the correlation so that the time starts counting again from the value it's on now
          this._localStartTimeCorrelation = {
            local: this._now,
            remote: Math.max(fragments[0].start, previousPlayableRegionStartTime + this._extrapolatedWindowDuration) * 1000
          };
        }
      }
    }

    var newDuration = data.details.totalduration;
    // if it's a live stream then shorten the duration to remove access
    // to the area after hlsjs's live sync point
    // seeks to areas after this point sometimes have issues
    if (this._playbackType === _playback2.default.LIVE) {
      var fragmentTargetDuration = data.details.targetduration;
      var hlsjsConfig = this.options.playback.hlsjsConfig || {};
      var liveSyncDurationCount = hlsjsConfig.liveSyncDurationCount || _hls2.default.DefaultConfig.liveSyncDurationCount;
      var hiddenAreaDuration = fragmentTargetDuration * liveSyncDurationCount;
      if (hiddenAreaDuration <= newDuration) {
        newDuration -= hiddenAreaDuration;
        this._durationExcludesAfterLiveSyncPoint = true;
      } else {
        this._durationExcludesAfterLiveSyncPoint = false;
      }
    }

    if (newDuration !== this._playableRegionDuration) {
      durationChanged = true;
      this._playableRegionDuration = newDuration;
    }

    // Note the end time is not the playableRegionDuration
    // The end time will always increase even if content is removed from the beginning
    var endTime = fragments[0].start + newDuration;
    var previousEndTime = previousPlayableRegionStartTime + previousPlayableRegionDuration;
    var endTimeChanged = endTime !== previousEndTime;
    if (endTimeChanged) {
      if (!this._localEndTimeCorrelation) {
        // set the correlation to map to the end
        this._localEndTimeCorrelation = {
          local: this._now,
          remote: endTime * 1000
        };
      } else {
        // check if the correlation still works
        var _corr = this._localEndTimeCorrelation;
        var _timePassed = this._now - _corr.local;
        // this should point to a time within the extrapolation window from the end
        var extrapolatedEndTime = (_corr.remote + _timePassed) / 1000;
        if (extrapolatedEndTime > endTime) {
          this._localEndTimeCorrelation = {
            local: this._now,
            remote: endTime * 1000
          };
        } else if (extrapolatedEndTime < endTime - this._extrapolatedWindowDuration) {
          // our extrapolated end time is now earlier than the extrapolation window from the actual end time
          // (maybe a chunk became available early)
          // reset correlation so that it sits at the beginning of the extrapolation window from the end time
          this._localEndTimeCorrelation = {
            local: this._now,
            remote: (endTime - this._extrapolatedWindowDuration) * 1000
          };
        } else if (extrapolatedEndTime > previousEndTime) {
          // end time was past the old end time (so would have been capped)
          // set the correlation so that it resumes from the time it was at at the end of the old window
          this._localEndTimeCorrelation = {
            local: this._now,
            remote: previousEndTime * 1000
          };
        }
      }
    }

    // now that the values have been updated call any methods that use on them so they get the updated values
    // immediately
    durationChanged && this._onDurationChange();
    startTimeChanged && this._onProgress();
  };

  HLS.prototype._onFragmentLoaded = function _onFragmentLoaded(evt, data) {
    this.trigger(_events2.default.PLAYBACK_FRAGMENT_LOADED, data);
  };

  HLS.prototype._onSubtitleLoaded = function _onSubtitleLoaded() {
    // This event may be triggered multiple times
    // Setup CC only once (disable CC by default)
    if (!this._ccIsSetup) {
      this.trigger(_events2.default.PLAYBACK_SUBTITLE_AVAILABLE);
      var trackId = this._playbackType === _playback2.default.LIVE ? -1 : this.closedCaptionsTrackId;
      this.closedCaptionsTrackId = trackId;
      this._ccIsSetup = true;
    }
  };

  HLS.prototype._onLevelSwitch = function _onLevelSwitch(evt, data) {
    if (!this.levels.length) this._fillLevels();

    this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_END);
    this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH, data);
    var currentLevel = this._hls.levels[data.level];
    if (currentLevel) {
      // TODO should highDefinition be private and maybe have a read only accessor if it's used somewhere
      this.highDefinition = currentLevel.height >= 720 || currentLevel.bitrate / 1000 >= 2000;
      this.trigger(_events2.default.PLAYBACK_HIGHDEFINITIONUPDATE, this.highDefinition);
      this.trigger(_events2.default.PLAYBACK_BITRATE, {
        height: currentLevel.height,
        width: currentLevel.width,
        bandwidth: currentLevel.bitrate,
        bitrate: currentLevel.bitrate,
        level: data.level
      });
    }
  };

  HLS.prototype.getPlaybackType = function getPlaybackType() {
    return this._playbackType;
  };

  HLS.prototype.isSeekEnabled = function isSeekEnabled() {
    return this._playbackType === _playback2.default.VOD || this.dvrEnabled;
  };

  (0, _createClass3.default)(HLS, [{
    key: 'dvrEnabled',
    get: function get() {
      // enabled when:
      // - the duration does not include content after hlsjs's live sync point
      // - the playable region duration is longer than the configured duration to enable dvr after
      // - the playback type is LIVE.
      return this._durationExcludesAfterLiveSyncPoint && this._duration >= this._minDvrSize && this.getPlaybackType() === _playback2.default.LIVE;
    }
  }]);
  return HLS;
}(_html5_video2.default);

exports.default = HLS;


HLS.canPlay = function (resource, mimeType) {
  var resourceParts = resource.split('?')[0].match(/.*\.(.*)$/) || [];
  var isHls = resourceParts.length > 1 && resourceParts[1].toLowerCase() === 'm3u8' || (0, _utils.listContainsIgnoreCase)(mimeType, ['application/vnd.apple.mpegurl', 'application/x-mpegURL']);

  return !!(_hls2.default.isSupported() && isHls);
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/hls/index.js":
/*!************************************!*\
  !*** ./src/playbacks/hls/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hls = __webpack_require__(/*! ./hls */ "./src/playbacks/hls/hls.js");

var _hls2 = _interopRequireDefault(_hls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _hls2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html5_audio/html5_audio.js":
/*!**************************************************!*\
  !*** ./src/playbacks/html5_audio/html5_audio.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _html5_video = __webpack_require__(/*! ../../playbacks/html5_video */ "./src/playbacks/html5_video/index.js");

var _html5_video2 = _interopRequireDefault(_html5_video);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: remove this playback and change HTML5Video to HTML5Playback (breaking change, only after 0.3.0)
var HTML5Audio = function (_HTML5Video) {
  (0, _inherits3.default)(HTML5Audio, _HTML5Video);

  function HTML5Audio() {
    (0, _classCallCheck3.default)(this, HTML5Audio);
    return (0, _possibleConstructorReturn3.default)(this, _HTML5Video.apply(this, arguments));
  }

  HTML5Audio.prototype.updateSettings = function updateSettings() {
    this.settings.left = ['playpause', 'position', 'duration'];
    this.settings.seekEnabled = this.isSeekEnabled();
    this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);
  };

  HTML5Audio.prototype.getPlaybackType = function getPlaybackType() {
    return _playback2.default.AOD;
  };

  (0, _createClass3.default)(HTML5Audio, [{
    key: 'name',
    get: function get() {
      return 'html5_audio';
    }
  }, {
    key: 'tagName',
    get: function get() {
      return 'audio';
    }
  }, {
    key: 'isAudioOnly',
    get: function get() {
      return true;
    }
  }]);
  return HTML5Audio;
}(_html5_video2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = HTML5Audio;


HTML5Audio.canPlay = function (resourceUrl, mimeType) {
  var mimetypes = {
    'wav': ['audio/wav'],
    'mp3': ['audio/mp3', 'audio/mpeg;codecs="mp3"'],
    'aac': ['audio/mp4;codecs="mp4a.40.5"'],
    'oga': ['audio/ogg']
  };
  return _html5_video2.default._canPlay('audio', mimetypes, resourceUrl, mimeType);
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html5_audio/index.js":
/*!********************************************!*\
  !*** ./src/playbacks/html5_audio/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _html5_audio = __webpack_require__(/*! ./html5_audio */ "./src/playbacks/html5_audio/html5_audio.js");

var _html5_audio2 = _interopRequireDefault(_html5_audio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html5_audio2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html5_video/html5_video.js":
/*!**************************************************!*\
  !*** ./src/playbacks/html5_video/html5_video.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _from = __webpack_require__(/*! babel-runtime/core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _browser = __webpack_require__(/*! ../../components/browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _error = __webpack_require__(/*! ../../components/error */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _log = __webpack_require__(/*! ../../plugins/log */ "./src/plugins/log/index.js");

var _log2 = _interopRequireDefault(_log);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _tracks = __webpack_require__(/*! ./public/tracks.html */ "./src/playbacks/html5_video/public/tracks.html");

var _tracks2 = _interopRequireDefault(_tracks);

__webpack_require__(/*! ./public/style.scss */ "./src/playbacks/html5_video/public/style.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var MIMETYPES = {
  'mp4': ['avc1.42E01E', 'avc1.58A01E', 'avc1.4D401E', 'avc1.64001E', 'mp4v.20.8', 'mp4v.20.240', 'mp4a.40.2'].map(function (codec) {
    return 'video/mp4; codecs="' + codec + ', mp4a.40.2"';
  }),
  'ogg': ['video/ogg; codecs="theora, vorbis"', 'video/ogg; codecs="dirac"', 'video/ogg; codecs="theora, speex"'],
  '3gpp': ['video/3gpp; codecs="mp4v.20.8, samr"'],
  'webm': ['video/webm; codecs="vp8, vorbis"'],
  'mkv': ['video/x-matroska; codecs="theora, vorbis"'],
  'm3u8': ['application/x-mpegurl']
};
MIMETYPES['ogv'] = MIMETYPES['ogg'];
MIMETYPES['3gp'] = MIMETYPES['3gpp'];

var AUDIO_MIMETYPES = {
  'wav': ['audio/wav'],
  'mp3': ['audio/mp3', 'audio/mpeg;codecs="mp3"'],
  'aac': ['audio/mp4;codecs="mp4a.40.5"'],
  'oga': ['audio/ogg']
};

var KNOWN_AUDIO_MIMETYPES = (0, _keys2.default)(AUDIO_MIMETYPES).reduce(function (acc, k) {
  return [].concat((0, _toConsumableArray3.default)(acc), (0, _toConsumableArray3.default)(AUDIO_MIMETYPES[k]));
}, []);

var UNKNOWN_ERROR = { code: 'unknown', message: 'unknown'

  // TODO: rename this Playback to HTML5Playback (breaking change, only after 0.3.0)
};
var HTML5Video = function (_Playback) {
  (0, _inherits3.default)(HTML5Video, _Playback);
  (0, _createClass3.default)(HTML5Video, [{
    key: 'name',
    get: function get() {
      return 'html5_video';
    }
  }, {
    key: 'tagName',
    get: function get() {
      return this.isAudioOnly ? 'audio' : 'video';
    }
  }, {
    key: 'isAudioOnly',
    get: function get() {
      var resourceUrl = this.options.src;
      var mimeTypes = HTML5Video._mimeTypesForUrl(resourceUrl, AUDIO_MIMETYPES, this.options.mimeType);
      return this.options.playback && this.options.playback.audioOnly || this.options.audioOnly || KNOWN_AUDIO_MIMETYPES.indexOf(mimeTypes[0]) >= 0;
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'data-html5-video': ''
      };
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'canplay': '_onCanPlay',
        'canplaythrough': '_handleBufferingEvents',
        'durationchange': '_onDurationChange',
        'ended': '_onEnded',
        'error': '_onError',
        'loadeddata': '_onLoadedData',
        'loadedmetadata': '_onLoadedMetadata',
        'pause': '_onPause',
        'playing': '_onPlaying',
        'progress': '_onProgress',
        'seeking': '_onSeeking',
        'seeked': '_onSeeked',
        'stalled': '_handleBufferingEvents',
        'timeupdate': '_onTimeUpdate',
        'waiting': '_onWaiting'
      };
    }

    /**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */

  }, {
    key: 'ended',
    get: function get() {
      return this.el.ended;
    }

    /**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * This is related to the PLAYBACK_BUFFERING and PLAYBACK_BUFFERFULL events
     * @property buffering
     * @type Boolean
     */

  }, {
    key: 'buffering',
    get: function get() {
      return this._isBuffering;
    }
  }]);

  function HTML5Video() {
    (0, _classCallCheck3.default)(this, HTML5Video);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Playback.call.apply(_Playback, [this].concat(args)));

    _this._destroyed = false;
    _this._loadStarted = false;
    _this._isBuffering = false;
    _this._playheadMoving = false;
    _this._playheadMovingTimer = null;
    _this._stopped = false;
    _this._ccTrackId = -1;
    _this._setupSrc(_this.options.src);
    // backwards compatibility (TODO: remove on 0.3.0)
    _this.options.playback || (_this.options.playback = _this.options || {});
    _this.options.playback.disableContextMenu = _this.options.playback.disableContextMenu || _this.options.disableVideoTagContextMenu;

    var playbackConfig = _this.options.playback;
    var preload = playbackConfig.preload || (_browser2.default.isSafari ? 'auto' : _this.options.preload);

    var posterUrl = void 0; // FIXME: poster plugin should always convert poster to object with expected properties ?
    if (_this.options.poster) {
      if (typeof _this.options.poster === 'string') posterUrl = _this.options.poster;else if (typeof _this.options.poster.url === 'string') posterUrl = _this.options.poster.url;
    }

    _clapprZepto2.default.extend(_this.el, {
      muted: _this.options.mute,
      defaultMuted: _this.options.mute,
      loop: _this.options.loop,
      poster: posterUrl,
      preload: preload || 'metadata',
      controls: (playbackConfig.controls || _this.options.useVideoTagDefaultControls) && 'controls',
      crossOrigin: playbackConfig.crossOrigin,
      'x-webkit-playsinline': playbackConfig.playInline
    });

    playbackConfig.playInline && _this.$el.attr({ playsinline: 'playsinline' });
    playbackConfig.crossOrigin && _this.$el.attr({ crossorigin: playbackConfig.crossOrigin });

    // TODO should settings be private?
    _this.settings = { default: ['seekbar'] };
    _this.settings.left = ['playpause', 'position', 'duration'];
    _this.settings.right = ['fullscreen', 'volume', 'hd-indicator'];

    playbackConfig.externalTracks && _this._setupExternalTracks(playbackConfig.externalTracks);

    _this.options.autoPlay && _this.attemptAutoPlay();
    return _this;
  }

  HTML5Video.prototype.configure = function configure(options) {
    _Playback.prototype.configure.call(this, options);
    this.el.loop = !!options.loop;
  };

  // See Playback.attemptAutoPlay()


  HTML5Video.prototype.attemptAutoPlay = function attemptAutoPlay() {
    var _this2 = this;

    this.canAutoPlay(function (result, error) {
      error && _log2.default.warn(_this2.name, 'autoplay error.', { result: result, error: error });

      // https://github.com/clappr/clappr/issues/1076
      result && process.nextTick(function () {
        return !_this2._destroyed && _this2.play();
      });
    });
  };

  // See Playback.canAutoPlay()


  HTML5Video.prototype.canAutoPlay = function canAutoPlay(cb) {
    if (this.options.disableCanAutoPlay) {
      cb(true, null);
      return;
    }

    var opts = {
      timeout: this.options.autoPlayTimeout || 500,
      inline: this.options.playback.playInline || false,
      muted: this.options.mute || false // Known issue: mediacontrols may asynchronously mute video


      // Use current video element if recycling feature enabled with mobile devices
    };if (_browser2.default.isMobile && _utils.DomRecycler.options.recycleVideo) opts.element = this.el;

    // Desktop browser autoplay policy may require user action
    // Mobile browser autoplay require user consent and video recycling feature enabled
    // It may returns a false positive with source-less player consent
    (0, _utils.canAutoPlayMedia)(cb, opts);
  };

  HTML5Video.prototype._setupExternalTracks = function _setupExternalTracks(tracks) {
    this._externalTracks = tracks.map(function (track) {
      return {
        kind: track.kind || 'subtitles', // Default is 'subtitles'
        label: track.label,
        lang: track.lang,
        src: track.src
      };
    });
  };

  /**
   * Sets the source url on the <video> element, and also the 'src' property.
   * @method setupSrc
   * @private
   * @param {String} srcUrl The source URL.
   */


  HTML5Video.prototype._setupSrc = function _setupSrc(srcUrl) {
    if (this.el.src === srcUrl) return;

    this._ccIsSetup = false;
    this.el.src = srcUrl;
    this._src = this.el.src;
  };

  HTML5Video.prototype._onLoadedMetadata = function _onLoadedMetadata(e) {
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_LOADEDMETADATA, { duration: e.target.duration, data: e });
    this._updateSettings();
    var autoSeekFromUrl = typeof this._options.autoSeekFromUrl === 'undefined' || this._options.autoSeekFromUrl;
    if (this.getPlaybackType() !== _playback2.default.LIVE && autoSeekFromUrl) this._checkInitialSeek();
  };

  HTML5Video.prototype._onDurationChange = function _onDurationChange() {
    this._updateSettings();
    this._onTimeUpdate();
    // onProgress uses the duration
    this._onProgress();
  };

  HTML5Video.prototype._updateSettings = function _updateSettings() {
    // we can't figure out if hls resource is VoD or not until it is being loaded or duration has changed.
    // that's why we check it again and update media control accordingly.
    if (this.getPlaybackType() === _playback2.default.VOD || this.getPlaybackType() === _playback2.default.AOD) this.settings.left = ['playpause', 'position', 'duration'];else this.settings.left = ['playstop'];

    this.settings.seekEnabled = this.isSeekEnabled();
    this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);
  };

  HTML5Video.prototype.isSeekEnabled = function isSeekEnabled() {
    return isFinite(this.getDuration());
  };

  HTML5Video.prototype.getPlaybackType = function getPlaybackType() {
    var onDemandType = this.tagName === 'audio' ? _playback2.default.AOD : _playback2.default.VOD;
    return [0, undefined, Infinity].indexOf(this.el.duration) >= 0 ? _playback2.default.LIVE : onDemandType;
  };

  HTML5Video.prototype.isHighDefinitionInUse = function isHighDefinitionInUse() {
    return false;
  };

  // On mobile device, HTML5 video element "retains" user action consent if
  // load() method is called. See Player.consent().


  HTML5Video.prototype.consent = function consent() {
    if (!this.isPlaying()) {
      _Playback.prototype.consent.call(this);
      this.el.load();
    }
  };

  HTML5Video.prototype.play = function play() {
    try {
      // && JSON.stringify(this.options.plugins).indexOf('VastAds') > -1
      var lib = !!(window.google && window.google.ima) || !!(window.ya && window.ya.videoAd);
      if (lib && this.options.plugins && this.options.VastAds.preroll && this.options.VastAds.preroll.data.length > 0) {
        this.trigger(_events2.default.PLAYBACK_PREROLL_REQUEST);
        return;
      }
    } catch (e) {}

    this.trigger(_events2.default.PLAYBACK_PLAY_INTENT);
    this._stopped = false;
    this._setupSrc(this._src);
    this._handleBufferingEvents();
    var promise = this.el.play();
    // For more details, see https://developers.google.com/web/updates/2016/03/play-returns-promise
    if (promise && promise.catch) promise.catch(function () {});
  };

  HTML5Video.prototype.pause = function pause() {
    this.el.pause();
  };

  HTML5Video.prototype.stop = function stop() {
    this.pause();
    this._stopped = true;
    // src will be added again in play()
    this.el.removeAttribute('src');
    this.el.load(); // load with no src to stop loading of the previous source and avoid leaks
    this._stopPlayheadMovingChecks();
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_STOP);
  };

  HTML5Video.prototype.volume = function volume(value) {
    if (value === 0) {
      this.$el.attr({ muted: 'true' });
      this.el.muted = true;
    } else {
      this.$el.attr({ muted: null });
      this.el.muted = false;
      this.el.volume = value / 100;
    }
  };

  /**
   * @deprecated
   * @private
   */


  HTML5Video.prototype.mute = function mute() {
    this.el.muted = true;
  };

  /**
   * @deprecated
   * @private
   */


  HTML5Video.prototype.unmute = function unmute() {
    this.el.muted = false;
  };

  HTML5Video.prototype.isMuted = function isMuted() {
    return this.el.muted === true || this.el.volume === 0;
  };

  HTML5Video.prototype.isPlaying = function isPlaying() {
    return !this.el.paused && !this.el.ended;
  };

  HTML5Video.prototype._startPlayheadMovingChecks = function _startPlayheadMovingChecks() {
    if (this._playheadMovingTimer !== null) return;

    this._playheadMovingTimeOnCheck = null;
    this._determineIfPlayheadMoving();
    this._playheadMovingTimer = setInterval(this._determineIfPlayheadMoving.bind(this), 500);
  };

  HTML5Video.prototype._stopPlayheadMovingChecks = function _stopPlayheadMovingChecks() {
    if (this._playheadMovingTimer === null) return;

    clearInterval(this._playheadMovingTimer);
    this._playheadMovingTimer = null;
    this._playheadMoving = false;
  };

  HTML5Video.prototype._determineIfPlayheadMoving = function _determineIfPlayheadMoving() {
    var before = this._playheadMovingTimeOnCheck;
    var now = this.el.currentTime;
    this._playheadMoving = before !== now;
    this._playheadMovingTimeOnCheck = now;
    this._handleBufferingEvents();
  };

  // this seems to happen when the user is having to wait
  // for something to happen AFTER A USER INTERACTION
  // e.g the player might be buffering, but when `play()` is called
  // only at this point will this be called.
  // Or the user may seek somewhere but the new area requires buffering,
  // so it will fire then as well.
  // On devices where playing is blocked until requested with a user action,
  // buffering may start, but never finish until the user initiates a play,
  // but this only happens when play is actually requested


  HTML5Video.prototype._onWaiting = function _onWaiting() {
    this._loadStarted = true;
    this._handleBufferingEvents();
  };

  // called after the first frame has loaded
  // note this doesn't fire on ios before the user has requested play
  // ideally the "loadstart" event would be used instead, but this fires
  // before a user has requested play on iOS, and also this is always fired
  // even if the preload setting is "none". In both these cases this causes
  // infinite buffering until the user does something which isn't great.


  HTML5Video.prototype._onLoadedData = function _onLoadedData() {
    this._loadStarted = true;
    this._handleBufferingEvents();
  };

  // note this doesn't fire on ios before user has requested play


  HTML5Video.prototype._onCanPlay = function _onCanPlay() {
    this._handleBufferingEvents();
  };

  HTML5Video.prototype._onPlaying = function _onPlaying() {
    this._checkForClosedCaptions();
    this._startPlayheadMovingChecks();
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_PLAY);
  };

  HTML5Video.prototype._onPause = function _onPause() {
    this._stopPlayheadMovingChecks();
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_PAUSE);
  };

  HTML5Video.prototype._onSeeking = function _onSeeking() {
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_SEEK);
  };

  HTML5Video.prototype._onSeeked = function _onSeeked() {
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_SEEKED);
  };

  HTML5Video.prototype._onEnded = function _onEnded() {
    this._handleBufferingEvents();
    this.trigger(_events2.default.PLAYBACK_ENDED, this.name);
  };

  // The playback should be classed as buffering if the following are true:
  // - the ready state is less then HAVE_FUTURE_DATA or the playhead isn't moving and it should be
  // - the media hasn't "ended",
  // - the media hasn't been stopped
  // - loading has started


  HTML5Video.prototype._handleBufferingEvents = function _handleBufferingEvents() {
    var playheadShouldBeMoving = !this.el.ended && !this.el.paused;
    var buffering = this._loadStarted && !this.el.ended && !this._stopped && (playheadShouldBeMoving && !this._playheadMoving || this.el.readyState < this.el.HAVE_FUTURE_DATA);
    if (this._isBuffering !== buffering) {
      this._isBuffering = buffering;
      if (buffering) this.trigger(_events2.default.PLAYBACK_BUFFERING, this.name);else this.trigger(_events2.default.PLAYBACK_BUFFERFULL, this.name);
    }
  };

  HTML5Video.prototype._onError = function _onError() {
    var _ref = this.el.error || UNKNOWN_ERROR,
        code = _ref.code,
        message = _ref.message;

    var isUnknownError = code === UNKNOWN_ERROR.code;

    var formattedError = this.createError({
      code: code,
      description: message,
      raw: this.el.error,
      level: isUnknownError ? _error2.default.Levels.WARN : _error2.default.Levels.FATAL
    });

    if (isUnknownError) _log2.default.warn(this.name, 'HTML5 unknown error: ', formattedError);else this.trigger(_events2.default.PLAYBACK_ERROR, formattedError);
  };

  HTML5Video.prototype.destroy = function destroy() {
    this._destroyed = true;
    this.handleTextTrackChange && this.el.textTracks.removeEventListener('change', this.handleTextTrackChange);
    _Playback.prototype.destroy.call(this);
    this.el.removeAttribute('src');
    this.el.load(); // load with no src to stop loading of the previous source and avoid leaks
    this._src = null;
    _utils.DomRecycler.garbage(this.$el);
  };

  HTML5Video.prototype.seek = function seek(time) {
    this.el.currentTime = time;
  };

  HTML5Video.prototype.seekPercentage = function seekPercentage(percentage) {
    var time = this.el.duration * (percentage / 100);
    this.seek(time);
  };

  HTML5Video.prototype._checkInitialSeek = function _checkInitialSeek() {
    var seekTime = (0, _utils.seekStringToSeconds)();
    if (seekTime !== 0) this.seek(seekTime);
  };

  HTML5Video.prototype.getCurrentTime = function getCurrentTime() {
    return this.el.currentTime;
  };

  HTML5Video.prototype.getDuration = function getDuration() {
    return this.el.duration;
  };

  HTML5Video.prototype._onTimeUpdate = function _onTimeUpdate() {
    if (this.getPlaybackType() === _playback2.default.LIVE) this.trigger(_events2.default.PLAYBACK_TIMEUPDATE, { current: 1, total: 1 }, this.name);else this.trigger(_events2.default.PLAYBACK_TIMEUPDATE, { current: this.el.currentTime, total: this.el.duration }, this.name);
  };

  HTML5Video.prototype._onProgress = function _onProgress() {
    if (!this.el.buffered.length) return;

    var buffered = [];
    var bufferedPos = 0;
    for (var i = 0; i < this.el.buffered.length; i++) {
      buffered = [].concat((0, _toConsumableArray3.default)(buffered), [{ start: this.el.buffered.start(i), end: this.el.buffered.end(i) }]);
      if (this.el.currentTime >= buffered[i].start && this.el.currentTime <= buffered[i].end) bufferedPos = i;
    }
    var progress = {
      start: buffered[bufferedPos].start,
      current: buffered[bufferedPos].end,
      total: this.el.duration
    };
    this.trigger(_events2.default.PLAYBACK_PROGRESS, progress, buffered);
  };

  HTML5Video.prototype._typeFor = function _typeFor(src) {
    var mimeTypes = HTML5Video._mimeTypesForUrl(src, MIMETYPES, this.options.mimeType);
    if (mimeTypes.length === 0) mimeTypes = HTML5Video._mimeTypesForUrl(src, AUDIO_MIMETYPES, this.options.mimeType);

    var mimeType = mimeTypes[0] || '';
    return mimeType.split(';')[0];
  };

  HTML5Video.prototype._ready = function _ready() {
    if (this._isReadyState) return;

    this._isReadyState = true;
    this.trigger(_events2.default.PLAYBACK_READY, this.name);
  };

  HTML5Video.prototype._checkForClosedCaptions = function _checkForClosedCaptions() {
    // Check if CC available only if current playback is HTML5Video
    if (this.isHTML5Video && !this._ccIsSetup) {
      if (this.hasClosedCaptionsTracks) {
        this.trigger(_events2.default.PLAYBACK_SUBTITLE_AVAILABLE);
        var trackId = this.closedCaptionsTrackId;
        this.closedCaptionsTrackId = trackId;
        this.handleTextTrackChange = this._handleTextTrackChange.bind(this);
        this.el.textTracks.addEventListener('change', this.handleTextTrackChange);
      }
      this._ccIsSetup = true;
    }
  };

  HTML5Video.prototype._handleTextTrackChange = function _handleTextTrackChange() {
    var tracks = this.closedCaptionsTracks;
    var track = tracks.find(function (track) {
      return track.track.mode === 'showing';
    }) || { id: -1 };

    if (this._ccTrackId !== track.id) {
      this._ccTrackId = track.id;
      this.trigger(_events2.default.PLAYBACK_SUBTITLE_CHANGED, {
        id: track.id
      });
    }
  };

  HTML5Video.prototype.render = function render() {
    if (this.options.playback.disableContextMenu) {
      this.$el.on('contextmenu', function () {
        return false;
      });
    }

    if (this._externalTracks && this._externalTracks.length > 0) {
      this.$el.html(this.template({
        tracks: this._externalTracks
      }));
    }

    this._ready();
    return this;
  };

  (0, _createClass3.default)(HTML5Video, [{
    key: 'isReady',
    get: function get() {
      return this._isReadyState;
    }
  }, {
    key: 'isHTML5Video',
    get: function get() {
      return this.name === HTML5Video.prototype.name;
    }
  }, {
    key: 'closedCaptionsTracks',
    get: function get() {
      var id = 0;
      var trackId = function trackId() {
        return id++;
      };
      var textTracks = this.el.textTracks ? (0, _from2.default)(this.el.textTracks) : [];

      return textTracks.filter(function (track) {
        return track.kind === 'subtitles' || track.kind === 'captions';
      }).map(function (track) {
        return { id: trackId(), name: track.label, track: track };
      });
    }
  }, {
    key: 'closedCaptionsTrackId',
    get: function get() {
      return this._ccTrackId;
    },
    set: function set(trackId) {
      if (!(0, _utils.isNumber)(trackId)) return;

      var tracks = this.closedCaptionsTracks;
      var showingTrack = void 0;

      // Note: -1 is for hide all tracks
      if (trackId !== -1) {
        showingTrack = tracks.find(function (track) {
          return track.id === trackId;
        });
        if (!showingTrack) return; // Track id not found

        if (showingTrack.track.mode === 'showing') return; // Track already showing
      }

      // Since it is possible to display multiple tracks,
      // ensure that all tracks are hidden.
      tracks.filter(function (track) {
        return track.track.mode !== 'hidden';
      }).forEach(function (track) {
        return track.track.mode = 'hidden';
      });

      showingTrack && (showingTrack.track.mode = 'showing');

      this._ccTrackId = trackId;
      this.trigger(_events2.default.PLAYBACK_SUBTITLE_CHANGED, {
        id: trackId
      });
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_tracks2.default);
    }
  }]);
  return HTML5Video;
}(_playback2.default);

exports.default = HTML5Video;


HTML5Video._mimeTypesForUrl = function (resourceUrl, mimeTypesByExtension, mimeType) {
  var extension = (resourceUrl.split('?')[0].match(/.*\.(.*)$/) || [])[1];
  var mimeTypes = mimeType || extension && mimeTypesByExtension[extension.toLowerCase()] || [];
  return mimeTypes.constructor === Array ? mimeTypes : [mimeTypes];
};

HTML5Video._canPlay = function (type, mimeTypesByExtension, resourceUrl, mimeType) {
  var mimeTypes = HTML5Video._mimeTypesForUrl(resourceUrl, mimeTypesByExtension, mimeType);
  var media = document.createElement(type);
  return !!mimeTypes.filter(function (mediaType) {
    return !!media.canPlayType(mediaType).replace(/no/, '');
  })[0];
};

HTML5Video.canPlay = function (resourceUrl, mimeType) {
  return HTML5Video._canPlay('audio', AUDIO_MIMETYPES, resourceUrl, mimeType) || HTML5Video._canPlay('video', MIMETYPES, resourceUrl, mimeType);
};
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/playbacks/html5_video/index.js":
/*!********************************************!*\
  !*** ./src/playbacks/html5_video/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _html5_video = __webpack_require__(/*! ./html5_video */ "./src/playbacks/html5_video/html5_video.js");

var _html5_video2 = _interopRequireDefault(_html5_video);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html5_video2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html5_video/public/style.scss":
/*!*****************************************************!*\
  !*** ./src/playbacks/html5_video/public/style.scss ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./style.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html5_video/public/style.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/playbacks/html5_video/public/tracks.html":
/*!******************************************************!*\
  !*** ./src/playbacks/html5_video/public/tracks.html ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<% for (var i = 0; i < tracks.length; i++) { %>\n  <track data-html5-video-track=\"<%= i %>\" kind=\"<%= tracks[i].kind %>\" label=\"<%= tracks[i].label %>\" srclang=\"<%= tracks[i].lang %>\" src=\"<%= tracks[i].src %>\" />\n<% }; %>\n";

/***/ }),

/***/ "./src/playbacks/html_img/html_img.js":
/*!********************************************!*\
  !*** ./src/playbacks/html_img/html_img.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

__webpack_require__(/*! ./public/style.scss */ "./src/playbacks/html_img/public/style.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HTMLImg = function (_Playback) {
  (0, _inherits3.default)(HTMLImg, _Playback);

  HTMLImg.prototype.getPlaybackType = function getPlaybackType() {
    return _playback2.default.NO_OP;
  };

  (0, _createClass3.default)(HTMLImg, [{
    key: 'name',
    get: function get() {
      return 'html_img';
    }
  }, {
    key: 'tagName',
    get: function get() {
      return 'img';
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'data-html-img': ''
      };
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'load': '_onLoad',
        'abort': '_onError',
        'error': '_onError'
      };
    }
  }]);

  function HTMLImg(params) {
    (0, _classCallCheck3.default)(this, HTMLImg);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Playback.call(this, params));

    _this.el.src = params.src;
    return _this;
  }

  HTMLImg.prototype.render = function render() {
    this.trigger(_events2.default.PLAYBACK_READY, this.name);
    return this;
  };

  HTMLImg.prototype._onLoad = function _onLoad() {
    this.trigger(_events2.default.PLAYBACK_ENDED, this.name);
  };

  HTMLImg.prototype._onError = function _onError(evt) {
    var m = evt.type === 'error' ? 'load error' : 'loading aborted';
    this.trigger(_events2.default.PLAYBACK_ERROR, { message: m }, this.name);
  };

  return HTMLImg;
}(_playback2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = HTMLImg;


HTMLImg.canPlay = function (resource) {
  return (/\.(png|jpg|jpeg|gif|bmp|tiff|pgm|pnm|webp)(|\?.*)$/i.test(resource)
  );
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html_img/index.js":
/*!*****************************************!*\
  !*** ./src/playbacks/html_img/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _html_img = __webpack_require__(/*! ./html_img */ "./src/playbacks/html_img/html_img.js");

var _html_img2 = _interopRequireDefault(_html_img);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _html_img2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/html_img/public/style.scss":
/*!**************************************************!*\
  !*** ./src/playbacks/html_img/public/style.scss ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./style.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/html_img/public/style.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/playbacks/no_op/index.js":
/*!**************************************!*\
  !*** ./src/playbacks/no_op/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _no_op = __webpack_require__(/*! ./no_op */ "./src/playbacks/no_op/no_op.js");

var _no_op2 = _interopRequireDefault(_no_op);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _no_op2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/no_op/no_op.js":
/*!**************************************!*\
  !*** ./src/playbacks/no_op/no_op.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _error = __webpack_require__(/*! ./public/error.html */ "./src/playbacks/no_op/public/error.html");

var _error2 = _interopRequireDefault(_error);

__webpack_require__(/*! ./public/style.scss */ "./src/playbacks/no_op/public/style.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NoOp = function (_Playback) {
  (0, _inherits3.default)(NoOp, _Playback);
  (0, _createClass3.default)(NoOp, [{
    key: 'name',
    get: function get() {
      return 'no_op';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_error2.default);
    }
  }, {
    key: 'attributes',
    get: function get() {
      return { 'data-no-op': '' };
    }
  }]);

  function NoOp() {
    (0, _classCallCheck3.default)(this, NoOp);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = (0, _possibleConstructorReturn3.default)(this, _Playback.call.apply(_Playback, [this].concat(args)));

    _this._noiseFrameNum = -1;
    return _this;
  }

  NoOp.prototype.render = function render() {
    var playbackNotSupported = this.options.playbackNotSupportedMessage || this.i18n.t('playback_not_supported');
    this.$el.html(this.template({ message: playbackNotSupported }));
    this.trigger(_events2.default.PLAYBACK_READY, this.name);
    var showForNoOp = !!(this.options.poster && this.options.poster.showForNoOp);
    if (this.options.autoPlay || !showForNoOp) this._animate();

    return this;
  };

  NoOp.prototype._noise = function _noise() {
    this._noiseFrameNum = (this._noiseFrameNum + 1) % 5;
    if (this._noiseFrameNum) {
      // only update noise every 5 frames to save cpu
      return;
    }

    var idata = this.context.createImageData(this.context.canvas.width, this.context.canvas.height);
    var buffer32 = void 0;
    try {
      buffer32 = new Uint32Array(idata.data.buffer);
    } catch (err) {
      buffer32 = new Uint32Array(this.context.canvas.width * this.context.canvas.height * 4);
      var data = idata.data;
      for (var i = 0; i < data.length; i++) {
        buffer32[i] = data[i];
      }
    }

    var len = buffer32.length,
        m = Math.random() * 6 + 4;
    var run = 0,
        color = 0;
    for (var _i = 0; _i < len;) {
      if (run < 0) {
        run = m * Math.random();
        var p = Math.pow(Math.random(), 0.4);
        color = 255 * p << 24;
      }
      run -= 1;
      buffer32[_i++] = color;
    }
    this.context.putImageData(idata, 0, 0);
  };

  NoOp.prototype._loop = function _loop() {
    var _this2 = this;

    if (this._stop) return;

    this._noise();
    this._animationHandle = (0, _utils.requestAnimationFrame)(function () {
      return _this2._loop();
    });
  };

  NoOp.prototype.destroy = function destroy() {
    if (this._animationHandle) {
      (0, _utils.cancelAnimationFrame)(this._animationHandle);
      this._stop = true;
    }
  };

  NoOp.prototype._animate = function _animate() {
    this.canvas = this.$el.find('canvas[data-no-op-canvas]')[0];
    this.context = this.canvas.getContext('2d');
    this._loop();
  };

  return NoOp;
}(_playback2.default);

exports.default = NoOp;


NoOp.canPlay = function (source) {
  // eslint-disable-line no-unused-vars
  return true;
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/playbacks/no_op/public/error.html":
/*!***********************************************!*\
  !*** ./src/playbacks/no_op/public/error.html ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<canvas data-no-op-canvas></canvas>\n<p data-no-op-msg><%=message%><p>\n";

/***/ }),

/***/ "./src/playbacks/no_op/public/style.scss":
/*!***********************************************!*\
  !*** ./src/playbacks/no_op/public/style.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./style.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/playbacks/no_op/public/style.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/click_to_pause/click_to_pause.js":
/*!******************************************************!*\
  !*** ./src/plugins/click_to_pause/click_to_pause.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _container_plugin = __webpack_require__(/*! ../../base/container_plugin */ "./src/base/container_plugin.js");

var _container_plugin2 = _interopRequireDefault(_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ClickToPausePlugin = function (_ContainerPlugin) {
  (0, _inherits3.default)(ClickToPausePlugin, _ContainerPlugin);
  (0, _createClass3.default)(ClickToPausePlugin, [{
    key: 'name',
    get: function get() {
      return 'click_to_pause';
    }
  }]);

  function ClickToPausePlugin(container) {
    (0, _classCallCheck3.default)(this, ClickToPausePlugin);
    return (0, _possibleConstructorReturn3.default)(this, _ContainerPlugin.call(this, container));
  }

  ClickToPausePlugin.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.container, _events2.default.CONTAINER_CLICK, this.click);
    this.listenTo(this.container, _events2.default.CONTAINER_SETTINGSUPDATE, this.settingsUpdate);
  };

  ClickToPausePlugin.prototype.click = function click() {
    var _this2 = this;

    if (this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrEnabled()) {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
        return;
      }
      this.timer = setTimeout(function () {
        clearTimeout(_this2.timer);
        _this2.timer = null;
        if (_this2.container.isPlaying()) _this2.container.pause();else _this2.container.play();
      }, 300);
    }
  };

  ClickToPausePlugin.prototype.settingsUpdate = function settingsUpdate() {
    var pointerEnabled = this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrEnabled();
    if (pointerEnabled === this.pointerEnabled) return;

    var method = pointerEnabled ? 'addClass' : 'removeClass';
    this.container.$el[method]('pointer-enabled');
    this.pointerEnabled = pointerEnabled;
  };

  return ClickToPausePlugin;
}(_container_plugin2.default); //Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = ClickToPausePlugin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/click_to_pause/index.js":
/*!*********************************************!*\
  !*** ./src/plugins/click_to_pause/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _click_to_pause = __webpack_require__(/*! ./click_to_pause */ "./src/plugins/click_to_pause/click_to_pause.js");

var _click_to_pause2 = _interopRequireDefault(_click_to_pause);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _click_to_pause2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/closed_captions/closed_captions.js":
/*!********************************************************!*\
  !*** ./src/plugins/closed_captions/closed_captions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _closed_captions = __webpack_require__(/*! ./public/closed_captions.html */ "./src/plugins/closed_captions/public/closed_captions.html");

var _closed_captions2 = _interopRequireDefault(_closed_captions);

__webpack_require__(/*! ./public/closed_captions.scss */ "./src/plugins/closed_captions/public/closed_captions.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ClosedCaptions = function (_UICorePlugin) {
  (0, _inherits3.default)(ClosedCaptions, _UICorePlugin);
  (0, _createClass3.default)(ClosedCaptions, [{
    key: 'name',
    get: function get() {
      return 'closed_captions';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_closed_captions2.default);
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'click [data-cc-button]': 'toggleContextMenu',
        'click [data-cc-select]': 'onTrackSelect'
      };
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'cc-controls',
        'data-cc-controls': ''
      };
    }
  }]);

  function ClosedCaptions(core) {
    (0, _classCallCheck3.default)(this, ClosedCaptions);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UICorePlugin.call(this, core));

    var config = core.options.closedCaptionsConfig;
    _this._title = config && config.title ? config.title : null;
    _this._ariaLabel = config && config.ariaLabel ? config.ariaLabel : 'cc-button';
    _this._labelCb = config && config.labelCallback && typeof config.labelCallback === 'function' ? config.labelCallback : function (track) {
      return track.name;
    };
    return _this;
  }

  ClosedCaptions.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged);
    this.listenTo(this.core.mediaControl, _events2.default.MEDIACONTROL_RENDERED, this.render);
    this.listenTo(this.core.mediaControl, _events2.default.MEDIACONTROL_HIDE, this.hideContextMenu);
    this.container = this.core.getCurrentContainer();
    if (this.container) {
      this.listenTo(this.container, _events2.default.CONTAINER_SUBTITLE_AVAILABLE, this.onSubtitleAvailable);
      this.listenTo(this.container, _events2.default.CONTAINER_SUBTITLE_CHANGED, this.onSubtitleChanged);
      this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.onContainerStop);
    }
  };

  ClosedCaptions.prototype.onContainerStop = function onContainerStop() {
    this.ccAvailable(false);
  };

  ClosedCaptions.prototype.containerChanged = function containerChanged() {
    this.ccAvailable(false);
    this.stopListening();
    this.bindEvents();
  };

  ClosedCaptions.prototype.onSubtitleAvailable = function onSubtitleAvailable() {
    this.renderCcButton();
    this.ccAvailable(true);
  };

  ClosedCaptions.prototype.onSubtitleChanged = function onSubtitleChanged(track) {
    this.setCurrentContextMenuElement(track.id);
  };

  ClosedCaptions.prototype.onTrackSelect = function onTrackSelect(event) {
    var trackId = parseInt(event.target.dataset.ccSelect, 10);
    this.container.closedCaptionsTrackId = trackId;
    this.hideContextMenu();
    event.stopPropagation();
    return false;
  };

  ClosedCaptions.prototype.ccAvailable = function ccAvailable(hasCC) {
    var method = hasCC ? 'addClass' : 'removeClass';
    this.$el[method]('available');
  };

  ClosedCaptions.prototype.toggleContextMenu = function toggleContextMenu() {
    this.$el.find('ul').toggle();
  };

  ClosedCaptions.prototype.hideContextMenu = function hideContextMenu() {
    this.$el.find('ul').hide();
  };

  ClosedCaptions.prototype.contextMenuElement = function contextMenuElement(id) {
    return this.$el.find('ul a' + (!isNaN(id) ? '[data-cc-select="' + id + '"]' : '')).parent();
  };

  ClosedCaptions.prototype.setCurrentContextMenuElement = function setCurrentContextMenuElement(trackId) {
    if (this._trackId !== trackId) {
      this.contextMenuElement().removeClass('current');
      this.contextMenuElement(trackId).addClass('current');
      var method = trackId > -1 ? 'addClass' : 'removeClass';
      this.$ccButton[method]('enabled');
      this._trackId = trackId;
    }
  };

  ClosedCaptions.prototype.renderCcButton = function renderCcButton() {
    var tracks = this.container ? this.container.closedCaptionsTracks : [];
    for (var i = 0; i < tracks.length; i++) {
      tracks[i].label = this._labelCb(tracks[i]);
    }this.$el.html(this.template({
      ariaLabel: this._ariaLabel,
      disabledLabel: this.core.i18n.t('disabled'),
      title: this._title,
      tracks: tracks
    }));

    this.$ccButton = this.$el.find('button.cc-button[data-cc-button]');
    this.$ccButton.append(_utils.SvgIcons.cc);
    this.$el.append(this.style);
  };

  ClosedCaptions.prototype.render = function render() {
    this.renderCcButton();

    var $fullscreen = this.core.mediaControl.$el.find('button[data-fullscreen]');
    if ($fullscreen[0]) this.$el.insertAfter($fullscreen);else this.core.mediaControl.$el.find('.media-control-right-panel[data-media-control]').prepend(this.$el);

    return this;
  };

  return ClosedCaptions;
}(_ui_core_plugin2.default);

exports.default = ClosedCaptions;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/closed_captions/index.js":
/*!**********************************************!*\
  !*** ./src/plugins/closed_captions/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _closed_captions = __webpack_require__(/*! ./closed_captions */ "./src/plugins/closed_captions/closed_captions.js");

var _closed_captions2 = _interopRequireDefault(_closed_captions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _closed_captions2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/closed_captions/public/closed_captions.html":
/*!*****************************************************************!*\
  !*** ./src/plugins/closed_captions/public/closed_captions.html ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<button type=\"button\" class=\"cc-button media-control-button media-control-icon\" data-cc-button aria-label=\"<%= ariaLabel %>\"></button>\n<ul>\n  <% if (title) { %>\n  <li data-title><%= title %></li>\n  <% }; %>\n  <li><a href=\"#\" data-cc-select=\"-1\"><%= disabledLabel %></a></li>\n  <% for (var i = 0; i < tracks.length; i++) { %>\n    <li><a href=\"#\" data-cc-select=\"<%= tracks[i].id %>\"><%= tracks[i].label %></a></li>\n  <% }; %>\n</ul>\n";

/***/ }),

/***/ "./src/plugins/closed_captions/public/closed_captions.scss":
/*!*****************************************************************!*\
  !*** ./src/plugins/closed_captions/public/closed_captions.scss ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./closed_captions.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/closed_captions/public/closed_captions.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/dvr_controls/dvr_controls.js":
/*!**************************************************!*\
  !*** ./src/plugins/dvr_controls/dvr_controls.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _index = __webpack_require__(/*! ./public/index.html */ "./src/plugins/dvr_controls/public/index.html");

var _index2 = _interopRequireDefault(_index);

__webpack_require__(/*! ./public/dvr_controls.scss */ "./src/plugins/dvr_controls/public/dvr_controls.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DVRControls = function (_UICorePlugin) {
  (0, _inherits3.default)(DVRControls, _UICorePlugin);
  (0, _createClass3.default)(DVRControls, [{
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_index2.default);
    }
  }, {
    key: 'name',
    get: function get() {
      return 'dvr_controls';
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'click .live-button': 'click'
      };
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'dvr-controls',
        'data-dvr-controls': ''
      };
    }
  }]);

  function DVRControls(core) {
    (0, _classCallCheck3.default)(this, DVRControls);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UICorePlugin.call(this, core));

    _this.settingsUpdate();
    return _this;
  }

  DVRControls.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core.mediaControl, _events2.default.MEDIACONTROL_CONTAINERCHANGED, this.containerChanged);
    this.listenTo(this.core.mediaControl, _events2.default.MEDIACONTROL_RENDERED, this.settingsUpdate);
    this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.render);
    if (this.core.getCurrentContainer()) {
      this.listenToOnce(this.core.getCurrentContainer(), _events2.default.CONTAINER_TIMEUPDATE, this.render);
      this.listenTo(this.core.getCurrentContainer(), _events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, this.dvrChanged);
    }
  };

  DVRControls.prototype.containerChanged = function containerChanged() {
    this.stopListening();
    this.bindEvents();
  };

  DVRControls.prototype.dvrChanged = function dvrChanged(dvrEnabled) {
    if (this.core.getPlaybackType() !== _playback2.default.LIVE) return;
    this.settingsUpdate();
    this.core.mediaControl.$el.addClass('live');
    if (dvrEnabled) {
      this.core.mediaControl.$el.addClass('dvr');
      this.core.mediaControl.$el.find('.media-control-indicator[data-position], .media-control-indicator[data-duration]').hide();
    } else {
      this.core.mediaControl.$el.removeClass('dvr');
    }
  };

  DVRControls.prototype.click = function click() {
    var mediaControl = this.core.mediaControl;
    var container = mediaControl.container;
    if (!container.isPlaying()) container.play();

    if (mediaControl.$el.hasClass('dvr')) container.seek(container.getDuration());
  };

  DVRControls.prototype.settingsUpdate = function settingsUpdate() {
    var _this2 = this;

    this.stopListening();
    this.core.mediaControl.$el.removeClass('live');
    if (this.shouldRender()) {
      this.render();
      this.$el.click(function () {
        return _this2.click();
      });
    }
    this.bindEvents();
  };

  DVRControls.prototype.shouldRender = function shouldRender() {
    var useDvrControls = this.core.options.useDvrControls === undefined || !!this.core.options.useDvrControls;
    return useDvrControls && this.core.getPlaybackType() === _playback2.default.LIVE;
  };

  DVRControls.prototype.render = function render() {
    this.$el.html(this.template({
      live: this.core.i18n.t('live'),
      backToLive: this.core.i18n.t('back_to_live')
    }));
    if (this.shouldRender()) {
      this.core.mediaControl.$el.addClass('live');
      this.core.mediaControl.$('.media-control-left-panel[data-media-control]').append(this.$el);
    }
    return this;
  };

  return DVRControls;
}(_ui_core_plugin2.default);

exports.default = DVRControls;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/dvr_controls/index.js":
/*!*******************************************!*\
  !*** ./src/plugins/dvr_controls/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dvr_controls = __webpack_require__(/*! ./dvr_controls */ "./src/plugins/dvr_controls/dvr_controls.js");

var _dvr_controls2 = _interopRequireDefault(_dvr_controls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _dvr_controls2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/dvr_controls/public/dvr_controls.scss":
/*!***********************************************************!*\
  !*** ./src/plugins/dvr_controls/public/dvr_controls.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./dvr_controls.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/dvr_controls/public/dvr_controls.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/dvr_controls/public/index.html":
/*!****************************************************!*\
  !*** ./src/plugins/dvr_controls/public/index.html ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"live-info\"><%= live %></div>\n<button type=\"button\" class=\"live-button\" aria-label=\"<%= backToLive %>\"><%= backToLive %></button>\n";

/***/ }),

/***/ "./src/plugins/end_video.js":
/*!**********************************!*\
  !*** ./src/plugins/end_video.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = __webpack_require__(/*! ../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _core_plugin = __webpack_require__(/*! ../base/core_plugin */ "./src/base/core_plugin.js");

var _core_plugin2 = _interopRequireDefault(_core_plugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EndVideo = function (_CorePlugin) {
  (0, _inherits3.default)(EndVideo, _CorePlugin);

  function EndVideo() {
    (0, _classCallCheck3.default)(this, EndVideo);
    return (0, _possibleConstructorReturn3.default)(this, _CorePlugin.apply(this, arguments));
  }

  EndVideo.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged);
    var container = this.core.activeContainer;
    if (container) {
      this.listenTo(container, _events2.default.CONTAINER_ENDED, this.ended);
      this.listenTo(container, _events2.default.CONTAINER_STOP, this.ended);
    }
  };

  EndVideo.prototype.containerChanged = function containerChanged() {
    this.stopListening();
    this.bindEvents();
  };

  EndVideo.prototype.ended = function ended() {
    var exitOnEnd = typeof this.core.options.exitFullscreenOnEnd === 'undefined' || this.core.options.exitFullscreenOnEnd;
    if (exitOnEnd && this.core.isFullscreen()) this.core.toggleFullscreen();
  };

  (0, _createClass3.default)(EndVideo, [{
    key: 'name',
    get: function get() {
      return 'end_video';
    }
  }]);
  return EndVideo;
}(_core_plugin2.default);

exports.default = EndVideo;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/error_screen/error_screen.js":
/*!**************************************************!*\
  !*** ./src/plugins/error_screen/error_screen.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _error = __webpack_require__(/*! ../../components/error/ */ "./src/components/error/index.js");

var _error2 = _interopRequireDefault(_error);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _error_screen = __webpack_require__(/*! ./public/error_screen.html */ "./src/plugins/error_screen/public/error_screen.html");

var _error_screen2 = _interopRequireDefault(_error_screen);

__webpack_require__(/*! ./public/error_screen.scss */ "./src/plugins/error_screen/public/error_screen.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ErrorScreen = function (_UICorePlugin) {
  (0, _inherits3.default)(ErrorScreen, _UICorePlugin);
  (0, _createClass3.default)(ErrorScreen, [{
    key: 'name',
    get: function get() {
      return 'error_screen';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_error_screen2.default);
    }
  }, {
    key: 'container',
    get: function get() {
      return this.core.getCurrentContainer();
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'player-error-screen',
        'data-error-screen': ''
      };
    }
  }]);

  function ErrorScreen(core) {
    var _ret;

    (0, _classCallCheck3.default)(this, ErrorScreen);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UICorePlugin.call(this, core));

    if (_this.options.disableErrorScreen) return _ret = _this.disable(), (0, _possibleConstructorReturn3.default)(_this, _ret);
    return _this;
  }

  ErrorScreen.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core, _events2.default.ERROR, this.onError);
    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this.onContainerChanged);
  };

  ErrorScreen.prototype.bindReload = function bindReload() {
    this.reloadButton = this.$el.find('.player-error-screen__reload');
    this.reloadButton && this.reloadButton.on('click', this.reload.bind(this));
  };

  ErrorScreen.prototype.reload = function reload() {
    var _this2 = this;

    this.listenToOnce(this.core, _events2.default.CORE_READY, function () {
      return _this2.container.play();
    });
    this.core.load(this.options.sources, this.options.mimeType);
    this.unbindReload();
  };

  ErrorScreen.prototype.unbindReload = function unbindReload() {
    this.reloadButton && this.reloadButton.off('click');
  };

  ErrorScreen.prototype.onContainerChanged = function onContainerChanged() {
    this.err = null;
    this.unbindReload();
    this.hide();
  };

  ErrorScreen.prototype.onError = function onError() {
    var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (err.level === _error2.default.Levels.FATAL) {
      this.err = err;
      this.container.disableMediaControl();
      this.container.stop();
      this.show();
    }
  };

  ErrorScreen.prototype.show = function show() {
    this.render();
    this.$el.show();
  };

  ErrorScreen.prototype.hide = function hide() {
    this.$el.hide();
  };

  ErrorScreen.prototype.render = function render() {
    if (!this.err) return;

    this.$el.html(this.template({
      title: this.err.UI.title,
      message: this.err.UI.message,
      code: this.err.code,
      icon: this.err.UI.icon || '',
      reloadIcon: _utils.SvgIcons.reload
    }));

    this.core.$el.append(this.el);

    this.bindReload();

    return this;
  };

  return ErrorScreen;
}(_ui_core_plugin2.default);

exports.default = ErrorScreen;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/error_screen/index.js":
/*!*******************************************!*\
  !*** ./src/plugins/error_screen/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _error_screen = __webpack_require__(/*! ./error_screen */ "./src/plugins/error_screen/error_screen.js");

var _error_screen2 = _interopRequireDefault(_error_screen);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _error_screen2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/error_screen/public/error_screen.html":
/*!***********************************************************!*\
  !*** ./src/plugins/error_screen/public/error_screen.html ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"player-error-screen__content\" data-error-screen>\n  <% if (icon) { %>\n  <div class=\"player-error-screen__icon\" data-error-screen><%= icon %></div>\n  <% } %>\n  <div class=\"player-error-screen__title\" data-error-screen><%= title %></div>\n  <div class=\"player-error-screen__message\" data-error-screen><%= message %></div>\n  <div class=\"player-error-screen__code\" data-error-screen>Error code: <%= code %></div>\n  <div class=\"player-error-screen__reload\" data-error-screen><%= reloadIcon %></div>\n</div>\n";

/***/ }),

/***/ "./src/plugins/error_screen/public/error_screen.scss":
/*!***********************************************************!*\
  !*** ./src/plugins/error_screen/public/error_screen.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./error_screen.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/error_screen/public/error_screen.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/favicon/favicon.js":
/*!****************************************!*\
  !*** ./src/plugins/favicon/favicon.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _core_plugin = __webpack_require__(/*! ../../base/core_plugin */ "./src/base/core_plugin.js");

var _core_plugin2 = _interopRequireDefault(_core_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var oldIcon = (0, _clapprZepto2.default)('link[rel="shortcut icon"]');

var Favicon = function (_CorePlugin) {
  (0, _inherits3.default)(Favicon, _CorePlugin);
  (0, _createClass3.default)(Favicon, [{
    key: 'name',
    get: function get() {
      return 'favicon';
    }
  }, {
    key: 'oldIcon',
    get: function get() {
      return oldIcon;
    }
  }]);

  function Favicon(core) {
    (0, _classCallCheck3.default)(this, Favicon);

    var _this = (0, _possibleConstructorReturn3.default)(this, _CorePlugin.call(this, core));

    _this._container = null;
    _this.configure();
    return _this;
  }

  Favicon.prototype.configure = function configure() {
    if (this.core.options.changeFavicon) {
      if (!this.enabled) {
        this.stopListening(this.core, _events2.default.CORE_OPTIONS_CHANGE);
        this.enable();
      }
    } else if (this.enabled) {
      this.disable();
      this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.configure);
    }
  };

  Favicon.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.configure);
    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this.containerChanged);
    this.core.activeContainer && this.containerChanged();
  };

  Favicon.prototype.containerChanged = function containerChanged() {
    this._container && this.stopListening(this._container);
    this._container = this.core.activeContainer;
    this.listenTo(this._container, _events2.default.CONTAINER_PLAY, this.setPlayIcon);
    this.listenTo(this._container, _events2.default.CONTAINER_PAUSE, this.setPauseIcon);
    this.listenTo(this._container, _events2.default.CONTAINER_STOP, this.resetIcon);
    this.listenTo(this._container, _events2.default.CONTAINER_ENDED, this.resetIcon);
    this.listenTo(this._container, _events2.default.CONTAINER_ERROR, this.resetIcon);
    this.resetIcon();
  };

  Favicon.prototype.disable = function disable() {
    _CorePlugin.prototype.disable.call(this);
    this.resetIcon();
  };

  Favicon.prototype.destroy = function destroy() {
    _CorePlugin.prototype.destroy.call(this);
    this.resetIcon();
  };

  Favicon.prototype.createIcon = function createIcon(svg) {
    var canvas = (0, _clapprZepto2.default)('<canvas/>');
    canvas[0].width = 16;
    canvas[0].height = 16;
    var ctx = canvas[0].getContext('2d');
    ctx.fillStyle = '#000';
    var d = (0, _clapprZepto2.default)(svg).find('path').attr('d');
    var path = new Path2D(d);
    ctx.fill(path);
    var icon = (0, _clapprZepto2.default)('<link rel="shortcut icon" type="image/png"/>');
    icon.attr('href', canvas[0].toDataURL('image/png'));
    return icon;
  };

  Favicon.prototype.setPlayIcon = function setPlayIcon() {
    if (!this.playIcon) this.playIcon = this.createIcon(_utils.SvgIcons.play);

    this.changeIcon(this.playIcon);
  };

  Favicon.prototype.setPauseIcon = function setPauseIcon() {
    if (!this.pauseIcon) this.pauseIcon = this.createIcon(_utils.SvgIcons.pause);

    this.changeIcon(this.pauseIcon);
  };

  Favicon.prototype.resetIcon = function resetIcon() {
    (0, _clapprZepto2.default)('link[rel="shortcut icon"]').remove();
    (0, _clapprZepto2.default)('head').append(this.oldIcon);
  };

  Favicon.prototype.changeIcon = function changeIcon(icon) {
    if (icon) {
      (0, _clapprZepto2.default)('link[rel="shortcut icon"]').remove();
      (0, _clapprZepto2.default)('head').append(icon);
    }
  };

  return Favicon;
}(_core_plugin2.default);

exports.default = Favicon;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/favicon/index.js":
/*!**************************************!*\
  !*** ./src/plugins/favicon/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _favicon = __webpack_require__(/*! ./favicon.js */ "./src/plugins/favicon/favicon.js");

var _favicon2 = _interopRequireDefault(_favicon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _favicon2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/google_analytics/google_analytics.js":
/*!**********************************************************!*\
  !*** ./src/plugins/google_analytics/google_analytics.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _container_plugin = __webpack_require__(/*! ../../base/container_plugin */ "./src/base/container_plugin.js");

var _container_plugin2 = _interopRequireDefault(_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var GoogleAnalytics = function (_ContainerPlugin) {
  (0, _inherits3.default)(GoogleAnalytics, _ContainerPlugin);
  (0, _createClass3.default)(GoogleAnalytics, [{
    key: 'name',
    get: function get() {
      return 'google_analytics';
    }
  }]);

  function GoogleAnalytics(container) {
    (0, _classCallCheck3.default)(this, GoogleAnalytics);

    var _this = (0, _possibleConstructorReturn3.default)(this, _ContainerPlugin.call(this, container));

    if (_this.container.options.gaAccount) {
      _this.account = _this.container.options.gaAccount;
      _this.trackerName = _this.container.options.gaTrackerName ? _this.container.options.gaTrackerName + '.' : 'Clappr.';
      _this.domainName = _this.container.options.gaDomainName;
      _this.currentHDState = undefined;
      _this.embedScript();
    }
    return _this;
  }

  GoogleAnalytics.prototype.embedScript = function embedScript() {
    var _this2 = this;

    if (!window._gat) {
      var script = document.createElement('script');
      script.setAttribute('type', 'text/javascript');
      script.setAttribute('async', 'async');
      script.setAttribute('src', '//www.google-analytics.com/ga.js');
      script.onload = function () {
        return _this2.addEventListeners();
      };
      document.body.appendChild(script);
    } else {
      this.addEventListeners();
    }
  };

  GoogleAnalytics.prototype.addEventListeners = function addEventListeners() {
    var _this3 = this;

    if (this.container) {
      this.listenTo(this.container, _events2.default.CONTAINER_READY, this.onReady);
      this.listenTo(this.container, _events2.default.CONTAINER_PLAY, this.onPlay);
      this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.onStop);
      this.listenTo(this.container, _events2.default.CONTAINER_PAUSE, this.onPause);
      this.listenTo(this.container, _events2.default.CONTAINER_ENDED, this.onEnded);
      this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERING, this.onBuffering);
      this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERFULL, this.onBufferFull);
      this.listenTo(this.container, _events2.default.CONTAINER_ERROR, this.onError);
      this.listenTo(this.container, _events2.default.CONTAINER_PLAYBACKSTATE, this.onPlaybackChanged);
      this.listenTo(this.container, _events2.default.CONTAINER_VOLUME, function (event) {
        return _this3.onVolumeChanged(event);
      });
      this.listenTo(this.container, _events2.default.CONTAINER_SEEK, function (event) {
        return _this3.onSeek(event);
      });
      this.listenTo(this.container, _events2.default.CONTAINER_FULL_SCREEN, this.onFullscreen);
      this.listenTo(this.container, _events2.default.CONTAINER_HIGHDEFINITIONUPDATE, this.onHD);
      this.listenTo(this.container, _events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, this.onDVR);
    }
    _gaq.push([this.trackerName + '_setAccount', this.account]);
    if (this.domainName) _gaq.push([this.trackerName + '_setDomainName', this.domainName]);
  };

  GoogleAnalytics.prototype.onReady = function onReady() {
    this.push(['Video', 'Playback', this.container.playback.name]);
  };

  GoogleAnalytics.prototype.onPlay = function onPlay() {
    this.push(['Video', 'Play', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onStop = function onStop() {
    this.push(['Video', 'Stop', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onEnded = function onEnded() {
    this.push(['Video', 'Ended', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onBuffering = function onBuffering() {
    this.push(['Video', 'Buffering', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onBufferFull = function onBufferFull() {
    this.push(['Video', 'Bufferfull', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onError = function onError() {
    this.push(['Video', 'Error', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onHD = function onHD(isHD) {
    var status = isHD ? 'ON' : 'OFF';
    if (status !== this.currentHDState) {
      this.currentHDState = status;
      this.push(['Video', 'HD - ' + status, this.container.playback.src]);
    }
  };

  GoogleAnalytics.prototype.onPlaybackChanged = function onPlaybackChanged(playbackState) {
    if (playbackState.type !== null) this.push(['Video', 'Playback Type - ' + playbackState.type, this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onDVR = function onDVR(dvrInUse) {
    var status = dvrInUse ? 'ON' : 'OFF';
    this.push(['Interaction', 'DVR - ' + status, this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onPause = function onPause() {
    this.push(['Video', 'Pause', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onSeek = function onSeek() {
    this.push(['Video', 'Seek', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onVolumeChanged = function onVolumeChanged() {
    this.push(['Interaction', 'Volume', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.onFullscreen = function onFullscreen() {
    this.push(['Interaction', 'Fullscreen', this.container.playback.src]);
  };

  GoogleAnalytics.prototype.push = function push(array) {
    var res = [this.trackerName + '_trackEvent'].concat(array);
    _gaq.push(res);
  };

  return GoogleAnalytics;
}(_container_plugin2.default);

exports.default = GoogleAnalytics;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/google_analytics/index.js":
/*!***********************************************!*\
  !*** ./src/plugins/google_analytics/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _google_analytics = __webpack_require__(/*! ./google_analytics */ "./src/plugins/google_analytics/google_analytics.js");

var _google_analytics2 = _interopRequireDefault(_google_analytics);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _google_analytics2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/log/index.js":
/*!**********************************!*\
  !*** ./src/plugins/log/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _log = __webpack_require__(/*! ./log */ "./src/plugins/log/log.js");

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _log2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/log/log.js":
/*!********************************!*\
  !*** ./src/plugins/log/log.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _vendor = __webpack_require__(/*! ../../vendor */ "./src/vendor/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BOLD = 'font-weight: bold; font-size: 13px;';
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var INFO = 'color: #006600;' + BOLD;
var DEBUG = 'color: #0000ff;' + BOLD;
var WARN = 'color: #ff8000;' + BOLD;
var ERROR = 'color: #ff0000;' + BOLD;

var LEVEL_DEBUG = 0;
var LEVEL_INFO = 1;
var LEVEL_WARN = 2;
var LEVEL_ERROR = 3;
var LEVEL_DISABLED = LEVEL_ERROR;

var COLORS = [DEBUG, INFO, WARN, ERROR, ERROR];
var DESCRIPTIONS = ['debug', 'info', 'warn', 'error', 'disabled'];

var Log = function () {
  function Log() {
    var _this = this;

    var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LEVEL_INFO;
    var offLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LEVEL_DISABLED;
    (0, _classCallCheck3.default)(this, Log);

    this.kibo = new _vendor.Kibo();
    this.kibo.down(['ctrl shift d'], function () {
      return _this.onOff();
    });
    this.BLACKLIST = ['timeupdate', 'playback:timeupdate', 'playback:progress', 'container:hover', 'container:timeupdate', 'container:progress'];
    this.level = level;
    this.offLevel = offLevel;
  }

  Log.prototype.debug = function debug(klass) {
    this.log(klass, LEVEL_DEBUG, Array.prototype.slice.call(arguments, 1));
  };

  Log.prototype.info = function info(klass) {
    this.log(klass, LEVEL_INFO, Array.prototype.slice.call(arguments, 1));
  };

  Log.prototype.warn = function warn(klass) {
    this.log(klass, LEVEL_WARN, Array.prototype.slice.call(arguments, 1));
  };

  Log.prototype.error = function error(klass) {
    this.log(klass, LEVEL_ERROR, Array.prototype.slice.call(arguments, 1));
  };

  Log.prototype.onOff = function onOff() {
    if (this.level === this.offLevel) {
      this.level = this.previousLevel;
    } else {
      this.previousLevel = this.level;
      this.level = this.offLevel;
    }
    // handle instances where console.log is unavailable
    if (window.console && window.console.log) window.console.log('%c[Clappr.Log] set log level to ' + DESCRIPTIONS[this.level], WARN);
  };

  Log.prototype.level = function level(newLevel) {
    this.level = newLevel;
  };

  Log.prototype.log = function log(klass, level, message) {
    if (this.BLACKLIST.indexOf(message[0]) >= 0) return;
    if (level < this.level) return;

    if (!message) {
      message = klass;
      klass = null;
    }
    var color = COLORS[level];
    var klassDescription = '';
    if (klass) klassDescription = '[' + klass + ']';

    if (window.console && window.console.log) window.console.log.apply(console, ['%c[' + DESCRIPTIONS[level] + ']' + klassDescription, color].concat(message));
  };

  return Log;
}();

exports.default = Log;


Log.LEVEL_DEBUG = LEVEL_DEBUG;
Log.LEVEL_INFO = LEVEL_INFO;
Log.LEVEL_WARN = LEVEL_WARN;
Log.LEVEL_ERROR = LEVEL_ERROR;

Log.getInstance = function () {
  if (this._instance === undefined) {
    this._instance = new this();
    this._instance.previousLevel = this._instance.level;
    this._instance.level = this._instance.offLevel;
  }
  return this._instance;
};

Log.setLevel = function (level) {
  this.getInstance().level = level;
};

Log.debug = function () {
  this.getInstance().debug.apply(this.getInstance(), arguments);
};
Log.info = function () {
  this.getInstance().info.apply(this.getInstance(), arguments);
};
Log.warn = function () {
  this.getInstance().warn.apply(this.getInstance(), arguments);
};
Log.error = function () {
  this.getInstance().error.apply(this.getInstance(), arguments);
};
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/media_control/index.js":
/*!********************************************!*\
  !*** ./src/plugins/media_control/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _media_control = __webpack_require__(/*! ./media_control */ "./src/plugins/media_control/media_control.js");

var _media_control2 = _interopRequireDefault(_media_control);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _media_control2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/media_control/media_control.js":
/*!****************************************************!*\
  !*** ./src/plugins/media_control/media_control.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _vendor = __webpack_require__(/*! ../../vendor */ "./src/vendor/index.js");

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _browser = __webpack_require__(/*! ../../components/browser */ "./src/components/browser/index.js");

var _browser2 = _interopRequireDefault(_browser);

var _mediator = __webpack_require__(/*! ../../components/mediator */ "./src/components/mediator.js");

var _mediator2 = _interopRequireDefault(_mediator);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

__webpack_require__(/*! ./public/media-control.scss */ "./src/plugins/media_control/public/media-control.scss");

var _mediaControl = __webpack_require__(/*! ./public/media-control.html */ "./src/plugins/media_control/public/media-control.html");

var _mediaControl2 = _interopRequireDefault(_mediaControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/**
 * The MediaControl is responsible for displaying the Player controls.
 */

var MediaControl = function (_UICorePlugin) {
  (0, _inherits3.default)(MediaControl, _UICorePlugin);
  (0, _createClass3.default)(MediaControl, [{
    key: 'name',
    get: function get() {
      return 'media_control';
    }
  }, {
    key: 'disabled',
    get: function get() {
      var playbackIsNOOP = this.container && this.container.getPlaybackType() === _playback2.default.NO_OP;
      return this.userDisabled || playbackIsNOOP;
    }
  }, {
    key: 'container',
    get: function get() {
      return this.core && this.core.activeContainer;
    }
  }, {
    key: 'playback',
    get: function get() {
      return this.core && this.core.activePlayback;
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'media-control',
        'data-media-control': ''
      };
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'click [data-play]': 'play',
        'click [data-pause]': 'pause',
        'click [data-playpause]': 'togglePlayPause',
        'click [data-stop]': 'stop',
        'click [data-playstop]': 'togglePlayStop',
        'click [data-fullscreen]': 'toggleFullscreen',
        'click .bar-container[data-seekbar]': 'seek',
        'click .bar-container[data-volume]': 'onVolumeClick',
        'click .drawer-icon[data-volume]': 'toggleMute',
        'mouseenter .drawer-container[data-volume]': 'showVolumeBar',
        'mouseleave .drawer-container[data-volume]': 'hideVolumeBar',
        'mousedown .bar-container[data-volume]': 'startVolumeDrag',
        'touchend .bar-container[data-volume]': 'startVolumeDrag',
        'mousemove .bar-container[data-volume]': 'mousemoveOnVolumeBar',
        'touchmove .bar-container[data-volume]': 'mousemoveOnVolumeBar',
        'mousedown .bar-scrubber[data-seekbar]': 'startSeekDrag',
        'touchstart .bar-scrubber[data-seekbar]': 'startSeekDrag',
        'mousemove .bar-container[data-seekbar]': 'mousemoveOnSeekBar',
        'touchmove .bar-container[data-seekbar]': 'mousemoveOnSeekBar',
        'mouseleave .bar-container[data-seekbar]': 'mouseleaveOnSeekBar',
        'mouseenter .media-control-layer[data-controls]': 'setUserKeepVisible',
        'mouseleave .media-control-layer[data-controls]': 'resetUserKeepVisible'
      };
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_mediaControl2.default);
    }
  }, {
    key: 'volume',
    get: function get() {
      return this.container && this.container.isReady ? this.container.volume : this.intendedVolume;
    }
  }, {
    key: 'muted',
    get: function get() {
      return this.volume === 0;
    }
  }]);

  function MediaControl(core) {
    (0, _classCallCheck3.default)(this, MediaControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UICorePlugin.call(this, core));

    _this.persistConfig = _this.options.persistConfig;
    _this.currentPositionValue = null;
    _this.currentDurationValue = null;
    _this.keepVisible = false;
    _this.fullScreenOnVideoTagSupported = null; // unknown
    _this.setInitialVolume();
    _this.settings = {
      left: ['play', 'stop', 'pause'],
      right: ['volume'],
      default: ['position', 'seekbar', 'duration']
    };
    _this.kibo = new _vendor.Kibo(_this.options.focusElement);
    _this.bindKeyEvents();

    if (_this.container) {
      if (!_clapprZepto2.default.isEmptyObject(_this.container.settings)) _this.settings = _clapprZepto2.default.extend({}, _this.container.settings);
    } else {
      _this.settings = {};
    }

    _this.userDisabled = false;
    if (_this.container && _this.container.mediaControlDisabled || _this.options.chromeless) _this.disable();

    _this.stopDragHandler = function (event) {
      return _this.stopDrag(event);
    };
    _this.updateDragHandler = function (event) {
      return _this.updateDrag(event);
    };
    (0, _clapprZepto2.default)(document).bind('mouseup', _this.stopDragHandler);
    (0, _clapprZepto2.default)(document).bind('mousemove', _this.updateDragHandler);
    return _this;
  }

  MediaControl.prototype.getExternalInterface = function getExternalInterface() {
    var _this2 = this;

    return {
      setVolume: this.setVolume,
      getVolume: function getVolume() {
        return _this2.volume;
      }
    };
  };

  MediaControl.prototype.bindEvents = function bindEvents() {
    var _this3 = this;

    this.stopListening();
    this.listenTo(this.core, _events2.default.CORE_ACTIVE_CONTAINER_CHANGED, this.onActiveContainerChanged);
    this.listenTo(this.core, _events2.default.CORE_MOUSE_MOVE, this.show);
    this.listenTo(this.core, _events2.default.CORE_MOUSE_LEAVE, function () {
      return _this3.hide(_this3.options.hideMediaControlDelay);
    });
    this.listenTo(this.core, _events2.default.CORE_FULLSCREEN, this.show);
    this.listenTo(this.core, _events2.default.CORE_OPTIONS_CHANGE, this.configure);
    _mediator2.default.on(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, this.playerResize, this);
    this.bindContainerEvents();
  };

  MediaControl.prototype.bindContainerEvents = function bindContainerEvents() {
    if (!this.container) return;
    this.listenTo(this.container, _events2.default.CONTAINER_PLAY, this.changeTogglePlay);
    this.listenTo(this.container, _events2.default.CONTAINER_PAUSE, this.changeTogglePlay);
    this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.changeTogglePlay);
    this.listenTo(this.container, _events2.default.CONTAINER_DBLCLICK, this.toggleFullscreen);
    this.listenTo(this.container, _events2.default.CONTAINER_TIMEUPDATE, this.onTimeUpdate);
    this.listenTo(this.container, _events2.default.CONTAINER_PROGRESS, this.updateProgressBar);
    this.listenTo(this.container, _events2.default.CONTAINER_SETTINGSUPDATE, this.settingsUpdate);
    this.listenTo(this.container, _events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, this.settingsUpdate);
    this.listenTo(this.container, _events2.default.CONTAINER_HIGHDEFINITIONUPDATE, this.highDefinitionUpdate);
    this.listenTo(this.container, _events2.default.CONTAINER_MEDIACONTROL_DISABLE, this.disable);
    this.listenTo(this.container, _events2.default.CONTAINER_MEDIACONTROL_ENABLE, this.enable);
    this.listenTo(this.container, _events2.default.CONTAINER_ENDED, this.ended);
    this.listenTo(this.container, _events2.default.CONTAINER_VOLUME, this.onVolumeChanged);
    this.listenTo(this.container, _events2.default.CONTAINER_OPTIONS_CHANGE, this.setInitialVolume);
    if (this.container.playback.el.nodeName.toLowerCase() === 'video') {
      // wait until the metadata has loaded and then check if fullscreen on video tag is supported
      this.listenToOnce(this.container, _events2.default.CONTAINER_LOADEDMETADATA, this.onLoadedMetadataOnVideoTag);
    }
  };

  MediaControl.prototype.disable = function disable() {
    this.userDisabled = true;
    this.hide();
    this.unbindKeyEvents();
    this.$el.hide();
  };

  MediaControl.prototype.enable = function enable() {
    if (this.options.chromeless) return;
    this.userDisabled = false;
    this.bindKeyEvents();
    this.show();
  };

  MediaControl.prototype.play = function play() {
    this.container && this.container.play();
  };

  MediaControl.prototype.pause = function pause() {
    this.container && this.container.pause();
  };

  MediaControl.prototype.stop = function stop() {
    this.container && this.container.stop();
  };

  MediaControl.prototype.setInitialVolume = function setInitialVolume() {
    var initialVolume = this.persistConfig ? _utils.Config.restore('volume') : 100;
    var options = this.container && this.container.options || this.options;
    this.setVolume(options.mute ? 0 : initialVolume, true);
  };

  MediaControl.prototype.onVolumeChanged = function onVolumeChanged() {
    this.updateVolumeUI();
  };

  MediaControl.prototype.onLoadedMetadataOnVideoTag = function onLoadedMetadataOnVideoTag() {
    var video = this.playback && this.playback.el;
    // video.webkitSupportsFullscreen is deprecated but iOS appears to only use this
    // see https://github.com/clappr/clappr/issues/1127
    if (!_utils.Fullscreen.fullscreenEnabled() && video.webkitSupportsFullscreen) {
      this.fullScreenOnVideoTagSupported = true;
      this.settingsUpdate();
    }
  };

  MediaControl.prototype.updateVolumeUI = function updateVolumeUI() {
    // this will be called after a render
    if (!this.rendered) return;

    // update volume bar scrubber/fill on bar mode
    this.$volumeBarContainer.find('.bar-fill-2').css({});
    var containerWidth = this.$volumeBarContainer.width();
    var barWidth = this.$volumeBarBackground.width();
    var offset = (containerWidth - barWidth) / 2.0;
    var pos = barWidth * this.volume / 100.0 + offset;
    this.$volumeBarFill.css({ width: this.volume + '%' });
    this.$volumeBarScrubber.css({ left: pos });

    // update volume bar segments on segmented bar mode
    this.$volumeBarContainer.find('.segmented-bar-element').removeClass('fill');
    var item = Math.ceil(this.volume / 10.0);
    this.$volumeBarContainer.find('.segmented-bar-element').slice(0, item).addClass('fill');
    this.$volumeIcon.html('');
    this.$volumeIcon.removeClass('muted');
    if (!this.muted) {
      this.$volumeIcon.append(_utils.SvgIcons.volume);
    } else {
      this.$volumeIcon.append(_utils.SvgIcons.volumeMute);
      this.$volumeIcon.addClass('muted');
    }
    this.applyButtonStyle(this.$volumeIcon);
  };

  MediaControl.prototype.changeTogglePlay = function changeTogglePlay() {
    this.$playPauseToggle.html('');
    this.$playStopToggle.html('');
    if (this.container && this.container.isPlaying()) {
      this.$playPauseToggle.append(_utils.SvgIcons.pause);
      this.$playStopToggle.append(_utils.SvgIcons.stop);
      this.trigger(_events2.default.MEDIACONTROL_PLAYING);
    } else {
      this.$playPauseToggle.append(_utils.SvgIcons.play);
      this.$playStopToggle.append(_utils.SvgIcons.play);
      this.trigger(_events2.default.MEDIACONTROL_NOTPLAYING);
      _browser2.default.isMobile && this.show();
    }
    this.applyButtonStyle(this.$playPauseToggle);
    this.applyButtonStyle(this.$playStopToggle);
  };

  MediaControl.prototype.mousemoveOnSeekBar = function mousemoveOnSeekBar(event) {
    if (this.settings.seekEnabled) {
      var offsetX = event.pageX - this.$seekBarContainer.offset().left - this.$seekBarHover.width() / 2;
      this.$seekBarHover.css({ left: offsetX });
    }
    this.trigger(_events2.default.MEDIACONTROL_MOUSEMOVE_SEEKBAR, event);
  };

  MediaControl.prototype.mouseleaveOnSeekBar = function mouseleaveOnSeekBar(event) {
    this.trigger(_events2.default.MEDIACONTROL_MOUSELEAVE_SEEKBAR, event);
  };

  MediaControl.prototype.onVolumeClick = function onVolumeClick(event) {
    this.setVolume(this.getVolumeFromUIEvent(event));
  };

  MediaControl.prototype.mousemoveOnVolumeBar = function mousemoveOnVolumeBar(event) {
    this.draggingVolumeBar && this.setVolume(this.getVolumeFromUIEvent(event));
  };

  MediaControl.prototype.playerResize = function playerResize(size) {
    this.$fullscreenToggle.html('');
    var icon = this.core.isFullscreen() ? _utils.SvgIcons.exitFullscreen : _utils.SvgIcons.fullscreen;
    this.$fullscreenToggle.append(icon);
    this.applyButtonStyle(this.$fullscreenToggle);
    this.$el.find('.media-control').length !== 0 && this.$el.removeClass('w320');
    if (size.width <= 320 || this.options.hideVolumeBar) this.$el.addClass('w320');
  };

  MediaControl.prototype.togglePlayPause = function togglePlayPause() {
    this.container.isPlaying() ? this.container.pause() : this.container.play();
    return false;
  };

  MediaControl.prototype.togglePlayStop = function togglePlayStop() {
    this.container.isPlaying() ? this.container.stop() : this.container.play();
  };

  MediaControl.prototype.startSeekDrag = function startSeekDrag(event) {
    if (!this.settings.seekEnabled) return;
    this.draggingSeekBar = true;
    this.$el.addClass('dragging');
    this.$seekBarLoaded.addClass('media-control-notransition');
    this.$seekBarPosition.addClass('media-control-notransition');
    this.$seekBarScrubber.addClass('media-control-notransition');
    event && event.preventDefault();
  };

  MediaControl.prototype.startVolumeDrag = function startVolumeDrag(event) {
    this.draggingVolumeBar = true;
    this.$el.addClass('dragging');
    event && event.preventDefault();
  };

  MediaControl.prototype.stopDrag = function stopDrag(event) {
    this.draggingSeekBar && this.seek(event);
    this.$el.removeClass('dragging');
    this.$seekBarLoaded.removeClass('media-control-notransition');
    this.$seekBarPosition.removeClass('media-control-notransition');
    this.$seekBarScrubber.removeClass('media-control-notransition dragging');
    this.draggingSeekBar = false;
    this.draggingVolumeBar = false;
  };

  MediaControl.prototype.updateDrag = function updateDrag(event) {
    if (this.draggingSeekBar) {
      event.preventDefault();
      var offsetX = event.pageX - this.$seekBarContainer.offset().left;
      var pos = offsetX / this.$seekBarContainer.width() * 100;
      pos = Math.min(100, Math.max(pos, 0));
      this.setSeekPercentage(pos);
    } else if (this.draggingVolumeBar) {
      event.preventDefault();
      this.setVolume(this.getVolumeFromUIEvent(event));
    }
  };

  MediaControl.prototype.getVolumeFromUIEvent = function getVolumeFromUIEvent(event) {
    var offsetY = event.pageX - this.$volumeBarContainer.offset().left;
    var volumeFromUI = offsetY / this.$volumeBarContainer.width() * 100;
    return volumeFromUI;
  };

  MediaControl.prototype.toggleMute = function toggleMute() {
    if (this.muted) {
      this.setVolume(this._mutedVolume || 100);
      this._mutedVolume = null;
      return;
    }

    this._mutedVolume = this.volume;
    this.setVolume(0);
  };

  MediaControl.prototype.setVolume = function setVolume(value) {
    var _this4 = this;

    var isInitialVolume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    value = Math.min(100, Math.max(value, 0));
    // this will hold the intended volume
    // it may not actually get set to this straight away
    // if the container is not ready etc
    this.intendedVolume = value;
    this.persistConfig && !isInitialVolume && _utils.Config.persist('volume', value);
    var setWhenContainerReady = function setWhenContainerReady() {
      if (_this4.container && _this4.container.isReady) {
        _this4.container.setVolume(value);
      } else {
        _this4.listenToOnce(_this4.container, _events2.default.CONTAINER_READY, function () {
          _this4.container.setVolume(value);
        });
      }
    };

    if (!this.container) this.listenToOnce(this, _events2.default.MEDIACONTROL_CONTAINERCHANGED, function () {
      return setWhenContainerReady();
    });else setWhenContainerReady();
  };

  MediaControl.prototype.toggleFullscreen = function toggleFullscreen() {
    this.trigger(_events2.default.MEDIACONTROL_FULLSCREEN, this.name);
    this.container.fullscreen();
    this.core.toggleFullscreen();
    this.resetUserKeepVisible();
  };

  MediaControl.prototype.onActiveContainerChanged = function onActiveContainerChanged() {
    this.fullScreenOnVideoTagSupported = null;
    _mediator2.default.off(this.options.playerId + ':' + _events2.default.PLAYER_RESIZE, this.playerResize, this);
    this.bindEvents();
    // set the new container to match the volume of the last one
    this.setInitialVolume();
    this.changeTogglePlay();
    this.bindContainerEvents();
    this.settingsUpdate();
    this.container && this.container.trigger(_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, this.container.isDvrInUse());
    this.container && this.container.mediaControlDisabled && this.disable();
    this.trigger(_events2.default.MEDIACONTROL_CONTAINERCHANGED);
  };

  MediaControl.prototype.showVolumeBar = function showVolumeBar() {
    this.hideVolumeId && clearTimeout(this.hideVolumeId);
    this.$volumeBarContainer.removeClass('volume-bar-hide');
  };

  MediaControl.prototype.hideVolumeBar = function hideVolumeBar() {
    var _this5 = this;

    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;

    if (!this.$volumeBarContainer) return;
    if (this.draggingVolumeBar) {
      this.hideVolumeId = setTimeout(function () {
        return _this5.hideVolumeBar();
      }, timeout);
    } else {
      this.hideVolumeId && clearTimeout(this.hideVolumeId);
      this.hideVolumeId = setTimeout(function () {
        return _this5.$volumeBarContainer.addClass('volume-bar-hide');
      }, timeout);
    }
  };

  MediaControl.prototype.ended = function ended() {
    this.changeTogglePlay();
  };

  MediaControl.prototype.updateProgressBar = function updateProgressBar(progress) {
    var loadedStart = progress.start / progress.total * 100;
    var loadedEnd = progress.current / progress.total * 100;
    this.$seekBarLoaded.css({ left: loadedStart + '%', width: loadedEnd - loadedStart + '%' });
  };

  MediaControl.prototype.onTimeUpdate = function onTimeUpdate(timeProgress) {
    if (this.draggingSeekBar) return;
    // TODO why should current time ever be negative?
    var position = timeProgress.current < 0 ? timeProgress.total : timeProgress.current;

    this.currentPositionValue = position;
    this.currentDurationValue = timeProgress.total;
    this.renderSeekBar();
  };

  MediaControl.prototype.renderSeekBar = function renderSeekBar() {
    // this will be triggered as soon as these become available
    if (this.currentPositionValue === null || this.currentDurationValue === null) return;

    // default to 100%
    this.currentSeekBarPercentage = 100;
    if (this.container && (this.container.getPlaybackType() !== _playback2.default.LIVE || this.container.isDvrInUse())) this.currentSeekBarPercentage = this.currentPositionValue / this.currentDurationValue * 100;

    this.setSeekPercentage(this.currentSeekBarPercentage);

    var newPosition = (0, _utils.formatTime)(this.currentPositionValue);
    var newDuration = (0, _utils.formatTime)(this.currentDurationValue);
    if (newPosition !== this.displayedPosition) {
      this.$position.text(newPosition);
      this.displayedPosition = newPosition;
    }
    if (newDuration !== this.displayedDuration) {
      this.$duration.text(newDuration);
      this.displayedDuration = newDuration;
    }
  };

  MediaControl.prototype.seek = function seek(event) {
    if (!this.settings.seekEnabled) return;
    var offsetX = event.pageX - this.$seekBarContainer.offset().left;
    var pos = offsetX / this.$seekBarContainer.width() * 100;
    pos = Math.min(100, Math.max(pos, 0));
    this.container && this.container.seekPercentage(pos);
    this.setSeekPercentage(pos);
    return false;
  };

  MediaControl.prototype.setKeepVisible = function setKeepVisible() {
    this.keepVisible = true;
  };

  MediaControl.prototype.resetKeepVisible = function resetKeepVisible() {
    this.keepVisible = false;
  };

  MediaControl.prototype.setUserKeepVisible = function setUserKeepVisible() {
    this.userKeepVisible = true;
  };

  MediaControl.prototype.resetUserKeepVisible = function resetUserKeepVisible() {
    this.userKeepVisible = false;
  };

  MediaControl.prototype.isVisible = function isVisible() {
    return !this.$el.hasClass('media-control-hide');
  };

  MediaControl.prototype.show = function show(event) {
    var _this6 = this;

    if (this.disabled) return;

    var timeout = 2000;
    var mousePointerMoved = event && event.clientX !== this.lastMouseX && event.clientY !== this.lastMouseY;
    if (!event || mousePointerMoved || navigator.userAgent.match(/firefox/i)) {
      clearTimeout(this.hideId);
      this.$el.show();
      this.trigger(_events2.default.MEDIACONTROL_SHOW, this.name);
      this.container && this.container.trigger(_events2.default.CONTAINER_MEDIACONTROL_SHOW, this.name);
      this.$el.removeClass('media-control-hide');
      this.hideId = setTimeout(function () {
        return _this6.hide();
      }, timeout);
      if (event) {
        this.lastMouseX = event.clientX;
        this.lastMouseY = event.clientY;
      }
    }
    var showing = true;
    this.updateCursorStyle(showing);
  };

  MediaControl.prototype.hide = function hide() {
    var _this7 = this;

    var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!this.isVisible()) return;

    var timeout = delay || 2000;
    clearTimeout(this.hideId);
    if (!this.disabled && this.options.hideMediaControl === false) return;

    var hasKeepVisibleRequested = this.userKeepVisible || this.keepVisible;
    var hasDraggingAction = this.draggingSeekBar || this.draggingVolumeBar;

    if (!this.disabled && (delay || hasKeepVisibleRequested || hasDraggingAction)) {
      this.hideId = setTimeout(function () {
        return _this7.hide();
      }, timeout);
    } else {
      this.trigger(_events2.default.MEDIACONTROL_HIDE, this.name);
      this.container && this.container.trigger(_events2.default.CONTAINER_MEDIACONTROL_HIDE, this.name);
      this.$el.addClass('media-control-hide');
      this.hideVolumeBar(0);
      var showing = false;
      this.updateCursorStyle(showing);
    }
  };

  MediaControl.prototype.updateCursorStyle = function updateCursorStyle(showing) {
    if (showing) this.core.$el.removeClass('nocursor');else if (this.core.isFullscreen()) this.core.$el.addClass('nocursor');
  };

  MediaControl.prototype.settingsUpdate = function settingsUpdate() {
    var newSettings = this.getSettings();
    if (newSettings && !this.fullScreenOnVideoTagSupported && !_utils.Fullscreen.fullscreenEnabled()) {
      // remove fullscreen from settings if it is present
      newSettings.default && (0, _utils.removeArrayItem)(newSettings.default, 'fullscreen');
      newSettings.left && (0, _utils.removeArrayItem)(newSettings.left, 'fullscreen');
      newSettings.right && (0, _utils.removeArrayItem)(newSettings.right, 'fullscreen');
    }
    var settingsChanged = (0, _stringify2.default)(this.settings) !== (0, _stringify2.default)(newSettings);
    if (settingsChanged) {
      this.settings = newSettings;
      this.render();
    }
  };

  MediaControl.prototype.getSettings = function getSettings() {
    return _clapprZepto2.default.extend(true, {}, this.container && this.container.settings);
  };

  MediaControl.prototype.highDefinitionUpdate = function highDefinitionUpdate(isHD) {
    this.isHD = isHD;
    var method = isHD ? 'addClass' : 'removeClass';
    this.$hdIndicator[method]('enabled');
  };

  MediaControl.prototype.createCachedElements = function createCachedElements() {
    var $layer = this.$el.find('.media-control-layer');
    this.$duration = $layer.find('.media-control-indicator[data-duration]');
    this.$fullscreenToggle = $layer.find('button.media-control-button[data-fullscreen]');
    this.$playPauseToggle = $layer.find('button.media-control-button[data-playpause]');
    this.$playStopToggle = $layer.find('button.media-control-button[data-playstop]');
    this.$position = $layer.find('.media-control-indicator[data-position]');
    this.$seekBarContainer = $layer.find('.bar-container[data-seekbar]');
    this.$seekBarHover = $layer.find('.bar-hover[data-seekbar]');
    this.$seekBarLoaded = $layer.find('.bar-fill-1[data-seekbar]');
    this.$seekBarPosition = $layer.find('.bar-fill-2[data-seekbar]');
    this.$seekBarScrubber = $layer.find('.bar-scrubber[data-seekbar]');
    this.$volumeBarContainer = $layer.find('.bar-container[data-volume]');
    this.$volumeContainer = $layer.find('.drawer-container[data-volume]');
    this.$volumeIcon = $layer.find('.drawer-icon[data-volume]');
    this.$volumeBarBackground = this.$el.find('.bar-background[data-volume]');
    this.$volumeBarFill = this.$el.find('.bar-fill-1[data-volume]');
    this.$volumeBarScrubber = this.$el.find('.bar-scrubber[data-volume]');
    this.$hdIndicator = this.$el.find('button.media-control-button[data-hd-indicator]');
    this.resetIndicators();
    this.initializeIcons();
  };

  MediaControl.prototype.resetIndicators = function resetIndicators() {
    this.displayedPosition = this.$position.text();
    this.displayedDuration = this.$duration.text();
  };

  MediaControl.prototype.initializeIcons = function initializeIcons() {
    var $layer = this.$el.find('.media-control-layer');
    $layer.find('button.media-control-button[data-play]').append(_utils.SvgIcons.play);
    $layer.find('button.media-control-button[data-pause]').append(_utils.SvgIcons.pause);
    $layer.find('button.media-control-button[data-stop]').append(_utils.SvgIcons.stop);
    this.$playPauseToggle.append(_utils.SvgIcons.play);
    this.$playStopToggle.append(_utils.SvgIcons.play);
    this.$volumeIcon.append(_utils.SvgIcons.volume);
    this.$fullscreenToggle.append(_utils.SvgIcons.fullscreen);
    this.$hdIndicator.append(_utils.SvgIcons.hd);
  };

  MediaControl.prototype.setSeekPercentage = function setSeekPercentage(value) {
    value = Math.max(Math.min(value, 100.0), 0);
    // not changed since last update
    if (this.displayedSeekBarPercentage === value) return;

    this.displayedSeekBarPercentage = value;
    this.$seekBarPosition.removeClass('media-control-notransition');
    this.$seekBarScrubber.removeClass('media-control-notransition');
    this.$seekBarPosition.css({ width: value + '%' });
    this.$seekBarScrubber.css({ left: value + '%' });
  };

  MediaControl.prototype.seekRelative = function seekRelative(delta) {
    if (!this.settings.seekEnabled) return;

    var currentTime = this.container.getCurrentTime();
    var duration = this.container.getDuration();
    var position = Math.min(Math.max(currentTime + delta, 0), duration);
    position = Math.min(position * 100 / duration, 100);
    this.container.seekPercentage(position);
  };

  MediaControl.prototype.bindKeyAndShow = function bindKeyAndShow(key, callback) {
    var _this8 = this;

    this.kibo.down(key, function () {
      _this8.show();
      return callback();
    });
  };

  MediaControl.prototype.bindKeyEvents = function bindKeyEvents() {
    var _this9 = this;

    if (_browser2.default.isMobile || this.options.disableKeyboardShortcuts) return;

    this.unbindKeyEvents();
    this.kibo = new _vendor.Kibo(this.options.focusElement || this.options.parentElement);
    this.bindKeyAndShow('space', function () {
      return _this9.togglePlayPause();
    });
    this.bindKeyAndShow('left', function () {
      return _this9.seekRelative(-5);
    });
    this.bindKeyAndShow('right', function () {
      return _this9.seekRelative(5);
    });
    this.bindKeyAndShow('shift left', function () {
      return _this9.seekRelative(-10);
    });
    this.bindKeyAndShow('shift right', function () {
      return _this9.seekRelative(10);
    });
    this.bindKeyAndShow('shift ctrl left', function () {
      return _this9.seekRelative(-15);
    });
    this.bindKeyAndShow('shift ctrl right', function () {
      return _this9.seekRelative(15);
    });
    var keys = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
    keys.forEach(function (i) {
      _this9.bindKeyAndShow(i, function () {
        _this9.settings.seekEnabled && _this9.container && _this9.container.seekPercentage(i * 10);
      });
    });
  };

  MediaControl.prototype.unbindKeyEvents = function unbindKeyEvents() {
    if (this.kibo) {
      this.kibo.off('space');
      this.kibo.off('left');
      this.kibo.off('right');
      this.kibo.off('shift left');
      this.kibo.off('shift right');
      this.kibo.off('shift ctrl left');
      this.kibo.off('shift ctrl right');
      this.kibo.off(['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']);
    }
  };

  MediaControl.prototype.parseColors = function parseColors() {
    if (this.options.mediacontrol) {
      this.buttonsColor = this.options.mediacontrol.buttons;
      var seekbarColor = this.options.mediacontrol.seekbar;
      this.$el.find('.bar-fill-2[data-seekbar]').css('background-color', seekbarColor);
      this.$el.find('.media-control-icon svg path').css('fill', this.buttonsColor);
      this.$el.find('.segmented-bar-element[data-volume]').css('boxShadow', 'inset 2px 0 0 ' + this.buttonsColor);
    }
  };

  MediaControl.prototype.applyButtonStyle = function applyButtonStyle(element) {
    this.buttonsColor && element && (0, _clapprZepto2.default)(element).find('svg path').css('fill', this.buttonsColor);
  };

  MediaControl.prototype.destroy = function destroy() {
    (0, _clapprZepto2.default)(document).unbind('mouseup', this.stopDragHandler);
    (0, _clapprZepto2.default)(document).unbind('mousemove', this.updateDragHandler);
    this.unbindKeyEvents();
    this.stopListening();
    _UICorePlugin.prototype.destroy.call(this);
  };

  /**
   * enables to configure the media control after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */


  MediaControl.prototype.configure = function configure(options) {
    // Check if chromeless mode or if configure is called with new source(s)
    if (this.options.chromeless || options.source || options.sources) this.disable();else this.enable();

    this.trigger(_events2.default.MEDIACONTROL_OPTIONS_CHANGE);
  };

  MediaControl.prototype.render = function render() {
    var _this10 = this;

    var timeout = this.options.hideMediaControlDelay || 2000;
    this.settings && this.$el.html(this.template({ settings: this.settings }));
    this.createCachedElements();
    this.$playPauseToggle.addClass('paused');
    this.$playStopToggle.addClass('stopped');

    this.changeTogglePlay();

    if (this.container) {
      this.hideId = setTimeout(function () {
        return _this10.hide();
      }, timeout);
      this.disabled && this.hide();
    }

    // Video volume cannot be changed with Safari on mobile devices
    // Display mute/unmute icon only if Safari version >= 10
    if (_browser2.default.isSafari && _browser2.default.isMobile) {
      if (_browser2.default.version < 10) this.$volumeContainer.css('display', 'none');else this.$volumeBarContainer.css('display', 'none');
    }

    this.$seekBarPosition.addClass('media-control-notransition');
    this.$seekBarScrubber.addClass('media-control-notransition');

    var previousSeekPercentage = 0;
    if (this.displayedSeekBarPercentage) previousSeekPercentage = this.displayedSeekBarPercentage;

    this.displayedSeekBarPercentage = null;
    this.setSeekPercentage(previousSeekPercentage);

    process.nextTick(function () {
      !_this10.settings.seekEnabled && _this10.$seekBarContainer.addClass('seek-disabled');
      !_browser2.default.isMobile && !_this10.options.disableKeyboardShortcuts && _this10.bindKeyEvents();
      _this10.playerResize({ width: _this10.options.width, height: _this10.options.height });
      _this10.hideVolumeBar(0);
    });

    this.parseColors();
    this.highDefinitionUpdate(this.isHD);

    this.core.$el.append(this.el);

    this.rendered = true;
    this.updateVolumeUI();
    this.trigger(_events2.default.MEDIACONTROL_RENDERED);
    return this;
  };

  return MediaControl;
}(_ui_core_plugin2.default);

exports.default = MediaControl;


MediaControl.extend = function (properties) {
  return (0, _utils.extend)(MediaControl, properties);
};
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/plugins/media_control/public/media-control.html":
/*!*************************************************************!*\
  !*** ./src/plugins/media_control/public/media-control.html ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"media-control-background\" data-background></div>\n<div class=\"media-control-layer\" data-controls>\n  <%  var renderBar = function(name) { %>\n      <div class=\"bar-container\" data-<%= name %>>\n        <div class=\"bar-background\" data-<%= name %>>\n          <div class=\"bar-fill-1\" data-<%= name %>></div>\n          <div class=\"bar-fill-2\" data-<%= name %>></div>\n          <div class=\"bar-hover\" data-<%= name %>></div>\n        </div>\n        <div class=\"bar-scrubber\" data-<%= name %>>\n          <div class=\"bar-scrubber-icon\" data-<%= name %>></div>\n        </div>\n      </div>\n  <%  }; %>\n  <%  var renderSegmentedBar = function(name, segments) {\n      segments = segments || 10; %>\n    <div class=\"bar-container\" data-<%= name %>>\n    <% for (var i = 0; i < segments; i++) { %>\n      <div class=\"segmented-bar-element\" data-<%= name %>></div>\n    <% } %>\n    </div>\n  <% }; %>\n  <% var renderDrawer = function(name, renderContent) { %>\n      <div class=\"drawer-container\" data-<%= name %>>\n        <div class=\"drawer-icon-container\" data-<%= name %>>\n          <div class=\"drawer-icon media-control-icon\" data-<%= name %>></div>\n          <span class=\"drawer-text\" data-<%= name %>></span>\n        </div>\n        <% renderContent(name); %>\n      </div>\n  <% }; %>\n  <% var renderIndicator = function(name) { %>\n      <div class=\"media-control-indicator\" data-<%= name %>></div>\n  <% }; %>\n  <% var renderButton = function(name) { %>\n    <button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %> aria-label=\"<%= name %>\"></button>\n  <% }; %>\n  <%  var templates = {\n        bar: renderBar,\n        segmentedBar: renderSegmentedBar,\n      };\n      var render = function(settingsList) {\n        settingsList.forEach(function(setting) {\n          if(setting === \"seekbar\") {\n            renderBar(setting);\n          } else if (setting === \"volume\") {\n            renderDrawer(setting, settings.volumeBarTemplate ? templates[settings.volumeBarTemplate] : function(name) { return renderSegmentedBar(name); });\n          } else if (setting === \"duration\" || setting === \"position\") {\n            renderIndicator(setting);\n          } else {\n            renderButton(setting);\n          }\n        });\n      }; %>\n  <% if (settings.default && settings.default.length) { %>\n  <div class=\"media-control-center-panel\" data-media-control>\n    <% render(settings.default); %>\n  </div>\n  <% } %>\n  <% if (settings.left && settings.left.length) { %>\n  <div class=\"media-control-left-panel\" data-media-control>\n    <% render(settings.left); %>\n  </div>\n  <% } %>\n  <% if (settings.right && settings.right.length) { %>\n  <div class=\"media-control-right-panel\" data-media-control>\n    <% render(settings.right); %>\n  </div>\n  <% } %>\n</div>\n";

/***/ }),

/***/ "./src/plugins/media_control/public/media-control.scss":
/*!*************************************************************!*\
  !*** ./src/plugins/media_control/public/media-control.scss ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./media-control.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/media_control/public/media-control.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/poster/index.js":
/*!*************************************!*\
  !*** ./src/plugins/poster/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _poster = __webpack_require__(/*! ./poster */ "./src/plugins/poster/poster.js");

var _poster2 = _interopRequireDefault(_poster);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _poster2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/poster/poster.js":
/*!**************************************!*\
  !*** ./src/plugins/poster/poster.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _ui_container_plugin = __webpack_require__(/*! ../../base/ui_container_plugin */ "./src/base/ui_container_plugin.js");

var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _error = __webpack_require__(/*! ../../components/error/error */ "./src/components/error/error.js");

var _error2 = _interopRequireDefault(_error);

var _poster = __webpack_require__(/*! ./public/poster.html */ "./src/plugins/poster/public/poster.html");

var _poster2 = _interopRequireDefault(_poster);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

__webpack_require__(/*! ./public/poster.scss */ "./src/plugins/poster/public/poster.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

var PosterPlugin = function (_UIContainerPlugin) {
  (0, _inherits3.default)(PosterPlugin, _UIContainerPlugin);
  (0, _createClass3.default)(PosterPlugin, [{
    key: 'name',
    get: function get() {
      return 'poster';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_poster2.default);
    }
  }, {
    key: 'shouldRender',
    get: function get() {
      var showForNoOp = !!(this.options.poster && this.options.poster.showForNoOp);
      return this.container.playback.name !== 'html_img' && (this.container.playback.getPlaybackType() !== _playback2.default.NO_OP || showForNoOp);
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'player-poster',
        'data-poster': ''
      };
    }
  }, {
    key: 'events',
    get: function get() {
      return {
        'click': 'clicked'
      };
    }
  }, {
    key: 'showOnVideoEnd',
    get: function get() {
      return !this.options.poster || this.options.poster.showOnVideoEnd || this.options.poster.showOnVideoEnd === undefined;
    }
  }]);

  function PosterPlugin(container) {
    (0, _classCallCheck3.default)(this, PosterPlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIContainerPlugin.call(this, container));

    _this.hasStartedPlaying = false;
    _this.playRequested = false;
    _this.render();
    process.nextTick(function () {
      return _this.update();
    });
    return _this;
  }

  PosterPlugin.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.onStop);
    this.listenTo(this.container, _events2.default.CONTAINER_PLAY, this.onPlay);
    this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERING, this.update);
    this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERFULL, this.update);
    this.listenTo(this.container, _events2.default.CONTAINER_OPTIONS_CHANGE, this.render);
    this.listenTo(this.container, _events2.default.CONTAINER_ERROR, this.onError);
    this.showOnVideoEnd && this.listenTo(this.container, _events2.default.CONTAINER_ENDED, this.onStop);
  };

  PosterPlugin.prototype.onError = function onError(error) {
    this.hasFatalError = error.level === _error2.default.Levels.FATAL;

    if (this.hasFatalError) {
      this.hasStartedPlaying = false;
      this.playRequested = false;
      this.showPlayButton();
    }
  };

  PosterPlugin.prototype.onPlay = function onPlay() {
    this.hasStartedPlaying = true;
    this.update();
  };

  PosterPlugin.prototype.onStop = function onStop() {
    this.hasStartedPlaying = false;
    this.playRequested = false;
    this.update();
  };

  PosterPlugin.prototype.updatePlayButton = function updatePlayButton(show) {
    if (show && (!this.options.chromeless || this.options.allowUserInteraction)) this.showPlayButton();else this.hidePlayButton();
  };

  PosterPlugin.prototype.showPlayButton = function showPlayButton() {
    if (this.hasFatalError && !this.options.disableErrorScreen) return;

    this.$playButton.show();
    this.$el.addClass('clickable');
  };

  PosterPlugin.prototype.hidePlayButton = function hidePlayButton() {
    this.$playButton.hide();
    this.$el.removeClass('clickable');
  };

  PosterPlugin.prototype.clicked = function clicked() {
    // Let "click_to_pause" plugin handle click event if media has started playing
    if (!this.hasStartedPlaying) {
      if (!this.options.chromeless || this.options.allowUserInteraction) {
        this.playRequested = true;
        this.update();
        this.container.play();
      }
      return false;
    }
  };

  PosterPlugin.prototype.shouldHideOnPlay = function shouldHideOnPlay() {
    // Audio broadcasts should keep the poster up; video should hide poster while playing.
    return !this.container.playback.isAudioOnly;
  };

  PosterPlugin.prototype.update = function update() {
    if (!this.shouldRender) return;

    var showPlayButton = !this.playRequested && !this.hasStartedPlaying && !this.container.buffering;
    this.updatePlayButton(showPlayButton);
    this.updatePoster();
  };

  PosterPlugin.prototype.updatePoster = function updatePoster() {
    if (!this.hasStartedPlaying) this.showPoster();else this.hidePoster();
  };

  PosterPlugin.prototype.showPoster = function showPoster() {
    this.container.disableMediaControl();
    this.$el.show();
  };

  PosterPlugin.prototype.hidePoster = function hidePoster() {
    this.container.enableMediaControl();
    if (this.shouldHideOnPlay()) this.$el.hide();
  };

  PosterPlugin.prototype.render = function render() {
    if (!this.shouldRender) return;

    this.$el.html(this.template());

    var isRegularPoster = this.options.poster && this.options.poster.custom === undefined;

    if (isRegularPoster) {
      var posterUrl = this.options.poster.url || this.options.poster;
      this.$el.css({ 'background-image': 'url(' + posterUrl + ')' });
    } else if (this.options.poster) {
      this.$el.css({ 'background': this.options.poster.custom });
    }

    this.container.$el.append(this.el);
    this.$playWrapper = this.$el.find('.play-wrapper');
    this.$playWrapper.append(_utils.SvgIcons.play);
    this.$playButton = this.$playWrapper.find('svg');
    this.$playButton.addClass('poster-icon');
    this.$playButton.attr('data-poster', '');

    var buttonsColor = this.options.mediacontrol && this.options.mediacontrol.buttons;
    if (buttonsColor) this.$el.find('svg path').css('fill', buttonsColor);

    if (this.options.mediacontrol && this.options.mediacontrol.buttons) {
      buttonsColor = this.options.mediacontrol.buttons;
      this.$playButton.css('color', buttonsColor);
    }
    this.update();
    return this;
  };

  return PosterPlugin;
}(_ui_container_plugin2.default);

exports.default = PosterPlugin;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/plugins/poster/public/poster.html":
/*!***********************************************!*\
  !*** ./src/plugins/poster/public/poster.html ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"play-wrapper\" data-poster></div>\n";

/***/ }),

/***/ "./src/plugins/poster/public/poster.scss":
/*!***********************************************!*\
  !*** ./src/plugins/poster/public/poster.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./poster.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/poster/public/poster.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/seek_time/index.js":
/*!****************************************!*\
  !*** ./src/plugins/seek_time/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _seek_time = __webpack_require__(/*! ./seek_time */ "./src/plugins/seek_time/seek_time.js");

var _seek_time2 = _interopRequireDefault(_seek_time);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _seek_time2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/seek_time/public/seek_time.html":
/*!*****************************************************!*\
  !*** ./src/plugins/seek_time/public/seek_time.html ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<span data-seek-time></span>\n<span data-duration></span>\n";

/***/ }),

/***/ "./src/plugins/seek_time/public/seek_time.scss":
/*!*****************************************************!*\
  !*** ./src/plugins/seek_time/public/seek_time.scss ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./seek_time.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/seek_time/public/seek_time.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/seek_time/seek_time.js":
/*!********************************************!*\
  !*** ./src/plugins/seek_time/seek_time.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../../base/utils */ "./src/base/utils.js");

var _ui_core_plugin = __webpack_require__(/*! ../../base/ui_core_plugin */ "./src/base/ui_core_plugin.js");

var _ui_core_plugin2 = _interopRequireDefault(_ui_core_plugin);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _playback = __webpack_require__(/*! ../../base/playback */ "./src/base/playback.js");

var _playback2 = _interopRequireDefault(_playback);

var _seek_time = __webpack_require__(/*! ./public/seek_time.html */ "./src/plugins/seek_time/public/seek_time.html");

var _seek_time2 = _interopRequireDefault(_seek_time);

__webpack_require__(/*! ./public/seek_time.scss */ "./src/plugins/seek_time/public/seek_time.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SeekTime = function (_UICorePlugin) {
  (0, _inherits3.default)(SeekTime, _UICorePlugin);
  (0, _createClass3.default)(SeekTime, [{
    key: 'name',
    get: function get() {
      return 'seek_time';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_seek_time2.default);
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'class': 'seek-time',
        'data-seek-time': ''
      };
    }
  }, {
    key: 'mediaControl',
    get: function get() {
      return this.core.mediaControl;
    }
  }, {
    key: 'mediaControlContainer',
    get: function get() {
      return this.mediaControl.container;
    }
  }, {
    key: 'isLiveStreamWithDvr',
    get: function get() {
      return this.mediaControlContainer && this.mediaControlContainer.getPlaybackType() === _playback2.default.LIVE && this.mediaControlContainer.isDvrEnabled();
    }
  }, {
    key: 'durationShown',
    get: function get() {
      return this.isLiveStreamWithDvr && !this.actualLiveTime;
    }
  }, {
    key: 'useActualLiveTime',
    get: function get() {
      return this.actualLiveTime && this.isLiveStreamWithDvr;
    }
  }]);

  function SeekTime(core) {
    (0, _classCallCheck3.default)(this, SeekTime);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UICorePlugin.call(this, core));

    _this.hoveringOverSeekBar = false;
    _this.hoverPosition = null;
    _this.duration = null;
    _this.firstFragDateTime = null;
    _this.actualLiveTime = !!_this.mediaControl.options.actualLiveTime;
    if (_this.actualLiveTime) {
      if (_this.mediaControl.options.actualLiveServerTime) _this.actualLiveServerTimeDiff = new Date().getTime() - new Date(_this.mediaControl.options.actualLiveServerTime).getTime();else _this.actualLiveServerTimeDiff = 0;
    }
    return _this;
  }

  SeekTime.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.mediaControl, _events2.default.MEDIACONTROL_RENDERED, this.render);
    this.listenTo(this.mediaControl, _events2.default.MEDIACONTROL_MOUSEMOVE_SEEKBAR, this.showTime);
    this.listenTo(this.mediaControl, _events2.default.MEDIACONTROL_MOUSELEAVE_SEEKBAR, this.hideTime);
    this.listenTo(this.mediaControl, _events2.default.MEDIACONTROL_CONTAINERCHANGED, this.onContainerChanged);
    if (this.mediaControlContainer) {
      this.listenTo(this.mediaControlContainer, _events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED, this.update);
      this.listenTo(this.mediaControlContainer, _events2.default.CONTAINER_TIMEUPDATE, this.updateDuration);
    }
  };

  SeekTime.prototype.onContainerChanged = function onContainerChanged() {
    this.stopListening();
    this.bindEvents();
  };

  SeekTime.prototype.updateDuration = function updateDuration(timeProgress) {
    this.duration = timeProgress.total;
    this.firstFragDateTime = timeProgress.firstFragDateTime;
    this.update();
  };

  SeekTime.prototype.showTime = function showTime(event) {
    this.hoveringOverSeekBar = true;
    this.calculateHoverPosition(event);
    this.update();
  };

  SeekTime.prototype.hideTime = function hideTime() {
    this.hoveringOverSeekBar = false;
    this.update();
  };

  SeekTime.prototype.calculateHoverPosition = function calculateHoverPosition(event) {
    var offset = event.pageX - this.mediaControl.$seekBarContainer.offset().left;
    // proportion into the seek bar that the mouse is hovered over 0-1
    this.hoverPosition = Math.min(1, Math.max(offset / this.mediaControl.$seekBarContainer.width(), 0));
  };

  SeekTime.prototype.getSeekTime = function getSeekTime() {
    var seekTime = void 0,
        secondsSinceMidnight = void 0,
        d = void 0,
        e = void 0;
    if (this.useActualLiveTime) {
      if (this.firstFragDateTime) {
        e = new Date(this.firstFragDateTime);
        d = new Date(this.firstFragDateTime);
        d.setHours(0, 0, 0, 0);
        secondsSinceMidnight = (e.getTime() - d.getTime()) / 1000 + this.duration;
      } else {
        d = new Date(new Date().getTime() - this.actualLiveServerTimeDiff);
        e = new Date(d);
        secondsSinceMidnight = (e - d.setHours(0, 0, 0, 0)) / 1000;
      }
      seekTime = secondsSinceMidnight - this.duration + this.hoverPosition * this.duration;
      if (seekTime < 0) seekTime += 86400;
    } else {
      seekTime = this.hoverPosition * this.duration;
    }

    return { seekTime: seekTime, secondsSinceMidnight: secondsSinceMidnight };
  };

  SeekTime.prototype.update = function update() {
    if (!this.rendered) {
      // update() is always called after a render
      return;
    }
    if (!this.shouldBeVisible()) {
      this.$el.hide();
      this.$el.css('left', '-100%');
    } else {
      var seekTime = this.getSeekTime();
      var currentSeekTime = (0, _utils.formatTime)(seekTime.seekTime, this.useActualLiveTime);
      // only update dom if necessary, ie time actually changed
      if (currentSeekTime !== this.displayedSeekTime) {
        this.$seekTimeEl.text(currentSeekTime);
        this.displayedSeekTime = currentSeekTime;
      }

      if (this.durationShown) {
        this.$durationEl.show();
        var currentDuration = (0, _utils.formatTime)(this.actualLiveTime ? seekTime.secondsSinceMidnight : this.duration, this.actualLiveTime);
        if (currentDuration !== this.displayedDuration) {
          this.$durationEl.text(currentDuration);
          this.displayedDuration = currentDuration;
        }
      } else {
        this.$durationEl.hide();
      }

      // the element must be unhidden before its width is requested, otherwise it's width will be reported as 0
      this.$el.show();
      var containerWidth = this.mediaControl.$seekBarContainer.width();
      var elWidth = this.$el.width();
      var elLeftPos = this.hoverPosition * containerWidth;
      elLeftPos -= elWidth / 2;
      elLeftPos = Math.max(0, Math.min(elLeftPos, containerWidth - elWidth));
      this.$el.css('left', elLeftPos);
    }
  };

  SeekTime.prototype.shouldBeVisible = function shouldBeVisible() {
    return this.mediaControlContainer && this.mediaControlContainer.settings.seekEnabled && this.hoveringOverSeekBar && this.hoverPosition !== null && this.duration !== null;
  };

  SeekTime.prototype.render = function render() {
    this.rendered = true;
    this.displayedDuration = null;
    this.displayedSeekTime = null;
    this.$el.html(this.template());
    this.$el.hide();
    this.mediaControl.$el.append(this.el);
    this.$seekTimeEl = this.$el.find('[data-seek-time]');
    this.$durationEl = this.$el.find('[data-duration]');
    this.$durationEl.hide();
    this.update();
  };

  return SeekTime;
}(_ui_core_plugin2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = SeekTime;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/sources.js":
/*!********************************!*\
  !*** ./src/plugins/sources.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _core_plugin = __webpack_require__(/*! ../base/core_plugin */ "./src/base/core_plugin.js");

var _core_plugin2 = _interopRequireDefault(_core_plugin);

var _events = __webpack_require__(/*! ../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SourcesPlugin = function (_CorePlugin) {
  (0, _inherits3.default)(SourcesPlugin, _CorePlugin);

  function SourcesPlugin() {
    (0, _classCallCheck3.default)(this, SourcesPlugin);
    return (0, _possibleConstructorReturn3.default)(this, _CorePlugin.apply(this, arguments));
  }

  SourcesPlugin.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.core, _events2.default.CORE_CONTAINERS_CREATED, this.onContainersCreated);
  };

  SourcesPlugin.prototype.onContainersCreated = function onContainersCreated() {
    var firstValidSource = this.core.containers.filter(function (container) {
      return container.playback.name !== 'no_op';
    })[0] || this.core.containers[0];
    if (firstValidSource) {
      this.core.containers.forEach(function (container) {
        if (container !== firstValidSource) container.destroy();
      });
    }
  };

  (0, _createClass3.default)(SourcesPlugin, [{
    key: 'name',
    get: function get() {
      return 'sources';
    }
  }]);
  return SourcesPlugin;
}(_core_plugin2.default);

exports.default = SourcesPlugin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/spinner_three_bounce/index.js":
/*!***************************************************!*\
  !*** ./src/plugins/spinner_three_bounce/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinner_three_bounce = __webpack_require__(/*! ./spinner_three_bounce */ "./src/plugins/spinner_three_bounce/spinner_three_bounce.js");

var _spinner_three_bounce2 = _interopRequireDefault(_spinner_three_bounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _spinner_three_bounce2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/spinner_three_bounce/public/spinner.html":
/*!**************************************************************!*\
  !*** ./src/plugins/spinner_three_bounce/public/spinner.html ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div data-bounce1></div><div data-bounce2></div><div data-bounce3></div>\n";

/***/ }),

/***/ "./src/plugins/spinner_three_bounce/public/spinner.scss":
/*!**************************************************************!*\
  !*** ./src/plugins/spinner_three_bounce/public/spinner.scss ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./spinner.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/spinner_three_bounce/public/spinner.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/spinner_three_bounce/spinner_three_bounce.js":
/*!******************************************************************!*\
  !*** ./src/plugins/spinner_three_bounce/spinner_three_bounce.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _ui_container_plugin = __webpack_require__(/*! ../../base/ui_container_plugin */ "./src/base/ui_container_plugin.js");

var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _spinner = __webpack_require__(/*! ./public/spinner.html */ "./src/plugins/spinner_three_bounce/public/spinner.html");

var _spinner2 = _interopRequireDefault(_spinner);

__webpack_require__(/*! ./public/spinner.scss */ "./src/plugins/spinner_three_bounce/public/spinner.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SpinnerThreeBouncePlugin = function (_UIContainerPlugin) {
  (0, _inherits3.default)(SpinnerThreeBouncePlugin, _UIContainerPlugin);
  (0, _createClass3.default)(SpinnerThreeBouncePlugin, [{
    key: 'name',
    get: function get() {
      return 'spinner';
    }
  }, {
    key: 'attributes',
    get: function get() {
      return {
        'data-spinner': '',
        'class': 'spinner-three-bounce'
      };
    }
  }]);

  function SpinnerThreeBouncePlugin(container) {
    (0, _classCallCheck3.default)(this, SpinnerThreeBouncePlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIContainerPlugin.call(this, container));

    _this.template = (0, _template2.default)(_spinner2.default);
    _this.showTimeout = null;
    _this.listenTo(_this.container, _events2.default.CONTAINER_STATE_BUFFERING, _this.onBuffering);
    _this.listenTo(_this.container, _events2.default.CONTAINER_STATE_BUFFERFULL, _this.onBufferFull);
    _this.listenTo(_this.container, _events2.default.CONTAINER_STOP, _this.onStop);
    _this.listenTo(_this.container, _events2.default.CONTAINER_ENDED, _this.onStop);
    _this.listenTo(_this.container, _events2.default.CONTAINER_ERROR, _this.onStop);
    _this.render();
    return _this;
  }

  SpinnerThreeBouncePlugin.prototype.onBuffering = function onBuffering() {
    this.show();
  };

  SpinnerThreeBouncePlugin.prototype.onBufferFull = function onBufferFull() {
    this.hide();
  };

  SpinnerThreeBouncePlugin.prototype.onStop = function onStop() {
    this.hide();
  };

  SpinnerThreeBouncePlugin.prototype.show = function show() {
    var _this2 = this;

    if (this.showTimeout === null) this.showTimeout = setTimeout(function () {
      return _this2.$el.show();
    }, 300);
  };

  SpinnerThreeBouncePlugin.prototype.hide = function hide() {
    if (this.showTimeout !== null) {
      clearTimeout(this.showTimeout);
      this.showTimeout = null;
    }
    this.$el.hide();
  };

  SpinnerThreeBouncePlugin.prototype.render = function render() {
    this.$el.html(this.template());
    this.container.$el.append(this.$el);
    this.$el.hide();
    if (this.container.buffering) this.onBuffering();

    return this;
  };

  return SpinnerThreeBouncePlugin;
}(_ui_container_plugin2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = SpinnerThreeBouncePlugin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/stats/index.js":
/*!************************************!*\
  !*** ./src/plugins/stats/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stats = __webpack_require__(/*! ./stats */ "./src/plugins/stats/stats.js");

var _stats2 = _interopRequireDefault(_stats);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _stats2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/stats/stats.js":
/*!************************************!*\
  !*** ./src/plugins/stats/stats.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _container_plugin = __webpack_require__(/*! ../../base/container_plugin */ "./src/base/container_plugin.js");

var _container_plugin2 = _interopRequireDefault(_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StatsPlugin = function (_ContainerPlugin) {
  (0, _inherits3.default)(StatsPlugin, _ContainerPlugin);
  (0, _createClass3.default)(StatsPlugin, [{
    key: 'name',
    get: function get() {
      return 'stats';
    }
  }]);

  function StatsPlugin(container) {
    (0, _classCallCheck3.default)(this, StatsPlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _ContainerPlugin.call(this, container));

    _this.setInitialAttrs();
    _this.reportInterval = _this.options.reportInterval || 5000;
    _this.state = 'IDLE';
    return _this;
  }

  StatsPlugin.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.container.playback, _events2.default.PLAYBACK_PLAY, this.onPlay);
    this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.onStop);
    this.listenTo(this.container, _events2.default.CONTAINER_ENDED, this.onStop);
    this.listenTo(this.container, _events2.default.CONTAINER_DESTROYED, this.onStop);
    this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERING, this.onBuffering);
    this.listenTo(this.container, _events2.default.CONTAINER_STATE_BUFFERFULL, this.onBufferFull);
    this.listenTo(this.container, _events2.default.CONTAINER_STATS_ADD, this.onStatsAdd);
    this.listenTo(this.container, _events2.default.CONTAINER_BITRATE, this.onStatsAdd);
    this.listenTo(this.container.playback, _events2.default.PLAYBACK_STATS_ADD, this.onStatsAdd);
  };

  StatsPlugin.prototype.setInitialAttrs = function setInitialAttrs() {
    this.firstPlay = true;
    this.startupTime = 0;
    this.rebufferingTime = 0;
    this.watchingTime = 0;
    this.rebuffers = 0;
    this.externalMetrics = {};
  };

  StatsPlugin.prototype.onPlay = function onPlay() {
    this.state = 'PLAYING';
    this.watchingTimeInit = Date.now();
    if (!this.intervalId) this.intervalId = setInterval(this.report.bind(this), this.reportInterval);
  };

  StatsPlugin.prototype.onStop = function onStop() {
    clearInterval(this.intervalId);
    this.report();
    this.intervalId = undefined;
    this.state = 'STOPPED';
  };

  StatsPlugin.prototype.onBuffering = function onBuffering() {
    if (this.firstPlay) this.startupTimeInit = Date.now();else this.rebufferingTimeInit = Date.now();

    this.state = 'BUFFERING';
    this.rebuffers++;
  };

  StatsPlugin.prototype.onBufferFull = function onBufferFull() {
    if (this.firstPlay && this.startupTimeInit) {
      this.firstPlay = false;
      this.startupTime = Date.now() - this.startupTimeInit;
      this.watchingTimeInit = Date.now();
    } else if (this.rebufferingTimeInit) {
      this.rebufferingTime += this.getRebufferingTime();
    }

    this.rebufferingTimeInit = undefined;
    this.state = 'PLAYING';
  };

  StatsPlugin.prototype.getRebufferingTime = function getRebufferingTime() {
    return Date.now() - this.rebufferingTimeInit;
  };

  StatsPlugin.prototype.getWatchingTime = function getWatchingTime() {
    var totalTime = Date.now() - this.watchingTimeInit;
    return totalTime - this.rebufferingTime;
  };

  StatsPlugin.prototype.isRebuffering = function isRebuffering() {
    return !!this.rebufferingTimeInit;
  };

  StatsPlugin.prototype.onStatsAdd = function onStatsAdd(metric) {
    _clapprZepto2.default.extend(this.externalMetrics, metric);
  };

  StatsPlugin.prototype.getStats = function getStats() {
    var metrics = {
      startupTime: this.startupTime,
      rebuffers: this.rebuffers,
      rebufferingTime: this.isRebuffering() ? this.rebufferingTime + this.getRebufferingTime() : this.rebufferingTime,
      watchingTime: this.isRebuffering() ? this.getWatchingTime() - this.getRebufferingTime() : this.getWatchingTime()
    };
    _clapprZepto2.default.extend(metrics, this.externalMetrics);
    return metrics;
  };

  StatsPlugin.prototype.report = function report() {
    this.container.statsReport(this.getStats());
  };

  return StatsPlugin;
}(_container_plugin2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = StatsPlugin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/strings.js":
/*!********************************!*\
  !*** ./src/plugins/strings.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _utils = __webpack_require__(/*! ../base/utils */ "./src/base/utils.js");

var _clapprZepto = __webpack_require__(/*! clappr-zepto */ "./node_modules/clappr-zepto/zepto.js");

var _clapprZepto2 = _interopRequireDefault(_clapprZepto);

var _core_plugin = __webpack_require__(/*! ../base/core_plugin */ "./src/base/core_plugin.js");

var _core_plugin2 = _interopRequireDefault(_core_plugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The internationalization (i18n) plugin
 * @class Strings
 * @constructor
 * @extends CorePlugin
 * @module plugins
 */
var Strings = function (_CorePlugin) {
  (0, _inherits3.default)(Strings, _CorePlugin);
  (0, _createClass3.default)(Strings, [{
    key: 'name',
    get: function get() {
      return 'strings';
    }
  }]);

  function Strings(core) {
    (0, _classCallCheck3.default)(this, Strings);

    var _this = (0, _possibleConstructorReturn3.default)(this, _CorePlugin.call(this, core));

    _this._initializeMessages();
    return _this;
  }
  /**
   * Gets a translated string for the given key.
   * @method t
   * @param {String} key the key to all messages
   * @return {String} translated label
   */


  Strings.prototype.t = function t(key) {
    var lang = this._language();
    var fallbackLang = this._messages['en'];
    var i18n = lang && this._messages[lang] || fallbackLang;
    return i18n[key] || fallbackLang[key] || key;
  };

  Strings.prototype._language = function _language() {
    return this.core.options.language || (0, _utils.getBrowserLanguage)();
  };

  Strings.prototype._initializeMessages = function _initializeMessages() {
    var defaultMessages = {
      'en': {
        'live': 'live',
        'back_to_live': 'back to live',
        'disabled': 'Disabled',
        'playback_not_supported': 'Your browser does not support the playback of this video. Please try using a different browser.',
        'default_error_title': 'Could not play video.',
        'default_error_message': 'There was a problem trying to load the video.'
      },
      'pt': {
        'live': 'ao vivo',
        'back_to_live': 'voltar para o ao vivo',
        'disabled': 'Desativado',
        'playback_not_supported': 'Seu navegador no supporta a reproduo deste video. Por favor, tente usar um navegador diferente.',
        'default_error_title': 'No foi possvel reproduzir o vdeo.',
        'default_error_message': 'Ocorreu um problema ao tentar carregar o vdeo.'
      },
      'es': {
        'live': 'vivo',
        'back_to_live': 'volver en vivo',
        'disabled': 'Discapacitado',
        'playback_not_supported': 'Su navegador no soporta la reproduccin de un video. Por favor, trate de usar un navegador diferente.'
      },
      'ru': {
        'live': ' ',
        'back_to_live': '  ',
        'disabled': '',
        'playback_not_supported': '      . ,   .'
      },
      'fr': {
        'live': 'en direct',
        'back_to_live': 'retour au direct',
        'disabled': 'Dsactiv',
        'playback_not_supported': 'Votre navigateur ne supporte pas la lecture de cette vido. Merci de tenter sur un autre navigateur.',
        'default_error_title': 'Impossible de lire la vido.',
        'default_error_message': 'Un problme est survenu lors du chargement de la vido.'
      },
      'tr': {
        'live': 'canl',
        'back_to_live': 'canl yayna dn',
        'disabled': 'Engelli',
        'playback_not_supported': 'Taraycnz bu videoyu oynatma desteine sahip deil. Ltfen farkl bir tarayc ile deneyin.'
      },
      'et': {
        'live': 'Otselekanne',
        'back_to_live': 'Tagasi otselekande juurde',
        'disabled': 'Keelatud',
        'playback_not_supported': 'Teie brauser ei toeta selle video taasesitust. Proovige kasutada muud brauserit.'
      },
      'ar': {
        'live': '',
        'back_to_live': '  ',
        'disabled': '',
        'playback_not_supported': '       .    .',
        'default_error_title': '   .',
        'default_error_message': '    .'
      }
    };

    this._messages = _clapprZepto2.default.extend(true, defaultMessages, this.core.options.strings || {});
    this._messages['pt-BR'] = this._messages['pt'];
    this._messages['en-US'] = this._messages['en'];
    this._messages['es-419'] = this._messages['es'];
    this._messages['fr-FR'] = this._messages['fr'];
    this._messages['tr-TR'] = this._messages['tr'];
    this._messages['et-EE'] = this._messages['et'];
    this._messages['ar-IQ'] = this._messages['ar'];
  };

  return Strings;
}(_core_plugin2.default);

exports.default = Strings;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/watermark/index.js":
/*!****************************************!*\
  !*** ./src/plugins/watermark/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _watermark = __webpack_require__(/*! ./watermark */ "./src/plugins/watermark/watermark.js");

var _watermark2 = _interopRequireDefault(_watermark);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _watermark2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./src/plugins/watermark/public/watermark.html":
/*!*****************************************************!*\
  !*** ./src/plugins/watermark/public/watermark.html ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"clappr-watermark\" data-watermark data-watermark-<%=position %>>\n<% if(typeof imageLink !== 'undefined') { %>\n<a target=_blank href=\"<%= imageLink %>\">\n<% } %>\n<img src=\"<%= imageUrl %>\">\n<% if(typeof imageLink !== 'undefined') { %>\n</a>\n<% } %>\n</div>\n";

/***/ }),

/***/ "./src/plugins/watermark/public/watermark.scss":
/*!*****************************************************!*\
  !*** ./src/plugins/watermark/public/watermark.scss ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader!../../../../node_modules/postcss-loader/lib!../../../../node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./watermark.scss */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/lib/index.js!./node_modules/sass-loader/lib/loader.js?includePaths[]=/Users/artemmyznikov/projects/clappr/src/base/scss!./src/plugins/watermark/public/watermark.scss");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"singleton":true,"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/plugins/watermark/watermark.js":
/*!********************************************!*\
  !*** ./src/plugins/watermark/watermark.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

var _ui_container_plugin = __webpack_require__(/*! ../../base/ui_container_plugin */ "./src/base/ui_container_plugin.js");

var _ui_container_plugin2 = _interopRequireDefault(_ui_container_plugin);

var _events = __webpack_require__(/*! ../../base/events */ "./src/base/events.js");

var _events2 = _interopRequireDefault(_events);

var _template = __webpack_require__(/*! ../../base/template */ "./src/base/template.js");

var _template2 = _interopRequireDefault(_template);

var _watermark = __webpack_require__(/*! ./public/watermark.html */ "./src/plugins/watermark/public/watermark.html");

var _watermark2 = _interopRequireDefault(_watermark);

__webpack_require__(/*! ./public/watermark.scss */ "./src/plugins/watermark/public/watermark.scss");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WaterMarkPlugin = function (_UIContainerPlugin) {
  (0, _inherits3.default)(WaterMarkPlugin, _UIContainerPlugin);
  (0, _createClass3.default)(WaterMarkPlugin, [{
    key: 'name',
    get: function get() {
      return 'watermark';
    }
  }, {
    key: 'template',
    get: function get() {
      return (0, _template2.default)(_watermark2.default);
    }
  }]);

  function WaterMarkPlugin(container) {
    (0, _classCallCheck3.default)(this, WaterMarkPlugin);

    var _this = (0, _possibleConstructorReturn3.default)(this, _UIContainerPlugin.call(this, container));

    _this.configure();
    return _this;
  }

  WaterMarkPlugin.prototype.bindEvents = function bindEvents() {
    this.listenTo(this.container, _events2.default.CONTAINER_PLAY, this.onPlay);
    this.listenTo(this.container, _events2.default.CONTAINER_STOP, this.onStop);
    this.listenTo(this.container, _events2.default.CONTAINER_OPTIONS_CHANGE, this.configure);
  };

  WaterMarkPlugin.prototype.configure = function configure() {
    this.position = this.options.position || 'bottom-right';
    if (this.options.watermark) {
      this.imageUrl = this.options.watermark;
      this.imageLink = this.options.watermarkLink;
      this.render();
    } else {
      this.$el.remove();
    }
  };

  WaterMarkPlugin.prototype.onPlay = function onPlay() {
    if (!this.hidden) this.$el.show();
  };

  WaterMarkPlugin.prototype.onStop = function onStop() {
    this.$el.hide();
  };

  WaterMarkPlugin.prototype.render = function render() {
    this.$el.hide();
    var templateOptions = { position: this.position, imageUrl: this.imageUrl, imageLink: this.imageLink };
    this.$el.html(this.template(templateOptions));
    this.container.$el.append(this.$el);
    return this;
  };

  return WaterMarkPlugin;
}(_ui_container_plugin2.default); // Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

exports.default = WaterMarkPlugin;
module.exports = exports['default'];

/***/ }),

/***/ "./src/vendor/index.js":
/*!*****************************!*\
  !*** ./src/vendor/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _kibo = __webpack_require__(/*! ./kibo */ "./src/vendor/kibo.js");

var _kibo2 = _interopRequireDefault(_kibo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = { Kibo: _kibo2.default };
module.exports = exports['default'];

/***/ }),

/***/ "./src/vendor/kibo.js":
/*!****************************!*\
  !*** ./src/vendor/kibo.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable */
// Kibo is released under the MIT License. Copyright (c) 2013 marquete.
// see https://github.com/marquete/kibo

var Kibo = function Kibo(element) {
  this.element = element || window.document;
  this.initialize();
};

Kibo.KEY_NAMES_BY_CODE = {
  8: 'backspace', 9: 'tab', 13: 'enter',
  16: 'shift', 17: 'ctrl', 18: 'alt',
  20: 'caps_lock',
  27: 'esc',
  32: 'space',
  37: 'left', 38: 'up', 39: 'right', 40: 'down',
  48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9',
  65: 'a', 66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h', 73: 'i', 74: 'j',
  75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o', 80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't',
  85: 'u', 86: 'v', 87: 'w', 88: 'x', 89: 'y', 90: 'z', 112: 'f1', 113: 'f2', 114: 'f3',
  115: 'f4', 116: 'f5', 117: 'f6', 118: 'f7', 119: 'f8', 120: 'f9', 121: 'f10', 122: 'f11', 123: 'f12'
};

Kibo.KEY_CODES_BY_NAME = {};
(function () {
  for (var key in Kibo.KEY_NAMES_BY_CODE) {
    if (Object.prototype.hasOwnProperty.call(Kibo.KEY_NAMES_BY_CODE, key)) {
      Kibo.KEY_CODES_BY_NAME[Kibo.KEY_NAMES_BY_CODE[key]] = +key;
    }
  }
})();

Kibo.MODIFIERS = ['shift', 'ctrl', 'alt'];

Kibo.registerEvent = function () {
  if (document.addEventListener) {
    return function (element, eventName, func) {
      element.addEventListener(eventName, func, false);
    };
  } else if (document.attachEvent) {
    return function (element, eventName, func) {
      element.attachEvent('on' + eventName, func);
    };
  }
}();

Kibo.unregisterEvent = function () {
  if (document.removeEventListener) {
    return function (element, eventName, func) {
      element.removeEventListener(eventName, func, false);
    };
  } else if (document.detachEvent) {
    return function (element, eventName, func) {
      element.detachEvent('on' + eventName, func);
    };
  }
}();

Kibo.stringContains = function (string, substring) {
  return string.indexOf(substring) !== -1;
};

Kibo.neatString = function (string) {
  return string.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
};

Kibo.capitalize = function (string) {
  return string.toLowerCase().replace(/^./, function (match) {
    return match.toUpperCase();
  });
};

Kibo.isString = function (what) {
  return Kibo.stringContains(Object.prototype.toString.call(what), 'String');
};

Kibo.arrayIncludes = function () {
  if (Array.prototype.indexOf) {
    return function (haystack, needle) {
      return haystack.indexOf(needle) !== -1;
    };
  } else {
    return function (haystack, needle) {
      for (var i = 0; i < haystack.length; i++) {
        if (haystack[i] === needle) {
          return true;
        }
      }
      return false;
    };
  }
}();

Kibo.extractModifiers = function (keyCombination) {
  var modifiers, i;
  modifiers = [];
  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
    if (Kibo.stringContains(keyCombination, Kibo.MODIFIERS[i])) {
      modifiers.push(Kibo.MODIFIERS[i]);
    }
  }
  return modifiers;
};

Kibo.extractKey = function (keyCombination) {
  var keys, i;
  keys = Kibo.neatString(keyCombination).split(' ');
  for (i = 0; i < keys.length; i++) {
    if (!Kibo.arrayIncludes(Kibo.MODIFIERS, keys[i])) {
      return keys[i];
    }
  }
};

Kibo.modifiersAndKey = function (keyCombination) {
  var result, key;

  if (Kibo.stringContains(keyCombination, 'any')) {
    return Kibo.neatString(keyCombination).split(' ').slice(0, 2).join(' ');
  }

  result = Kibo.extractModifiers(keyCombination);

  key = Kibo.extractKey(keyCombination);
  if (key && !Kibo.arrayIncludes(Kibo.MODIFIERS, key)) {
    result.push(key);
  }

  return result.join(' ');
};

Kibo.keyName = function (keyCode) {
  return Kibo.KEY_NAMES_BY_CODE[keyCode + ''];
};

Kibo.keyCode = function (keyName) {
  return +Kibo.KEY_CODES_BY_NAME[keyName];
};

Kibo.prototype.initialize = function () {
  var i,
      that = this;

  this.lastKeyCode = -1;
  this.lastModifiers = {};
  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
    this.lastModifiers[Kibo.MODIFIERS[i]] = false;
  }

  this.keysDown = { any: [] };
  this.keysUp = { any: [] };
  this.downHandler = this.handler('down');
  this.upHandler = this.handler('up');

  Kibo.registerEvent(this.element, 'keydown', this.downHandler);
  Kibo.registerEvent(this.element, 'keyup', this.upHandler);
  Kibo.registerEvent(window, 'unload', function unloader() {
    Kibo.unregisterEvent(that.element, 'keydown', that.downHandler);
    Kibo.unregisterEvent(that.element, 'keyup', that.upHandler);
    Kibo.unregisterEvent(window, 'unload', unloader);
  });
};

Kibo.prototype.handler = function (upOrDown) {
  var that = this;
  return function (e) {
    var i, registeredKeys, lastModifiersAndKey;

    e = e || window.event;

    that.lastKeyCode = e.keyCode;
    for (i = 0; i < Kibo.MODIFIERS.length; i++) {
      that.lastModifiers[Kibo.MODIFIERS[i]] = e[Kibo.MODIFIERS[i] + 'Key'];
    }
    if (Kibo.arrayIncludes(Kibo.MODIFIERS, Kibo.keyName(that.lastKeyCode))) {
      that.lastModifiers[Kibo.keyName(that.lastKeyCode)] = true;
    }

    registeredKeys = that['keys' + Kibo.capitalize(upOrDown)];

    for (i = 0; i < registeredKeys.any.length; i++) {
      if (registeredKeys.any[i](e) === false && e.preventDefault) {
        e.preventDefault();
      }
    }

    lastModifiersAndKey = that.lastModifiersAndKey();
    if (registeredKeys[lastModifiersAndKey]) {
      for (i = 0; i < registeredKeys[lastModifiersAndKey].length; i++) {
        if (registeredKeys[lastModifiersAndKey][i](e) === false && e.preventDefault) {
          e.preventDefault();
        }
      }
    }
  };
};

Kibo.prototype.registerKeys = function (upOrDown, newKeys, func) {
  var i,
      keys,
      registeredKeys = this['keys' + Kibo.capitalize(upOrDown)];

  if (Kibo.isString(newKeys)) {
    newKeys = [newKeys];
  }

  for (i = 0; i < newKeys.length; i++) {
    keys = newKeys[i];
    keys = Kibo.modifiersAndKey(keys + '');

    if (registeredKeys[keys]) {
      registeredKeys[keys].push(func);
    } else {
      registeredKeys[keys] = [func];
    }
  }

  return this;
};

// jshint maxdepth:5
Kibo.prototype.unregisterKeys = function (upOrDown, newKeys, func) {
  var i,
      j,
      keys,
      registeredKeys = this['keys' + Kibo.capitalize(upOrDown)];

  if (Kibo.isString(newKeys)) {
    newKeys = [newKeys];
  }

  for (i = 0; i < newKeys.length; i++) {
    keys = newKeys[i];
    keys = Kibo.modifiersAndKey(keys + '');

    if (func === null) {
      delete registeredKeys[keys];
    } else {
      if (registeredKeys[keys]) {
        for (j = 0; j < registeredKeys[keys].length; j++) {
          if (String(registeredKeys[keys][j]) === String(func)) {
            registeredKeys[keys].splice(j, 1);
            break;
          }
        }
      }
    }
  }

  return this;
};

Kibo.prototype.off = function (keys) {
  return this.unregisterKeys('down', keys, null);
};

Kibo.prototype.delegate = function (upOrDown, keys, func) {
  return func !== null || func !== undefined ? this.registerKeys(upOrDown, keys, func) : this.unregisterKeys(upOrDown, keys, func);
};

Kibo.prototype.down = function (keys, func) {
  return this.delegate('down', keys, func);
};

Kibo.prototype.up = function (keys, func) {
  return this.delegate('up', keys, func);
};

Kibo.prototype.lastKey = function (modifier) {
  if (!modifier) {
    return Kibo.keyName(this.lastKeyCode);
  }

  return this.lastModifiers[modifier];
};

Kibo.prototype.lastModifiersAndKey = function () {
  var result, i;

  result = [];
  for (i = 0; i < Kibo.MODIFIERS.length; i++) {
    if (this.lastKey(Kibo.MODIFIERS[i])) {
      result.push(Kibo.MODIFIERS[i]);
    }
  }

  if (!Kibo.arrayIncludes(result, this.lastKey())) {
    result.push(this.lastKey());
  }

  return result.join(' ');
};

exports.default = Kibo;
module.exports = exports['default'];

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DbGFwcHIvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0NsYXBwci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY2xhcHByLXplcHRvL3plcHRvLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyL3B1YmxpYy9zdHlsZS5zY3NzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2NvcmUvcHVibGljL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9odG1sNV92aWRlby9wdWJsaWMvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL2h0bWxfaW1nL3B1YmxpYy9zdHlsZS5zY3NzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbGF5YmFja3Mvbm9fb3AvcHVibGljL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvY2xvc2VkX2NhcHRpb25zL3B1YmxpYy9jbG9zZWRfY2FwdGlvbnMuc2NzcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9kdnJfY29udHJvbHMvcHVibGljL2R2cl9jb250cm9scy5zY3NzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL2Vycm9yX3NjcmVlbi9wdWJsaWMvZXJyb3Jfc2NyZWVuLnNjc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvbWVkaWFfY29udHJvbC9wdWJsaWMvbWVkaWEtY29udHJvbC5zY3NzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3Bvc3Rlci9wdWJsaWMvcG9zdGVyLnNjc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc2Vla190aW1lL3B1YmxpYy9zZWVrX3RpbWUuc2NzcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9zcGlubmVyX3RocmVlX2JvdW5jZS9wdWJsaWMvc3Bpbm5lci5zY3NzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3dhdGVybWFyay9wdWJsaWMvd2F0ZXJtYXJrLnNjc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzIiwid2VicGFjazovL0NsYXBwci8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS9iYXNlX29iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS9jb250YWluZXJfcGx1Z2luLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL2NvcmVfcGx1Z2luLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL2Vycm9yX21peGluLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS9tZWRpYS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS9wbGF5YmFjay5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2Jhc2Uvc3R5bGVyLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL3N2Z19pY29ucy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS91aV9jb250YWluZXJfcGx1Z2luLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL3VpX2NvcmVfcGx1Z2luLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9iYXNlL3VpX29iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvYmFzZS91dGlscy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9icm93c2VyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvYnJvd3Nlci9icm93c2VyX2RhdGEuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9icm93c2VyL29zX2RhdGEuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9jb250YWluZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyL3B1YmxpYy9zdHlsZS5zY3NzPzkxN2QiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyX2ZhY3RvcnkvY29udGFpbmVyX2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyX2ZhY3RvcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29yZS9jb3JlLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29yZS9wdWJsaWMvUm9ib3RvLnR0ZiIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9jb3JlL3B1YmxpYy9mb250cy5jc3MiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29yZS9wdWJsaWMvc3R5bGUuc2Nzcz84YjE3Iiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2NvcmVfZmFjdG9yeS9jb3JlX2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2NvbXBvbmVudHMvY29yZV9mYWN0b3J5L2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2Vycm9yL2Vycm9yLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2Vycm9yL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL2xvYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9sb2FkZXIvbG9hZGVyLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL21lZGlhdG9yLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9jb21wb25lbnRzL3BsYXllci5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvY29tcG9uZW50cy9wbGF5ZXJfaW5mby5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvaWNvbnMvMDEtcGxheS5zdmciLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2ljb25zLzAyLXBhdXNlLnN2ZyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvaWNvbnMvMDMtc3RvcC5zdmciLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2ljb25zLzA0LXZvbHVtZS5zdmciLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2ljb25zLzA1LW11dGUuc3ZnIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9pY29ucy8wNi1leHBhbmQuc3ZnIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9pY29ucy8wNy1zaHJpbmsuc3ZnIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9pY29ucy8wOC1oZC5zdmciLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL2ljb25zLzA5LWNjLnN2ZyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvaWNvbnMvMTAtcmVsb2FkLnN2ZyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL2hscy9obHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9obHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9odG1sNV9hdWRpby9odG1sNV9hdWRpby5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL2h0bWw1X2F1ZGlvL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbGF5YmFja3MvaHRtbDVfdmlkZW8vaHRtbDVfdmlkZW8uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9odG1sNV92aWRlby9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL2h0bWw1X3ZpZGVvL3B1YmxpYy9zdHlsZS5zY3NzPzExZDEiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9odG1sNV92aWRlby9wdWJsaWMvdHJhY2tzLmh0bWwiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9odG1sX2ltZy9odG1sX2ltZy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL2h0bWxfaW1nL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbGF5YmFja3MvaHRtbF9pbWcvcHVibGljL3N0eWxlLnNjc3M/N2RmZSIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL25vX29wL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbGF5YmFja3Mvbm9fb3Avbm9fb3AuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsYXliYWNrcy9ub19vcC9wdWJsaWMvZXJyb3IuaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGxheWJhY2tzL25vX29wL3B1YmxpYy9zdHlsZS5zY3NzP2VhMTYiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvY2xpY2tfdG9fcGF1c2UvY2xpY2tfdG9fcGF1c2UuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvY2xpY2tfdG9fcGF1c2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvY2xvc2VkX2NhcHRpb25zL2Nsb3NlZF9jYXB0aW9ucy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9jbG9zZWRfY2FwdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvY2xvc2VkX2NhcHRpb25zL3B1YmxpYy9jbG9zZWRfY2FwdGlvbnMuaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9jbG9zZWRfY2FwdGlvbnMvcHVibGljL2Nsb3NlZF9jYXB0aW9ucy5zY3NzP2FiZDUiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZHZyX2NvbnRyb2xzL2R2cl9jb250cm9scy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9kdnJfY29udHJvbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZHZyX2NvbnRyb2xzL3B1YmxpYy9kdnJfY29udHJvbHMuc2Nzcz80NmViIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL2R2cl9jb250cm9scy9wdWJsaWMvaW5kZXguaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9lbmRfdmlkZW8uanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZXJyb3Jfc2NyZWVuL2Vycm9yX3NjcmVlbi5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9lcnJvcl9zY3JlZW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZXJyb3Jfc2NyZWVuL3B1YmxpYy9lcnJvcl9zY3JlZW4uaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9lcnJvcl9zY3JlZW4vcHVibGljL2Vycm9yX3NjcmVlbi5zY3NzP2U1MjIiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZmF2aWNvbi9mYXZpY29uLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL2Zhdmljb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvZ29vZ2xlX2FuYWx5dGljcy9nb29nbGVfYW5hbHl0aWNzLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL2dvb2dsZV9hbmFseXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvbG9nL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL2xvZy9sb2cuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvbWVkaWFfY29udHJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9tZWRpYV9jb250cm9sL21lZGlhX2NvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvbWVkaWFfY29udHJvbC9wdWJsaWMvbWVkaWEtY29udHJvbC5odG1sIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL21lZGlhX2NvbnRyb2wvcHVibGljL21lZGlhLWNvbnRyb2wuc2Nzcz9mZDdhIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3Bvc3Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9wb3N0ZXIvcG9zdGVyLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3Bvc3Rlci9wdWJsaWMvcG9zdGVyLmh0bWwiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvcG9zdGVyL3B1YmxpYy9wb3N0ZXIuc2Nzcz9jYzYwIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3NlZWtfdGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9zZWVrX3RpbWUvcHVibGljL3NlZWtfdGltZS5odG1sIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3NlZWtfdGltZS9wdWJsaWMvc2Vla190aW1lLnNjc3M/Zjg1YyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9zZWVrX3RpbWUvc2Vla190aW1lLmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy9wbHVnaW5zL3NvdXJjZXMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3Bpbm5lcl90aHJlZV9ib3VuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3Bpbm5lcl90aHJlZV9ib3VuY2UvcHVibGljL3NwaW5uZXIuaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy9zcGlubmVyX3RocmVlX2JvdW5jZS9wdWJsaWMvc3Bpbm5lci5zY3NzP2RhNDYiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3Bpbm5lcl90aHJlZV9ib3VuY2Uvc3Bpbm5lcl90aHJlZV9ib3VuY2UuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3RhdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3RhdHMvc3RhdHMuanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy93YXRlcm1hcmsvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvd2F0ZXJtYXJrL3B1YmxpYy93YXRlcm1hcmsuaHRtbCIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvcGx1Z2lucy93YXRlcm1hcmsvcHVibGljL3dhdGVybWFyay5zY3NzP2IzZjAiLCJ3ZWJwYWNrOi8vQ2xhcHByLy4vc3JjL3BsdWdpbnMvd2F0ZXJtYXJrL3dhdGVybWFyay5qcyIsIndlYnBhY2s6Ly9DbGFwcHIvLi9zcmMvdmVuZG9yL2luZGV4LmpzIiwid2VicGFjazovL0NsYXBwci8uL3NyYy92ZW5kb3Iva2liby5qcyJdLCJuYW1lcyI6WyJCYXNlT2JqZWN0IiwiX29wdGlvbnMiLCJvcHRpb25zIiwidW5pcXVlSWQiLCJFdmVudHMiLCJDb250YWluZXJQbHVnaW4iLCJjb250YWluZXIiLCJwbGF5ZXJFcnJvciIsImVuYWJsZWQiLCJiaW5kRXZlbnRzIiwiZW5hYmxlIiwiZGlzYWJsZSIsInN0b3BMaXN0ZW5pbmciLCJkZXN0cm95IiwicHJvdG90eXBlIiwiRXJyb3JNaXhpbiIsImV4dGVuZCIsInByb3BlcnRpZXMiLCJ0eXBlIiwiQ29yZVBsdWdpbiIsImNvcmUiLCJnZXRFeHRlcm5hbEludGVyZmFjZSIsImNyZWF0ZUVycm9yIiwiZXJyb3IiLCJ1c2VDb2RlUHJlZml4Iiwic2NvcGUiLCJjb25zdHJ1Y3RvciIsIm9yaWdpbiIsIm5hbWUiLCJpMThuIiwicHJlZml4ZWRDb2RlIiwiY29kZSIsImRlZmF1bHRFcnJvciIsImRlc2NyaXB0aW9uIiwibGV2ZWwiLCJQbGF5ZXJFcnJvciIsIkxldmVscyIsIkZBVEFMIiwicmF3IiwiZXJyb3JEYXRhIiwiVUkiLCJkZWZhdWx0VUkiLCJ0aXRsZSIsInQiLCJtZXNzYWdlIiwiTG9nIiwid2FybiIsInNsaWNlIiwiQXJyYXkiLCJldmVudFNwbGl0dGVyIiwiZXZlbnRzQXBpIiwib2JqIiwiYWN0aW9uIiwicmVzdCIsImtleSIsImFwcGx5IiwiY29uY2F0IiwidGVzdCIsIm5hbWVzIiwic3BsaXQiLCJpIiwibCIsImxlbmd0aCIsInRyaWdnZXJFdmVudHMiLCJldmVudHMiLCJhcmdzIiwia2xhc3MiLCJldiIsImExIiwiYTIiLCJhMyIsInJ1biIsImNhbGxiYWNrIiwiY2FsbCIsImN0eCIsImV4Y2VwdGlvbiIsIm9uIiwiY29udGV4dCIsIl9ldmVudHMiLCJwdXNoIiwib25jZSIsIm9mZiIsImFyZ3VtZW50cyIsInJldGFpbiIsImoiLCJrIiwiX2NhbGxiYWNrIiwidHJpZ2dlciIsImRlYnVnIiwiYWxsRXZlbnRzIiwiYWxsIiwibGlzdGVuaW5nVG8iLCJfbGlzdGVuaW5nVG8iLCJyZW1vdmUiLCJfbGlzdGVuSWQiLCJpZCIsInJlZ2lzdGVyIiwiZXZlbnROYW1lIiwiQ3VzdG9tIiwicHJvcGVydHkiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsIm1hcCIsInZhbHVlIiwiaW5kZXgiLCJqb2luIiwibGlzdEF2YWlsYWJsZUN1c3RvbUV2ZW50cyIsImZpbHRlciIsImxpc3Rlbk1ldGhvZHMiLCJsaXN0ZW5UbyIsImxpc3RlblRvT25jZSIsImZvckVhY2giLCJtZXRob2QiLCJQTEFZRVJfUkVBRFkiLCJQTEFZRVJfUkVTSVpFIiwiUExBWUVSX0ZVTExTQ1JFRU4iLCJQTEFZRVJfUExBWSIsIlBMQVlFUl9QQVVTRSIsIlBMQVlFUl9TVE9QIiwiUExBWUVSX0VOREVEIiwiUExBWUVSX1NFRUsiLCJQTEFZRVJfRVJST1IiLCJFUlJPUiIsIlBMQVlFUl9USU1FVVBEQVRFIiwiUExBWUVSX1ZPTFVNRVVQREFURSIsIlBMQVlFUl9TVUJUSVRMRV9BVkFJTEFCTEUiLCJQTEFZQkFDS19QUk9HUkVTUyIsIlBMQVlCQUNLX1RJTUVVUERBVEUiLCJQTEFZQkFDS19SRUFEWSIsIlBMQVlCQUNLX0JVRkZFUklORyIsIlBMQVlCQUNLX0JVRkZFUkZVTEwiLCJQTEFZQkFDS19TRVRUSU5HU1VQREFURSIsIlBMQVlCQUNLX0xPQURFRE1FVEFEQVRBIiwiUExBWUJBQ0tfSElHSERFRklOSVRJT05VUERBVEUiLCJQTEFZQkFDS19CSVRSQVRFIiwiUExBWUJBQ0tfTEVWRUxTX0FWQUlMQUJMRSIsIlBMQVlCQUNLX0ZJUlNUX0xFVkVMIiwiUExBWUJBQ0tfTEVWRUxfU1dJVENIX1NUQVJUIiwiUExBWUJBQ0tfTEVWRUxfU1dJVENIX0VORCIsIlBMQVlCQUNLX1BMQVlCQUNLU1RBVEUiLCJQTEFZQkFDS19EVlIiLCJQTEFZQkFDS19NRURJQUNPTlRST0xfRElTQUJMRSIsIlBMQVlCQUNLX01FRElBQ09OVFJPTF9FTkFCTEUiLCJQTEFZQkFDS19FTkRFRCIsIlBMQVlCQUNLX1BMQVlfSU5URU5UIiwiUExBWUJBQ0tfUFJFUk9MTF9SRVFVRVNUIiwiUExBWUJBQ0tfUExBWSIsIlBMQVlCQUNLX1BBVVNFIiwiUExBWUJBQ0tfU0VFSyIsIlBMQVlCQUNLX1NFRUtFRCIsIlBMQVlCQUNLX1NUT1AiLCJQTEFZQkFDS19FUlJPUiIsIlBMQVlCQUNLX1NUQVRTX0FERCIsIlBMQVlCQUNLX0ZSQUdNRU5UX0xPQURFRCIsIlBMQVlCQUNLX0xFVkVMX1NXSVRDSCIsIlBMQVlCQUNLX1NVQlRJVExFX0FWQUlMQUJMRSIsIlBMQVlCQUNLX1NVQlRJVExFX0NIQU5HRUQiLCJDT1JFX0NPTlRBSU5FUlNfQ1JFQVRFRCIsIkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VEIiwiQ09SRV9PUFRJT05TX0NIQU5HRSIsIkNPUkVfUkVBRFkiLCJDT1JFX0ZVTExTQ1JFRU4iLCJDT1JFX1JFU0laRSIsIkNPUkVfU0NSRUVOX09SSUVOVEFUSU9OX0NIQU5HRUQiLCJDT1JFX01PVVNFX01PVkUiLCJDT1JFX01PVVNFX0xFQVZFIiwiQ09OVEFJTkVSX1BMQVlCQUNLU1RBVEUiLCJDT05UQUlORVJfUExBWUJBQ0tEVlJTVEFURUNIQU5HRUQiLCJDT05UQUlORVJfQklUUkFURSIsIkNPTlRBSU5FUl9TVEFUU19SRVBPUlQiLCJDT05UQUlORVJfREVTVFJPWUVEIiwiQ09OVEFJTkVSX1JFQURZIiwiQ09OVEFJTkVSX0VSUk9SIiwiQ09OVEFJTkVSX0xPQURFRE1FVEFEQVRBIiwiQ09OVEFJTkVSX1NVQlRJVExFX0FWQUlMQUJMRSIsIkNPTlRBSU5FUl9TVUJUSVRMRV9DSEFOR0VEIiwiQ09OVEFJTkVSX1RJTUVVUERBVEUiLCJDT05UQUlORVJfUFJPR1JFU1MiLCJDT05UQUlORVJfUExBWSIsIkNPTlRBSU5FUl9TVE9QIiwiQ09OVEFJTkVSX1BBVVNFIiwiQ09OVEFJTkVSX0VOREVEIiwiQ09OVEFJTkVSX0NMSUNLIiwiQ09OVEFJTkVSX0RCTENMSUNLIiwiQ09OVEFJTkVSX0NPTlRFWFRNRU5VIiwiQ09OVEFJTkVSX01PVVNFX0VOVEVSIiwiQ09OVEFJTkVSX01PVVNFX0xFQVZFIiwiQ09OVEFJTkVSX1NFRUsiLCJDT05UQUlORVJfU0VFS0VEIiwiQ09OVEFJTkVSX1ZPTFVNRSIsIkNPTlRBSU5FUl9GVUxMU0NSRUVOIiwiQ09OVEFJTkVSX1NUQVRFX0JVRkZFUklORyIsIkNPTlRBSU5FUl9TVEFURV9CVUZGRVJGVUxMIiwiQ09OVEFJTkVSX1NFVFRJTkdTVVBEQVRFIiwiQ09OVEFJTkVSX0hJR0hERUZJTklUSU9OVVBEQVRFIiwiQ09OVEFJTkVSX01FRElBQ09OVFJPTF9TSE9XIiwiQ09OVEFJTkVSX01FRElBQ09OVFJPTF9ISURFIiwiQ09OVEFJTkVSX01FRElBQ09OVFJPTF9ESVNBQkxFIiwiQ09OVEFJTkVSX01FRElBQ09OVFJPTF9FTkFCTEUiLCJDT05UQUlORVJfU1RBVFNfQUREIiwiQ09OVEFJTkVSX09QVElPTlNfQ0hBTkdFIiwiTUVESUFDT05UUk9MX1JFTkRFUkVEIiwiTUVESUFDT05UUk9MX0ZVTExTQ1JFRU4iLCJNRURJQUNPTlRST0xfU0hPVyIsIk1FRElBQ09OVFJPTF9ISURFIiwiTUVESUFDT05UUk9MX01PVVNFTU9WRV9TRUVLQkFSIiwiTUVESUFDT05UUk9MX01PVVNFTEVBVkVfU0VFS0JBUiIsIk1FRElBQ09OVFJPTF9QTEFZSU5HIiwiTUVESUFDT05UUk9MX05PVFBMQVlJTkciLCJNRURJQUNPTlRST0xfQ09OVEFJTkVSQ0hBTkdFRCIsIk1FRElBQ09OVFJPTF9PUFRJT05TX0NIQU5HRSIsIm1wNCIsIlBsYXliYWNrIiwiX2kxOG4iLCJfY29uc2VudGVkIiwic2V0dGluZ3MiLCJjb25zZW50IiwicGxheSIsInBhdXNlIiwic3RvcCIsInNlZWsiLCJ0aW1lIiwic2Vla1BlcmNlbnRhZ2UiLCJwZXJjZW50YWdlIiwiZ2V0U3RhcnRUaW1lT2Zmc2V0IiwiZ2V0RHVyYXRpb24iLCJpc1BsYXlpbmciLCJnZXRQbGF5YmFja1R5cGUiLCJOT19PUCIsImlzSGlnaERlZmluaXRpb25JblVzZSIsInZvbHVtZSIsImNvbmZpZ3VyZSIsIiQiLCJhdHRlbXB0QXV0b1BsYXkiLCJjYW5BdXRvUGxheSIsInJlc3VsdCIsImNiIiwiY2xvc2VkQ2FwdGlvbnNUcmFja3MiLCJ0cmFja0lkIiwiVUlPYmplY3QiLCJjYW5QbGF5Iiwic291cmNlIiwibWltZVR5cGUiLCJWT0QiLCJBT0QiLCJMSVZFIiwiZmluZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJlZGljYXRlIiwiVHlwZUVycm9yIiwibyIsImxlbiIsInRoaXNBcmciLCJrVmFsdWUiLCJ1bmRlZmluZWQiLCJTdHlsZXIiLCJnZXRTdHlsZUZvciIsInN0eWxlIiwiYmFzZVVybCIsImh0bWwiLCJ0b1N0cmluZyIsImNjIiwiY2NJY29uIiwiZXhpdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbkljb24iLCJmdWxsc2NyZWVuIiwiZnVsbHNjcmVlbkljb24iLCJoZCIsImhkSWNvbiIsInBhdXNlSWNvbiIsInBsYXlJY29uIiwicmVsb2FkIiwicmVsb2FkSWNvbiIsInN0b3BJY29uIiwidm9sdW1lSWNvbiIsInZvbHVtZU11dGUiLCJ2b2x1bWVNdXRlSWNvbiIsImV2YWx1YXRlIiwiaW50ZXJwb2xhdGUiLCJlc2NhcGUiLCJub01hdGNoIiwiZXNjYXBlcyIsImVzY2FwZXIiLCJodG1sRW50aXRpZXMiLCJlbnRpdHlSZSIsIlJlZ0V4cCIsImVzY2FwZUV4cHIiLCJzdHJpbmciLCJyZXBsYWNlIiwibWF0Y2giLCJjb3VudGVyIiwidG1wbCIsInRleHQiLCJkYXRhIiwicmVuZGVyIiwibWF0Y2hlciIsIm9mZnNldCIsInZhcmlhYmxlIiwiRnVuY3Rpb24iLCJlIiwidGVtcGxhdGUiLCJVSUNvbnRhaW5lclBsdWdpbiIsIiRlbCIsInNob3ciLCJoaWRlIiwiVUlDb3JlUGx1Z2luIiwiZGVsZWdhdGVFdmVudFNwbGl0dGVyIiwiY2lkIiwiX2Vuc3VyZUVsZW1lbnQiLCJkZWxlZ2F0ZUV2ZW50cyIsInNlbGVjdG9yIiwidW5kZWxlZ2F0ZUV2ZW50cyIsInNldEVsZW1lbnQiLCJlbGVtZW50IiwiZGVsZWdhdGUiLCJ6ZXB0byIsImlzWiIsImVsIiwiYmluZCIsImF0dHJzIiwiYXR0cmlidXRlcyIsImNsYXNzTmFtZSIsIkRvbVJlY3ljbGVyIiwiY3JlYXRlIiwidGFnTmFtZSIsImF0dHIiLCJhc3NpZ24iLCJmb3JtYXRUaW1lIiwic2Vla1N0cmluZ1RvU2Vjb25kcyIsImlzTnVtYmVyIiwiY3VycmVudFNjcmlwdFVybCIsImdldEJyb3dzZXJMYW5ndWFnZSIsIm5vdyIsInJlbW92ZUFycmF5SXRlbSIsImxpc3RDb250YWluc0lnbm9yZUNhc2UiLCJjYW5BdXRvUGxheU1lZGlhIiwicHJvcCIsInByb3BEZXNjcmlwdG9yIiwicGFyZW50IiwiU3Vycm9nYXRlIiwiaW5pdGlhbGl6ZSIsInBhZGRlZEhvdXJzIiwiaXNGaW5pdGUiLCJwYXJzZUludCIsInNlY29uZHMiLCJtaW51dGVzIiwiaG91cnMiLCJkYXlzIiwib3V0IiwiRnVsbHNjcmVlbiIsImZ1bGxzY3JlZW5FbGVtZW50IiwiZG9jdW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsIm1vekZ1bGxTY3JlZW5FbGVtZW50IiwibXNGdWxsc2NyZWVuRWxlbWVudCIsInJlcXVlc3RGdWxsc2NyZWVuIiwid2Via2l0RW50ZXJGdWxsU2NyZWVuIiwid2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4iLCJtb3pSZXF1ZXN0RnVsbFNjcmVlbiIsIm1zUmVxdWVzdEZ1bGxzY3JlZW4iLCJxdWVyeVNlbGVjdG9yIiwiY2FuY2VsRnVsbHNjcmVlbiIsIndlYmtpdENhbmNlbEZ1bGxTY3JlZW4iLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm1vekNhbmNlbEZ1bGxTY3JlZW4iLCJtc0V4aXRGdWxsc2NyZWVuIiwiZnVsbHNjcmVlbkVuYWJsZWQiLCJ3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCIsIm1vekZ1bGxTY3JlZW5FbmFibGVkIiwibXNGdWxsc2NyZWVuRW5hYmxlZCIsIkNvbmZpZyIsIl9kZWZhdWx0Q29uZmlnIiwicGFyc2UiLCJfZGVmYXVsdFZhbHVlRm9yIiwiX2NyZWF0ZUtleXNwYWNlIiwiZG9tYWluIiwicmVzdG9yZSIsIkJyb3dzZXIiLCJoYXNMb2NhbHN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJwZXJzaXN0IiwiUXVlcnlTdHJpbmciLCJwYXJhbXNTdHJpbmciLCJwbCIsInNlYXJjaCIsImRlY29kZSIsInMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJhbXMiLCJleGVjIiwicXVlcnkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInN1YnN0cmluZyIsIl91cmxQYXJhbXMiLCJoYXNoIiwiX2hhc2hQYXJhbXMiLCJwYXJhbU5hbWUiLCJzZWVrU3RyaW5nIiwiaGFzaFBhcmFtcyIsInBhcnRzIiwiZmFjdG9yIiwic3VmZml4IiwiaWRzQ291bnRlciIsInByZWZpeCIsInBhcnNlRmxvYXQiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzcmMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmbiIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIiwid2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsInBlcmZvcm1hbmNlIiwiRGF0ZSIsImFyciIsIml0ZW0iLCJpbmRleE9mIiwic3BsaWNlIiwiaXRlbXMiLCJpdGVtRWFjaCIsImlubGluZSIsIm11dGVkIiwidGltZW91dCIsIk1lZGlhIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInByb21pc2UiLCJ0aW1lb3V0SWQiLCJzZXRSZXN1bHQiLCJFcnJvciIsInRoZW4iLCJjYXRjaCIsImVyciIsInZpZGVvU3RhY2siLCJyZWN5Y2xlVmlkZW8iLCJzaGlmdCIsImdhcmJhZ2UiLCJjaGlsZHJlbiIsIkRvdWJsZUV2ZW50SGFuZGxlciIsImRlbGF5IiwibGFzdFRpbWUiLCJoYW5kbGUiLCJldmVudCIsInByZXZlbnRlZCIsImN1cnJlbnRUaW1lIiwiZ2V0VGltZSIsImRpZmZUaW1lIiwicHJldmVudERlZmF1bHQiLCJTdmdJY29ucyIsIkljb25zIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJoYXNGbGFzaCIsImZvIiwiQWN0aXZlWE9iamVjdCIsIm1pbWVUeXBlcyIsImVuYWJsZWRQbHVnaW4iLCJnZXRCcm93c2VySW5mbyIsInVhIiwiZXh0cmEiLCJ2ZXJzaW9uIiwiYXBwTmFtZSIsImFwcFZlcnNpb24iLCJnZXRCcm93c2VyRGF0YSIsImJyb3dzZXJPYmplY3QiLCJ1c2VyQWdlbnQiLCJCUk9XU0VSX0RBVEEiLCJicm93c2VyIiwiYnJvd3NlclJlZ0V4cCIsImlkZW50aWZpZXIiLCJicm93c2VyUmVnRXhwUmVzdWx0IiwiZ3JvdXAiLCJ2ZXJzaW9uSWRlbnRpZmllciIsInZlcnNpb25SZWdFeHAiLCJ2ZXJzaW9uUmVnRXhwUmVzdWx0Iiwic2V0QnJvd3NlclZlcnNpb24iLCJzcGxpdFZlcnNpb24iLCJmdWxsVmVyc2lvbiIsIm1ham9yVmVyc2lvbiIsIm1pbm9yVmVyc2lvbiIsImdldE9zRGF0YSIsIm9zT2JqZWN0IiwiT1NfREFUQSIsIm9zIiwib3NSZWdFeHAiLCJvc1JlZ0V4cFJlc3VsdCIsInNldE9zVmVyc2lvbiIsInZlcnNpb25TZXBhcmF0b3IiLCJzZXBhcmF0b3IiLCJmaW5hbFNlcGFyYXRvciIsInN1YnN0ciIsImdldFZpZXdwb3J0U2l6ZSIsInZpZXdwb3J0T2JqZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJzZXRWaWV3cG9ydE9yaWVudGF0aW9uIiwib3JpZW50YXRpb24iLCJ2aWV3cG9ydCIsImdldERldmljZSIsInBsYXRmb3JtUmVnRXhwIiwibWF0Y2hlcyIsImRldmljZSIsImJyb3dzZXJJbmZvIiwiaXNFZGdlIiwiaXNDaHJvbWUiLCJpc1NhZmFyaSIsImlzRmlyZWZveCIsImlzTGVnYWN5SUUiLCJpc0lFIiwiaXNJRTExIiwiaXNDaHJvbWVjYXN0IiwiaXNNb2JpbGUiLCJpc2lPUyIsImlzQW5kcm9pZCIsImlzV2luZG93c1Bob25lIiwiaXNXaW44QXBwIiwiaXNXaWlVIiwiaXNQUzQiLCJDb250YWluZXIiLCJjbGFzcyIsInBsYXliYWNrIiwiZW5kZWQiLCJidWZmZXJpbmciLCJoYXNDbG9zZWRDYXB0aW9uc1RyYWNrcyIsImNsb3NlZENhcHRpb25zVHJhY2tJZCIsImlzUmVhZHkiLCJtZWRpYUNvbnRyb2xEaXNhYmxlZCIsInBsdWdpbnMiLCJkYmxUYXBIYW5kbGVyIiwiY2xpY2tUaW1lciIsImNsaWNrRGVsYXkiLCJvblByb2dyZXNzIiwidGltZVVwZGF0ZWQiLCJyZWFkeSIsIm9uQnVmZmVyaW5nIiwiYnVmZmVyZnVsbCIsInNldHRpbmdzVXBkYXRlIiwibG9hZGVkTWV0YWRhdGEiLCJoaWdoRGVmaW5pdGlvblVwZGF0ZSIsInVwZGF0ZUJpdHJhdGUiLCJwbGF5YmFja1N0YXRlQ2hhbmdlZCIsInBsYXliYWNrRHZyU3RhdGVDaGFuZ2VkIiwiZGlzYWJsZU1lZGlhQ29udHJvbCIsImVuYWJsZU1lZGlhQ29udHJvbCIsIm9uU2Vla2VkIiwib25FbmRlZCIsInBsYXlpbmciLCJwYXVzZWQiLCJzdG9wcGVkIiwic3VidGl0bGVBdmFpbGFibGUiLCJzdWJ0aXRsZUNoYW5nZWQiLCJ0cmFjayIsInN0YXRlIiwiZHZySW5Vc2UiLCJuZXdCaXRyYXRlIiwic3RhdHNSZXBvcnQiLCJtZXRyaWNzIiwiaXNEdnJFbmFibGVkIiwiZHZyRW5hYmxlZCIsImlzRHZySW5Vc2UiLCJwbHVnaW4iLCJzZXRTdHlsZSIsImNzcyIsImFuaW1hdGUiLCJkdXJhdGlvbiIsImdldEN1cnJlbnRUaW1lIiwibWV0YWRhdGEiLCJ0aW1lUHJvZ3Jlc3MiLCJjdXJyZW50IiwiY2xpY2tlZCIsImNocm9tZWxlc3MiLCJhbGxvd1VzZXJJbnRlcmFjdGlvbiIsImNhbmNlbENsaWNrZWQiLCJkYmxDbGlja2VkIiwiZGlzYWJsZURibENsaWNrRnVsbHNjcmVlbiIsImRibFRhcCIsImV2dCIsIm9uQ29udGV4dE1lbnUiLCJzZXRWb2x1bWUiLCJhZGRQbHVnaW4iLCJoYXNQbHVnaW4iLCJnZXRQbHVnaW4iLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsImlzSEQiLCJ1cGRhdGVTdHlsZSIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJhcHBlbmQiLCJDb250YWluZXJGYWN0b3J5IiwibG9hZGVyIiwiY3JlYXRlQ29udGFpbmVycyIsIkRlZmVycmVkIiwicmVzb2x2ZSIsInNvdXJjZXMiLCJjcmVhdGVDb250YWluZXIiLCJmaW5kUGxheWJhY2tQbHVnaW4iLCJwbGF5YmFja1BsdWdpbnMiLCJwIiwicmVzb2x2ZWRTb3VyY2UiLCJwcm90b2NvbCIsInBsYXliYWNrUGx1Z2luIiwiZGVmZXIiLCJhZGRDb250YWluZXJQbHVnaW5zIiwiY29udGFpbmVyUGx1Z2lucyIsIlBsdWdpbiIsIkNvcmUiLCJ0YWJpbmRleCIsImR1bW15TWVkaWFDb250cm9sIiwiX2R1bW15TWVkaWFDb250cm9sIiwiX2FjdGl2ZUNvbnRhaW5lciIsImFjdGl2ZUNvbnRhaW5lciIsImNvbmZpZ3VyZURvbVJlY3ljbGVyIiwicGxheWVySW5mbyIsIlBsYXllckluZm8iLCJnZXRJbnN0YW5jZSIsInBsYXllcklkIiwiZmlyc3RSZXNpemUiLCJjb250YWluZXJzIiwiX2JvdW5kRnVsbHNjcmVlbkhhbmRsZXIiLCJoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlIiwiaGFuZGxlV2luZG93UmVzaXplIiwiY29udGFpbmVyRmFjdG9yeSIsInByZXBhcmVDb250YWluZXJzIiwic2V0dXBDb250YWluZXJzIiwicmVzb2x2ZU9uQ29udGFpbmVyc1JlYWR5IiwidXBkYXRlU2l6ZSIsImlzRnVsbHNjcmVlbiIsInNldEZ1bGxzY3JlZW4iLCJzZXRQbGF5ZXJTaXplIiwicmVtb3ZlQXR0ciIsInByZXZpb3VzU2l6ZSIsImN1cnJlbnRTaXplIiwicmVzaXplIiwidHJpZ2dlclJlc2l6ZSIsImVuYWJsZVJlc2l6ZU9ic2VydmVyIiwiY2hlY2tTaXplQ2FsbGJhY2siLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInJlc2l6ZU9ic2VydmVySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsIm5ld1NpemUiLCJ0aGVyZVdhc0NoYW5nZSIsIm9sZEhlaWdodCIsIm9sZFdpZHRoIiwiY29tcHV0ZWRTaXplIiwiTWVkaWF0b3IiLCJkaXNhYmxlUmVzaXplT2JzZXJ2ZXIiLCJjbGVhckludGVydmFsIiwid2hlbiIsImRvbmUiLCJsb2FkIiwidW5iaW5kIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiX3NjcmVlbk9yaWVudGF0aW9uIiwicmVtb3ZlQ29udGFpbmVyIiwiYyIsInNldHVwQ29udGFpbmVyIiwicmVuZGVyQ29udGFpbmVycyIsImFwcGVuZFRvUGFyZW50IiwiYXBwZW5kQ2hpbGQiLCJnZXRDdXJyZW50Q29udGFpbmVyIiwiZ2V0Q3VycmVudFBsYXliYWNrIiwiYWN0aXZlUGxheWJhY2siLCJ0b2dnbGVGdWxsc2NyZWVuIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJoYXNDb3JlUGFyZW50IiwiYXBwZW5kVG8iLCJwYXJlbnRFbGVtZW50IiwiZm9udFN0eWxlIiwic2l6ZSIsIkNvcmVGYWN0b3J5IiwicGxheWVyIiwiYWRkQ29yZVBsdWdpbnMiLCJjb3JlUGx1Z2lucyIsInNldHVwRXh0ZXJuYWxJbnRlcmZhY2UiLCJleHRlcm5hbEZ1bmN0aW9ucyIsIldBUk4iLCJJTkZPIiwiTG9hZGVyIiwiZXh0ZXJuYWxQbHVnaW5zIiwidXNlT25seVBsYWluSHRtbDVQbHVnaW5zIiwiUExBSU5fSFRNTDVfT05MWSIsIkhMU1ZpZGVvUGxheWJhY2siLCJIVE1MNVZpZGVvUGxheWJhY2siLCJIVE1MNUF1ZGlvUGxheWJhY2siLCJIVE1MSW1nUGxheWJhY2siLCJOb09wIiwiU3Bpbm5lclRocmVlQm91bmNlUGx1Z2luIiwiV2F0ZXJNYXJrUGx1Z2luIiwiUG9zdGVyUGx1Z2luIiwiU3RhdHNQbHVnaW4iLCJHb29nbGVBbmFseXRpY3NQbHVnaW4iLCJDbGlja1RvUGF1c2VQbHVnaW4iLCJNZWRpYUNvbnRyb2wiLCJEVlJDb250cm9scyIsIkNsb3NlZENhcHRpb25zIiwiRmF2aWNvbiIsIlNlZWtUaW1lIiwiU291cmNlc1BsdWdpbiIsIkVuZFZpZGVvIiwiRXJyb3JTY3JlZW4iLCJTdHJpbmdzIiwiaXNBcnJheSIsInZhbGlkYXRlRXh0ZXJuYWxQbHVnaW5zVHlwZSIsImFkZEV4dGVybmFsUGx1Z2lucyIsImdyb3VwUGx1Z2luc0J5VHlwZSIsInJlZHVjZSIsIm1lbW8iLCJyZW1vdmVEdXBzIiwibGlzdCIsImdyb3VwVXAiLCJwbHVnaW5zTWFwIiwicmVkdWNlUmlnaHQiLCJ1bnNoaWZ0IiwicGx1Z2ludHlwZXMiLCJlcnJvck1lc3NhZ2UiLCJSZWZlcmVuY2VFcnJvciIsIm9wdHMiLCJQbGF5ZXIiLCJfbG9hZGVyIiwiX3JlYWR5Iiwib25SZWFkeSIsIm9uUmVzaXplIiwib25QbGF5Iiwib25QYXVzZSIsIm9uU3RvcCIsIm9uU2VlayIsIm9uRXJyb3IiLCJvblRpbWVVcGRhdGUiLCJvblZvbHVtZVVwZGF0ZSIsIm9uU3VidGl0bGVBdmFpbGFibGUiLCJwbGF5YmFja0RlZmF1bHRPcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJwZXJzaXN0Q29uZmlnIiwiX25vcm1hbGl6ZVNvdXJjZXMiLCJkaXNhYmxlS2V5Ym9hcmRTaG9ydGN1dHMiLCJfcmVnaXN0ZXJPcHRpb25FdmVudExpc3RlbmVycyIsIl9jb3JlRmFjdG9yeSIsInBhcmVudElkIiwic2V0UGFyZW50SWQiLCJhdHRhY2hUbyIsIl9hZGRFdmVudExpc3RlbmVycyIsIl9vblJlYWR5IiwiX2NvbnRhaW5lckNoYW5nZWQiLCJfb25GdWxsc2NyZWVuQ2hhbmdlIiwiX29uUmVzaXplIiwiX2FkZENvbnRhaW5lckV2ZW50TGlzdGVuZXJzIiwiX29uUGxheSIsIl9vblBhdXNlIiwiX29uU3RvcCIsIl9vbkVuZGVkIiwiX29uU2VlayIsIl9vbkVycm9yIiwiX29uVGltZVVwZGF0ZSIsIl9vblZvbHVtZVVwZGF0ZSIsIl9vblN1YnRpdGxlQXZhaWxhYmxlIiwibmV3RXZlbnRzIiwiaGFzTmV3RXZlbnRzIiwidXNlckV2ZW50IiwiZXZlbnRUeXBlIiwiZXZlbnRzTWFwcGluZyIsImV2ZW50RnVuY3Rpb24iLCJhdXRvUGxheSIsIm11dGUiLCJfbXV0ZWRWb2x1bWUiLCJnZXRWb2x1bWUiLCJ1bm11dGUiLCJfcGxheWVycyIsIlZFUlNJT04iLCJVdGlscyIsIkhMUyIsIkhUTUw1QXVkaW8iLCJIVE1MNVZpZGVvIiwiSFRNTEltZyIsIlBvc3RlciIsIlZlbmRvciIsIkFVVE8iLCJfbGV2ZWxzIiwiX2N1cnJlbnRMZXZlbCIsImhsc1VzZU5leHRMZXZlbCIsIl9obHMiLCJuZXh0TGV2ZWwiLCJjdXJyZW50TGV2ZWwiLCJfaXNSZWFkeVN0YXRlIiwiX3BsYXliYWNrVHlwZSIsIl9wbGF5bGlzdFR5cGUiLCJfZXh0cmFwb2xhdGVkU3RhcnRUaW1lIiwiX3BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lIiwiX2xvY2FsU3RhcnRUaW1lQ29ycmVsYXRpb24iLCJjb3JyIiwidGltZVBhc3NlZCIsIl9ub3ciLCJsb2NhbCIsImV4dHJhcG9sYXRlZFdpbmRvd1N0YXJ0VGltZSIsInJlbW90ZSIsIk1hdGgiLCJtaW4iLCJfZXh0cmFwb2xhdGVkV2luZG93RHVyYXRpb24iLCJhY3R1YWxFbmRUaW1lIiwiX3BsYXlhYmxlUmVnaW9uRHVyYXRpb24iLCJfbG9jYWxFbmRUaW1lQ29ycmVsYXRpb24iLCJleHRyYXBvbGF0ZWRFbmRUaW1lIiwibWF4IiwiX2V4dHJhcG9sYXRlZEVuZFRpbWUiLCJfc3RhcnRUaW1lIiwiX3NlZ21lbnRUYXJnZXREdXJhdGlvbiIsIl9leHRyYXBvbGF0ZWRXaW5kb3dOdW1TZWdtZW50cyIsIkhMU0pTIiwiX21pbkR2clNpemUiLCJobHNNaW5pbXVtRHZyU2l6ZSIsImV4dHJhcG9sYXRlZFdpbmRvd051bVNlZ21lbnRzIiwicGxheWJhY2tUeXBlIiwiX2xhc3RUaW1lVXBkYXRlIiwidG90YWwiLCJfbGFzdER1cmF0aW9uIiwiX3Byb2dyYW1EYXRlVGltZSIsIl9kdXJhdGlvbkV4Y2x1ZGVzQWZ0ZXJMaXZlU3luY1BvaW50IiwiX3JlY292ZXJBdHRlbXB0c1JlbWFpbmluZyIsImhsc1JlY292ZXJBdHRlbXB0cyIsIl9zZXR1cCIsIl9jY0lzU2V0dXAiLCJfY2NUcmFja3NVcGRhdGVkIiwiaGxzanNDb25maWciLCJNRURJQV9BVFRBQ0hFRCIsImxvYWRTb3VyY2UiLCJMRVZFTF9MT0FERUQiLCJfdXBkYXRlUGxheWJhY2tUeXBlIiwiTEVWRUxfVVBEQVRFRCIsIl9vbkxldmVsVXBkYXRlZCIsIkxFVkVMX1NXSVRDSElORyIsIl9vbkxldmVsU3dpdGNoIiwiRlJBR19MT0FERUQiLCJfb25GcmFnbWVudExvYWRlZCIsIl9vbkhMU0pTRXJyb3IiLCJTVUJUSVRMRV9UUkFDS19MT0FERUQiLCJfb25TdWJ0aXRsZUxvYWRlZCIsIlNVQlRJVExFX1RSQUNLU19VUERBVEVEIiwiYXR0YWNoTWVkaWEiLCJfcmVjb3ZlciIsIl9yZWNvdmVyZWREZWNvZGluZ0Vycm9yIiwicmVjb3Zlck1lZGlhRXJyb3IiLCJfcmVjb3ZlcmVkQXVkaW9Db2RlY0Vycm9yIiwic3dhcEF1ZGlvQ29kZWMiLCJmb3JtYXR0ZWRFcnJvciIsIl9zZXR1cFNyYyIsInNyY1VybCIsIl9zdGFydFRpbWVVcGRhdGVUaW1lciIsIl90aW1lVXBkYXRlVGltZXIiLCJfb25EdXJhdGlvbkNoYW5nZSIsIl9zdG9wVGltZVVwZGF0ZVRpbWVyIiwiZ2V0UHJvZ3JhbURhdGVUaW1lIiwiX2R1cmF0aW9uIiwic2Vla1RvIiwiX3VwZGF0ZUR2ciIsInNlZWtUb0xpdmVQb2ludCIsInN0YXR1cyIsIl91cGRhdGVTZXR0aW5ncyIsImxlZnQiLCJzZWVrRW5hYmxlZCIsImlzU2Vla0VuYWJsZWQiLCJkZXRhaWxzIiwicmVzcG9uc2UiLCJmYXRhbCIsIkVycm9yVHlwZXMiLCJORVRXT1JLX0VSUk9SIiwiRXJyb3JEZXRhaWxzIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIk1BTklGRVNUX0xPQURfVElNRU9VVCIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJMRVZFTF9MT0FEX0VSUk9SIiwiTEVWRUxfTE9BRF9USU1FT1VUIiwic3RhcnRMb2FkIiwiTUVESUFfRVJST1IiLCJ0cmlnZ2VyRmF0YWxFcnJvck9uUmVzb3VyY2VEZW5pZWQiLCJfa2V5SXNEZW5pZWQiLCJLRVlfTE9BRF9FUlJPUiIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwidXBkYXRlIiwiZmlyc3RGcmFnRGF0ZVRpbWUiLCJpc1NhbWUiLCJfb25Qcm9ncmVzcyIsImJ1ZmZlcmVkIiwiYnVmZmVyZWRQb3MiLCJzdGFydCIsImVuZCIsInByb2dyZXNzIiwibGliIiwiZ29vZ2xlIiwiaW1hIiwieWEiLCJ2aWRlb0FkIiwiVmFzdEFkcyIsInByZXJvbGwiLCJsaXZlIiwiX2ZpbGxMZXZlbHMiLCJsZXZlbHMiLCJsYWJlbCIsImJpdHJhdGUiLCJ0YXJnZXRkdXJhdGlvbiIsInN0YXJ0VGltZUNoYW5nZWQiLCJkdXJhdGlvbkNoYW5nZWQiLCJmcmFnbWVudHMiLCJwcmV2aW91c1BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lIiwicHJldmlvdXNQbGF5YWJsZVJlZ2lvbkR1cmF0aW9uIiwicmF3UHJvZ3JhbURhdGVUaW1lIiwic3RhcnRUaW1lIiwibmV3RHVyYXRpb24iLCJ0b3RhbGR1cmF0aW9uIiwiZnJhZ21lbnRUYXJnZXREdXJhdGlvbiIsImxpdmVTeW5jRHVyYXRpb25Db3VudCIsIkRlZmF1bHRDb25maWciLCJoaWRkZW5BcmVhRHVyYXRpb24iLCJlbmRUaW1lIiwicHJldmlvdXNFbmRUaW1lIiwiZW5kVGltZUNoYW5nZWQiLCJoaWdoRGVmaW5pdGlvbiIsImJhbmR3aWR0aCIsInJlc291cmNlIiwicmVzb3VyY2VQYXJ0cyIsImlzSGxzIiwiaXNTdXBwb3J0ZWQiLCJ1cGRhdGVTZXR0aW5ncyIsInJlc291cmNlVXJsIiwibWltZXR5cGVzIiwiX2NhblBsYXkiLCJNSU1FVFlQRVMiLCJjb2RlYyIsIkFVRElPX01JTUVUWVBFUyIsIktOT1dOX0FVRElPX01JTUVUWVBFUyIsImFjYyIsIlVOS05PV05fRVJST1IiLCJpc0F1ZGlvT25seSIsIl9taW1lVHlwZXNGb3JVcmwiLCJhdWRpb09ubHkiLCJfaXNCdWZmZXJpbmciLCJfZGVzdHJveWVkIiwiX2xvYWRTdGFydGVkIiwiX3BsYXloZWFkTW92aW5nIiwiX3BsYXloZWFkTW92aW5nVGltZXIiLCJfc3RvcHBlZCIsIl9jY1RyYWNrSWQiLCJkaXNhYmxlQ29udGV4dE1lbnUiLCJkaXNhYmxlVmlkZW9UYWdDb250ZXh0TWVudSIsInBsYXliYWNrQ29uZmlnIiwicHJlbG9hZCIsInBvc3RlclVybCIsInBvc3RlciIsInVybCIsImRlZmF1bHRNdXRlZCIsImxvb3AiLCJjb250cm9scyIsInVzZVZpZGVvVGFnRGVmYXVsdENvbnRyb2xzIiwiY3Jvc3NPcmlnaW4iLCJwbGF5SW5saW5lIiwicGxheXNpbmxpbmUiLCJjcm9zc29yaWdpbiIsImRlZmF1bHQiLCJyaWdodCIsImV4dGVybmFsVHJhY2tzIiwiX3NldHVwRXh0ZXJuYWxUcmFja3MiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJkaXNhYmxlQ2FuQXV0b1BsYXkiLCJhdXRvUGxheVRpbWVvdXQiLCJ0cmFja3MiLCJfZXh0ZXJuYWxUcmFja3MiLCJraW5kIiwibGFuZyIsIl9zcmMiLCJfb25Mb2FkZWRNZXRhZGF0YSIsIl9oYW5kbGVCdWZmZXJpbmdFdmVudHMiLCJ0YXJnZXQiLCJhdXRvU2Vla0Zyb21VcmwiLCJfY2hlY2tJbml0aWFsU2VlayIsIm9uRGVtYW5kVHlwZSIsIkluZmluaXR5IiwicmVtb3ZlQXR0cmlidXRlIiwiX3N0b3BQbGF5aGVhZE1vdmluZ0NoZWNrcyIsImlzTXV0ZWQiLCJfc3RhcnRQbGF5aGVhZE1vdmluZ0NoZWNrcyIsIl9wbGF5aGVhZE1vdmluZ1RpbWVPbkNoZWNrIiwiX2RldGVybWluZUlmUGxheWhlYWRNb3ZpbmciLCJiZWZvcmUiLCJfb25XYWl0aW5nIiwiX29uTG9hZGVkRGF0YSIsIl9vbkNhblBsYXkiLCJfb25QbGF5aW5nIiwiX2NoZWNrRm9yQ2xvc2VkQ2FwdGlvbnMiLCJfb25TZWVraW5nIiwiX29uU2Vla2VkIiwicGxheWhlYWRTaG91bGRCZU1vdmluZyIsInJlYWR5U3RhdGUiLCJIQVZFX0ZVVFVSRV9EQVRBIiwiaXNVbmtub3duRXJyb3IiLCJoYW5kbGVUZXh0VHJhY2tDaGFuZ2UiLCJ0ZXh0VHJhY2tzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNlZWtUaW1lIiwiX3R5cGVGb3IiLCJpc0hUTUw1VmlkZW8iLCJfaGFuZGxlVGV4dFRyYWNrQ2hhbmdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1vZGUiLCJzaG93aW5nVHJhY2siLCJ0cmFja3NIVE1MIiwibWltZVR5cGVzQnlFeHRlbnNpb24iLCJleHRlbnNpb24iLCJtZWRpYSIsImNhblBsYXlUeXBlIiwibWVkaWFUeXBlIiwiX29uTG9hZCIsIm0iLCJub09wSFRNTCIsIl9ub2lzZUZyYW1lTnVtIiwicGxheWJhY2tOb3RTdXBwb3J0ZWQiLCJwbGF5YmFja05vdFN1cHBvcnRlZE1lc3NhZ2UiLCJzaG93Rm9yTm9PcCIsIl9hbmltYXRlIiwiX25vaXNlIiwiaWRhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJjYW52YXMiLCJidWZmZXIzMiIsIlVpbnQzMkFycmF5IiwiYnVmZmVyIiwicmFuZG9tIiwiY29sb3IiLCJwb3ciLCJwdXRJbWFnZURhdGEiLCJfbG9vcCIsIl9zdG9wIiwiX2FuaW1hdGlvbkhhbmRsZSIsImdldENvbnRleHQiLCJjbGljayIsInRpbWVyIiwicG9pbnRlckVuYWJsZWQiLCJjY0hUTUwiLCJjb25maWciLCJjbG9zZWRDYXB0aW9uc0NvbmZpZyIsIl90aXRsZSIsIl9hcmlhTGFiZWwiLCJhcmlhTGFiZWwiLCJfbGFiZWxDYiIsImxhYmVsQ2FsbGJhY2siLCJjb250YWluZXJDaGFuZ2VkIiwibWVkaWFDb250cm9sIiwiaGlkZUNvbnRleHRNZW51Iiwib25TdWJ0aXRsZUNoYW5nZWQiLCJvbkNvbnRhaW5lclN0b3AiLCJjY0F2YWlsYWJsZSIsInJlbmRlckNjQnV0dG9uIiwic2V0Q3VycmVudENvbnRleHRNZW51RWxlbWVudCIsIm9uVHJhY2tTZWxlY3QiLCJkYXRhc2V0IiwiY2NTZWxlY3QiLCJzdG9wUHJvcGFnYXRpb24iLCJoYXNDQyIsInRvZ2dsZUNvbnRleHRNZW51IiwidG9nZ2xlIiwiY29udGV4dE1lbnVFbGVtZW50IiwiaXNOYU4iLCJfdHJhY2tJZCIsIiRjY0J1dHRvbiIsImRpc2FibGVkTGFiZWwiLCIkZnVsbHNjcmVlbiIsImluc2VydEFmdGVyIiwicHJlcGVuZCIsImR2ckhUTUwiLCJkdnJDaGFuZ2VkIiwiaGFzQ2xhc3MiLCJzaG91bGRSZW5kZXIiLCJ1c2VEdnJDb250cm9scyIsImJhY2tUb0xpdmUiLCJleGl0T25FbmQiLCJleGl0RnVsbHNjcmVlbk9uRW5kIiwidGVtcGxhdGVIdG1sIiwiZGlzYWJsZUVycm9yU2NyZWVuIiwib25Db250YWluZXJDaGFuZ2VkIiwiYmluZFJlbG9hZCIsInJlbG9hZEJ1dHRvbiIsInVuYmluZFJlbG9hZCIsImljb24iLCJvbGRJY29uIiwiX2NvbnRhaW5lciIsImNoYW5nZUZhdmljb24iLCJzZXRQbGF5SWNvbiIsInNldFBhdXNlSWNvbiIsInJlc2V0SWNvbiIsImNyZWF0ZUljb24iLCJzdmciLCJmaWxsU3R5bGUiLCJkIiwicGF0aCIsIlBhdGgyRCIsImZpbGwiLCJ0b0RhdGFVUkwiLCJjaGFuZ2VJY29uIiwiR29vZ2xlQW5hbHl0aWNzIiwiZ2FBY2NvdW50IiwiYWNjb3VudCIsInRyYWNrZXJOYW1lIiwiZ2FUcmFja2VyTmFtZSIsImRvbWFpbk5hbWUiLCJnYURvbWFpbk5hbWUiLCJjdXJyZW50SERTdGF0ZSIsImVtYmVkU2NyaXB0IiwiX2dhdCIsInNjcmlwdCIsIm9ubG9hZCIsImFkZEV2ZW50TGlzdGVuZXJzIiwiYm9keSIsIm9uQnVmZmVyRnVsbCIsIm9uUGxheWJhY2tDaGFuZ2VkIiwib25Wb2x1bWVDaGFuZ2VkIiwiQ09OVEFJTkVSX0ZVTExfU0NSRUVOIiwib25GdWxsc2NyZWVuIiwib25IRCIsIm9uRFZSIiwiX2dhcSIsInBsYXliYWNrU3RhdGUiLCJhcnJheSIsInJlcyIsIkJPTEQiLCJERUJVRyIsIkxFVkVMX0RFQlVHIiwiTEVWRUxfSU5GTyIsIkxFVkVMX1dBUk4iLCJMRVZFTF9FUlJPUiIsIkxFVkVMX0RJU0FCTEVEIiwiQ09MT1JTIiwiREVTQ1JJUFRJT05TIiwib2ZmTGV2ZWwiLCJraWJvIiwiS2libyIsImRvd24iLCJvbk9mZiIsIkJMQUNLTElTVCIsImxvZyIsImluZm8iLCJwcmV2aW91c0xldmVsIiwiY29uc29sZSIsIm5ld0xldmVsIiwia2xhc3NEZXNjcmlwdGlvbiIsIl9pbnN0YW5jZSIsInNldExldmVsIiwicGxheWJhY2tJc05PT1AiLCJ1c2VyRGlzYWJsZWQiLCJtZWRpYUNvbnRyb2xIVE1MIiwiaW50ZW5kZWRWb2x1bWUiLCJjdXJyZW50UG9zaXRpb25WYWx1ZSIsImN1cnJlbnREdXJhdGlvblZhbHVlIiwia2VlcFZpc2libGUiLCJmdWxsU2NyZWVuT25WaWRlb1RhZ1N1cHBvcnRlZCIsInNldEluaXRpYWxWb2x1bWUiLCJmb2N1c0VsZW1lbnQiLCJiaW5kS2V5RXZlbnRzIiwiaXNFbXB0eU9iamVjdCIsInN0b3BEcmFnSGFuZGxlciIsInN0b3BEcmFnIiwidXBkYXRlRHJhZ0hhbmRsZXIiLCJ1cGRhdGVEcmFnIiwib25BY3RpdmVDb250YWluZXJDaGFuZ2VkIiwiaGlkZU1lZGlhQ29udHJvbERlbGF5IiwicGxheWVyUmVzaXplIiwiYmluZENvbnRhaW5lckV2ZW50cyIsImNoYW5nZVRvZ2dsZVBsYXkiLCJ1cGRhdGVQcm9ncmVzc0JhciIsIm5vZGVOYW1lIiwib25Mb2FkZWRNZXRhZGF0YU9uVmlkZW9UYWciLCJ1bmJpbmRLZXlFdmVudHMiLCJpbml0aWFsVm9sdW1lIiwidXBkYXRlVm9sdW1lVUkiLCJ2aWRlbyIsIndlYmtpdFN1cHBvcnRzRnVsbHNjcmVlbiIsInJlbmRlcmVkIiwiJHZvbHVtZUJhckNvbnRhaW5lciIsImNvbnRhaW5lcldpZHRoIiwiYmFyV2lkdGgiLCIkdm9sdW1lQmFyQmFja2dyb3VuZCIsInBvcyIsIiR2b2x1bWVCYXJGaWxsIiwiJHZvbHVtZUJhclNjcnViYmVyIiwiY2VpbCIsIiR2b2x1bWVJY29uIiwiYXBwbHlCdXR0b25TdHlsZSIsIiRwbGF5UGF1c2VUb2dnbGUiLCIkcGxheVN0b3BUb2dnbGUiLCJtb3VzZW1vdmVPblNlZWtCYXIiLCJvZmZzZXRYIiwicGFnZVgiLCIkc2Vla0JhckNvbnRhaW5lciIsIiRzZWVrQmFySG92ZXIiLCJtb3VzZWxlYXZlT25TZWVrQmFyIiwib25Wb2x1bWVDbGljayIsImdldFZvbHVtZUZyb21VSUV2ZW50IiwibW91c2Vtb3ZlT25Wb2x1bWVCYXIiLCJkcmFnZ2luZ1ZvbHVtZUJhciIsIiRmdWxsc2NyZWVuVG9nZ2xlIiwiaGlkZVZvbHVtZUJhciIsInRvZ2dsZVBsYXlQYXVzZSIsInRvZ2dsZVBsYXlTdG9wIiwic3RhcnRTZWVrRHJhZyIsImRyYWdnaW5nU2Vla0JhciIsIiRzZWVrQmFyTG9hZGVkIiwiJHNlZWtCYXJQb3NpdGlvbiIsIiRzZWVrQmFyU2NydWJiZXIiLCJzdGFydFZvbHVtZURyYWciLCJzZXRTZWVrUGVyY2VudGFnZSIsIm9mZnNldFkiLCJ2b2x1bWVGcm9tVUkiLCJ0b2dnbGVNdXRlIiwiaXNJbml0aWFsVm9sdW1lIiwic2V0V2hlbkNvbnRhaW5lclJlYWR5IiwicmVzZXRVc2VyS2VlcFZpc2libGUiLCJzaG93Vm9sdW1lQmFyIiwiaGlkZVZvbHVtZUlkIiwibG9hZGVkU3RhcnQiLCJsb2FkZWRFbmQiLCJwb3NpdGlvbiIsInJlbmRlclNlZWtCYXIiLCJjdXJyZW50U2Vla0JhclBlcmNlbnRhZ2UiLCJuZXdQb3NpdGlvbiIsImRpc3BsYXllZFBvc2l0aW9uIiwiJHBvc2l0aW9uIiwiZGlzcGxheWVkRHVyYXRpb24iLCIkZHVyYXRpb24iLCJzZXRLZWVwVmlzaWJsZSIsInJlc2V0S2VlcFZpc2libGUiLCJzZXRVc2VyS2VlcFZpc2libGUiLCJ1c2VyS2VlcFZpc2libGUiLCJpc1Zpc2libGUiLCJkaXNhYmxlZCIsIm1vdXNlUG9pbnRlck1vdmVkIiwiY2xpZW50WCIsImxhc3RNb3VzZVgiLCJjbGllbnRZIiwibGFzdE1vdXNlWSIsImhpZGVJZCIsInNob3dpbmciLCJ1cGRhdGVDdXJzb3JTdHlsZSIsImhpZGVNZWRpYUNvbnRyb2wiLCJoYXNLZWVwVmlzaWJsZVJlcXVlc3RlZCIsImhhc0RyYWdnaW5nQWN0aW9uIiwibmV3U2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsInNldHRpbmdzQ2hhbmdlZCIsIiRoZEluZGljYXRvciIsImNyZWF0ZUNhY2hlZEVsZW1lbnRzIiwiJGxheWVyIiwiJHZvbHVtZUNvbnRhaW5lciIsInJlc2V0SW5kaWNhdG9ycyIsImluaXRpYWxpemVJY29ucyIsImRpc3BsYXllZFNlZWtCYXJQZXJjZW50YWdlIiwic2Vla1JlbGF0aXZlIiwiZGVsdGEiLCJiaW5kS2V5QW5kU2hvdyIsImtleXMiLCJwYXJzZUNvbG9ycyIsIm1lZGlhY29udHJvbCIsImJ1dHRvbnNDb2xvciIsImJ1dHRvbnMiLCJzZWVrYmFyQ29sb3IiLCJzZWVrYmFyIiwicHJldmlvdXNTZWVrUGVyY2VudGFnZSIsInBvc3RlckhUTUwiLCJzaG93T25WaWRlb0VuZCIsImhhc1N0YXJ0ZWRQbGF5aW5nIiwicGxheVJlcXVlc3RlZCIsImhhc0ZhdGFsRXJyb3IiLCJzaG93UGxheUJ1dHRvbiIsInVwZGF0ZVBsYXlCdXR0b24iLCJoaWRlUGxheUJ1dHRvbiIsIiRwbGF5QnV0dG9uIiwic2hvdWxkSGlkZU9uUGxheSIsInVwZGF0ZVBvc3RlciIsInNob3dQb3N0ZXIiLCJoaWRlUG9zdGVyIiwiaXNSZWd1bGFyUG9zdGVyIiwiY3VzdG9tIiwiJHBsYXlXcmFwcGVyIiwic2Vla1RpbWVIVE1MIiwibWVkaWFDb250cm9sQ29udGFpbmVyIiwiaXNMaXZlU3RyZWFtV2l0aER2ciIsImFjdHVhbExpdmVUaW1lIiwiaG92ZXJpbmdPdmVyU2Vla0JhciIsImhvdmVyUG9zaXRpb24iLCJhY3R1YWxMaXZlU2VydmVyVGltZSIsImFjdHVhbExpdmVTZXJ2ZXJUaW1lRGlmZiIsInNob3dUaW1lIiwiaGlkZVRpbWUiLCJ1cGRhdGVEdXJhdGlvbiIsImNhbGN1bGF0ZUhvdmVyUG9zaXRpb24iLCJnZXRTZWVrVGltZSIsInNlY29uZHNTaW5jZU1pZG5pZ2h0IiwidXNlQWN0dWFsTGl2ZVRpbWUiLCJzZXRIb3VycyIsInNob3VsZEJlVmlzaWJsZSIsImN1cnJlbnRTZWVrVGltZSIsImRpc3BsYXllZFNlZWtUaW1lIiwiJHNlZWtUaW1lRWwiLCJkdXJhdGlvblNob3duIiwiJGR1cmF0aW9uRWwiLCJjdXJyZW50RHVyYXRpb24iLCJlbFdpZHRoIiwiZWxMZWZ0UG9zIiwib25Db250YWluZXJzQ3JlYXRlZCIsImZpcnN0VmFsaWRTb3VyY2UiLCJzcGlubmVySFRNTCIsInNob3dUaW1lb3V0Iiwic2V0SW5pdGlhbEF0dHJzIiwicmVwb3J0SW50ZXJ2YWwiLCJvblN0YXRzQWRkIiwiZmlyc3RQbGF5Iiwic3RhcnR1cFRpbWUiLCJyZWJ1ZmZlcmluZ1RpbWUiLCJ3YXRjaGluZ1RpbWUiLCJyZWJ1ZmZlcnMiLCJleHRlcm5hbE1ldHJpY3MiLCJ3YXRjaGluZ1RpbWVJbml0IiwiaW50ZXJ2YWxJZCIsInJlcG9ydCIsInN0YXJ0dXBUaW1lSW5pdCIsInJlYnVmZmVyaW5nVGltZUluaXQiLCJnZXRSZWJ1ZmZlcmluZ1RpbWUiLCJnZXRXYXRjaGluZ1RpbWUiLCJ0b3RhbFRpbWUiLCJpc1JlYnVmZmVyaW5nIiwibWV0cmljIiwiZ2V0U3RhdHMiLCJfaW5pdGlhbGl6ZU1lc3NhZ2VzIiwiX2xhbmd1YWdlIiwiZmFsbGJhY2tMYW5nIiwiX21lc3NhZ2VzIiwiZGVmYXVsdE1lc3NhZ2VzIiwic3RyaW5ncyIsIndhdGVybWFya0hUTUwiLCJ3YXRlcm1hcmsiLCJpbWFnZVVybCIsImltYWdlTGluayIsIndhdGVybWFya0xpbmsiLCJoaWRkZW4iLCJ0ZW1wbGF0ZU9wdGlvbnMiLCJLRVlfTkFNRVNfQllfQ09ERSIsIktFWV9DT0RFU19CWV9OQU1FIiwiaGFzT3duUHJvcGVydHkiLCJNT0RJRklFUlMiLCJyZWdpc3RlckV2ZW50IiwiZnVuYyIsImF0dGFjaEV2ZW50IiwidW5yZWdpc3RlckV2ZW50IiwiZGV0YWNoRXZlbnQiLCJzdHJpbmdDb250YWlucyIsIm5lYXRTdHJpbmciLCJjYXBpdGFsaXplIiwiaXNTdHJpbmciLCJ3aGF0IiwiYXJyYXlJbmNsdWRlcyIsImhheXN0YWNrIiwibmVlZGxlIiwiZXh0cmFjdE1vZGlmaWVycyIsImtleUNvbWJpbmF0aW9uIiwibW9kaWZpZXJzIiwiZXh0cmFjdEtleSIsIm1vZGlmaWVyc0FuZEtleSIsImtleU5hbWUiLCJrZXlDb2RlIiwidGhhdCIsImxhc3RLZXlDb2RlIiwibGFzdE1vZGlmaWVycyIsImtleXNEb3duIiwiYW55Iiwia2V5c1VwIiwiZG93bkhhbmRsZXIiLCJoYW5kbGVyIiwidXBIYW5kbGVyIiwidW5sb2FkZXIiLCJ1cE9yRG93biIsInJlZ2lzdGVyZWRLZXlzIiwibGFzdE1vZGlmaWVyc0FuZEtleSIsInJlZ2lzdGVyS2V5cyIsIm5ld0tleXMiLCJ1bnJlZ2lzdGVyS2V5cyIsIlN0cmluZyIsInVwIiwibGFzdEtleSIsIm1vZGlmaWVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVB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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0NBQXNDO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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QTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWEsZUFBZTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQiwyQ0FBMkMsOENBQThDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTs7QUFFekI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEVBQThFLFFBQVE7QUFDdEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxFQUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLEdBQUcsT0FBTyxnQkFBZ0IsSUFBSSxjQUFjLFVBQVUsUUFBUTtBQUMvRjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0EsYUFBYTtBQUNiLHdJQUF3STs7QUFFeEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa1BBQWtQOztBQUVsUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTiwrQ0FBK0MsMERBQTBELDJDQUEyQyxpQ0FBaUM7Ozs7Ozs7QUFPckw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRywrQkFBK0IsRUFBRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtIQUErSDs7QUFFL0g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLDRFQUE0RTs7QUFFNUUsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtGQUErRixjQUFjLEVBQUU7QUFDL0csaUdBQWlHLDZCQUE2QixFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTix1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLCtDQUErQywwREFBMEQsMkNBQTJDLGlDQUFpQzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkZBQTZGO0FBQzdGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLG1DQUFtQzs7O0FBRzFDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvRUFBb0U7QUFDN0U7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0U7QUFDeEU7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCLGNBQWMsSUFBSSxVQUFVO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyx5QkFBeUIsRUFBRTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkUsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQyx3Q0FBd0MsS0FBSztBQUNoRixPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5REFBeUQsaUJBQWlCLE1BQU0sZUFBZSxPQUFPLEtBQUs7QUFDaEosU0FBUztBQUNUO0FBQ0Esb0VBQW9FLGlCQUFpQixNQUFNLGVBQWUsT0FBTyxLQUFLO0FBQ3RIO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUdBQXlHOztBQUV6RztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywy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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHFCQUFxQjtBQUMxQixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSwwTEFBMEw7QUFDMUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7OztBQUdUO0FBQ0EsMkdBQTJHOztBQUUzRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUMsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyRkFBMkY7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtIQUFrSCxpQ0FBaUMsRUFBRTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOzs7Ozs7Ozs7O0FBVXJMLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTiwrQ0FBK0MsMERBQTBELDJDQUEyQyxpQ0FBaUM7Ozs7Ozs7QUFPckw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Es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T0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyxtQkFBbUIsRUFBRTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTDtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQTs7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OztBQUdMO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMERBQTBELDJDQUEyQyxpQ0FBaUM7O0FBRXJMO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpR0FBaUcsNEJBQTRCLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7QUFJRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHLHlCQUF5QixFQUFFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpR0FBaUcsbUJBQW1CLEVBQUU7QUFDdEgsbUdBQW1HLGtCQUFrQixFQUFFO0FBQ3ZILHdHQUF3Ryx1QkFBdUIsRUFBRTtBQUNqSSx1R0FBdUcsc0JBQXNCLEVBQUU7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUEsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsdUNBQXVDOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUEsMkNBQTJDLFNBQVM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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Q0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHLGtCQUFrQixFQUFFO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVuVixnQ0FBZ0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCwyQ0FBMkMsRUFBRSxFQUFFLEVBQUUsNkNBQTZDLDJFQUEyRSxFQUFFLE9BQU8saURBQWlELGtGQUFrRixFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRXBoQiwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL007QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyxxQkFBcUIsRUFBRTtBQUN4SDs7O0FBR0EsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7O0FBSUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyxpQkFBaUIsRUFBRTtBQUNwSDtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7OztBQUlyTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7QUFJRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHLGtCQUFrQixFQUFFO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyxtQkFBbUIsRUFBRTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDs7QUFFeEQsOENBQThDLE1BQU07QUFDcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlDQUF5Qzs7QUFFN0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7OztBQUduQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLEtBQUs7QUFDbEMsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxnRUFBZ0UsYUFBYSxXQUFXLGNBQWMsUUFBUSxXQUFXO0FBQzFKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRkFBaUYsWUFBWTs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7O0FBR0wsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZIQUE2SDs7QUFFN0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdHQUF3Ryx1QkFBdUIsRUFBRTtBQUNqSSwwR0FBMEcseUJBQXlCLEVBQUU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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T0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwSEFBMEg7QUFDMUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDOzs7QUFHaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFD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QUFDQTtBQUNBLENBQUMsa0RBQWtEOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDOztBQUUvQyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUdBQXVHLHNCQUFzQixFQUFFO0FBQy9IO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQyw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7OztBQUdBLDZEQUE2RDtBQUM3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBLHlEQUF5RDs7QUFFekQsb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0dBQXdHLHVCQUF1QixFQUFFO0FBQ2pJO0FBQ0E7QUFDQTs7OztBQUlBLCtDQUErQywwREFBMEQsMkNBQTJDLGlDQUFpQzs7QUFFckwsa0NBQWtDLGdFQUFnRSxzREFBc0QsK0RBQStELG1DQUFtQywyRUFBMkUsRUFBRSxxQ0FBcUMsaURBQWlELDRCQUE0QixFQUFFLHFCQUFxQix3RUFBd0UsRUFBRSxxREFBcUQsZUFBZSx3RUFBd0UsRUFBRSxFQUFFLHdDQUF3QyxHQUFHLGdDQUFnQzs7QUFFcnZCLDBDQUEwQyxtQ0FBbUMsZ0NBQWdDLEVBQUUsT0FBTyx3REFBd0QsZ0JBQWdCLHVCQUF1QixrREFBa0Qsa0NBQWtDLHVEQUF1RCxpQkFBaUIsR0FBRyxFQUFFLDBDQUEwQzs7QUFFaGEsc0NBQXNDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sd0VBQXdFLEdBQUcsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFOztBQUVsVSxnQ0FBZ0MsbUVBQW1FOztBQUVuRyxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4Syw2QkFBNkIsZ0dBQWdHLGdEQUFnRCxHQUFHLDJCQUEyQjs7OztBQUkzTTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTs7QUFFbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVixDQUFDO0FBQ0QsK0I7Ozs7Ozs7Ozs7O0FDaHh6QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7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QUFDRDs7QUFFRCxTQUFPem9DLE9BQU9sSSxJQUFQLENBQVksR0FBWixDQUFQO0FBQ0QsQ0FmRDs7a0JBaUJlZ2hDLEkiLCJmaWxlIjoiY2xhcHByLmRlYnVnLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsYXBwclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDbGFwcHJcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiZGlzdC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbWFpbi5qc1wiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX2Fzc2lnbjIuZGVmYXVsdCB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9mcm9tID0gcmVxdWlyZShcIi4uL2NvcmUtanMvYXJyYXkvZnJvbVwiKTtcblxudmFyIF9mcm9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zyb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07IiwiLyogWmVwdG8gdjEuMi4wIC0gemVwdG8gYWpheCBjYWxsYmFja3MgZGVmZXJyZWQgZXZlbnQgaWUgc2VsZWN0b3IgLSB6ZXB0b2pzLmNvbS9saWNlbnNlICovXG5cblxudmFyIFplcHRvID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBjb25jYXQgPSBlbXB0eUFycmF5LmNvbmNhdCwgZmlsdGVyID0gZW1wdHlBcnJheS5maWx0ZXIsIHNsaWNlID0gZW1wdHlBcnJheS5zbGljZSxcbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICBlbGVtZW50RGlzcGxheSA9IHt9LCBjbGFzc0NhY2hlID0ge30sXG4gICAgY3NzTnVtYmVyID0geyAnY29sdW1uLWNvdW50JzogMSwgJ2NvbHVtbnMnOiAxLCAnZm9udC13ZWlnaHQnOiAxLCAnbGluZS1oZWlnaHQnOiAxLCdvcGFjaXR5JzogMSwgJ3otaW5kZXgnOiAxLCAnem9vbSc6IDEgfSxcbiAgICBmcmFnbWVudFJFID0gL15cXHMqPChcXHcrfCEpW14+XSo+LyxcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcbiAgICB0YWdFeHBhbmRlclJFID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxuICAgIHJvb3ROb2RlUkUgPSAvXig/OmJvZHl8aHRtbCkkL2ksXG4gICAgY2FwaXRhbFJFID0gLyhbQS1aXSkvZyxcblxuICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBnZXQvc2V0IHZpYSBtZXRob2QgY2FsbHNcbiAgICBtZXRob2RBdHRyaWJ1dGVzID0gWyd2YWwnLCAnY3NzJywgJ2h0bWwnLCAndGV4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdvZmZzZXQnXSxcblxuICAgIGFkamFjZW5jeU9wZXJhdG9ycyA9IFsgJ2FmdGVyJywgJ3ByZXBlbmQnLCAnYmVmb3JlJywgJ2FwcGVuZCcgXSxcbiAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyksXG4gICAgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpLFxuICAgIGNvbnRhaW5lcnMgPSB7XG4gICAgICAndHInOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxuICAgICAgJ3Rib2R5JzogdGFibGUsICd0aGVhZCc6IHRhYmxlLCAndGZvb3QnOiB0YWJsZSxcbiAgICAgICd0ZCc6IHRhYmxlUm93LCAndGgnOiB0YWJsZVJvdyxcbiAgICAgICcqJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9LFxuICAgIHJlYWR5UkUgPSAvY29tcGxldGV8bG9hZGVkfGludGVyYWN0aXZlLyxcbiAgICBzaW1wbGVTZWxlY3RvclJFID0gL15bXFx3LV0qJC8sXG4gICAgY2xhc3MydHlwZSA9IHt9LFxuICAgIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZyxcbiAgICB6ZXB0byA9IHt9LFxuICAgIGNhbWVsaXplLCB1bmlxLFxuICAgIHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBwcm9wTWFwID0ge1xuICAgICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4JyxcbiAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgICAnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXG4gICAgICAnY2VsbHNwYWNpbmcnOiAnY2VsbFNwYWNpbmcnLFxuICAgICAgJ2NlbGxwYWRkaW5nJzogJ2NlbGxQYWRkaW5nJyxcbiAgICAgICdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxuICAgICAgJ2NvbHNwYW4nOiAnY29sU3BhbicsXG4gICAgICAndXNlbWFwJzogJ3VzZU1hcCcsXG4gICAgICAnZnJhbWVib3JkZXInOiAnZnJhbWVCb3JkZXInLFxuICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnXG4gICAgfSxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxuICAgICAgZnVuY3Rpb24ob2JqZWN0KXsgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5IH1cblxuICB6ZXB0by5tYXRjaGVzID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yIHx8ICFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZVxuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBlbGVtZW50Lm1hdGNoZXMgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yXG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgIC8vIGZhbGwgYmFjayB0byBwZXJmb3JtaW5nIGEgc2VsZWN0b3I6XG4gICAgdmFyIG1hdGNoLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsIHRlbXAgPSAhcGFyZW50XG4gICAgaWYgKHRlbXApIChwYXJlbnQgPSB0ZW1wUGFyZW50KS5hcHBlbmRDaGlsZChlbGVtZW50KVxuICAgIG1hdGNoID0gfnplcHRvLnFzYShwYXJlbnQsIHNlbGVjdG9yKS5pbmRleE9mKGVsZW1lbnQpXG4gICAgdGVtcCAmJiB0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpXG4gICAgcmV0dXJuIG1hdGNoXG4gIH1cblxuICBmdW5jdGlvbiB0eXBlKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IFN0cmluZyhvYmopIDpcbiAgICAgIGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiXG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlKHZhbHVlKSA9PSBcImZ1bmN0aW9uXCIgfVxuICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopICAgICB7IHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdyB9XG4gIGZ1bmN0aW9uIGlzRG9jdW1lbnQob2JqKSAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5ub2RlVHlwZSA9PSBvYmouRE9DVU1FTlRfTk9ERSB9XG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgICAgIHsgcmV0dXJuIHR5cGUob2JqKSA9PSBcIm9iamVjdFwiIH1cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiAhaXNXaW5kb3cob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlXG4gIH1cblxuICBmdW5jdGlvbiBsaWtlQXJyYXkob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmICdsZW5ndGgnIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgdHlwZSA9ICQudHlwZShvYmopXG5cbiAgICByZXR1cm4gJ2Z1bmN0aW9uJyAhPSB0eXBlICYmICFpc1dpbmRvdyhvYmopICYmIChcbiAgICAgICdhcnJheScgPT0gdHlwZSB8fCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0gIT0gbnVsbCB9KSB9XG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHsgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDAgPyAkLmZuLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpIDogYXJyYXkgfVxuICBjYW1lbGl6ZSA9IGZ1bmN0aW9uKHN0cil7IHJldHVybiBzdHIucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaHIpeyByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJyB9KSB9XG4gIGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzo6L2csICcvJylcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csICckMV8kMicpXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKVxuICAgICAgICAgICAucmVwbGFjZSgvXy9nLCAnLScpXG4gICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgdW5pcSA9IGZ1bmN0aW9uKGFycmF5KXsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtLCBpZHgpeyByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PSBpZHggfSkgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzUkUobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIGNsYXNzQ2FjaGUgP1xuICAgICAgY2xhc3NDYWNoZVtuYW1lXSA6IChjbGFzc0NhY2hlW25hbWVdID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUFkZFB4KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0pID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkobm9kZU5hbWUpIHtcbiAgICB2YXIgZWxlbWVudCwgZGlzcGxheVxuICAgIGlmICghZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdKSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudClcbiAgICAgIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKVxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpXG4gICAgICBkaXNwbGF5ID09IFwibm9uZVwiICYmIChkaXNwbGF5ID0gXCJibG9ja1wiKVxuICAgICAgZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuICdjaGlsZHJlbicgaW4gZWxlbWVudCA/XG4gICAgICBzbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pIDpcbiAgICAgICQubWFwKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSl7IGlmIChub2RlLm5vZGVUeXBlID09IDEpIHJldHVybiBub2RlIH0pXG4gIH1cblxuICBmdW5jdGlvbiBaKGRvbSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgaSwgbGVuID0gZG9tID8gZG9tLmxlbmd0aCA6IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXNbaV0gPSBkb21baV1cbiAgICB0aGlzLmxlbmd0aCA9IGxlblxuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xuICB9XG5cbiAgLy8gYCQuemVwdG8uZnJhZ21lbnRgIHRha2VzIGEgaHRtbCBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHRhZyBuYW1lXG4gIC8vIHRvIGdlbmVyYXRlIERPTSBub2RlcyBmcm9tIHRoZSBnaXZlbiBodG1sIHN0cmluZy5cbiAgLy8gVGhlIGdlbmVyYXRlZCBET00gbm9kZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMgZm9yIGV4YW1wbGUgdG8gbWFrZVxuICAvLyBpdCBjb21wYXRpYmxlIHdpdGggYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBET00gZnVsbHkuXG4gIHplcHRvLmZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCwgbmFtZSwgcHJvcGVydGllcykge1xuICAgIHZhciBkb20sIG5vZGVzLCBjb250YWluZXJcblxuICAgIC8vIEEgc3BlY2lhbCBjYXNlIG9wdGltaXphdGlvbiBmb3IgYSBzaW5nbGUgdGFnXG4gICAgaWYgKHNpbmdsZVRhZ1JFLnRlc3QoaHRtbCkpIGRvbSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKVxuXG4gICAgaWYgKCFkb20pIHtcbiAgICAgIGlmIChodG1sLnJlcGxhY2UpIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnRXhwYW5kZXJSRSwgXCI8JDE+PC8kMj5cIilcbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBmcmFnbWVudFJFLnRlc3QoaHRtbCkgJiYgUmVnRXhwLiQxXG4gICAgICBpZiAoIShuYW1lIGluIGNvbnRhaW5lcnMpKSBuYW1lID0gJyonXG5cbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNbbmFtZV1cbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJyArIGh0bWxcbiAgICAgIGRvbSA9ICQuZWFjaChzbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSB7XG4gICAgICBub2RlcyA9ICQoZG9tKVxuICAgICAgJC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID4gLTEpIG5vZGVzW2tleV0odmFsdWUpXG4gICAgICAgIGVsc2Ugbm9kZXMuYXR0cihrZXksIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvLyBgJC56ZXB0by5aYCBzd2FwcyBvdXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgZ2l2ZW4gYGRvbWAgYXJyYXlcbiAgLy8gb2Ygbm9kZXMgd2l0aCBgJC5mbmAgYW5kIHRodXMgc3VwcGx5aW5nIGFsbCB0aGUgWmVwdG8gZnVuY3Rpb25zXG4gIC8vIHRvIHRoZSBhcnJheS4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cbiAgemVwdG8uWiA9IGZ1bmN0aW9uKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFooZG9tLCBzZWxlY3RvcilcbiAgfVxuXG4gIC8vIGAkLnplcHRvLmlzWmAgc2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIFplcHRvXG4gIC8vIGNvbGxlY3Rpb24uIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXG4gIHplcHRvLmlzWiA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB6ZXB0by5aXG4gIH1cblxuICAvLyBgJC56ZXB0by5pbml0YCBpcyBaZXB0bydzIGNvdW50ZXJwYXJ0IHRvIGpRdWVyeSdzIGAkLmZuLmluaXRgIGFuZFxuICAvLyB0YWtlcyBhIENTUyBzZWxlY3RvciBhbmQgYW4gb3B0aW9uYWwgY29udGV4dCAoYW5kIGhhbmRsZXMgdmFyaW91c1xuICAvLyBzcGVjaWFsIGNhc2VzKS5cbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cbiAgemVwdG8uaW5pdCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbVxuICAgIC8vIElmIG5vdGhpbmcgZ2l2ZW4sIHJldHVybiBhbiBlbXB0eSBaZXB0byBjb2xsZWN0aW9uXG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHplcHRvLlooKVxuICAgIC8vIE9wdGltaXplIGZvciBzdHJpbmcgc2VsZWN0b3JzXG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKVxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XG4gICAgICAvLyBOb3RlOiBJbiBib3RoIENocm9tZSAyMSBhbmQgRmlyZWZveCAxNSwgRE9NIGVycm9yIDEyXG4gICAgICAvLyBpcyB0aHJvd24gaWYgdGhlIGZyYWdtZW50IGRvZXNuJ3QgYmVnaW4gd2l0aCA8XG4gICAgICBpZiAoc2VsZWN0b3JbMF0gPT0gJzwnICYmIGZyYWdtZW50UkUudGVzdChzZWxlY3RvcikpXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb250ZXh0LCBjcmVhdGUgYSBjb2xsZWN0aW9uIG9uIHRoYXQgY29udGV4dCBmaXJzdCwgYW5kIHNlbGVjdFxuICAgICAgLy8gbm9kZXMgZnJvbSB0aGVyZVxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxuICAgICAgLy8gSWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cbiAgICAgIGVsc2UgZG9tID0gemVwdG8ucXNhKGRvY3VtZW50LCBzZWxlY3RvcilcbiAgICB9XG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiwgY2FsbCBpdCB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuICQoZG9jdW1lbnQpLnJlYWR5KHNlbGVjdG9yKVxuICAgIC8vIElmIGEgWmVwdG8gY29sbGVjdGlvbiBpcyBnaXZlbiwganVzdCByZXR1cm4gaXRcbiAgICBlbHNlIGlmICh6ZXB0by5pc1ooc2VsZWN0b3IpKSByZXR1cm4gc2VsZWN0b3JcbiAgICBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbGl6ZSBhcnJheSBpZiBhbiBhcnJheSBvZiBub2RlcyBpcyBnaXZlblxuICAgICAgaWYgKGlzQXJyYXkoc2VsZWN0b3IpKSBkb20gPSBjb21wYWN0KHNlbGVjdG9yKVxuICAgICAgLy8gV3JhcCBET00gbm9kZXMuXG4gICAgICBlbHNlIGlmIChpc09iamVjdChzZWxlY3RvcikpXG4gICAgICAgIGRvbSA9IFtzZWxlY3Rvcl0sIHNlbGVjdG9yID0gbnVsbFxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XG4gICAgICBlbHNlIGlmIChmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxuICAgICAgICBkb20gPSB6ZXB0by5mcmFnbWVudChzZWxlY3Rvci50cmltKCksIFJlZ0V4cC4kMSwgY29udGV4dCksIHNlbGVjdG9yID0gbnVsbFxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXG4gICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiAkKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpXG4gICAgICAvLyBBbmQgbGFzdCBidXQgbm8gbGVhc3QsIGlmIGl0J3MgYSBDU1Mgc2VsZWN0b3IsIHVzZSBpdCB0byBzZWxlY3Qgbm9kZXMuXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIG5ldyBaZXB0byBjb2xsZWN0aW9uIGZyb20gdGhlIG5vZGVzIGZvdW5kXG4gICAgcmV0dXJuIHplcHRvLlooZG9tLCBzZWxlY3RvcilcbiAgfVxuXG4gIC8vIGAkYCB3aWxsIGJlIHRoZSBiYXNlIGBaZXB0b2Agb2JqZWN0LiBXaGVuIGNhbGxpbmcgdGhpc1xuICAvLyBmdW5jdGlvbiBqdXN0IGNhbGwgYCQuemVwdG8uaW5pdCwgd2hpY2ggbWFrZXMgdGhlIGltcGxlbWVudGF0aW9uXG4gIC8vIGRldGFpbHMgb2Ygc2VsZWN0aW5nIG5vZGVzIGFuZCBjcmVhdGluZyBaZXB0byBjb2xsZWN0aW9uc1xuICAvLyBwYXRjaGFibGUgaW4gcGx1Z2lucy5cbiAgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcbiAgICByZXR1cm4gemVwdG8uaW5pdChzZWxlY3RvciwgY29udGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xuICAgIGZvciAoa2V5IGluIHNvdXJjZSlcbiAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmICFpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSlcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9XG4gICAgICAgIGlmIChpc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhaXNBcnJheSh0YXJnZXRba2V5XSkpXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXVxuICAgICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICB9XG5cbiAgLy8gQ29weSBhbGwgYnV0IHVuZGVmaW5lZCBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmVcbiAgLy8gb2JqZWN0cyB0byB0aGUgYHRhcmdldGAgb2JqZWN0LlxuICAkLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIGRlZXAsIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcbiAgICAgIGRlZXAgPSB0YXJnZXRcbiAgICAgIHRhcmdldCA9IGFyZ3Muc2hpZnQoKVxuICAgIH1cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKXsgZXh0ZW5kKHRhcmdldCwgYXJnLCBkZWVwKSB9KVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIGAkLnplcHRvLnFzYWAgaXMgWmVwdG8ncyBDU1Mgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24gd2hpY2hcbiAgLy8gdXNlcyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGAgYW5kIG9wdGltaXplcyBmb3Igc29tZSBzcGVjaWFsIGNhc2VzLCBsaWtlIGAjaWRgLlxuICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxuICB6ZXB0by5xc2EgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcil7XG4gICAgdmFyIGZvdW5kLFxuICAgICAgICBtYXliZUlEID0gc2VsZWN0b3JbMF0gPT0gJyMnLFxuICAgICAgICBtYXliZUNsYXNzID0gIW1heWJlSUQgJiYgc2VsZWN0b3JbMF0gPT0gJy4nLFxuICAgICAgICBuYW1lT25seSA9IG1heWJlSUQgfHwgbWF5YmVDbGFzcyA/IHNlbGVjdG9yLnNsaWNlKDEpIDogc2VsZWN0b3IsIC8vIEVuc3VyZSB0aGF0IGEgMSBjaGFyIHRhZyBuYW1lIHN0aWxsIGdldHMgY2hlY2tlZFxuICAgICAgICBpc1NpbXBsZSA9IHNpbXBsZVNlbGVjdG9yUkUudGVzdChuYW1lT25seSlcbiAgICByZXR1cm4gKGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQgJiYgaXNTaW1wbGUgJiYgbWF5YmVJRCkgPyAvLyBTYWZhcmkgRG9jdW1lbnRGcmFnbWVudCBkb2Vzbid0IGhhdmUgZ2V0RWxlbWVudEJ5SWRcbiAgICAgICggKGZvdW5kID0gZWxlbWVudC5nZXRFbGVtZW50QnlJZChuYW1lT25seSkpID8gW2ZvdW5kXSA6IFtdICkgOlxuICAgICAgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAxMSkgPyBbXSA6XG4gICAgICBzbGljZS5jYWxsKFxuICAgICAgICBpc1NpbXBsZSAmJiAhbWF5YmVJRCAmJiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPyAvLyBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lL1RhZ05hbWVcbiAgICAgICAgICBtYXliZUNsYXNzID8gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWVPbmx5KSA6IC8vIElmIGl0J3Mgc2ltcGxlLCBpdCBjb3VsZCBiZSBhIGNsYXNzXG4gICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikgOiAvLyBPciBhIHRhZ1xuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgLy8gT3IgaXQncyBub3Qgc2ltcGxlLCBhbmQgd2UgbmVlZCB0byBxdWVyeSBhbGxcbiAgICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlcmVkKG5vZGVzLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gJChub2RlcykgOiAkKG5vZGVzKS5maWx0ZXIoc2VsZWN0b3IpXG4gIH1cblxuICAkLmNvbnRhaW5zID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zID9cbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBwYXJlbnQgIT09IG5vZGUgJiYgcGFyZW50LmNvbnRhaW5zKG5vZGUpXG4gICAgfSA6XG4gICAgZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XG4gICAgICB3aGlsZSAobm9kZSAmJiAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgZnVuY3Rpb24gZnVuY0FyZyhjb250ZXh0LCBhcmcsIGlkeCwgcGF5bG9hZCkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZykgPyBhcmcuY2FsbChjb250ZXh0LCBpZHgsIHBheWxvYWQpIDogYXJnXG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9PSBudWxsID8gbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgOiBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGFjY2VzcyBjbGFzc05hbWUgcHJvcGVydHkgd2hpbGUgcmVzcGVjdGluZyBTVkdBbmltYXRlZFN0cmluZ1xuICBmdW5jdGlvbiBjbGFzc05hbWUobm9kZSwgdmFsdWUpe1xuICAgIHZhciBrbGFzcyA9IG5vZGUuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICBzdmcgICA9IGtsYXNzICYmIGtsYXNzLmJhc2VWYWwgIT09IHVuZGVmaW5lZFxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBzdmcgPyBrbGFzcy5iYXNlVmFsIDoga2xhc3NcbiAgICBzdmcgPyAoa2xhc3MuYmFzZVZhbCA9IHZhbHVlKSA6IChub2RlLmNsYXNzTmFtZSA9IHZhbHVlKVxuICB9XG5cbiAgLy8gXCJ0cnVlXCIgID0+IHRydWVcbiAgLy8gXCJmYWxzZVwiID0+IGZhbHNlXG4gIC8vIFwibnVsbFwiICA9PiBudWxsXG4gIC8vIFwiNDJcIiAgICA9PiA0MlxuICAvLyBcIjQyLjVcIiAgPT4gNDIuNVxuICAvLyBcIjA4XCIgICAgPT4gXCIwOFwiXG4gIC8vIEpTT04gICAgPT4gcGFyc2UgaWYgdmFsaWRcbiAgLy8gU3RyaW5nICA9PiBzZWxmXG4gIGZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHZhbHVlID9cbiAgICAgICAgdmFsdWUgPT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgKCB2YWx1ZSA9PSBcImZhbHNlXCIgPyBmYWxzZSA6XG4gICAgICAgICAgdmFsdWUgPT0gXCJudWxsXCIgPyBudWxsIDpcbiAgICAgICAgICArdmFsdWUgKyBcIlwiID09IHZhbHVlID8gK3ZhbHVlIDpcbiAgICAgICAgICAvXltcXFtcXHtdLy50ZXN0KHZhbHVlKSA/ICQucGFyc2VKU09OKHZhbHVlKSA6XG4gICAgICAgICAgdmFsdWUgKVxuICAgICAgICA6IHZhbHVlXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICAkLnR5cGUgPSB0eXBlXG4gICQuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb25cbiAgJC5pc1dpbmRvdyA9IGlzV2luZG93XG4gICQuaXNBcnJheSA9IGlzQXJyYXlcbiAgJC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdFxuXG4gICQuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lXG4gICAgZm9yIChuYW1lIGluIG9iaikgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gICQuaXNOdW1lcmljID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIG51bSA9IE51bWJlcih2YWwpLCB0eXBlID0gdHlwZW9mIHZhbFxuICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlICE9ICdib29sZWFuJyAmJlxuICAgICAgKHR5cGUgIT0gJ3N0cmluZycgfHwgdmFsLmxlbmd0aCkgJiZcbiAgICAgICFpc05hTihudW0pICYmIGlzRmluaXRlKG51bSkgfHwgZmFsc2VcbiAgfVxuXG4gICQuaW5BcnJheSA9IGZ1bmN0aW9uKGVsZW0sIGFycmF5LCBpKXtcbiAgICByZXR1cm4gZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyYXksIGVsZW0sIGkpXG4gIH1cblxuICAkLmNhbWVsQ2FzZSA9IGNhbWVsaXplXG4gICQudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IFwiXCIgOiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXG4gIH1cblxuICAvLyBwbHVnaW4gY29tcGF0aWJpbGl0eVxuICAkLnV1aWQgPSAwXG4gICQuc3VwcG9ydCA9IHsgfVxuICAkLmV4cHIgPSB7IH1cbiAgJC5ub29wID0gZnVuY3Rpb24oKSB7fVxuXG4gICQubWFwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcbiAgICB2YXIgdmFsdWUsIHZhbHVlcyA9IFtdLCBpLCBrZXlcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSlcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKVxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWVzLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgZm9yIChrZXkgaW4gZWxlbWVudHMpIHtcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1trZXldLCBrZXkpXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbih2YWx1ZXMpXG4gIH1cblxuICAkLmVhY2ggPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIHZhciBpLCBrZXlcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1tpXSwgaSwgZWxlbWVudHNbaV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKVxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1trZXldLCBrZXksIGVsZW1lbnRzW2tleV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzXG4gIH1cblxuICAkLmdyZXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbChlbGVtZW50cywgY2FsbGJhY2spXG4gIH1cblxuICBpZiAod2luZG93LkpTT04pICQucGFyc2VKU09OID0gSlNPTi5wYXJzZVxuXG4gIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAkLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfSlcblxuICAvLyBEZWZpbmUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIGFsbFxuICAvLyBaZXB0byBjb2xsZWN0aW9uc1xuICAkLmZuID0ge1xuICAgIGNvbnN0cnVjdG9yOiB6ZXB0by5aLFxuICAgIGxlbmd0aDogMCxcblxuICAgIC8vIEJlY2F1c2UgYSBjb2xsZWN0aW9uIGFjdHMgbGlrZSBhbiBhcnJheVxuICAgIC8vIGNvcHkgb3ZlciB0aGVzZSB1c2VmdWwgYXJyYXkgZnVuY3Rpb25zLlxuICAgIGZvckVhY2g6IGVtcHR5QXJyYXkuZm9yRWFjaCxcbiAgICByZWR1Y2U6IGVtcHR5QXJyYXkucmVkdWNlLFxuICAgIHB1c2g6IGVtcHR5QXJyYXkucHVzaCxcbiAgICBzb3J0OiBlbXB0eUFycmF5LnNvcnQsXG4gICAgc3BsaWNlOiBlbXB0eUFycmF5LnNwbGljZSxcbiAgICBpbmRleE9mOiBlbXB0eUFycmF5LmluZGV4T2YsXG4gICAgY29uY2F0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGksIHZhbHVlLCBhcmdzID0gW11cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaV1cbiAgICAgICAgYXJnc1tpXSA9IHplcHRvLmlzWih2YWx1ZSkgPyB2YWx1ZS50b0FycmF5KCkgOiB2YWx1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseSh6ZXB0by5pc1oodGhpcykgPyB0aGlzLnRvQXJyYXkoKSA6IHRoaXMsIGFyZ3MpXG4gICAgfSxcblxuICAgIC8vIGBtYXBgIGFuZCBgc2xpY2VgIGluIHRoZSBqUXVlcnkgQVBJIHdvcmsgZGlmZmVyZW50bHlcbiAgICAvLyBmcm9tIHRoZWlyIGFycmF5IGNvdW50ZXJwYXJ0c1xuICAgIG1hcDogZnVuY3Rpb24oZm4pe1xuICAgICAgcmV0dXJuICQoJC5tYXAodGhpcywgZnVuY3Rpb24oZWwsIGkpeyByZXR1cm4gZm4uY2FsbChlbCwgaSwgZWwpIH0pKVxuICAgIH0sXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gJChzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgIH0sXG5cbiAgICByZWFkeTogZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiBkb2N1bWVudC5ib2R5IGV4aXN0cyBmb3IgSUUgYXMgdGhhdCBicm93c2VyIHJlcG9ydHNcbiAgICAgIC8vIGRvY3VtZW50IHJlYWR5IHdoZW4gaXQgaGFzbid0IHlldCBjcmVhdGVkIHRoZSBib2R5IGVsZW1lbnRcbiAgICAgIGlmIChyZWFkeVJFLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkgJiYgZG9jdW1lbnQuYm9keSkgY2FsbGJhY2soJClcbiAgICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7IGNhbGxiYWNrKCQpIH0sIGZhbHNlKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oaWR4KXtcbiAgICAgIHJldHVybiBpZHggPT09IHVuZGVmaW5lZCA/IHNsaWNlLmNhbGwodGhpcykgOiB0aGlzW2lkeCA+PSAwID8gaWR4IDogaWR4ICsgdGhpcy5sZW5ndGhdXG4gICAgfSxcbiAgICB0b0FycmF5OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5nZXQoKSB9LFxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPSBudWxsKVxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICAgIGVtcHR5QXJyYXkuZXZlcnkuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCwgaWR4KXtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWwsIGlkeCwgZWwpICE9PSBmYWxzZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMubm90KHRoaXMubm90KHNlbGVjdG9yKSlcbiAgICAgIHJldHVybiAkKGZpbHRlci5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gemVwdG8ubWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihzZWxlY3Rvcixjb250ZXh0KXtcbiAgICAgIHJldHVybiAkKHVuaXEodGhpcy5jb25jYXQoJChzZWxlY3Rvcixjb250ZXh0KSkpKVxuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgemVwdG8ubWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgdmFyIG5vZGVzPVtdXG4gICAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgc2VsZWN0b3IuY2FsbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcyxpZHgpKSBub2Rlcy5wdXNoKHRoaXMpXG4gICAgICAgIH0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDpcbiAgICAgICAgICAobGlrZUFycmF5KHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yLml0ZW0pKSA/IHNsaWNlLmNhbGwoc2VsZWN0b3IpIDogJChzZWxlY3RvcilcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZihlbCkgPCAwKSBub2Rlcy5wdXNoKGVsKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gaXNPYmplY3Qoc2VsZWN0b3IpID9cbiAgICAgICAgICAkLmNvbnRhaW5zKHRoaXMsIHNlbGVjdG9yKSA6XG4gICAgICAgICAgJCh0aGlzKS5maW5kKHNlbGVjdG9yKS5zaXplKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24oaWR4KXtcbiAgICAgIHJldHVybiBpZHggPT09IC0xID8gdGhpcy5zbGljZShpZHgpIDogdGhpcy5zbGljZShpZHgsICsgaWR4ICsgMSlcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1swXVxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHZhciByZXN1bHQsICR0aGlzID0gdGhpc1xuICAgICAgaWYgKCFzZWxlY3RvcikgcmVzdWx0ID0gJCgpXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcpXG4gICAgICAgIHJlc3VsdCA9ICQoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBub2RlID0gdGhpc1xuICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCgkdGhpcywgZnVuY3Rpb24ocGFyZW50KXtcbiAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgbm9kZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT0gMSkgcmVzdWx0ID0gJCh6ZXB0by5xc2EodGhpc1swXSwgc2VsZWN0b3IpKVxuICAgICAgZWxzZSByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gemVwdG8ucXNhKHRoaXMsIHNlbGVjdG9yKSB9KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xuICAgICAgdmFyIG5vZGVzID0gW10sIGNvbGxlY3Rpb24gPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcgJiYgJChzZWxlY3RvcilcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihfLCBub2RlKXtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiB6ZXB0by5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpXG4gICAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVzLmluZGV4T2Yobm9kZSkgPCAwKSBub2Rlcy5wdXNoKG5vZGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG5vZGVzID0gdGhpc1xuICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIG5vZGVzID0gJC5tYXAobm9kZXMsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIGlmICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPCAwKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICByZXR1cm4gZmlsdGVyZWQoYW5jZXN0b3JzLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHVuaXEodGhpcy5wbHVjaygncGFyZW50Tm9kZScpKSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiBjaGlsZHJlbih0aGlzKSB9KSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnREb2N1bWVudCB8fCBzbGljZS5jYWxsKHRoaXMuY2hpbGROb2RlcykgfSlcbiAgICB9LFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gZmlsdGVyZWQodGhpcy5tYXAoZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICByZXR1cm4gZmlsdGVyLmNhbGwoY2hpbGRyZW4oZWwucGFyZW50Tm9kZSksIGZ1bmN0aW9uKGNoaWxkKXsgcmV0dXJuIGNoaWxkIT09ZWwgfSlcbiAgICAgIH0pLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLmlubmVySFRNTCA9ICcnIH0pXG4gICAgfSxcbiAgICAvLyBgcGx1Y2tgIGlzIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLmpzXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKHByb3BlcnR5KXtcbiAgICAgIHJldHVybiAkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCl7IHJldHVybiBlbFtwcm9wZXJ0eV0gfSlcbiAgICB9LFxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIilcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSh0aGlzLm5vZGVOYW1lKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihuZXdDb250ZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZShuZXdDb250ZW50KS5yZW1vdmUoKVxuICAgIH0sXG4gICAgd3JhcDogZnVuY3Rpb24oc3RydWN0dXJlKXtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXG4gICAgICBpZiAodGhpc1swXSAmJiAhZnVuYylcbiAgICAgICAgdmFyIGRvbSAgID0gJChzdHJ1Y3R1cmUpLmdldCgwKSxcbiAgICAgICAgICAgIGNsb25lID0gZG9tLnBhcmVudE5vZGUgfHwgdGhpcy5sZW5ndGggPiAxXG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICAkKHRoaXMpLndyYXBBbGwoXG4gICAgICAgICAgZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6XG4gICAgICAgICAgICBjbG9uZSA/IGRvbS5jbG9uZU5vZGUodHJ1ZSkgOiBkb21cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XG4gICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAkKHRoaXNbMF0pLmJlZm9yZShzdHJ1Y3R1cmUgPSAkKHN0cnVjdHVyZSkpXG4gICAgICAgIHZhciBjaGlsZHJlblxuICAgICAgICAvLyBkcmlsbCBkb3duIHRvIHRoZSBpbm1vc3QgZWxlbWVudFxuICAgICAgICB3aGlsZSAoKGNoaWxkcmVuID0gc3RydWN0dXJlLmNoaWxkcmVuKCkpLmxlbmd0aCkgc3RydWN0dXJlID0gY2hpbGRyZW4uZmlyc3QoKVxuICAgICAgICAkKHN0cnVjdHVyZSkuYXBwZW5kKHRoaXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpLFxuICAgICAgICAgICAgZG9tICA9IGZ1bmMgPyBzdHJ1Y3R1cmUuY2FsbCh0aGlzLCBpbmRleCkgOiBzdHJ1Y3R1cmVcbiAgICAgICAgY29udGVudHMubGVuZ3RoID8gY29udGVudHMud3JhcEFsbChkb20pIDogc2VsZi5hcHBlbmQoZG9tKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHVud3JhcDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAkKHRoaXMpLnJlcGxhY2VXaXRoKCQodGhpcykuY2hpbGRyZW4oKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpIH0pXG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICB9LFxuICAgIHRvZ2dsZTogZnVuY3Rpb24oc2V0dGluZyl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBlbCA9ICQodGhpcylcbiAgICAgICAgOyhzZXR0aW5nID09PSB1bmRlZmluZWQgPyBlbC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcbiAgICBuZXh0OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ25leHRFbGVtZW50U2libGluZycpKS5maWx0ZXIoc2VsZWN0b3IgfHwgJyonKSB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG9yaWdpbkh0bWwgPSB0aGlzLmlubmVySFRNTFxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbClcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmdW5jQXJnKHRoaXMsIHRleHQsIGlkeCwgdGhpcy50ZXh0Q29udGVudClcbiAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gbmV3VGV4dCA9PSBudWxsID8gJycgOiAnJytuZXdUZXh0XG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXMucGx1Y2soJ3RleHRDb250ZW50Jykuam9pbihcIlwiKSA6IG51bGwpXG4gICAgfSxcbiAgICBhdHRyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XG4gICAgICB2YXIgcmVzdWx0XG4gICAgICByZXR1cm4gKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmICEoMSBpbiBhcmd1bWVudHMpKSA/XG4gICAgICAgICgwIGluIHRoaXMgJiYgdGhpc1swXS5ub2RlVHlwZSA9PSAxICYmIChyZXN1bHQgPSB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKSkgIT0gbnVsbCA/IHJlc3VsdCA6IHVuZGVmaW5lZCkgOlxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSBmb3IgKGtleSBpbiBuYW1lKSBzZXRBdHRyaWJ1dGUodGhpcywga2V5LCBuYW1lW2tleV0pXG4gICAgICAgICAgZWxzZSBzZXRBdHRyaWJ1dGUodGhpcywgbmFtZSwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSkpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcywgYXR0cmlidXRlKVxuICAgICAgfSwgdGhpcyl9KVxuICAgIH0sXG4gICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAgICAgbmFtZSA9IHByb3BNYXBbbmFtZV0gfHwgbmFtZVxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzW25hbWVdKVxuICAgICAgICB9KSA6XG4gICAgICAgICh0aGlzWzBdICYmIHRoaXNbMF1bbmFtZV0pXG4gICAgfSxcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgZGVsZXRlIHRoaXNbbmFtZV0gfSlcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcbiAgICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBuYW1lLnJlcGxhY2UoY2FwaXRhbFJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxuXG4gICAgICB2YXIgZGF0YSA9ICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUsIHZhbHVlKSA6XG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSlcblxuICAgICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkZXNlcmlhbGl6ZVZhbHVlKGRhdGEpIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmICgwIGluIGFyZ3VtZW50cykge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcIlwiXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKHRoaXNbMF0ubXVsdGlwbGUgP1xuICAgICAgICAgICAkKHRoaXNbMF0pLmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zZWxlY3RlZCB9KS5wbHVjaygndmFsdWUnKSA6XG4gICAgICAgICAgIHRoaXNbMF0udmFsdWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKXtcbiAgICAgIGlmIChjb29yZGluYXRlcykgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBjb29yZHMgPSBmdW5jQXJnKHRoaXMsIGNvb3JkaW5hdGVzLCBpbmRleCwgJHRoaXMub2Zmc2V0KCkpLFxuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJHRoaXMub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCksXG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiAgY29vcmRzLnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCR0aGlzLmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykgcHJvcHNbJ3Bvc2l0aW9uJ10gPSAncmVsYXRpdmUnXG4gICAgICAgICR0aGlzLmNzcyhwcm9wcylcbiAgICAgIH0pXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gdGhpc1swXSAmJiAhJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXNbMF0pKVxuICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH1cbiAgICAgIHZhciBvYmogPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBvYmoubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdG9wOiBvYmoudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChvYmoud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQob2JqLmhlaWdodClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNzczogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbMF1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcGVydHkpXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fVxuICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcbiAgICAgICAgICAkLmVhY2gocHJvcGVydHksIGZ1bmN0aW9uKF8sIHByb3Ape1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSAoZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wKV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHByb3BzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNzcyA9ICcnXG4gICAgICBpZiAodHlwZShwcm9wZXJ0eSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMClcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKSB9KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY3NzID0gZGFzaGVyaXplKHByb3BlcnR5KSArIFwiOlwiICsgbWF5YmVBZGRQeChwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0eSlcbiAgICAgICAgICBpZiAoIXByb3BlcnR5W2tleV0gJiYgcHJvcGVydHlba2V5XSAhPT0gMClcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShrZXkpKSB9KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNzcyArPSBkYXNoZXJpemUoa2V5KSArICc6JyArIG1heWJlQWRkUHgoa2V5LCBwcm9wZXJ0eVtrZXldKSArICc7J1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3MgfSlcbiAgICB9LFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KXtcbiAgICAgIHJldHVybiBlbGVtZW50ID8gdGhpcy5pbmRleE9mKCQoZWxlbWVudClbMF0pIDogdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4T2YodGhpc1swXSlcbiAgICB9LFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwodGhpcywgZnVuY3Rpb24oZWwpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0KGNsYXNzTmFtZShlbCkpXG4gICAgICB9LCBjbGFzc1JFKG5hbWUpKVxuICAgIH0sXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXG4gICAgICAgIGNsYXNzTGlzdCA9IFtdXG4gICAgICAgIHZhciBjbHMgPSBjbGFzc05hbWUodGhpcyksIG5ld05hbWUgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xzKVxuICAgICAgICBuZXdOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcyhrbGFzcykpIGNsYXNzTGlzdC5wdXNoKGtsYXNzKVxuICAgICAgICB9LCB0aGlzKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoICYmIGNsYXNzTmFtZSh0aGlzLCBjbHMgKyAoY2xzID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTGlzdC5qb2luKFwiIFwiKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNsYXNzTmFtZSh0aGlzLCAnJylcbiAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NOYW1lKHRoaXMpXG4gICAgICAgIGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc0xpc3QpLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5yZXBsYWNlKGNsYXNzUkUoa2xhc3MpLCBcIiBcIilcbiAgICAgICAgfSlcbiAgICAgICAgY2xhc3NOYW1lKHRoaXMsIGNsYXNzTGlzdC50cmltKCkpXG4gICAgICB9KVxuICAgIH0sXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUsIHdoZW4pe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBuYW1lcyA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc05hbWUodGhpcykpXG4gICAgICAgIG5hbWVzLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgICh3aGVuID09PSB1bmRlZmluZWQgPyAhJHRoaXMuaGFzQ2xhc3Moa2xhc3MpIDogd2hlbikgP1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgc2Nyb2xsVG9wOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGhhc1Njcm9sbFRvcCA/IHRoaXNbMF0uc2Nyb2xsVG9wIDogdGhpc1swXS5wYWdlWU9mZnNldFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxUb3AgP1xuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHRoaXMuc2Nyb2xsWCwgdmFsdWUpIH0pXG4gICAgfSxcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnIGluIHRoaXNbMF1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsTGVmdCA/XG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsTGVmdCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cblxuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxuICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJvb3ROb2RlUkUudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKVxuXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcbiAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG4gICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcbiAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoICQoZWxlbSkuY3NzKCdtYXJnaW4tbGVmdCcpICkgfHwgMFxuXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcbiAgICAgIHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSApIHx8IDBcbiAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykgKSB8fCAwXG5cbiAgICAgIC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXJvb3ROb2RlUkUudGVzdChwYXJlbnQubm9kZU5hbWUpICYmICQocGFyZW50KS5jc3MoXCJwb3NpdGlvblwiKSA9PSBcInN0YXRpY1wiKVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnRcbiAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBmb3Igbm93XG4gICQuZm4uZGV0YWNoID0gJC5mbi5yZW1vdmVcblxuICAvLyBHZW5lcmF0ZSB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgZnVuY3Rpb25zXG4gIDtbJ3dpZHRoJywgJ2hlaWdodCddLmZvckVhY2goZnVuY3Rpb24oZGltZW5zaW9uKXtcbiAgICB2YXIgZGltZW5zaW9uUHJvcGVydHkgPVxuICAgICAgZGltZW5zaW9uLnJlcGxhY2UoLy4vLCBmdW5jdGlvbihtKXsgcmV0dXJuIG1bMF0udG9VcHBlckNhc2UoKSB9KVxuXG4gICAgJC5mbltkaW1lbnNpb25dID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgdmFyIG9mZnNldCwgZWwgPSB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzV2luZG93KGVsKSA/IGVsWydpbm5lcicgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxuICAgICAgICBpc0RvY3VtZW50KGVsKSA/IGVsLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XG4gICAgICAgIChvZmZzZXQgPSB0aGlzLm9mZnNldCgpKSAmJiBvZmZzZXRbZGltZW5zaW9uXVxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGVsID0gJCh0aGlzKVxuICAgICAgICBlbC5jc3MoZGltZW5zaW9uLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIGVsW2RpbWVuc2lvbl0oKSkpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuKSB7XG4gICAgZnVuKG5vZGUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIHRyYXZlcnNlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGZ1bilcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSBgYWZ0ZXJgLCBgcHJlcGVuZGAsIGBiZWZvcmVgLCBgYXBwZW5kYCxcbiAgLy8gYGluc2VydEFmdGVyYCwgYGluc2VydEJlZm9yZWAsIGBhcHBlbmRUb2AsIGFuZCBgcHJlcGVuZFRvYCBtZXRob2RzLlxuICBhZGphY2VuY3lPcGVyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvciwgb3BlcmF0b3JJbmRleCkge1xuICAgIHZhciBpbnNpZGUgPSBvcGVyYXRvckluZGV4ICUgMiAvLz0+IHByZXBlbmQsIGFwcGVuZFxuXG4gICAgJC5mbltvcGVyYXRvcl0gPSBmdW5jdGlvbigpe1xuICAgICAgLy8gYXJndW1lbnRzIGNhbiBiZSBub2RlcywgYXJyYXlzIG9mIG5vZGVzLCBaZXB0byBvYmplY3RzIGFuZCBIVE1MIHN0cmluZ3NcbiAgICAgIHZhciBhcmdUeXBlLCBub2RlcyA9ICQubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW11cbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlKGFyZylcbiAgICAgICAgICAgIGlmIChhcmdUeXBlID09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJyLnB1c2goZWwpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJC56ZXB0by5pc1ooZWwpKSByZXR1cm4gYXJyID0gYXJyLmNvbmNhdChlbC5nZXQoKSlcbiAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KHplcHRvLmZyYWdtZW50KGVsKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJvYmplY3RcIiB8fCBhcmcgPT0gbnVsbCA/XG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwYXJlbnQsIGNvcHlCeUNsb25lID0gdGhpcy5sZW5ndGggPiAxXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihfLCB0YXJnZXQpe1xuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxuXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIG1ldGhvZHMgdG8gYSBcImJlZm9yZVwiIG9wZXJhdGlvblxuICAgICAgICB0YXJnZXQgPSBvcGVyYXRvckluZGV4ID09IDAgPyB0YXJnZXQubmV4dFNpYmxpbmcgOlxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDEgPyB0YXJnZXQuZmlyc3RDaGlsZCA6XG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMiA/IHRhcmdldCA6XG4gICAgICAgICAgICAgICAgIG51bGxcblxuICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9ICQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBwYXJlbnQpXG5cbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBpZiAoY29weUJ5Q2xvbmUpIG5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHJldHVybiAkKG5vZGUpLnJlbW92ZSgpXG5cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldClcbiAgICAgICAgICBpZiAocGFyZW50SW5Eb2N1bWVudCkgdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZSAhPSBudWxsICYmIGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICAgICAoIWVsLnR5cGUgfHwgZWwudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpICYmICFlbC5zcmMpe1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWwub3duZXJEb2N1bWVudCA/IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3dcbiAgICAgICAgICAgICAgdGFyZ2V0WydldmFsJ10uY2FsbCh0YXJnZXQsIGVsLmlubmVySFRNTClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBhZnRlciAgICA9PiBpbnNlcnRBZnRlclxuICAgIC8vIHByZXBlbmQgID0+IHByZXBlbmRUb1xuICAgIC8vIGJlZm9yZSAgID0+IGluc2VydEJlZm9yZVxuICAgIC8vIGFwcGVuZCAgID0+IGFwcGVuZFRvXG4gICAgJC5mbltpbnNpZGUgPyBvcGVyYXRvcisnVG8nIDogJ2luc2VydCcrKG9wZXJhdG9ySW5kZXggPyAnQmVmb3JlJyA6ICdBZnRlcicpXSA9IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgJChodG1sKVtvcGVyYXRvcl0odGhpcylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxuXG4gIHplcHRvLloucHJvdG90eXBlID0gWi5wcm90b3R5cGUgPSAkLmZuXG5cbiAgLy8gRXhwb3J0IGludGVybmFsIEFQSSBmdW5jdGlvbnMgaW4gdGhlIGAkLnplcHRvYCBuYW1lc3BhY2VcbiAgemVwdG8udW5pcSA9IHVuaXFcbiAgemVwdG8uZGVzZXJpYWxpemVWYWx1ZSA9IGRlc2VyaWFsaXplVmFsdWVcbiAgJC56ZXB0byA9IHplcHRvXG5cbiAgcmV0dXJuICRcbn0pKClcblxud2luZG93LlplcHRvID0gWmVwdG9cbndpbmRvdy4kID09PSB1bmRlZmluZWQgJiYgKHdpbmRvdy4kID0gWmVwdG8pXG5cbjsoZnVuY3Rpb24oJCl7XG4gIHZhciBqc29ucElEID0gK25ldyBEYXRlKCksXG4gICAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgIGtleSxcbiAgICAgIG5hbWUsXG4gICAgICByc2NyaXB0ID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksXG4gICAgICBzY3JpcHRUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvamF2YXNjcmlwdC9pLFxuICAgICAgeG1sVHlwZVJFID0gL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcL3htbC9pLFxuICAgICAganNvblR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICBodG1sVHlwZSA9ICd0ZXh0L2h0bWwnLFxuICAgICAgYmxhbmtSRSA9IC9eXFxzKiQvLFxuICAgICAgb3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG5cbiAgb3JpZ2luQW5jaG9yLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gIC8vIHRyaWdnZXIgYSBjdXN0b20gZXZlbnQgYW5kIHJldHVybiBmYWxzZSBpZiBpdCB3YXMgY2FuY2VsbGVkXG4gIGZ1bmN0aW9uIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgdmFyIGV2ZW50ID0gJC5FdmVudChldmVudE5hbWUpXG4gICAgJChjb250ZXh0KS50cmlnZ2VyKGV2ZW50LCBkYXRhKVxuICAgIHJldHVybiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcbiAgfVxuXG4gIC8vIHRyaWdnZXIgYW4gQWpheCBcImdsb2JhbFwiIGV2ZW50XG4gIGZ1bmN0aW9uIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsIGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwpIHJldHVybiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQgfHwgZG9jdW1lbnQsIGV2ZW50TmFtZSwgZGF0YSlcbiAgfVxuXG4gIC8vIE51bWJlciBvZiBhY3RpdmUgQWpheCByZXF1ZXN0c1xuICAkLmFjdGl2ZSA9IDBcblxuICBmdW5jdGlvbiBhamF4U3RhcnQoc2V0dGluZ3MpIHtcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsICYmICQuYWN0aXZlKysgPT09IDApIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIG51bGwsICdhamF4U3RhcnQnKVxuICB9XG4gIGZ1bmN0aW9uIGFqYXhTdG9wKHNldHRpbmdzKSB7XG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiAhKC0tJC5hY3RpdmUpKSB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCAnYWpheFN0b3AnKVxuICB9XG5cbiAgLy8gdHJpZ2dlcnMgYW4gZXh0cmEgZ2xvYmFsIGV2ZW50IFwiYWpheEJlZm9yZVNlbmRcIiB0aGF0J3MgbGlrZSBcImFqYXhTZW5kXCIgYnV0IGNhbmNlbGFibGVcbiAgZnVuY3Rpb24gYWpheEJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykge1xuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxuICAgIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlIHx8XG4gICAgICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4QmVmb3JlU2VuZCcsIFt4aHIsIHNldHRpbmdzXSkgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheFNlbmQnLCBbeGhyLCBzZXR0aW5nc10pXG4gIH1cbiAgZnVuY3Rpb24gYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQsIHN0YXR1cyA9ICdzdWNjZXNzJ1xuICAgIHNldHRpbmdzLnN1Y2Nlc3MuY2FsbChjb250ZXh0LCBkYXRhLCBzdGF0dXMsIHhocilcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmVXaXRoKGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhocl0pXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTdWNjZXNzJywgW3hociwgc2V0dGluZ3MsIGRhdGFdKVxuICAgIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpXG4gIH1cbiAgLy8gdHlwZTogXCJ0aW1lb3V0XCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiLCBcInBhcnNlcmVycm9yXCJcbiAgZnVuY3Rpb24gYWpheEVycm9yKGVycm9yLCB0eXBlLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZCkge1xuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxuICAgIHNldHRpbmdzLmVycm9yLmNhbGwoY29udGV4dCwgeGhyLCB0eXBlLCBlcnJvcilcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlamVjdFdpdGgoY29udGV4dCwgW3hociwgdHlwZSwgZXJyb3JdKVxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4RXJyb3InLCBbeGhyLCBzZXR0aW5ncywgZXJyb3IgfHwgdHlwZV0pXG4gICAgYWpheENvbXBsZXRlKHR5cGUsIHhociwgc2V0dGluZ3MpXG4gIH1cbiAgLy8gc3RhdHVzOiBcInN1Y2Nlc3NcIiwgXCJub3Rtb2RpZmllZFwiLCBcImVycm9yXCIsIFwidGltZW91dFwiLCBcImFib3J0XCIsIFwicGFyc2VyZXJyb3JcIlxuICBmdW5jdGlvbiBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XG4gICAgc2V0dGluZ3MuY29tcGxldGUuY2FsbChjb250ZXh0LCB4aHIsIHN0YXR1cylcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheENvbXBsZXRlJywgW3hociwgc2V0dGluZ3NdKVxuICAgIGFqYXhTdG9wKHNldHRpbmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gYWpheERhdGFGaWx0ZXIoZGF0YSwgdHlwZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAoc2V0dGluZ3MuZGF0YUZpbHRlciA9PSBlbXB0eSkgcmV0dXJuIGRhdGFcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcbiAgICByZXR1cm4gc2V0dGluZ3MuZGF0YUZpbHRlci5jYWxsKGNvbnRleHQsIGRhdGEsIHR5cGUpXG4gIH1cblxuICAvLyBFbXB0eSBmdW5jdGlvbiwgdXNlZCBhcyBkZWZhdWx0IGNhbGxiYWNrXG4gIGZ1bmN0aW9uIGVtcHR5KCkge31cblxuICAkLmFqYXhKU09OUCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmVycmVkKXtcbiAgICBpZiAoISgndHlwZScgaW4gb3B0aW9ucykpIHJldHVybiAkLmFqYXgob3B0aW9ucylcblxuICAgIHZhciBfY2FsbGJhY2tOYW1lID0gb3B0aW9ucy5qc29ucENhbGxiYWNrLFxuICAgICAgY2FsbGJhY2tOYW1lID0gKCQuaXNGdW5jdGlvbihfY2FsbGJhY2tOYW1lKSA/XG4gICAgICAgIF9jYWxsYmFja05hbWUoKSA6IF9jYWxsYmFja05hbWUpIHx8ICgnWmVwdG8nICsgKGpzb25wSUQrKykpLFxuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICBvcmlnaW5hbENhbGxiYWNrID0gd2luZG93W2NhbGxiYWNrTmFtZV0sXG4gICAgICByZXNwb25zZURhdGEsXG4gICAgICBhYm9ydCA9IGZ1bmN0aW9uKGVycm9yVHlwZSkge1xuICAgICAgICAkKHNjcmlwdCkudHJpZ2dlckhhbmRsZXIoJ2Vycm9yJywgZXJyb3JUeXBlIHx8ICdhYm9ydCcpXG4gICAgICB9LFxuICAgICAgeGhyID0geyBhYm9ydDogYWJvcnQgfSwgYWJvcnRUaW1lb3V0XG5cbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnByb21pc2UoeGhyKVxuXG4gICAgJChzY3JpcHQpLm9uKCdsb2FkIGVycm9yJywgZnVuY3Rpb24oZSwgZXJyb3JUeXBlKXtcbiAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXG4gICAgICAkKHNjcmlwdCkub2ZmKCkucmVtb3ZlKClcblxuICAgICAgaWYgKGUudHlwZSA9PSAnZXJyb3InIHx8ICFyZXNwb25zZURhdGEpIHtcbiAgICAgICAgYWpheEVycm9yKG51bGwsIGVycm9yVHlwZSB8fCAnZXJyb3InLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWpheFN1Y2Nlc3MocmVzcG9uc2VEYXRhWzBdLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG9yaWdpbmFsQ2FsbGJhY2tcbiAgICAgIGlmIChyZXNwb25zZURhdGEgJiYgJC5pc0Z1bmN0aW9uKG9yaWdpbmFsQ2FsbGJhY2spKVxuICAgICAgICBvcmlnaW5hbENhbGxiYWNrKHJlc3BvbnNlRGF0YVswXSlcblxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHJlc3BvbnNlRGF0YSA9IHVuZGVmaW5lZFxuICAgIH0pXG5cbiAgICBpZiAoYWpheEJlZm9yZVNlbmQoeGhyLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIGFib3J0KCdhYm9ydCcpXG4gICAgICByZXR1cm4geGhyXG4gICAgfVxuXG4gICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbigpe1xuICAgICAgcmVzcG9uc2VEYXRhID0gYXJndW1lbnRzXG4gICAgfVxuXG4gICAgc2NyaXB0LnNyYyA9IG9wdGlvbnMudXJsLnJlcGxhY2UoL1xcPyguKyk9XFw/LywgJz8kMT0nICsgY2FsbGJhY2tOYW1lKVxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGFib3J0KCd0aW1lb3V0JylcbiAgICB9LCBvcHRpb25zLnRpbWVvdXQpXG5cbiAgICByZXR1cm4geGhyXG4gIH1cblxuICAkLmFqYXhTZXR0aW5ncyA9IHtcbiAgICAvLyBEZWZhdWx0IHR5cGUgb2YgcmVxdWVzdFxuICAgIHR5cGU6ICdHRVQnLFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgYmVmb3JlIHJlcXVlc3RcbiAgICBiZWZvcmVTZW5kOiBlbXB0eSxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXG4gICAgc3VjY2VzczogZW1wdHksXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCB0aGUgdGhlIHNlcnZlciBkcm9wcyBlcnJvclxuICAgIGVycm9yOiBlbXB0eSxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIG9uIHJlcXVlc3QgY29tcGxldGUgKGJvdGg6IGVycm9yIGFuZCBzdWNjZXNzKVxuICAgIGNvbXBsZXRlOiBlbXB0eSxcbiAgICAvLyBUaGUgY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrc1xuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgLy8gV2hldGhlciB0byB0cmlnZ2VyIFwiZ2xvYmFsXCIgQWpheCBldmVudHNcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgLy8gVHJhbnNwb3J0XG4gICAgeGhyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpXG4gICAgfSxcbiAgICAvLyBNSU1FIHR5cGVzIG1hcHBpbmdcbiAgICAvLyBJSVMgcmV0dXJucyBKYXZhc2NyaXB0IGFzIFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XCJcbiAgICBhY2NlcHRzOiB7XG4gICAgICBzY3JpcHQ6ICd0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCcsXG4gICAgICBqc29uOiAgIGpzb25UeXBlLFxuICAgICAgeG1sOiAgICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCcsXG4gICAgICBodG1sOiAgIGh0bWxUeXBlLFxuICAgICAgdGV4dDogICAndGV4dC9wbGFpbidcbiAgICB9LFxuICAgIC8vIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgdG8gYW5vdGhlciBkb21haW5cbiAgICBjcm9zc0RvbWFpbjogZmFsc2UsXG4gICAgLy8gRGVmYXVsdCB0aW1lb3V0XG4gICAgdGltZW91dDogMCxcbiAgICAvLyBXaGV0aGVyIGRhdGEgc2hvdWxkIGJlIHNlcmlhbGl6ZWQgdG8gc3RyaW5nXG4gICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgLy8gV2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYmUgYWxsb3dlZCB0byBjYWNoZSBHRVQgcmVzcG9uc2VzXG4gICAgY2FjaGU6IHRydWUsXG4gICAgLy9Vc2VkIHRvIGhhbmRsZSB0aGUgcmF3IHJlc3BvbnNlIGRhdGEgb2YgWE1MSHR0cFJlcXVlc3QuXG4gICAgLy9UaGlzIGlzIGEgcHJlLWZpbHRlcmluZyBmdW5jdGlvbiB0byBzYW5pdGl6ZSB0aGUgcmVzcG9uc2UuXG4gICAgLy9UaGUgc2FuaXRpemVkIHJlc3BvbnNlIHNob3VsZCBiZSByZXR1cm5lZFxuICAgIGRhdGFGaWx0ZXI6IGVtcHR5XG4gIH1cblxuICBmdW5jdGlvbiBtaW1lVG9EYXRhVHlwZShtaW1lKSB7XG4gICAgaWYgKG1pbWUpIG1pbWUgPSBtaW1lLnNwbGl0KCc7JywgMilbMF1cbiAgICByZXR1cm4gbWltZSAmJiAoIG1pbWUgPT0gaHRtbFR5cGUgPyAnaHRtbCcgOlxuICAgICAgbWltZSA9PSBqc29uVHlwZSA/ICdqc29uJyA6XG4gICAgICBzY3JpcHRUeXBlUkUudGVzdChtaW1lKSA/ICdzY3JpcHQnIDpcbiAgICAgIHhtbFR5cGVSRS50ZXN0KG1pbWUpICYmICd4bWwnICkgfHwgJ3RleHQnXG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRRdWVyeSh1cmwsIHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5ID09ICcnKSByZXR1cm4gdXJsXG4gICAgcmV0dXJuICh1cmwgKyAnJicgKyBxdWVyeSkucmVwbGFjZSgvWyY/XXsxLDJ9LywgJz8nKVxuICB9XG5cbiAgLy8gc2VyaWFsaXplIHBheWxvYWQgYW5kIGFwcGVuZCBpdCB0byB0aGUgVVJMIGZvciBHRVQgcmVxdWVzdHNcbiAgZnVuY3Rpb24gc2VyaWFsaXplRGF0YShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucHJvY2Vzc0RhdGEgJiYgb3B0aW9ucy5kYXRhICYmICQudHlwZShvcHRpb25zLmRhdGEpICE9IFwic3RyaW5nXCIpXG4gICAgICBvcHRpb25zLmRhdGEgPSAkLnBhcmFtKG9wdGlvbnMuZGF0YSwgb3B0aW9ucy50cmFkaXRpb25hbClcbiAgICBpZiAob3B0aW9ucy5kYXRhICYmICghb3B0aW9ucy50eXBlIHx8IG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpID09ICdHRVQnIHx8ICdqc29ucCcgPT0gb3B0aW9ucy5kYXRhVHlwZSkpXG4gICAgICBvcHRpb25zLnVybCA9IGFwcGVuZFF1ZXJ5KG9wdGlvbnMudXJsLCBvcHRpb25zLmRhdGEpLCBvcHRpb25zLmRhdGEgPSB1bmRlZmluZWRcbiAgfVxuXG4gICQuYWpheCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgZGVmZXJyZWQgPSAkLkRlZmVycmVkICYmICQuRGVmZXJyZWQoKSxcbiAgICAgICAgdXJsQW5jaG9yLCBoYXNoSW5kZXhcbiAgICBmb3IgKGtleSBpbiAkLmFqYXhTZXR0aW5ncykgaWYgKHNldHRpbmdzW2tleV0gPT09IHVuZGVmaW5lZCkgc2V0dGluZ3Nba2V5XSA9ICQuYWpheFNldHRpbmdzW2tleV1cblxuICAgIGFqYXhTdGFydChzZXR0aW5ncylcblxuICAgIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIHtcbiAgICAgIHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzZXR0aW5ncy51cmxcbiAgICAgIC8vIGNsZWFucyB1cCBVUkwgZm9yIC5ocmVmIChJRSBvbmx5KSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWRyb2JieS96ZXB0by9wdWxsLzEwNDlcbiAgICAgIHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWZcbiAgICAgIHNldHRpbmdzLmNyb3NzRG9tYWluID0gKG9yaWdpbkFuY2hvci5wcm90b2NvbCArICcvLycgKyBvcmlnaW5BbmNob3IuaG9zdCkgIT09ICh1cmxBbmNob3IucHJvdG9jb2wgKyAnLy8nICsgdXJsQW5jaG9yLmhvc3QpXG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncy51cmwpIHNldHRpbmdzLnVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpXG4gICAgaWYgKChoYXNoSW5kZXggPSBzZXR0aW5ncy51cmwuaW5kZXhPZignIycpKSA+IC0xKSBzZXR0aW5ncy51cmwgPSBzZXR0aW5ncy51cmwuc2xpY2UoMCwgaGFzaEluZGV4KVxuICAgIHNlcmlhbGl6ZURhdGEoc2V0dGluZ3MpXG5cbiAgICB2YXIgZGF0YVR5cGUgPSBzZXR0aW5ncy5kYXRhVHlwZSwgaGFzUGxhY2Vob2xkZXIgPSAvXFw/Lis9XFw/Ly50ZXN0KHNldHRpbmdzLnVybClcbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIGRhdGFUeXBlID0gJ2pzb25wJ1xuXG4gICAgaWYgKHNldHRpbmdzLmNhY2hlID09PSBmYWxzZSB8fCAoXG4gICAgICAgICAoIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gdHJ1ZSkgJiZcbiAgICAgICAgICgnc2NyaXB0JyA9PSBkYXRhVHlwZSB8fCAnanNvbnAnID09IGRhdGFUeXBlKVxuICAgICAgICApKVxuICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAnXz0nICsgRGF0ZS5ub3coKSlcblxuICAgIGlmICgnanNvbnAnID09IGRhdGFUeXBlKSB7XG4gICAgICBpZiAoIWhhc1BsYWNlaG9sZGVyKVxuICAgICAgICBzZXR0aW5ncy51cmwgPSBhcHBlbmRRdWVyeShzZXR0aW5ncy51cmwsXG4gICAgICAgICAgc2V0dGluZ3MuanNvbnAgPyAoc2V0dGluZ3MuanNvbnAgKyAnPT8nKSA6IHNldHRpbmdzLmpzb25wID09PSBmYWxzZSA/ICcnIDogJ2NhbGxiYWNrPT8nKVxuICAgICAgcmV0dXJuICQuYWpheEpTT05QKHNldHRpbmdzLCBkZWZlcnJlZClcbiAgICB9XG5cbiAgICB2YXIgbWltZSA9IHNldHRpbmdzLmFjY2VwdHNbZGF0YVR5cGVdLFxuICAgICAgICBoZWFkZXJzID0geyB9LFxuICAgICAgICBzZXRIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgeyBoZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBbbmFtZSwgdmFsdWVdIH0sXG4gICAgICAgIHByb3RvY29sID0gL14oW1xcdy1dKzopXFwvXFwvLy50ZXN0KHNldHRpbmdzLnVybCkgPyBSZWdFeHAuJDEgOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wsXG4gICAgICAgIHhociA9IHNldHRpbmdzLnhocigpLFxuICAgICAgICBuYXRpdmVTZXRIZWFkZXIgPSB4aHIuc2V0UmVxdWVzdEhlYWRlcixcbiAgICAgICAgYWJvcnRUaW1lb3V0XG5cbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnByb21pc2UoeGhyKVxuXG4gICAgaWYgKCFzZXR0aW5ncy5jcm9zc0RvbWFpbikgc2V0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0JylcbiAgICBzZXRIZWFkZXIoJ0FjY2VwdCcsIG1pbWUgfHwgJyovKicpXG4gICAgaWYgKG1pbWUgPSBzZXR0aW5ncy5taW1lVHlwZSB8fCBtaW1lKSB7XG4gICAgICBpZiAobWltZS5pbmRleE9mKCcsJykgPiAtMSkgbWltZSA9IG1pbWUuc3BsaXQoJywnLCAyKVswXVxuICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZSlcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8IChzZXR0aW5ncy5jb250ZW50VHlwZSAhPT0gZmFsc2UgJiYgc2V0dGluZ3MuZGF0YSAmJiBzZXR0aW5ncy50eXBlLnRvVXBwZXJDYXNlKCkgIT0gJ0dFVCcpKVxuICAgICAgc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBzZXR0aW5ncy5jb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcblxuICAgIGlmIChzZXR0aW5ncy5oZWFkZXJzKSBmb3IgKG5hbWUgaW4gc2V0dGluZ3MuaGVhZGVycykgc2V0SGVhZGVyKG5hbWUsIHNldHRpbmdzLmhlYWRlcnNbbmFtZV0pXG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIgPSBzZXRIZWFkZXJcblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5XG4gICAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yID0gZmFsc2VcbiAgICAgICAgaWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHByb3RvY29sID09ICdmaWxlOicpKSB7XG4gICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZSB8fCBtaW1lVG9EYXRhVHlwZShzZXR0aW5ncy5taW1lVHlwZSB8fCB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKVxuXG4gICAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT0gJ2FycmF5YnVmZmVyJyB8fCB4aHIucmVzcG9uc2VUeXBlID09ICdibG9iJylcbiAgICAgICAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlVGV4dFxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9nbG9iYWwtZXZhbC13aGF0LWFyZS10aGUtb3B0aW9ucy9cbiAgICAgICAgICAgICAgLy8gc2FuaXRpemUgcmVzcG9uc2UgYWNjb3JkaW5nbHkgaWYgZGF0YSBmaWx0ZXIgY2FsbGJhY2sgcHJvdmlkZWRcbiAgICAgICAgICAgICAgcmVzdWx0ID0gYWpheERhdGFGaWx0ZXIocmVzdWx0LCBkYXRhVHlwZSwgc2V0dGluZ3MpXG4gICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykgICAgKDEsZXZhbCkocmVzdWx0KVxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAneG1sJykgIHJlc3VsdCA9IHhoci5yZXNwb25zZVhNTFxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAnanNvbicpIHJlc3VsdCA9IGJsYW5rUkUudGVzdChyZXN1bHQpID8gbnVsbCA6ICQucGFyc2VKU09OKHJlc3VsdClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgZXJyb3IgPSBlIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gYWpheEVycm9yKGVycm9yLCAncGFyc2VyZXJyb3InLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhamF4U3VjY2VzcyhyZXN1bHQsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFqYXhFcnJvcih4aHIuc3RhdHVzVGV4dCB8fCBudWxsLCB4aHIuc3RhdHVzID8gJ2Vycm9yJyA6ICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFqYXhCZWZvcmVTZW5kKHhociwgc2V0dGluZ3MpID09PSBmYWxzZSkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICAgIGFqYXhFcnJvcihudWxsLCAnYWJvcnQnLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcbiAgICAgIHJldHVybiB4aHJcbiAgICB9XG5cbiAgICB2YXIgYXN5bmMgPSAnYXN5bmMnIGluIHNldHRpbmdzID8gc2V0dGluZ3MuYXN5bmMgOiB0cnVlXG4gICAgeGhyLm9wZW4oc2V0dGluZ3MudHlwZSwgc2V0dGluZ3MudXJsLCBhc3luYywgc2V0dGluZ3MudXNlcm5hbWUsIHNldHRpbmdzLnBhc3N3b3JkKVxuXG4gICAgaWYgKHNldHRpbmdzLnhockZpZWxkcykgZm9yIChuYW1lIGluIHNldHRpbmdzLnhockZpZWxkcykgeGhyW25hbWVdID0gc2V0dGluZ3MueGhyRmllbGRzW25hbWVdXG5cbiAgICBmb3IgKG5hbWUgaW4gaGVhZGVycykgbmF0aXZlU2V0SGVhZGVyLmFwcGx5KHhociwgaGVhZGVyc1tuYW1lXSlcblxuICAgIGlmIChzZXR0aW5ncy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlcbiAgICAgICAgeGhyLmFib3J0KClcbiAgICAgICAgYWpheEVycm9yKG51bGwsICd0aW1lb3V0JywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXG4gICAgICB9LCBzZXR0aW5ncy50aW1lb3V0KVxuXG4gICAgLy8gYXZvaWQgc2VuZGluZyBlbXB0eSBzdHJpbmcgKCMzMTkpXG4gICAgeGhyLnNlbmQoc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsKVxuICAgIHJldHVybiB4aHJcbiAgfVxuXG4gIC8vIGhhbmRsZSBvcHRpb25hbCBkYXRhL3N1Y2Nlc3MgYXJndW1lbnRzXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUpIHtcbiAgICBpZiAoJC5pc0Z1bmN0aW9uKGRhdGEpKSBkYXRhVHlwZSA9IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSBkYXRhLCBkYXRhID0gdW5kZWZpbmVkXG4gICAgaWYgKCEkLmlzRnVuY3Rpb24oc3VjY2VzcykpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IHVuZGVmaW5lZFxuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHVybFxuICAgICwgZGF0YTogZGF0YVxuICAgICwgc3VjY2Vzczogc3VjY2Vzc1xuICAgICwgZGF0YVR5cGU6IGRhdGFUeXBlXG4gICAgfVxuICB9XG5cbiAgJC5nZXQgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcbiAgICByZXR1cm4gJC5hamF4KHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXG4gIH1cblxuICAkLnBvc3QgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBvcHRpb25zLnR5cGUgPSAnUE9TVCdcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXG4gIH1cblxuICAkLmdldEpTT04gPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MgKi8pe1xuICAgIHZhciBvcHRpb25zID0gcGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAnanNvbidcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXG4gIH1cblxuICAkLmZuLmxvYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHN1Y2Nlc3Mpe1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVybiB0aGlzXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBwYXJ0cyA9IHVybC5zcGxpdCgvXFxzLyksIHNlbGVjdG9yLFxuICAgICAgICBvcHRpb25zID0gcGFyc2VBcmd1bWVudHModXJsLCBkYXRhLCBzdWNjZXNzKSxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zLnN1Y2Nlc3NcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkgb3B0aW9ucy51cmwgPSBwYXJ0c1swXSwgc2VsZWN0b3IgPSBwYXJ0c1sxXVxuICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgIHNlbGYuaHRtbChzZWxlY3RvciA/XG4gICAgICAgICQoJzxkaXY+JykuaHRtbChyZXNwb25zZS5yZXBsYWNlKHJzY3JpcHQsIFwiXCIpKS5maW5kKHNlbGVjdG9yKVxuICAgICAgICA6IHJlc3BvbnNlKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgIH1cbiAgICAkLmFqYXgob3B0aW9ucylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwsIHNjb3BlKXtcbiAgICB2YXIgdHlwZSwgYXJyYXkgPSAkLmlzQXJyYXkob2JqKSwgaGFzaCA9ICQuaXNQbGFpbk9iamVjdChvYmopXG4gICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdHlwZSA9ICQudHlwZSh2YWx1ZSlcbiAgICAgIGlmIChzY29wZSkga2V5ID0gdHJhZGl0aW9uYWwgPyBzY29wZSA6XG4gICAgICAgIHNjb3BlICsgJ1snICsgKGhhc2ggfHwgdHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdhcnJheScgPyBrZXkgOiAnJykgKyAnXSdcbiAgICAgIC8vIGhhbmRsZSBkYXRhIGluIHNlcmlhbGl6ZUFycmF5KCkgZm9ybWF0XG4gICAgICBpZiAoIXNjb3BlICYmIGFycmF5KSBwYXJhbXMuYWRkKHZhbHVlLm5hbWUsIHZhbHVlLnZhbHVlKVxuICAgICAgLy8gcmVjdXJzZSBpbnRvIG5lc3RlZCBvYmplY3RzXG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiYXJyYXlcIiB8fCAoIXRyYWRpdGlvbmFsICYmIHR5cGUgPT0gXCJvYmplY3RcIikpXG4gICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCB0cmFkaXRpb25hbCwga2V5KVxuICAgICAgZWxzZSBwYXJhbXMuYWRkKGtleSwgdmFsdWUpXG4gICAgfSlcbiAgfVxuXG4gICQucGFyYW0gPSBmdW5jdGlvbihvYmosIHRyYWRpdGlvbmFsKXtcbiAgICB2YXIgcGFyYW1zID0gW11cbiAgICBwYXJhbXMuYWRkID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCQuaXNGdW5jdGlvbih2YWx1ZSkpIHZhbHVlID0gdmFsdWUoKVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gXCJcIlxuICAgICAgdGhpcy5wdXNoKGVzY2FwZShrZXkpICsgJz0nICsgZXNjYXBlKHZhbHVlKSlcbiAgICB9XG4gICAgc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbClcbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKVxuICB9XG59KShaZXB0bylcblxuOyhmdW5jdGlvbigkKXtcbiAgLy8gQ3JlYXRlIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gYmUgZmlyZWQgaW4gYSBzZXF1ZW5jZSwgd2l0aCBjb25maWd1cmFibGUgYmVoYXZpb3VyXG4gIC8vIE9wdGlvbiBmbGFnczpcbiAgLy8gICAtIG9uY2U6IENhbGxiYWNrcyBmaXJlZCBhdCBtb3N0IG9uZSB0aW1lLlxuICAvLyAgIC0gbWVtb3J5OiBSZW1lbWJlciB0aGUgbW9zdCByZWNlbnQgY29udGV4dCBhbmQgYXJndW1lbnRzXG4gIC8vICAgLSBzdG9wT25GYWxzZTogQ2Vhc2UgaXRlcmF0aW5nIG92ZXIgY2FsbGJhY2sgbGlzdFxuICAvLyAgIC0gdW5pcXVlOiBQZXJtaXQgYWRkaW5nIGF0IG1vc3Qgb25lIGluc3RhbmNlIG9mIHRoZSBzYW1lIGNhbGxiYWNrXG4gICQuQ2FsbGJhY2tzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucylcblxuICAgIHZhciBtZW1vcnksIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcbiAgICAgICAgZmlyZWQsICAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuICAgICAgICBmaXJpbmcsIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgICAgZmlyaW5nU3RhcnQsIC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuICAgICAgICBmaXJpbmdMZW5ndGgsIC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuICAgICAgICBmaXJpbmdJbmRleCwgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcbiAgICAgICAgbGlzdCA9IFtdLCAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuICAgICAgICBzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sIC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcbiAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhXG4gICAgICAgICAgZmlyZWQgPSB0cnVlXG4gICAgICAgICAgZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwXG4gICAgICAgICAgZmlyaW5nU3RhcnQgPSAwXG4gICAgICAgICAgZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGhcbiAgICAgICAgICBmaXJpbmcgPSB0cnVlXG4gICAgICAgICAgZm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoIDsgKytmaXJpbmdJbmRleCApIHtcbiAgICAgICAgICAgIGlmIChsaXN0W2ZpcmluZ0luZGV4XS5hcHBseShkYXRhWzBdLCBkYXRhWzFdKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSkge1xuICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJpbmcgPSBmYWxzZVxuICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICBpZiAoc3RhY2spIHN0YWNrLmxlbmd0aCAmJiBmaXJlKHN0YWNrLnNoaWZ0KCkpXG4gICAgICAgICAgICBlbHNlIGlmIChtZW1vcnkpIGxpc3QubGVuZ3RoID0gMFxuICAgICAgICAgICAgZWxzZSBDYWxsYmFja3MuZGlzYWJsZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIENhbGxiYWNrcyA9IHtcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICQuZWFjaChhcmdzLCBmdW5jdGlvbihfLCBhcmcpe1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmlxdWUgfHwgIUNhbGxiYWNrcy5oYXMoYXJnKSkgbGlzdC5wdXNoKGFyZylcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZW9mIGFyZyAhPT0gJ3N0cmluZycpIGFkZChhcmcpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZChhcmd1bWVudHMpXG4gICAgICAgICAgICAgIGlmIChmaXJpbmcpIGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAgICAgICAgIGVsc2UgaWYgKG1lbW9yeSkge1xuICAgICAgICAgICAgICAgIGZpcmluZ1N0YXJ0ID0gc3RhcnRcbiAgICAgICAgICAgICAgICBmaXJlKG1lbW9yeSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAkLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihfLCBhcmcpe1xuICAgICAgICAgICAgICAgIHZhciBpbmRleFxuICAgICAgICAgICAgICAgIHdoaWxlICgoaW5kZXggPSAkLmluQXJyYXkoYXJnLCBsaXN0LCBpbmRleCkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgICBpZiAoZmlyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8PSBmaXJpbmdMZW5ndGgpIC0tZmlyaW5nTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8PSBmaXJpbmdJbmRleCkgLS1maXJpbmdJbmRleFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXM6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gISEobGlzdCAmJiAoZm4gPyAkLmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOiBsaXN0Lmxlbmd0aCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aCA9IDBcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhbGlzdFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdGFjayA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFtZW1vcnkpIENhbGxiYWNrcy5kaXNhYmxlKClcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICFzdGFja1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ICYmICghZmlyZWQgfHwgc3RhY2spKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdXG4gICAgICAgICAgICAgIGFyZ3MgPSBbY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3NdXG4gICAgICAgICAgICAgIGlmIChmaXJpbmcpIHN0YWNrLnB1c2goYXJncylcbiAgICAgICAgICAgICAgZWxzZSBmaXJlKGFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FsbGJhY2tzLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWZpcmVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICByZXR1cm4gQ2FsbGJhY2tzXG4gIH1cbn0pKFplcHRvKVxuXG47KGZ1bmN0aW9uKCQpe1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcblxuICBmdW5jdGlvbiBEZWZlcnJlZChmdW5jKSB7XG4gICAgdmFyIHR1cGxlcyA9IFtcbiAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcbiAgICAgICAgICBbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgJC5DYWxsYmFja3Moe29uY2U6MSwgbWVtb3J5OjF9KSwgXCJyZXNvbHZlZFwiIF0sXG4gICAgICAgICAgWyBcInJlamVjdFwiLCBcImZhaWxcIiwgJC5DYWxsYmFja3Moe29uY2U6MSwgbWVtb3J5OjF9KSwgXCJyZWplY3RlZFwiIF0sXG4gICAgICAgICAgWyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsICQuQ2FsbGJhY2tzKHttZW1vcnk6MX0pIF1cbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGUgPSBcInBlbmRpbmdcIixcbiAgICAgICAgcHJvbWlzZSA9IHtcbiAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24oLyogZm5Eb25lIFssIGZuRmFpbGVkIFssIGZuUHJvZ3Jlc3NdXSAqLykge1xuICAgICAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50c1xuICAgICAgICAgICAgcmV0dXJuIERlZmVycmVkKGZ1bmN0aW9uKGRlZmVyKXtcbiAgICAgICAgICAgICAgJC5lYWNoKHR1cGxlcywgZnVuY3Rpb24oaSwgdHVwbGUpe1xuICAgICAgICAgICAgICAgIHZhciBmbiA9ICQuaXNGdW5jdGlvbihmbnNbaV0pICYmIGZuc1tpXVxuICAgICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzFdXShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkICYmICQuaXNGdW5jdGlvbihyZXR1cm5lZC5wcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAuZG9uZShkZWZlci5yZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAgIC5mYWlsKGRlZmVyLnJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAucHJvZ3Jlc3MoZGVmZXIubm90aWZ5KVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzID09PSBwcm9taXNlID8gZGVmZXIucHJvbWlzZSgpIDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGZuID8gW3JldHVybmVkXSA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICBkZWZlclt0dXBsZVswXSArIFwiV2l0aFwiXShjb250ZXh0LCB2YWx1ZXMpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZm5zID0gbnVsbFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gJC5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmZXJyZWQgPSB7fVxuXG4gICAgJC5lYWNoKHR1cGxlcywgZnVuY3Rpb24oaSwgdHVwbGUpe1xuICAgICAgdmFyIGxpc3QgPSB0dXBsZVsyXSxcbiAgICAgICAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWzNdXG5cbiAgICAgIHByb21pc2VbdHVwbGVbMV1dID0gbGlzdC5hZGRcblxuICAgICAgaWYgKHN0YXRlU3RyaW5nKSB7XG4gICAgICAgIGxpc3QuYWRkKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0cmluZ1xuICAgICAgICB9LCB0dXBsZXNbaV4xXVsyXS5kaXNhYmxlLCB0dXBsZXNbMl1bMl0ubG9jaylcbiAgICAgIH1cblxuICAgICAgZGVmZXJyZWRbdHVwbGVbMF1dID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoXG4gICAgfSlcblxuICAgIHByb21pc2UucHJvbWlzZShkZWZlcnJlZClcbiAgICBpZiAoZnVuYykgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZClcbiAgICByZXR1cm4gZGVmZXJyZWRcbiAgfVxuXG4gICQud2hlbiA9IGZ1bmN0aW9uKHN1Yikge1xuICAgIHZhciByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBsZW4gPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJlbWFpbiA9IGxlbiAhPT0gMSB8fCAoc3ViICYmICQuaXNGdW5jdGlvbihzdWIucHJvbWlzZSkpID8gbGVuIDogMCxcbiAgICAgICAgZGVmZXJyZWQgPSByZW1haW4gPT09IDEgPyBzdWIgOiBEZWZlcnJlZCgpLFxuICAgICAgICBwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzLFxuICAgICAgICB1cGRhdGVGbiA9IGZ1bmN0aW9uKGksIGN0eCwgdmFsKXtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgICAgY3R4W2ldID0gdGhpc1xuICAgICAgICAgICAgdmFsW2ldID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKGFyZ3VtZW50cykgOiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gcHJvZ3Jlc3NWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChjdHgsIHZhbClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISgtLXJlbWFpbikpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY3R4LCB2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgcHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkobGVuKVxuICAgICAgcHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheShsZW4pXG4gICAgICByZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkobGVuKVxuICAgICAgZm9yICggOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVzW2ldICYmICQuaXNGdW5jdGlvbihyZXNvbHZlVmFsdWVzW2ldLnByb21pc2UpKSB7XG4gICAgICAgICAgcmVzb2x2ZVZhbHVlc1tpXS5wcm9taXNlKClcbiAgICAgICAgICAgIC5kb25lKHVwZGF0ZUZuKGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcykpXG4gICAgICAgICAgICAuZmFpbChkZWZlcnJlZC5yZWplY3QpXG4gICAgICAgICAgICAucHJvZ3Jlc3ModXBkYXRlRm4oaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC0tcmVtYWluXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZW1haW4pIGRlZmVycmVkLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcylcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpXG4gIH1cblxuICAkLkRlZmVycmVkID0gRGVmZXJyZWRcbn0pKFplcHRvKVxuXG47KGZ1bmN0aW9uKCQpe1xuICB2YXIgX3ppZCA9IDEsIHVuZGVmaW5lZCxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbixcbiAgICAgIGlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKXsgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ3N0cmluZycgfSxcbiAgICAgIGhhbmRsZXJzID0ge30sXG4gICAgICBzcGVjaWFsRXZlbnRzPXt9LFxuICAgICAgZm9jdXNpblN1cHBvcnRlZCA9ICdvbmZvY3VzaW4nIGluIHdpbmRvdyxcbiAgICAgIGZvY3VzID0geyBmb2N1czogJ2ZvY3VzaW4nLCBibHVyOiAnZm9jdXNvdXQnIH0sXG4gICAgICBob3ZlciA9IHsgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsIG1vdXNlbGVhdmU6ICdtb3VzZW91dCcgfVxuXG4gIHNwZWNpYWxFdmVudHMuY2xpY2sgPSBzcGVjaWFsRXZlbnRzLm1vdXNlZG93biA9IHNwZWNpYWxFdmVudHMubW91c2V1cCA9IHNwZWNpYWxFdmVudHMubW91c2Vtb3ZlID0gJ01vdXNlRXZlbnRzJ1xuXG4gIGZ1bmN0aW9uIHppZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuX3ppZCB8fCAoZWxlbWVudC5femlkID0gX3ppZCsrKVxuICB9XG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKSB7XG4gICAgZXZlbnQgPSBwYXJzZShldmVudClcbiAgICBpZiAoZXZlbnQubnMpIHZhciBtYXRjaGVyID0gbWF0Y2hlckZvcihldmVudC5ucylcbiAgICByZXR1cm4gKGhhbmRsZXJzW3ppZChlbGVtZW50KV0gfHwgW10pLmZpbHRlcihmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gaGFuZGxlclxuICAgICAgICAmJiAoIWV2ZW50LmUgIHx8IGhhbmRsZXIuZSA9PSBldmVudC5lKVxuICAgICAgICAmJiAoIWV2ZW50Lm5zIHx8IG1hdGNoZXIudGVzdChoYW5kbGVyLm5zKSlcbiAgICAgICAgJiYgKCFmbiAgICAgICB8fCB6aWQoaGFuZGxlci5mbikgPT09IHppZChmbikpXG4gICAgICAgICYmICghc2VsZWN0b3IgfHwgaGFuZGxlci5zZWwgPT0gc2VsZWN0b3IpXG4gICAgfSlcbiAgfVxuICBmdW5jdGlvbiBwYXJzZShldmVudCkge1xuICAgIHZhciBwYXJ0cyA9ICgnJyArIGV2ZW50KS5zcGxpdCgnLicpXG4gICAgcmV0dXJuIHtlOiBwYXJ0c1swXSwgbnM6IHBhcnRzLnNsaWNlKDEpLnNvcnQoKS5qb2luKCcgJyl9XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hlckZvcihucykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCApJyArIG5zLnJlcGxhY2UoJyAnLCAnIC4qID8nKSArICcoPzogfCQpJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlU2V0dGluZykge1xuICAgIHJldHVybiBoYW5kbGVyLmRlbCAmJlxuICAgICAgKCFmb2N1c2luU3VwcG9ydGVkICYmIChoYW5kbGVyLmUgaW4gZm9jdXMpKSB8fFxuICAgICAgISFjYXB0dXJlU2V0dGluZ1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhbEV2ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gaG92ZXJbdHlwZV0gfHwgKGZvY3VzaW5TdXBwb3J0ZWQgJiYgZm9jdXNbdHlwZV0pIHx8IHR5cGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZChlbGVtZW50LCBldmVudHMsIGZuLCBkYXRhLCBzZWxlY3RvciwgZGVsZWdhdG9yLCBjYXB0dXJlKXtcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudCksIHNldCA9IChoYW5kbGVyc1tpZF0gfHwgKGhhbmRsZXJzW2lkXSA9IFtdKSlcbiAgICBldmVudHMuc3BsaXQoL1xccy8pLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYgKGV2ZW50ID09ICdyZWFkeScpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShmbilcbiAgICAgIHZhciBoYW5kbGVyICAgPSBwYXJzZShldmVudClcbiAgICAgIGhhbmRsZXIuZm4gICAgPSBmblxuICAgICAgaGFuZGxlci5zZWwgICA9IHNlbGVjdG9yXG4gICAgICAvLyBlbXVsYXRlIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmVcbiAgICAgIGlmIChoYW5kbGVyLmUgaW4gaG92ZXIpIGZuID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0XG4gICAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhJC5jb250YWlucyh0aGlzLCByZWxhdGVkKSkpXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgaGFuZGxlci5kZWwgICA9IGRlbGVnYXRvclxuICAgICAgdmFyIGNhbGxiYWNrICA9IGRlbGVnYXRvciB8fCBmblxuICAgICAgaGFuZGxlci5wcm94eSA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBlID0gY29tcGF0aWJsZShlKVxuICAgICAgICBpZiAoZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm5cbiAgICAgICAgZS5kYXRhID0gZGF0YVxuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkoZWxlbWVudCwgZS5fYXJncyA9PSB1bmRlZmluZWQgPyBbZV0gOiBbZV0uY29uY2F0KGUuX2FyZ3MpKVxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuaSA9IHNldC5sZW5ndGhcbiAgICAgIHNldC5wdXNoKGhhbmRsZXIpXG4gICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihyZWFsRXZlbnQoaGFuZGxlci5lKSwgaGFuZGxlci5wcm94eSwgZXZlbnRDYXB0dXJlKGhhbmRsZXIsIGNhcHR1cmUpKVxuICAgIH0pXG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQsIGV2ZW50cywgZm4sIHNlbGVjdG9yLCBjYXB0dXJlKXtcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudClcbiAgICA7KGV2ZW50cyB8fCAnJykuc3BsaXQoL1xccy8pLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LCBmbiwgc2VsZWN0b3IpLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcil7XG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tpZF1baGFuZGxlci5pXVxuICAgICAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIocmVhbEV2ZW50KGhhbmRsZXIuZSksIGhhbmRsZXIucHJveHksIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gICQuZXZlbnQgPSB7IGFkZDogYWRkLCByZW1vdmU6IHJlbW92ZSB9XG5cbiAgJC5wcm94eSA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSAoMiBpbiBhcmd1bWVudHMpICYmIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKVxuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgdmFyIHByb3h5Rm4gPSBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpIH1cbiAgICAgIHByb3h5Rm4uX3ppZCA9IHppZChmbilcbiAgICAgIHJldHVybiBwcm94eUZuXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb250ZXh0KSkge1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KGZuW2NvbnRleHRdLCBmbilcbiAgICAgICAgcmV0dXJuICQucHJveHkuYXBwbHkobnVsbCwgYXJncylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkLnByb3h5KGZuW2NvbnRleHRdLCBmbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGVkIGZ1bmN0aW9uXCIpXG4gICAgfVxuICB9XG5cbiAgJC5mbi5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgZGF0YSwgY2FsbGJhY2spXG4gIH1cbiAgJC5mbi51bmJpbmQgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgY2FsbGJhY2spXG4gIH1cbiAgJC5mbi5vbmUgPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrLCAxKVxuICB9XG5cbiAgdmFyIHJldHVyblRydWUgPSBmdW5jdGlvbigpe3JldHVybiB0cnVlfSxcbiAgICAgIHJldHVybkZhbHNlID0gZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2V9LFxuICAgICAgaWdub3JlUHJvcGVydGllcyA9IC9eKFtBLVpdfHJldHVyblZhbHVlJHxsYXllcltYWV0kfHdlYmtpdE1vdmVtZW50W1hZXSQpLyxcbiAgICAgIGV2ZW50TWV0aG9kcyA9IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICdpc0RlZmF1bHRQcmV2ZW50ZWQnLFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ICdpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCcsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogJ2lzUHJvcGFnYXRpb25TdG9wcGVkJ1xuICAgICAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhdGlibGUoZXZlbnQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgfHwgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgc291cmNlIHx8IChzb3VyY2UgPSBldmVudClcblxuICAgICAgJC5lYWNoKGV2ZW50TWV0aG9kcywgZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2VNZXRob2QgPSBzb3VyY2VbbmFtZV1cbiAgICAgICAgZXZlbnRbbmFtZV0gPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHRoaXNbcHJlZGljYXRlXSA9IHJldHVyblRydWVcbiAgICAgICAgICByZXR1cm4gc291cmNlTWV0aG9kICYmIHNvdXJjZU1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgICBldmVudFtwcmVkaWNhdGVdID0gcmV0dXJuRmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIGV2ZW50LnRpbWVTdGFtcCB8fCAoZXZlbnQudGltZVN0YW1wID0gRGF0ZS5ub3coKSlcblxuICAgICAgaWYgKHNvdXJjZS5kZWZhdWx0UHJldmVudGVkICE9PSB1bmRlZmluZWQgPyBzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCA6XG4gICAgICAgICAgJ3JldHVyblZhbHVlJyBpbiBzb3VyY2UgPyBzb3VyY2UucmV0dXJuVmFsdWUgPT09IGZhbHNlIDpcbiAgICAgICAgICBzb3VyY2UuZ2V0UHJldmVudERlZmF1bHQgJiYgc291cmNlLmdldFByZXZlbnREZWZhdWx0KCkpXG4gICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWVcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcm94eShldmVudCkge1xuICAgIHZhciBrZXksIHByb3h5ID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9XG4gICAgZm9yIChrZXkgaW4gZXZlbnQpXG4gICAgICBpZiAoIWlnbm9yZVByb3BlcnRpZXMudGVzdChrZXkpICYmIGV2ZW50W2tleV0gIT09IHVuZGVmaW5lZCkgcHJveHlba2V5XSA9IGV2ZW50W2tleV1cblxuICAgIHJldHVybiBjb21wYXRpYmxlKHByb3h5LCBldmVudClcbiAgfVxuXG4gICQuZm4uZGVsZWdhdGUgPSBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxuICB9XG4gICQuZm4udW5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxuICB9XG5cbiAgJC5mbi5saXZlID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICAkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gICQuZm4uZGllID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICAkKGRvY3VtZW50LmJvZHkpLnVuZGVsZWdhdGUodGhpcy5zZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkLmZuLm9uID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgb25lKXtcbiAgICB2YXIgYXV0b1JlbW92ZSwgZGVsZWdhdG9yLCAkdGhpcyA9IHRoaXNcbiAgICBpZiAoZXZlbnQgJiYgIWlzU3RyaW5nKGV2ZW50KSkge1xuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XG4gICAgICAgICR0aGlzLm9uKHR5cGUsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKVxuICAgICAgfSlcbiAgICAgIHJldHVybiAkdGhpc1xuICAgIH1cblxuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjayAhPT0gZmFsc2UpXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBmYWxzZSlcbiAgICAgIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKGNhbGxiYWNrID09PSBmYWxzZSkgY2FsbGJhY2sgPSByZXR1cm5GYWxzZVxuXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oXywgZWxlbWVudCl7XG4gICAgICBpZiAob25lKSBhdXRvUmVtb3ZlID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHJlbW92ZShlbGVtZW50LCBlLnR5cGUsIGNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IpIGRlbGVnYXRvciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgZXZ0LCBtYXRjaCA9ICQoZS50YXJnZXQpLmNsb3Nlc3Qoc2VsZWN0b3IsIGVsZW1lbnQpLmdldCgwKVxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2ggIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBldnQgPSAkLmV4dGVuZChjcmVhdGVQcm94eShlKSwge2N1cnJlbnRUYXJnZXQ6IG1hdGNoLCBsaXZlRmlyZWQ6IGVsZW1lbnR9KVxuICAgICAgICAgIHJldHVybiAoYXV0b1JlbW92ZSB8fCBjYWxsYmFjaykuYXBwbHkobWF0Y2gsIFtldnRdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZChlbGVtZW50LCBldmVudCwgY2FsbGJhY2ssIGRhdGEsIHNlbGVjdG9yLCBkZWxlZ2F0b3IgfHwgYXV0b1JlbW92ZSlcbiAgICB9KVxuICB9XG4gICQuZm4ub2ZmID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjayl7XG4gICAgdmFyICR0aGlzID0gdGhpc1xuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XG4gICAgICAkLmVhY2goZXZlbnQsIGZ1bmN0aW9uKHR5cGUsIGZuKXtcbiAgICAgICAgJHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCBmbilcbiAgICAgIH0pXG4gICAgICByZXR1cm4gJHRoaXNcbiAgICB9XG5cbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxuICAgICAgY2FsbGJhY2sgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcblxuICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIGNhbGxiYWNrID0gcmV0dXJuRmFsc2VcblxuICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICByZW1vdmUodGhpcywgZXZlbnQsIGNhbGxiYWNrLCBzZWxlY3RvcilcbiAgICB9KVxuICB9XG5cbiAgJC5mbi50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgIGV2ZW50ID0gKGlzU3RyaW5nKGV2ZW50KSB8fCAkLmlzUGxhaW5PYmplY3QoZXZlbnQpKSA/ICQuRXZlbnQoZXZlbnQpIDogY29tcGF0aWJsZShldmVudClcbiAgICBldmVudC5fYXJncyA9IGFyZ3NcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBoYW5kbGUgZm9jdXMoKSwgYmx1cigpIGJ5IGNhbGxpbmcgdGhlbSBkaXJlY3RseVxuICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gZm9jdXMgJiYgdHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gXCJmdW5jdGlvblwiKSB0aGlzW2V2ZW50LnR5cGVdKClcbiAgICAgIC8vIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG1pZ2h0IG5vdCBiZSBET00gZWxlbWVudHNcbiAgICAgIGVsc2UgaWYgKCdkaXNwYXRjaEV2ZW50JyBpbiB0aGlzKSB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICBlbHNlICQodGhpcykudHJpZ2dlckhhbmRsZXIoZXZlbnQsIGFyZ3MpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHRyaWdnZXJzIGV2ZW50IGhhbmRsZXJzIG9uIGN1cnJlbnQgZWxlbWVudCBqdXN0IGFzIGlmIGFuIGV2ZW50IG9jY3VycmVkLFxuICAvLyBkb2Vzbid0IHRyaWdnZXIgYW4gYWN0dWFsIGV2ZW50LCBkb2Vzbid0IGJ1YmJsZVxuICAkLmZuLnRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgIHZhciBlLCByZXN1bHRcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICBlID0gY3JlYXRlUHJveHkoaXNTdHJpbmcoZXZlbnQpID8gJC5FdmVudChldmVudCkgOiBldmVudClcbiAgICAgIGUuX2FyZ3MgPSBhcmdzXG4gICAgICBlLnRhcmdldCA9IGVsZW1lbnRcbiAgICAgICQuZWFjaChmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQudHlwZSB8fCBldmVudCksIGZ1bmN0aW9uKGksIGhhbmRsZXIpe1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyLnByb3h5KGUpXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVybiBmYWxzZVxuICAgICAgfSlcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIHNob3J0Y3V0IG1ldGhvZHMgZm9yIGAuYmluZChldmVudCwgZm4pYCBmb3IgZWFjaCBldmVudCB0eXBlXG4gIDsoJ2ZvY3VzaW4gZm9jdXNvdXQgZm9jdXMgYmx1ciBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrICcrXG4gICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSAnK1xuICAnY2hhbmdlIHNlbGVjdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yJykuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgJC5mbltldmVudF0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuICgwIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmJpbmQoZXZlbnQsIGNhbGxiYWNrKSA6XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudClcbiAgICB9XG4gIH0pXG5cbiAgJC5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzKSB7XG4gICAgaWYgKCFpc1N0cmluZyh0eXBlKSkgcHJvcHMgPSB0eXBlLCB0eXBlID0gcHJvcHMudHlwZVxuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KHNwZWNpYWxFdmVudHNbdHlwZV0gfHwgJ0V2ZW50cycpLCBidWJibGVzID0gdHJ1ZVxuICAgIGlmIChwcm9wcykgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykgKG5hbWUgPT0gJ2J1YmJsZXMnKSA/IChidWJibGVzID0gISFwcm9wc1tuYW1lXSkgOiAoZXZlbnRbbmFtZV0gPSBwcm9wc1tuYW1lXSlcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgYnViYmxlcywgdHJ1ZSlcbiAgICByZXR1cm4gY29tcGF0aWJsZShldmVudClcbiAgfVxuXG59KShaZXB0bylcblxuOyhmdW5jdGlvbigpe1xuICAvLyBnZXRDb21wdXRlZFN0eWxlIHNob3VsZG4ndCBmcmVhayBvdXQgd2hlbiBjYWxsZWRcbiAgLy8gd2l0aG91dCBhIHZhbGlkIGVsZW1lbnQgYXMgYXJndW1lbnRcbiAgdHJ5IHtcbiAgICBnZXRDb21wdXRlZFN0eWxlKHVuZGVmaW5lZClcbiAgfSBjYXRjaChlKSB7XG4gICAgdmFyIG5hdGl2ZUdldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlXG4gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBwc2V1ZG9FbGVtZW50KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVHZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pKClcblxuOyhmdW5jdGlvbigkKXtcbiAgdmFyIHplcHRvID0gJC56ZXB0bywgb2xkUXNhID0gemVwdG8ucXNhLCBvbGRNYXRjaGVzID0gemVwdG8ubWF0Y2hlc1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoZWxlbSl7XG4gICAgZWxlbSA9ICQoZWxlbSlcbiAgICByZXR1cm4gISEoZWxlbS53aWR0aCgpIHx8IGVsZW0uaGVpZ2h0KCkpICYmIGVsZW0uY3NzKFwiZGlzcGxheVwiKSAhPT0gXCJub25lXCJcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgYSBzdWJzZXQgZnJvbTpcbiAgLy8gaHR0cDovL2FwaS5qcXVlcnkuY29tL2NhdGVnb3J5L3NlbGVjdG9ycy9qcXVlcnktc2VsZWN0b3ItZXh0ZW5zaW9ucy9cbiAgLy9cbiAgLy8gRWFjaCBmaWx0ZXIgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGN1cnJlbnQgaW5kZXgsIGFsbCBub2RlcyBpbiB0aGVcbiAgLy8gY29uc2lkZXJlZCBzZXQsIGFuZCBhIHZhbHVlIGlmIHRoZXJlIHdlcmUgcGFyZW50aGVzZXMuIFRoZSB2YWx1ZVxuICAvLyBvZiBgdGhpc2AgaXMgdGhlIG5vZGUgY3VycmVudGx5IGJlaW5nIGNvbnNpZGVyZWQuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAvLyByZXN1bHRpbmcgbm9kZShzKSwgbnVsbCwgb3IgdW5kZWZpbmVkLlxuICAvL1xuICAvLyBDb21wbGV4IHNlbGVjdG9ycyBhcmUgbm90IHN1cHBvcnRlZDpcbiAgLy8gICBsaTpoYXMobGFiZWw6Y29udGFpbnMoXCJmb29cIikpICsgbGk6aGFzKGxhYmVsOmNvbnRhaW5zKFwiYmFyXCIpKVxuICAvLyAgIHVsLmlubmVyOmZpcnN0ID4gbGlcbiAgdmFyIGZpbHRlcnMgPSAkLmV4cHJbJzonXSA9IHtcbiAgICB2aXNpYmxlOiAgZnVuY3Rpb24oKXsgaWYgKHZpc2libGUodGhpcykpIHJldHVybiB0aGlzIH0sXG4gICAgaGlkZGVuOiAgIGZ1bmN0aW9uKCl7IGlmICghdmlzaWJsZSh0aGlzKSkgcmV0dXJuIHRoaXMgfSxcbiAgICBzZWxlY3RlZDogZnVuY3Rpb24oKXsgaWYgKHRoaXMuc2VsZWN0ZWQpIHJldHVybiB0aGlzIH0sXG4gICAgY2hlY2tlZDogIGZ1bmN0aW9uKCl7IGlmICh0aGlzLmNoZWNrZWQpIHJldHVybiB0aGlzIH0sXG4gICAgcGFyZW50OiAgIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnBhcmVudE5vZGUgfSxcbiAgICBmaXJzdDogICAgZnVuY3Rpb24oaWR4KXsgaWYgKGlkeCA9PT0gMCkgcmV0dXJuIHRoaXMgfSxcbiAgICBsYXN0OiAgICAgZnVuY3Rpb24oaWR4LCBub2Rlcyl7IGlmIChpZHggPT09IG5vZGVzLmxlbmd0aCAtIDEpIHJldHVybiB0aGlzIH0sXG4gICAgZXE6ICAgICAgIGZ1bmN0aW9uKGlkeCwgXywgdmFsdWUpeyBpZiAoaWR4ID09PSB2YWx1ZSkgcmV0dXJuIHRoaXMgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24oaWR4LCBfLCB0ZXh0KXsgaWYgKCQodGhpcykudGV4dCgpLmluZGV4T2YodGV4dCkgPiAtMSkgcmV0dXJuIHRoaXMgfSxcbiAgICBoYXM6ICAgICAgZnVuY3Rpb24oaWR4LCBfLCBzZWwpeyBpZiAoemVwdG8ucXNhKHRoaXMsIHNlbCkubGVuZ3RoKSByZXR1cm4gdGhpcyB9XG4gIH1cblxuICB2YXIgZmlsdGVyUmUgPSBuZXcgUmVnRXhwKCcoLiopOihcXFxcdyspKD86XFxcXCgoW14pXSspXFxcXCkpPyRcXFxccyonKSxcbiAgICAgIGNoaWxkUmUgID0gL15cXHMqPi8sXG4gICAgICBjbGFzc1RhZyA9ICdaZXB0bycgKyAoK25ldyBEYXRlKCkpXG5cbiAgZnVuY3Rpb24gcHJvY2VzcyhzZWwsIGZuKSB7XG4gICAgLy8gcXVvdGUgdGhlIGhhc2ggaW4gYGFbaHJlZl49I11gIGV4cHJlc3Npb25cbiAgICBzZWwgPSBzZWwucmVwbGFjZSgvPSNcXF0vZywgJz1cIiNcIl0nKVxuICAgIHZhciBmaWx0ZXIsIGFyZywgbWF0Y2ggPSBmaWx0ZXJSZS5leGVjKHNlbClcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMl0gaW4gZmlsdGVycykge1xuICAgICAgZmlsdGVyID0gZmlsdGVyc1ttYXRjaFsyXV0sIGFyZyA9IG1hdGNoWzNdXG4gICAgICBzZWwgPSBtYXRjaFsxXVxuICAgICAgaWYgKGFyZykge1xuICAgICAgICB2YXIgbnVtID0gTnVtYmVyKGFyZylcbiAgICAgICAgaWYgKGlzTmFOKG51bSkpIGFyZyA9IGFyZy5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csICcnKVxuICAgICAgICBlbHNlIGFyZyA9IG51bVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4oc2VsLCBmaWx0ZXIsIGFyZylcbiAgfVxuXG4gIHplcHRvLnFzYSA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHByb2Nlc3Moc2VsZWN0b3IsIGZ1bmN0aW9uKHNlbCwgZmlsdGVyLCBhcmcpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRhZ2dlZFBhcmVudFxuICAgICAgICBpZiAoIXNlbCAmJiBmaWx0ZXIpIHNlbCA9ICcqJ1xuICAgICAgICBlbHNlIGlmIChjaGlsZFJlLnRlc3Qoc2VsKSlcbiAgICAgICAgICAvLyBzdXBwb3J0IFwiPiAqXCIgY2hpbGQgcXVlcmllcyBieSB0YWdnaW5nIHRoZSBwYXJlbnQgbm9kZSB3aXRoIGFcbiAgICAgICAgICAvLyB1bmlxdWUgY2xhc3MgYW5kIHByZXBlbmRpbmcgdGhhdCBjbGFzc25hbWUgb250byB0aGUgc2VsZWN0b3JcbiAgICAgICAgICB0YWdnZWRQYXJlbnQgPSAkKG5vZGUpLmFkZENsYXNzKGNsYXNzVGFnKSwgc2VsID0gJy4nK2NsYXNzVGFnKycgJytzZWxcblxuICAgICAgICB2YXIgbm9kZXMgPSBvbGRRc2Eobm9kZSwgc2VsKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIHBlcmZvcm1pbmcgc2VsZWN0b3I6ICVvJywgc2VsZWN0b3IpXG4gICAgICAgIHRocm93IGVcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0YWdnZWRQYXJlbnQpIHRhZ2dlZFBhcmVudC5yZW1vdmVDbGFzcyhjbGFzc1RhZylcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZmlsdGVyID8gbm9kZXMgOlxuICAgICAgICB6ZXB0by51bmlxKCQubWFwKG5vZGVzLCBmdW5jdGlvbihuLCBpKXsgcmV0dXJuIGZpbHRlci5jYWxsKG4sIGksIG5vZGVzLCBhcmcpIH0pKVxuICAgIH0pXG4gIH1cblxuICB6ZXB0by5tYXRjaGVzID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3Ipe1xuICAgIHJldHVybiBwcm9jZXNzKHNlbGVjdG9yLCBmdW5jdGlvbihzZWwsIGZpbHRlciwgYXJnKXtcbiAgICAgIHJldHVybiAoIXNlbCB8fCBvbGRNYXRjaGVzKG5vZGUsIHNlbCkpICYmXG4gICAgICAgICghZmlsdGVyIHx8IGZpbHRlci5jYWxsKG5vZGUsIG51bGwsIGFyZykgPT09IG5vZGUpXG4gICAgfSlcbiAgfVxufSkoWmVwdG8pXG5tb2R1bGUuZXhwb3J0cyA9IFplcHRvXG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZyb207XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5rZXlzO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgaXNFbnVtLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkR09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHsgJEdPUFMuZigxKTsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNvbnRhaW5lcltkYXRhLWNvbnRhaW5lcl0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC13aWR0aDogMTAwJTsgfVxcbiAgLmNvbnRhaW5lcltkYXRhLWNvbnRhaW5lcl0gLmNocm9tZWxlc3Mge1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7IH1cXG5cXG5bZGF0YS1wbGF5ZXJdOm5vdCgubm9jdXJzb3IpIC5jb250YWluZXJbZGF0YS1jb250YWluZXJdOm5vdCguY2hyb21lbGVzcykucG9pbnRlci1lbmFibGVkIHtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiW2RhdGEtcGxheWVyXSB7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1vLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlcjogMDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1zaXplOiAxMDAlO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJSb2JvdG9cXFwiLCBcXFwiT3BlbiBTYW5zXFxcIiwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICB0ZXh0LXNoYWRvdzogMCAwIDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuICBbZGF0YS1wbGF5ZXJdIGRpdiwgW2RhdGEtcGxheWVyXSBzcGFuLCBbZGF0YS1wbGF5ZXJdIGFwcGxldCwgW2RhdGEtcGxheWVyXSBvYmplY3QsIFtkYXRhLXBsYXllcl0gaWZyYW1lLFxcbiAgW2RhdGEtcGxheWVyXSBoMSwgW2RhdGEtcGxheWVyXSBoMiwgW2RhdGEtcGxheWVyXSBoMywgW2RhdGEtcGxheWVyXSBoNCwgW2RhdGEtcGxheWVyXSBoNSwgW2RhdGEtcGxheWVyXSBoNiwgW2RhdGEtcGxheWVyXSBwLCBbZGF0YS1wbGF5ZXJdIGJsb2NrcXVvdGUsIFtkYXRhLXBsYXllcl0gcHJlLFxcbiAgW2RhdGEtcGxheWVyXSBhLCBbZGF0YS1wbGF5ZXJdIGFiYnIsIFtkYXRhLXBsYXllcl0gYWNyb255bSwgW2RhdGEtcGxheWVyXSBhZGRyZXNzLCBbZGF0YS1wbGF5ZXJdIGJpZywgW2RhdGEtcGxheWVyXSBjaXRlLCBbZGF0YS1wbGF5ZXJdIGNvZGUsXFxuICBbZGF0YS1wbGF5ZXJdIGRlbCwgW2RhdGEtcGxheWVyXSBkZm4sIFtkYXRhLXBsYXllcl0gZW0sIFtkYXRhLXBsYXllcl0gaW1nLCBbZGF0YS1wbGF5ZXJdIGlucywgW2RhdGEtcGxheWVyXSBrYmQsIFtkYXRhLXBsYXllcl0gcSwgW2RhdGEtcGxheWVyXSBzLCBbZGF0YS1wbGF5ZXJdIHNhbXAsXFxuICBbZGF0YS1wbGF5ZXJdIHNtYWxsLCBbZGF0YS1wbGF5ZXJdIHN0cmlrZSwgW2RhdGEtcGxheWVyXSBzdHJvbmcsIFtkYXRhLXBsYXllcl0gc3ViLCBbZGF0YS1wbGF5ZXJdIHN1cCwgW2RhdGEtcGxheWVyXSB0dCwgW2RhdGEtcGxheWVyXSB2YXIsXFxuICBbZGF0YS1wbGF5ZXJdIGIsIFtkYXRhLXBsYXllcl0gdSwgW2RhdGEtcGxheWVyXSBpLCBbZGF0YS1wbGF5ZXJdIGNlbnRlcixcXG4gIFtkYXRhLXBsYXllcl0gZGwsIFtkYXRhLXBsYXllcl0gZHQsIFtkYXRhLXBsYXllcl0gZGQsIFtkYXRhLXBsYXllcl0gb2wsIFtkYXRhLXBsYXllcl0gdWwsIFtkYXRhLXBsYXllcl0gbGksXFxuICBbZGF0YS1wbGF5ZXJdIGZpZWxkc2V0LCBbZGF0YS1wbGF5ZXJdIGZvcm0sIFtkYXRhLXBsYXllcl0gbGFiZWwsIFtkYXRhLXBsYXllcl0gbGVnZW5kLFxcbiAgW2RhdGEtcGxheWVyXSB0YWJsZSwgW2RhdGEtcGxheWVyXSBjYXB0aW9uLCBbZGF0YS1wbGF5ZXJdIHRib2R5LCBbZGF0YS1wbGF5ZXJdIHRmb290LCBbZGF0YS1wbGF5ZXJdIHRoZWFkLCBbZGF0YS1wbGF5ZXJdIHRyLCBbZGF0YS1wbGF5ZXJdIHRoLCBbZGF0YS1wbGF5ZXJdIHRkLFxcbiAgW2RhdGEtcGxheWVyXSBhcnRpY2xlLCBbZGF0YS1wbGF5ZXJdIGFzaWRlLCBbZGF0YS1wbGF5ZXJdIGNhbnZhcywgW2RhdGEtcGxheWVyXSBkZXRhaWxzLCBbZGF0YS1wbGF5ZXJdIGVtYmVkLFxcbiAgW2RhdGEtcGxheWVyXSBmaWd1cmUsIFtkYXRhLXBsYXllcl0gZmlnY2FwdGlvbiwgW2RhdGEtcGxheWVyXSBmb290ZXIsIFtkYXRhLXBsYXllcl0gaGVhZGVyLCBbZGF0YS1wbGF5ZXJdIGhncm91cCxcXG4gIFtkYXRhLXBsYXllcl0gbWVudSwgW2RhdGEtcGxheWVyXSBuYXYsIFtkYXRhLXBsYXllcl0gb3V0cHV0LCBbZGF0YS1wbGF5ZXJdIHJ1YnksIFtkYXRhLXBsYXllcl0gc2VjdGlvbiwgW2RhdGEtcGxheWVyXSBzdW1tYXJ5LFxcbiAgW2RhdGEtcGxheWVyXSB0aW1lLCBbZGF0YS1wbGF5ZXJdIG1hcmssIFtkYXRhLXBsYXllcl0gYXVkaW8sIFtkYXRhLXBsYXllcl0gdmlkZW8ge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgZm9udDogaW5oZXJpdDtcXG4gICAgZm9udC1zaXplOiAxMDAlO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cXG4gIFtkYXRhLXBsYXllcl0gdGFibGUge1xcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICBib3JkZXItc3BhY2luZzogMDsgfVxcbiAgW2RhdGEtcGxheWVyXSBjYXB0aW9uLCBbZGF0YS1wbGF5ZXJdIHRoLCBbZGF0YS1wbGF5ZXJdIHRkIHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgW2RhdGEtcGxheWVyXSBxLCBbZGF0YS1wbGF5ZXJdIGJsb2NrcXVvdGUge1xcbiAgICBxdW90ZXM6IG5vbmU7IH1cXG4gICAgW2RhdGEtcGxheWVyXSBxOmJlZm9yZSwgW2RhdGEtcGxheWVyXSBxOmFmdGVyLCBbZGF0YS1wbGF5ZXJdIGJsb2NrcXVvdGU6YmVmb3JlLCBbZGF0YS1wbGF5ZXJdIGJsb2NrcXVvdGU6YWZ0ZXIge1xcbiAgICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICAgIGNvbnRlbnQ6IG5vbmU7IH1cXG4gIFtkYXRhLXBsYXllcl0gYSBpbWcge1xcbiAgICBib3JkZXI6IG5vbmU7IH1cXG4gIFtkYXRhLXBsYXllcl06Zm9jdXMge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICBbZGF0YS1wbGF5ZXJdICoge1xcbiAgICBtYXgtd2lkdGg6IG5vbmU7XFxuICAgIGJveC1zaXppbmc6IGluaGVyaXQ7XFxuICAgIGZsb2F0OiBub25lOyB9XFxuICBbZGF0YS1wbGF5ZXJdIGRpdiB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICBbZGF0YS1wbGF5ZXJdLmZ1bGxzY3JlZW4ge1xcbiAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xcbiAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwOyB9XFxuICBbZGF0YS1wbGF5ZXJdLm5vY3Vyc29yIHtcXG4gICAgY3Vyc29yOiBub25lOyB9XFxuXFxuLmNsYXBwci1zdHlsZSB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIltkYXRhLWh0bWw1LXZpZGVvXSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJbZGF0YS1odG1sLWltZ10ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgbWF4LWhlaWdodDogMTAwJTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiW2RhdGEtbm8tb3BdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuW2RhdGEtbm8tb3BdIHBbZGF0YS1uby1vcC1tc2ddIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMjVweDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICAvKiBjZW50ZXIgdmVydGljYWxseSAqL1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGF1dG87IH1cXG5cXG5bZGF0YS1uby1vcF0gY2FudmFzW2RhdGEtbm8tb3AtY2FudmFzXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzc3O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jYy1jb250cm9sc1tkYXRhLWNjLWNvbnRyb2xzXSB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuICAuY2MtY29udHJvbHNbZGF0YS1jYy1jb250cm9sc10uYXZhaWxhYmxlIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIC5jYy1jb250cm9sc1tkYXRhLWNjLWNvbnRyb2xzXSAuY2MtYnV0dG9uIHtcXG4gICAgcGFkZGluZzogNnB4ICFpbXBvcnRhbnQ7IH1cXG4gICAgLmNjLWNvbnRyb2xzW2RhdGEtY2MtY29udHJvbHNdIC5jYy1idXR0b24uZW5hYmxlZCB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgb3BhY2l0eTogMS4wOyB9XFxuICAgICAgLmNjLWNvbnRyb2xzW2RhdGEtY2MtY29udHJvbHNdIC5jYy1idXR0b24uZW5hYmxlZDpob3ZlciB7XFxuICAgICAgICBvcGFjaXR5OiAxLjA7XFxuICAgICAgICB0ZXh0LXNoYWRvdzogbm9uZTsgfVxcbiAgLmNjLWNvbnRyb2xzW2RhdGEtY2MtY29udHJvbHNdID4gdWwge1xcbiAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm90dG9tOiAyNXB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjsgfVxcbiAgLmNjLWNvbnRyb2xzW2RhdGEtY2MtY29udHJvbHNdIGxpIHtcXG4gICAgZm9udC1zaXplOiAxMHB4OyB9XFxuICAgIC5jYy1jb250cm9sc1tkYXRhLWNjLWNvbnRyb2xzXSBsaVtkYXRhLXRpdGxlXSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2MzYzJjMjtcXG4gICAgICBwYWRkaW5nOiA1cHg7IH1cXG4gICAgLmNjLWNvbnRyb2xzW2RhdGEtY2MtY29udHJvbHNdIGxpIGEge1xcbiAgICAgIGNvbG9yOiAjNDQ0O1xcbiAgICAgIHBhZGRpbmc6IDJweCAxMHB4O1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAgIC5jYy1jb250cm9sc1tkYXRhLWNjLWNvbnRyb2xzXSBsaSBhOmhvdmVyIHtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM1NTU7XFxuICAgICAgICBjb2xvcjogd2hpdGU7IH1cXG4gICAgICAgIC5jYy1jb250cm9sc1tkYXRhLWNjLWNvbnRyb2xzXSBsaSBhOmhvdmVyIGEge1xcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbiAgICAuY2MtY29udHJvbHNbZGF0YS1jYy1jb250cm9sc10gbGkuY3VycmVudCBhIHtcXG4gICAgICBjb2xvcjogI2YwMDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmR2ci1jb250cm9sc1tkYXRhLWR2ci1jb250cm9sc10ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xcbiAgZm9udC1zaXplOiAxMHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBtYXJnaW4tbGVmdDogNnB4OyB9XFxuICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1pbmZvIHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgICBmb250LWZhbWlseTogXFxcIlJvYm90b1xcXCIsIFxcXCJPcGVuIFNhbnNcXFwiLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsgfVxcbiAgICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1pbmZvOmJlZm9yZSB7XFxuICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICB3aWR0aDogN3B4O1xcbiAgICAgIGhlaWdodDogN3B4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDMuNXB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMy41cHg7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmMDEwMTsgfVxcbiAgICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1pbmZvLmRpc2FibGVkIHtcXG4gICAgICBvcGFjaXR5OiAwLjM7IH1cXG4gICAgICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1pbmZvLmRpc2FibGVkOmJlZm9yZSB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XFxuICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1idXR0b24ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBoZWlnaHQ6IDMycHg7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJSb2JvdG9cXFwiLCBcXFwiT3BlbiBTYW5zXFxcIiwgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjFzIGVhc2U7IH1cXG4gICAgLmR2ci1jb250cm9sc1tkYXRhLWR2ci1jb250cm9sc10gLmxpdmUtYnV0dG9uOmJlZm9yZSB7XFxuICAgICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICB3aWR0aDogN3B4O1xcbiAgICAgIGhlaWdodDogN3B4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDMuNXB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogMy41cHg7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjsgfVxcbiAgICAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1idXR0b246aG92ZXIge1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgdGV4dC1zaGFkb3c6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSkgMCAwIDVweDsgfVxcblxcbi5kdnIgLmR2ci1jb250cm9sc1tkYXRhLWR2ci1jb250cm9sc10gLmxpdmUtaW5mbyB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLmR2ciAuZHZyLWNvbnRyb2xzW2RhdGEtZHZyLWNvbnRyb2xzXSAubGl2ZS1idXR0b24ge1xcbiAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4uZHZyLm1lZGlhLWNvbnRyb2wubGl2ZVtkYXRhLW1lZGlhLWNvbnRyb2xdIC5tZWRpYS1jb250cm9sLWxheWVyW2RhdGEtY29udHJvbHNdIC5iYXItY29udGFpbmVyW2RhdGEtc2Vla2Jhcl0gLmJhci1iYWNrZ3JvdW5kW2RhdGEtc2Vla2Jhcl0gLmJhci1maWxsLTJbZGF0YS1zZWVrYmFyXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA1YWZmOyB9XFxuXFxuLm1lZGlhLWNvbnRyb2wubGl2ZVtkYXRhLW1lZGlhLWNvbnRyb2xdIC5tZWRpYS1jb250cm9sLWxheWVyW2RhdGEtY29udHJvbHNdIC5iYXItY29udGFpbmVyW2RhdGEtc2Vla2Jhcl0gLmJhci1iYWNrZ3JvdW5kW2RhdGEtc2Vla2Jhcl0gLmJhci1maWxsLTJbZGF0YS1zZWVrYmFyXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwMTAxOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJkaXYucGxheWVyLWVycm9yLXNjcmVlbiB7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICBjb2xvcjogI0NDQ0FDQTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xcbiAgei1pbmRleDogMjAwMDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IH1cXG4gIGRpdi5wbGF5ZXItZXJyb3Itc2NyZWVuX19jb250ZW50W2RhdGEtZXJyb3Itc2NyZWVuXSB7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgY29sb3I6ICNDQ0NBQ0E7XFxuICAgIG1hcmdpbi10b3A6IDQ1cHg7IH1cXG4gIGRpdi5wbGF5ZXItZXJyb3Itc2NyZWVuX190aXRsZVtkYXRhLWVycm9yLXNjcmVlbl0ge1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgbGluZS1oZWlnaHQ6IDMwcHg7XFxuICAgIGZvbnQtc2l6ZTogMThweDsgfVxcbiAgZGl2LnBsYXllci1lcnJvci1zY3JlZW5fX21lc3NhZ2VbZGF0YS1lcnJvci1zY3JlZW5dIHtcXG4gICAgd2lkdGg6IDkwJTtcXG4gICAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIGRpdi5wbGF5ZXItZXJyb3Itc2NyZWVuX19jb2RlW2RhdGEtZXJyb3Itc2NyZWVuXSB7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgbWFyZ2luLXRvcDogMTVweDsgfVxcbiAgZGl2LnBsYXllci1lcnJvci1zY3JlZW5fX3JlbG9hZCB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgd2lkdGg6IDMwcHg7XFxuICAgIG1hcmdpbjogMTVweCBhdXRvIDA7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBsYXllci1wb3N0ZXJbZGF0YS1wb3N0ZXJdIHtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgei1pbmRleDogOTk4O1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDUwJSA1MCU7IH1cXG4gIC5wbGF5ZXItcG9zdGVyW2RhdGEtcG9zdGVyXS5jbGlja2FibGUge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gIC5wbGF5ZXItcG9zdGVyW2RhdGEtcG9zdGVyXTpob3ZlciAucGxheS13cmFwcGVyW2RhdGEtcG9zdGVyXSB7XFxuICAgIG9wYWNpdHk6IDE7IH1cXG4gIC5wbGF5ZXItcG9zdGVyW2RhdGEtcG9zdGVyXSAucGxheS13cmFwcGVyW2RhdGEtcG9zdGVyXSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDI1JTtcXG4gICAgbWFyZ2luOiAwIGF1dG87XFxuICAgIG9wYWNpdHk6IDAuNzU7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlOyB9XFxuICAgIC5wbGF5ZXItcG9zdGVyW2RhdGEtcG9zdGVyXSAucGxheS13cmFwcGVyW2RhdGEtcG9zdGVyXSBzdmcge1xcbiAgICAgIGhlaWdodDogMTAwJTsgfVxcbiAgICAgIC5wbGF5ZXItcG9zdGVyW2RhdGEtcG9zdGVyXSAucGxheS13cmFwcGVyW2RhdGEtcG9zdGVyXSBzdmcgcGF0aCB7XFxuICAgICAgICBmaWxsOiAjZmZmOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2Vlay10aW1lW2RhdGEtc2Vlay10aW1lXSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICBmb250LXNpemU6IDA7XFxuICBsZWZ0OiAtMTAwJTtcXG4gIGJvdHRvbTogNTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMiwgMiwgMiwgMC41KTtcXG4gIHotaW5kZXg6IDk5OTk7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZTsgfVxcbiAgLnNlZWstdGltZVtkYXRhLXNlZWstdGltZV0uaGlkZGVuW2RhdGEtc2Vlay10aW1lXSB7XFxuICAgIG9wYWNpdHk6IDA7IH1cXG4gIC5zZWVrLXRpbWVbZGF0YS1zZWVrLXRpbWVdIFtkYXRhLXNlZWstdGltZV0ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1zaXplOiAxMHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDdweDtcXG4gICAgcGFkZGluZy1yaWdodDogN3B4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9XFxuICAuc2Vlay10aW1lW2RhdGEtc2Vlay10aW1lXSBbZGF0YS1kdXJhdGlvbl0ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICAgIGZvbnQtc2l6ZTogMTBweDtcXG4gICAgcGFkZGluZy1yaWdodDogN3B4O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9XFxuICAgIC5zZWVrLXRpbWVbZGF0YS1zZWVrLXRpbWVdIFtkYXRhLWR1cmF0aW9uXTpiZWZvcmUge1xcbiAgICAgIGNvbnRlbnQ6IFxcXCJ8XFxcIjtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDdweDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnNwaW5uZXItdGhyZWUtYm91bmNlW2RhdGEtc3Bpbm5lcl0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICB3aWR0aDogNzBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgLyogY2VudGVyIHZlcnRpY2FsbHkgKi9cXG4gIHRvcDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpOyB9XFxuICAuc3Bpbm5lci10aHJlZS1ib3VuY2VbZGF0YS1zcGlubmVyXSA+IGRpdiB7XFxuICAgIHdpZHRoOiAxOHB4O1xcbiAgICBoZWlnaHQ6IDE4cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgYW5pbWF0aW9uOiBib3VuY2VkZWxheSAxLjRzIGluZmluaXRlIGVhc2UtaW4tb3V0O1xcbiAgICAvKiBQcmV2ZW50IGZpcnN0IGZyYW1lIGZyb20gZmxpY2tlcmluZyB3aGVuIGFuaW1hdGlvbiBzdGFydHMgKi9cXG4gICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDsgfVxcbiAgLnNwaW5uZXItdGhyZWUtYm91bmNlW2RhdGEtc3Bpbm5lcl0gW2RhdGEtYm91bmNlMV0ge1xcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjMyczsgfVxcbiAgLnNwaW5uZXItdGhyZWUtYm91bmNlW2RhdGEtc3Bpbm5lcl0gW2RhdGEtYm91bmNlMl0ge1xcbiAgICBhbmltYXRpb24tZGVsYXk6IC0wLjE2czsgfVxcblxcbkBrZXlmcmFtZXMgYm91bmNlZGVsYXkge1xcbiAgMCUsIDgwJSwgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7IH1cXG4gIDQwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7IH0gfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmNsYXBwci13YXRlcm1hcmtbZGF0YS13YXRlcm1hcmtdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG1pbi13aWR0aDogNzBweDtcXG4gIG1heC13aWR0aDogMjAwcHg7XFxuICB3aWR0aDogMTIlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgei1pbmRleDogMTA7IH1cXG5cXG4uY2xhcHByLXdhdGVybWFya1tkYXRhLXdhdGVybWFya10gYSB7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLmNsYXBwci13YXRlcm1hcmtbZGF0YS13YXRlcm1hcmtdIGltZyB7XFxuICBtYXgtd2lkdGg6IDEwMCU7IH1cXG5cXG4uY2xhcHByLXdhdGVybWFya1tkYXRhLXdhdGVybWFyay1ib3R0b20tbGVmdF0ge1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgbGVmdDogMTBweDsgfVxcblxcbi5jbGFwcHItd2F0ZXJtYXJrW2RhdGEtd2F0ZXJtYXJrLWJvdHRvbS1yaWdodF0ge1xcbiAgYm90dG9tOiAxMHB4O1xcbiAgcmlnaHQ6IDQycHg7IH1cXG5cXG4uY2xhcHByLXdhdGVybWFya1tkYXRhLXdhdGVybWFyay10b3AtbGVmdF0ge1xcbiAgdG9wOiAxMHB4O1xcbiAgbGVmdDogMTBweDsgfVxcblxcbi5jbGFwcHItd2F0ZXJtYXJrW2RhdGEtd2F0ZXJtYXJrLXRvcC1yaWdodF0ge1xcbiAgdG9wOiAxMHB4O1xcbiAgcmlnaHQ6IDM3cHg7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuIiwidHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiSGxzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkhsc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9obHMudHNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKHRydWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgdmFyIFVSTF9SRUdFWCA9IC9eKCg/OlthLXpBLVowLTkrXFwtLl0rOik/KShcXC9cXC9bXlxcLz8jXSopPygoPzpbXlxcLz8jXSpcXC8pKlteOz8jXSopPyg7W14/I10qKT8oXFw/W14jXSopPygjLiopPyQvO1xuICB2YXIgRklSU1RfU0VHTUVOVF9SRUdFWCA9IC9eKFteXFwvPyNdKikoLiopJC87XG4gIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICB2YXIgU0xBU0hfRE9UX0RPVF9SRUdFWCA9IC8oPzpcXC98XilcXC5cXC5cXC8oPyFcXC5cXC5cXC8pW15cXC9dKig/PVxcLykvZztcblxuICB2YXIgVVJMVG9vbGtpdCA9IHtcbiAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICAgIC8vIEUuZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSBmYWxzZSAoZGVmYXVsdCwgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9nXG4gICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIC8vIHJlbW92ZSBhbnkgcmVtYWluaW5nIHNwYWNlIGFuZCBDUkxGXG4gICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcbiAgICAgIGlmICghcmVsYXRpdmVVUkwpIHtcbiAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICAgICAgICAvLyBlbnRpcmUgYmFzZSBVUkwgKGkuZS4sIGlzIHNldCBlcXVhbCB0byB0aGUgYmFzZSBVUkwpXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgICBpZiAoIWJhc2VQYXJ0c0Zvck5vcm1hbGlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKFxuICAgICAgICAgIGJhc2VQYXJ0c0Zvck5vcm1hbGlzZS5wYXRoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJhc2VQYXJ0c0Zvck5vcm1hbGlzZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnNjaGVtZSkge1xuICAgICAgICAvLyAyYikgSWYgdGhlIGVtYmVkZGVkIFVSTCBzdGFydHMgd2l0aCBhIHNjaGVtZSBuYW1lLCBpdCBpc1xuICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICAgICAgICBpZiAoIW9wdHMuYWx3YXlzTm9ybWFsaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVVJMO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF0aXZlUGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhyZWxhdGl2ZVBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXNlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICAgICAgaWYgKCFiYXNlUGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0cy5uZXRMb2MgJiYgYmFzZVBhcnRzLnBhdGggJiYgYmFzZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgJ2V4YW1wbGUuY29tL2EnIHRvIGJlIGhhbmRsZWQgYXMgJy8vZXhhbXBsZS5jb20vYScgaW5zdGVhZCBvZiAnL2V4YW1wbGUuY29tL2EnXG4gICAgICAgIHZhciBwYXRoUGFydHMgPSBGSVJTVF9TRUdNRU5UX1JFR0VYLmV4ZWMoYmFzZVBhcnRzLnBhdGgpO1xuICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9IHBhdGhQYXJ0c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICAgICAgICBiYXNlUGFydHMucGF0aCA9ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICAgICAgICAvLyAyYykgT3RoZXJ3aXNlLCB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBzY2hlbWUgb2ZcbiAgICAgICAgLy8gdGhlIGJhc2UgVVJMLlxuICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gICAgICAgIG5ldExvYzogcmVsYXRpdmVQYXJ0cy5uZXRMb2MsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiByZWxhdGl2ZVBhcnRzLnF1ZXJ5LFxuICAgICAgICBmcmFnbWVudDogcmVsYXRpdmVQYXJ0cy5mcmFnbWVudCxcbiAgICAgIH07XG4gICAgICBpZiAoIXJlbGF0aXZlUGFydHMubmV0TG9jKSB7XG4gICAgICAgIC8vIDMpIElmIHRoZSBlbWJlZGRlZCBVUkwncyA8bmV0X2xvYz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gICAgICAgIC8vIChpZiBhbnkpIG9mIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgYnVpbHRQYXJ0cy5uZXRMb2MgPSBiYXNlUGFydHMubmV0TG9jO1xuICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gICAgICAgIC8vIHBhdGggaXMgbm90IHJlbGF0aXZlIGFuZCB3ZSBza2lwIHRvIFN0ZXAgNy5cbiAgICAgICAgaWYgKHJlbGF0aXZlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIDUpIElmIHRoZSBlbWJlZGRlZCBVUkwgcGF0aCBpcyBlbXB0eSAoYW5kIG5vdCBwcmVjZWRlZCBieSBhXG4gICAgICAgICAgICAvLyBzbGFzaCksIHRoZW4gdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgYmFzZSBVUkwgcGF0aFxuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gICAgICAgICAgICAvLyA1YSkgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxwYXJhbXM+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cGFyYW1zPiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhcmFtcykge1xuICAgICAgICAgICAgICBidWlsdFBhcnRzLnBhcmFtcyA9IGJhc2VQYXJ0cy5wYXJhbXM7XG4gICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgICAgLy8gc3RlcCA3OyBvdGhlcndpc2UsIGl0IGluaGVyaXRzIHRoZSA8cXVlcnk+IG9mIHRoZSBiYXNlXG4gICAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmQgd2Ugc2tpcCB0byBzdGVwIDcuXG4gICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICAgICAgICAgICAgICAgIGJ1aWx0UGFydHMucXVlcnkgPSBiYXNlUGFydHMucXVlcnk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNikgVGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgYmFzZSBVUkwncyBwYXRoIChhbnl0aGluZ1xuICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICAgICAgICAgICAgLy8gc2xhc2ggaXMgcHJlc2VudCkgaXMgcmVtb3ZlZCBhbmQgdGhlIGVtYmVkZGVkIFVSTCdzIHBhdGggaXNcbiAgICAgICAgICAgIC8vIGFwcGVuZGVkIGluIGl0cyBwbGFjZS5cbiAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPVxuICAgICAgICAgICAgICBiYXNlVVJMUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVVSTFBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1aWx0UGFydHMucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuICAgICAgICAgID8gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aClcbiAgICAgICAgICA6IHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKGJ1aWx0UGFydHMpO1xuICAgIH0sXG4gICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFVSTF9SRUdFWC5leGVjKHVybCk7XG4gICAgICBpZiAoIXBhcnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgICAgICAgbmV0TG9jOiBwYXJ0c1syXSB8fCAnJyxcbiAgICAgICAgcGF0aDogcGFydHNbM10gfHwgJycsXG4gICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gICAgICAgIHF1ZXJ5OiBwYXJ0c1s1XSB8fCAnJyxcbiAgICAgICAgZnJhZ21lbnQ6IHBhcnRzWzZdIHx8ICcnLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gICAgICAvLyB0aGVuIGFwcGxpZWQsIGluIG9yZGVyLCB0byB0aGUgbmV3IHBhdGg6XG4gICAgICAvLyA2YSkgQWxsIG9jY3VycmVuY2VzIG9mIFwiLi9cIiwgd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoXG4gICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIDZiKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCIuXCIgYXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsXG4gICAgICAvLyB0aGF0IFwiLlwiIGlzIHJlbW92ZWQuXG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gICAgICAvLyA2YykgQWxsIG9jY3VycmVuY2VzIG9mIFwiPHNlZ21lbnQ+Ly4uL1wiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIGFyZSByZW1vdmVkLlxuICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgICAgIC8vIHJlbW92aW5nIHRoZSBsZWZ0bW9zdCBtYXRjaGluZyBwYXR0ZXJuIG9uIGVhY2ggaXRlcmF0aW9uLFxuICAgICAgLy8gdW50aWwgbm8gbWF0Y2hpbmcgcGF0dGVybiByZW1haW5zLlxuICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICAgICAgLy8gY29tcGxldGUgcGF0aCBzZWdtZW50IG5vdCBlcXVhbCB0byBcIi4uXCIsIHRoYXRcbiAgICAgIC8vIFwiPHNlZ21lbnQ+Ly4uXCIgaXMgcmVtb3ZlZC5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgcGF0aC5sZW5ndGggIT09IChwYXRoID0gcGF0aC5yZXBsYWNlKFNMQVNIX0RPVF9ET1RfUkVHRVgsICcnKSkubGVuZ3RoXG4gICAgICApIHt9XG4gICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgYnVpbGRVUkxGcm9tUGFydHM6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcGFydHMuc2NoZW1lICtcbiAgICAgICAgcGFydHMubmV0TG9jICtcbiAgICAgICAgcGFydHMucGF0aCArXG4gICAgICAgIHBhcnRzLnBhcmFtcyArXG4gICAgICAgIHBhcnRzLnF1ZXJ5ICtcbiAgICAgICAgcGFydHMuZnJhZ21lbnRcbiAgICAgICk7XG4gICAgfSxcbiAgfTtcblxuICBpZiAodHJ1ZSlcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIGVsc2Uge31cbn0pKHRoaXMpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYndvcmtpZnktd2VicGFjay9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiB3ZWJwYWNrQm9vdHN0cmFwRnVuYyAobW9kdWxlcykge1xuLyoqKioqKi8gIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gICAgaWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyAgICAgIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyAgICAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gICAgICBpOiBtb2R1bGVJZCxcbi8qKioqKiovICAgICAgbDogZmFsc2UsXG4vKioqKioqLyAgICAgIGV4cG9ydHM6IHt9XG4vKioqKioqLyAgICB9O1xuXG4vKioqKioqLyAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyAgICBtb2R1bGUubCA9IHRydWU7XG5cbi8qKioqKiovICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyAgfVxuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyAgLy8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuLyoqKioqKi8gIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gICAgaWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovICAgICAgICBnZXQ6IGdldHRlclxuLyoqKioqKi8gICAgICB9KTtcbi8qKioqKiovICAgIH1cbi8qKioqKiovICB9O1xuXG4vKioqKioqLyAgLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovICAgICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovICAgIHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyAgfTtcblxuLyoqKioqKi8gIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuLyoqKioqKi8gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbi8qKioqKiovICAvLyBvbiBlcnJvciBmdW5jdGlvbiBmb3IgYXN5bmMgbG9hZGluZ1xuLyoqKioqKi8gIF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiAgdmFyIGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IEVOVFJZX01PRFVMRSlcbiAgcmV0dXJuIGYuZGVmYXVsdCB8fCBmIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0c1xufVxuXG52YXIgbW9kdWxlTmFtZVJlcUV4cCA9ICdbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8XFwvfEBdKydcbnZhciBkZXBlbmRlbmN5UmVnRXhwID0gJ1xcXFwoXFxcXHMqKFxcL1xcXFwqLio/XFxcXCpcXC8pP1xcXFxzKi4qPygnICsgbW9kdWxlTmFtZVJlcUV4cCArICcpLio/XFxcXCknIC8vIGFkZGl0aW9uYWwgY2hhcnMgd2hlbiBvdXRwdXQucGF0aGluZm8gaXMgdHJ1ZVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTkzNjYxLzEzMDQ0MlxuZnVuY3Rpb24gcXVvdGVSZWdFeHAgKHN0cikge1xuICByZXR1cm4gKHN0ciArICcnKS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKVxufVxuXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gIWlzTmFOKDEgKiBuKTsgLy8gMSAqIG4gY29udmVydHMgaW50ZWdlcnMsIGludGVnZXJzIGFzIHN0cmluZyAoXCIxMjNcIiksIDFlMyBhbmQgXCIxZTNcIiB0byBpbnRlZ2VycyBhbmQgc3RyaW5ncyB0byBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlRGVwZW5kZW5jaWVzIChzb3VyY2VzLCBtb2R1bGUsIHF1ZXVlTmFtZSkge1xuICB2YXIgcmV0dmFsID0ge31cbiAgcmV0dmFsW3F1ZXVlTmFtZV0gPSBbXVxuXG4gIHZhciBmblN0cmluZyA9IG1vZHVsZS50b1N0cmluZygpXG4gIHZhciB3cmFwcGVyU2lnbmF0dXJlID0gZm5TdHJpbmcubWF0Y2goL15mdW5jdGlvblxccz9cXHcqXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpLylcbiAgaWYgKCF3cmFwcGVyU2lnbmF0dXJlKSByZXR1cm4gcmV0dmFsXG4gIHZhciB3ZWJwYWNrUmVxdWlyZU5hbWUgPSB3cmFwcGVyU2lnbmF0dXJlWzFdXG5cbiAgLy8gbWFpbiBidW5kbGUgZGVwc1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoXFxcXFxcXFxufFxcXFxXKScgKyBxdW90ZVJlZ0V4cCh3ZWJwYWNrUmVxdWlyZU5hbWUpICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB2YXIgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm5TdHJpbmcpKSkge1xuICAgIGlmIChtYXRjaFszXSA9PT0gJ2RsbC1yZWZlcmVuY2UnKSBjb250aW51ZVxuICAgIHJldHZhbFtxdWV1ZU5hbWVdLnB1c2gobWF0Y2hbM10pXG4gIH1cblxuICAvLyBkbGwgZGVwc1xuICByZSA9IG5ldyBSZWdFeHAoJ1xcXFwoJyArIHF1b3RlUmVnRXhwKHdlYnBhY2tSZXF1aXJlTmFtZSkgKyAnXFxcXChcIihkbGwtcmVmZXJlbmNlXFxcXHMoJyArIG1vZHVsZU5hbWVSZXFFeHAgKyAnKSlcIlxcXFwpXFxcXCknICsgZGVwZW5kZW5jeVJlZ0V4cCwgJ2cnKVxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhmblN0cmluZykpKSB7XG4gICAgaWYgKCFzb3VyY2VzW21hdGNoWzJdXSkge1xuICAgICAgcmV0dmFsW3F1ZXVlTmFtZV0ucHVzaChtYXRjaFsxXSlcbiAgICAgIHNvdXJjZXNbbWF0Y2hbMl1dID0gX193ZWJwYWNrX3JlcXVpcmVfXyhtYXRjaFsxXSkubVxuICAgIH1cbiAgICByZXR2YWxbbWF0Y2hbMl1dID0gcmV0dmFsW21hdGNoWzJdXSB8fCBbXVxuICAgIHJldHZhbFttYXRjaFsyXV0ucHVzaChtYXRjaFs0XSlcbiAgfVxuXG4gIC8vIGNvbnZlcnQgMWUzIGJhY2sgdG8gMTAwMCAtIHRoaXMgY2FuIGJlIGltcG9ydGFudCBhZnRlciB1Z2xpZnktanMgY29udmVydGVkIDEwMDAgdG8gMWUzXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmV0dmFsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXR2YWxba2V5c1tpXV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChpc051bWVyaWMocmV0dmFsW2tleXNbaV1dW2pdKSkge1xuICAgICAgICByZXR2YWxba2V5c1tpXV1bal0gPSAxICogcmV0dmFsW2tleXNbaV1dW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuZnVuY3Rpb24gaGFzVmFsdWVzSW5RdWV1ZXMgKHF1ZXVlcykge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXVlcylcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNWYWx1ZXMsIGtleSkge1xuICAgIHJldHVybiBoYXNWYWx1ZXMgfHwgcXVldWVzW2tleV0ubGVuZ3RoID4gMFxuICB9LCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWlyZWRNb2R1bGVzIChzb3VyY2VzLCBtb2R1bGVJZCkge1xuICB2YXIgbW9kdWxlc1F1ZXVlID0ge1xuICAgIG1haW46IFttb2R1bGVJZF1cbiAgfVxuICB2YXIgcmVxdWlyZWRNb2R1bGVzID0ge1xuICAgIG1haW46IFtdXG4gIH1cbiAgdmFyIHNlZW5Nb2R1bGVzID0ge1xuICAgIG1haW46IHt9XG4gIH1cblxuICB3aGlsZSAoaGFzVmFsdWVzSW5RdWV1ZXMobW9kdWxlc1F1ZXVlKSkge1xuICAgIHZhciBxdWV1ZXMgPSBPYmplY3Qua2V5cyhtb2R1bGVzUXVldWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZU5hbWUgPSBxdWV1ZXNbaV1cbiAgICAgIHZhciBxdWV1ZSA9IG1vZHVsZXNRdWV1ZVtxdWV1ZU5hbWVdXG4gICAgICB2YXIgbW9kdWxlVG9DaGVjayA9IHF1ZXVlLnBvcCgpXG4gICAgICBzZWVuTW9kdWxlc1txdWV1ZU5hbWVdID0gc2Vlbk1vZHVsZXNbcXVldWVOYW1lXSB8fCB7fVxuICAgICAgaWYgKHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gfHwgIXNvdXJjZXNbcXVldWVOYW1lXVttb2R1bGVUb0NoZWNrXSkgY29udGludWVcbiAgICAgIHNlZW5Nb2R1bGVzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10gPSB0cnVlXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXSA9IHJlcXVpcmVkTW9kdWxlc1txdWV1ZU5hbWVdIHx8IFtdXG4gICAgICByZXF1aXJlZE1vZHVsZXNbcXVldWVOYW1lXS5wdXNoKG1vZHVsZVRvQ2hlY2spXG4gICAgICB2YXIgbmV3TW9kdWxlcyA9IGdldE1vZHVsZURlcGVuZGVuY2llcyhzb3VyY2VzLCBzb3VyY2VzW3F1ZXVlTmFtZV1bbW9kdWxlVG9DaGVja10sIHF1ZXVlTmFtZSlcbiAgICAgIHZhciBuZXdNb2R1bGVzS2V5cyA9IE9iamVjdC5rZXlzKG5ld01vZHVsZXMpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld01vZHVsZXNLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dIHx8IFtdXG4gICAgICAgIG1vZHVsZXNRdWV1ZVtuZXdNb2R1bGVzS2V5c1tqXV0gPSBtb2R1bGVzUXVldWVbbmV3TW9kdWxlc0tleXNbal1dLmNvbmNhdChuZXdNb2R1bGVzW25ld01vZHVsZXNLZXlzW2pdXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZWRNb2R1bGVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBzb3VyY2VzID0ge1xuICAgIG1haW46IF9fd2VicGFja19yZXF1aXJlX18ubVxuICB9XG5cbiAgdmFyIHJlcXVpcmVkTW9kdWxlcyA9IG9wdGlvbnMuYWxsID8geyBtYWluOiBPYmplY3Qua2V5cyhzb3VyY2VzLm1haW4pIH0gOiBnZXRSZXF1aXJlZE1vZHVsZXMoc291cmNlcywgbW9kdWxlSWQpXG5cbiAgdmFyIHNyYyA9ICcnXG5cbiAgT2JqZWN0LmtleXMocmVxdWlyZWRNb2R1bGVzKS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09ICdtYWluJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICB2YXIgZW50cnlNb2R1bGUgPSAwXG4gICAgd2hpbGUgKHJlcXVpcmVkTW9kdWxlc1ttb2R1bGVdW2VudHJ5TW9kdWxlXSkge1xuICAgICAgZW50cnlNb2R1bGUrK1xuICAgIH1cbiAgICByZXF1aXJlZE1vZHVsZXNbbW9kdWxlXS5wdXNoKGVudHJ5TW9kdWxlKVxuICAgIHNvdXJjZXNbbW9kdWxlXVtlbnRyeU1vZHVsZV0gPSAnKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgeyBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX187IH0pJ1xuICAgIHNyYyA9IHNyYyArICd2YXIgJyArIG1vZHVsZSArICcgPSAoJyArIHdlYnBhY2tCb290c3RyYXBGdW5jLnRvU3RyaW5nKCkucmVwbGFjZSgnRU5UUllfTU9EVUxFJywgSlNPTi5zdHJpbmdpZnkoZW50cnlNb2R1bGUpKSArICcpKHsnICsgcmVxdWlyZWRNb2R1bGVzW21vZHVsZV0ubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gJycgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnOiAnICsgc291cmNlc1ttb2R1bGVdW2lkXS50b1N0cmluZygpIH0pLmpvaW4oJywnKSArICd9KTtcXG4nXG4gIH0pXG5cbiAgc3JjID0gc3JjICsgJ25ldyAoKCcgKyB3ZWJwYWNrQm9vdHN0cmFwRnVuYy50b1N0cmluZygpLnJlcGxhY2UoJ0VOVFJZX01PRFVMRScsIEpTT04uc3RyaW5naWZ5KG1vZHVsZUlkKSkgKyAnKSh7JyArIHJlcXVpcmVkTW9kdWxlcy5tYWluLm1hcChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICcnICsgSlNPTi5zdHJpbmdpZnkoaWQpICsgJzogJyArIHNvdXJjZXMubWFpbltpZF0udG9TdHJpbmcoKSB9KS5qb2luKCcsJykgKyAnfSkpKHNlbGYpOydcblxuICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICBpZiAob3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iIH1cblxuICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMXG5cbiAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHdvcmtlclVybClcbiAgd29ya2VyLm9iamVjdFVSTCA9IHdvcmtlclVybFxuXG4gIHJldHVybiB3b3JrZXJcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25maWcudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbmZpZy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogaGxzRGVmYXVsdENvbmZpZywgbWVyZ2VDb25maWcsIGVuYWJsZVN0cmVhbWluZ01vZGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaGxzRGVmYXVsdENvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1lcmdlQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVuYWJsZVN0cmVhbWluZ01vZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmFibGVTdHJlYW1pbmdNb2RlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hYnJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hdWRpb19zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9hdWRpb190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9zdWJ0aXRsZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9zdWJ0aXRsZV90cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9idWZmZXJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl90aW1lbGluZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9jYXBfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9jYXAtbGV2ZWwtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9mcHNfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9lbWVfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9lbWUtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfeGhyX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMveGhyLWxvYWRlciAqLyBcIi4vc3JjL3V0aWxzL3hoci1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2ZldGNoX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvZmV0Y2gtbG9hZGVyICovIFwiLi9zcmMvdXRpbHMvZmV0Y2gtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jdWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9jdWVzICovIFwiLi9zcmMvdXRpbHMvY3Vlcy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuLy8gSXQgaXMgY2xvbmVkIHdoZW5ldmVyIGEgbmV3IEhscyBpbnN0YW5jZSBpcyBjcmVhdGVkLCBieSBrZWVwaW5nIHRoZSBjb25maWdcbi8vIHNoYWxsb3cgdGhlIHByb3BlcnRpZXMgYXJlIGNsb25lZCwgYW5kIHdlIGRvbid0IGVuZCB1cCBtYW5pcHVsYXRpbmcgdGhlIGRlZmF1bHRcbnZhciBobHNEZWZhdWx0Q29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgYXV0b1N0YXJ0TG9hZDogdHJ1ZSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWZhdWx0QXVkaW9Db2RlYzogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBsb2dnZXJcbiAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGNhcExldmVsVG9QbGF5ZXJTaXplOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMTAwMCAqIDEwMDAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDogSW5maW5pdHksXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZTogMS4yNSxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBJbmZpbml0eSxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBlbmFibGVXb3JrZXI6IHRydWUsXG4gIC8vIHVzZWQgYnkgZGVtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSxcbiAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OiAxLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAvLyB1c2VkIGJ5IHBsYXlsaXN0LWxvYWRlclxuICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIGZyYWdMb2FkaW5nVGltZU91dDogMjAwMDAsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIGZyYWdMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBzdGFydEZyYWdQcmVmZXRjaDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDUwMDAsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBhcHBlbmRFcnJvck1heFJldHJ5OiAzLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGxvYWRlcjogX3V0aWxzX3hocl9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJkZWZhdWx0XCJdLFxuICAvLyBsb2FkZXI6IEZldGNoTG9hZGVyLFxuICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZnJhZ21lbnQtbG9hZGVyXG4gIHBMb2FkZXI6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgeGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSB4aHItbG9hZGVyXG4gIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IF9jb250cm9sbGVyX2Ficl9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICBidWZmZXJDb250cm9sbGVyOiBfY29udHJvbGxlcl9idWZmZXJfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSxcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBfY29udHJvbGxlcl9jYXBfbGV2ZWxfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSxcbiAgZnBzQ29udHJvbGxlcjogX2NvbnRyb2xsZXJfZnBzX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0sXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cy1kZW11eGVyXG4gIGFickV3bWFGYXN0TGl2ZTogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd0xpdmU6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dWb0Q6IDksXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTogNWU1LFxuICAvLyA1MDAga2JwcyAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhGYWN0b3I6IDAuOTUsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IDAuNyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heFN0YXJ2YXRpb25EZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhMb2FkaW5nRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWluQXV0b0JpdHJhdGU6IDAsXG4gIC8vIHVzZWQgYnkgaGxzXG4gIGVtZUVuYWJsZWQ6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHdpZGV2aW5lTGljZW5zZVVybDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGRybVN5c3RlbU9wdGlvbnM6IHt9LFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXCJdLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIHRlc3RCYW5kd2lkdGg6IHRydWUsXG4gIHByb2dyZXNzaXZlOiBmYWxzZSxcbiAgbG93TGF0ZW5jeU1vZGU6IHRydWVcbn0sIHRpbWVsaW5lQ29uZmlnKCkpLCB7fSwge1xuICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfc3VidGl0bGVfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIlN1YnRpdGxlU3RyZWFtQ29udHJvbGxlclwiXSA6IHVuZGVmaW5lZCxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6ICB0cnVlID8gX2NvbnRyb2xsZXJfc3VidGl0bGVfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSA6IHVuZGVmaW5lZCxcbiAgdGltZWxpbmVDb250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX3RpbWVsaW5lX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlRpbWVsaW5lQ29udHJvbGxlclwiXSA6IHVuZGVmaW5lZCxcbiAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX2F1ZGlvX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdIDogdW5kZWZpbmVkLFxuICBhdWRpb1RyYWNrQ29udHJvbGxlcjogIHRydWUgPyBfY29udHJvbGxlcl9hdWRpb190cmFja19jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdIDogdW5kZWZpbmVkLFxuICBlbWVDb250cm9sbGVyOiAgdHJ1ZSA/IF9jb250cm9sbGVyX2VtZV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJkZWZhdWx0XCJdIDogdW5kZWZpbmVkXG59KTtcblxuZnVuY3Rpb24gdGltZWxpbmVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgY3VlSGFuZGxlcjogX3V0aWxzX2N1ZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18sXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6IHRydWUsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUlNU0MxOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiAnRW5nbGlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiAnZXMnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpIHtcbiAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBobHMuanMgY29uZmlnOiBkb24ndCBtaXggdXAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50L2xpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCBhbmQgbGl2ZVN5bmNEdXJhdGlvbi9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIpO1xuICB9XG5cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICB9XG5cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25cIicpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKSB7XG4gIHZhciBjdXJyZW50TG9hZGVyID0gY29uZmlnLmxvYWRlcjtcblxuICBpZiAoY3VycmVudExvYWRlciAhPT0gX3V0aWxzX2ZldGNoX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImRlZmF1bHRcIl0gJiYgY3VycmVudExvYWRlciAhPT0gX3V0aWxzX3hocl9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJkZWZhdWx0XCJdKSB7XG4gICAgLy8gSWYgYSBkZXZlbG9wZXIgaGFzIGNvbmZpZ3VyZWQgdGhlaXIgb3duIGxvYWRlciwgcmVzcGVjdCB0aGF0IGNob2ljZVxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bXCJsb2dnZXJcIl0ubG9nKCdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnKTtcbiAgICBjb25maWcucHJvZ3Jlc3NpdmUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9IE9iamVjdChfdXRpbHNfZmV0Y2hfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZmV0Y2hTdXBwb3J0ZWRcIl0pKCk7XG5cbiAgICBpZiAoY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSkge1xuICAgICAgY29uZmlnLmxvYWRlciA9IF91dGlsc19mZXRjaF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJkZWZhdWx0XCJdO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUyA9IHRydWU7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wibG9nZ2VyXCJdLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2Fici1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2V3bWFfYmFuZHdpZHRoX2VzdGltYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yICovIFwiLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzXCIpO1xuXG5cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKlxuICogc2ltcGxlIEFCUiBDb250cm9sbGVyXG4gKiAgLSBjb21wdXRlIG5leHQgbGV2ZWwgYmFzZWQgb24gbGFzdCBmcmFnbWVudCBidyBoZXVyaXN0aWNzXG4gKiAgLSBpbXBsZW1lbnQgYW4gYWJhbmRvbiBydWxlcyB0cmlnZ2VyZWQgaWYgd2UgaGF2ZSBsZXNzIHRoYW4gMiBmcmFnIGJ1ZmZlcmVkIGFuZCBpZiBjb21wdXRlZCBidyBzaG93cyB0aGF0IHdlIHJpc2sgYnVmZmVyIHN0YWxsaW5nXG4gKi9cblxuXG5cblxuXG5cbnZhciBBYnJDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQWJyQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAwO1xuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMub25DaGVjayA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSBuZXcgX3V0aWxzX2V3bWFfYmFuZHdpZHRoX2VzdGltYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXShjb25maWcuYWJyRXdtYVNsb3dWb0QsIGNvbmZpZy5hYnJFd21hRmFzdFZvRCwgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBYnJDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG5cbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicpIHtcbiAgICAgIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICB2YXIgX2RhdGEkcGFydDtcblxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAgdGhpcy5wYXJ0Q3VycmVudCA9IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSAhPSBudWxsID8gX2RhdGEkcGFydCA6IG51bGw7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25DaGVjaywgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICAgIFRoaXMgbWV0aG9kIG1vbml0b3JzIHRoZSBkb3dubG9hZCByYXRlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LCBhbmQgd2lsbCBkb3duc3dpdGNoIGlmIHRoYXQgZnJhZ21lbnQgd2lsbCBub3QgbG9hZFxuICAgICAgcXVpY2tseSBlbm91Z2ggdG8gcHJldmVudCB1bmRlcmJ1ZmZlcmluZ1xuICAgICovXG4gIDtcblxuICBfcHJvdG8uX2FiYW5kb25SdWxlc0NoZWNrID0gZnVuY3Rpb24gX2FiYW5kb25SdWxlc0NoZWNrKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgcGFydCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBhdXRvTGV2ZWxFbmFibGVkID0gaGxzLmF1dG9MZXZlbEVuYWJsZWQsXG4gICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgIG1lZGlhID0gaGxzLm1lZGlhO1xuXG4gICAgaWYgKCFmcmFnIHx8ICFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247IC8vIElmIGxvYWRpbmcgaGFzIGJlZW4gYWJvcnRlZCBhbmQgbm90IGluIGxvd0xhdGVuY3lNb2RlLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cblxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0ud2FybignZnJhZyBsb2FkZXIgZGVzdHJveSBvciBhYm9ydGVkLCBkaXNhcm0gYWJhbmRvblJ1bGVzJyk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTsgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBjaGVjayBvbmx5IHJ1bnMgaWYgd2UncmUgaW4gQUJSIG1vZGUgYW5kIGFjdHVhbGx5IHBsYXlpbmdcblxuXG4gICAgaWYgKCFhdXRvTGV2ZWxFbmFibGVkIHx8IG1lZGlhLnBhdXNlZCB8fCAhbWVkaWEucGxheWJhY2tSYXRlIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3REZWxheSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKTsgLy8gSW4gb3JkZXIgdG8gd29yayB3aXRoIGEgc3RhYmxlIGJhbmR3aWR0aCwgb25seSBiZWdpbiBtb25pdG9yaW5nIGJhbmR3aWR0aCBhZnRlciBoYWxmIG9mIHRoZSBmcmFnbWVudCBoYXMgYmVlbiBsb2FkZWRcblxuICAgIGlmIChyZXF1ZXN0RGVsYXkgPD0gNTAwICogZHVyYXRpb24gLyBwbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgbWluQXV0b0xldmVsID0gaGxzLm1pbkF1dG9MZXZlbDtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgdmFyIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgfHwgTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGR1cmF0aW9uICogbGV2ZWwubWF4Qml0cmF0ZSAvIDgpKTtcbiAgICB2YXIgbG9hZFJhdGUgPSBNYXRoLm1heCgxLCBzdGF0cy5id0VzdGltYXRlID8gc3RhdHMuYndFc3RpbWF0ZSAvIDggOiBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gcmVxdWVzdERlbGF5KTsgLy8gZnJhZ0xvYWREZWxheSBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGJ1ZmZlciB0aGUgZW50aXJlIGZyYWdtZW50XG5cbiAgICB2YXIgZnJhZ0xvYWRlZERlbGF5ID0gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlO1xuICAgIHZhciBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTsgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuXG4gICAgdmFyIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA9IChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIHBvcywgY29uZmlnLm1heEJ1ZmZlckhvbGUpLmVuZCAtIHBvcykgLyBwbGF5YmFja1JhdGU7IC8vIEF0dGVtcHQgYW4gZW1lcmdlbmN5IGRvd25zd2l0Y2ggb25seSBpZiBsZXNzIHRoYW4gMiBmcmFnbWVudCBsZW5ndGhzIGFyZSBidWZmZXJlZCwgYW5kIHRoZSB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nXG4gICAgLy8gdGhlIGN1cnJlbnQgZnJhZ21lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYnVmZmVyIHdlIGhhdmUgbGVmdFxuXG4gICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA+PSAyICogZHVyYXRpb24gLyBwbGF5YmFja1JhdGUgfHwgZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG5leHRMb2FkTGV2ZWw7IC8vIEl0ZXJhdGUgdGhyb3VnaCBsb3dlciBsZXZlbCBhbmQgdHJ5IHRvIGZpbmQgdGhlIGxhcmdlc3Qgb25lIHRoYXQgYXZvaWRzIHJlYnVmZmVyaW5nXG5cbiAgICBmb3IgKG5leHRMb2FkTGV2ZWwgPSBmcmFnLmxldmVsIC0gMTsgbmV4dExvYWRMZXZlbCA+IG1pbkF1dG9MZXZlbDsgbmV4dExvYWRMZXZlbC0tKSB7XG4gICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAvLyAwLjggOiBjb25zaWRlciBvbmx5IDgwJSBvZiBjdXJyZW50IGJ3IHRvIGJlIGNvbnNlcnZhdGl2ZVxuICAgICAgLy8gOCA9IGJpdHMgcGVyIGJ5dGUgKGJwcy9CcHMpXG4gICAgICB2YXIgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlIC8gKDggKiAwLjggKiBsb2FkUmF0ZSk7XG5cbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgLy8gdG8gbG9hZCB0aGUgY3VycmVudCBvbmVcblxuXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYndFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0ud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgaXMgbG9hZGluZyB0b28gc2xvd2x5IGFuZCB3aWxsIGNhdXNlIGFuIHVuZGVyYnVmZmVyOyBhYm9ydGluZyBhbmQgc3dpdGNoaW5nIHRvIGxldmVsIFwiICsgbmV4dExvYWRMZXZlbCArIFwiXFxuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogXCIgKyAoT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGJ3RXN0aW1hdGUpID8gKGJ3RXN0aW1hdGUgLyAxMDI0KS50b0ZpeGVkKDMpIDogJ1Vua25vd24nKSArIFwiIEtiL3NcXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiBcIiArIGZyYWdMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIHRoZSBuZXh0IGZyYWdtZW50OiBcIiArIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6IFwiICsgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LnRvRml4ZWQoMykgKyBcIiBzXCIpO1xuICAgIGhscy5uZXh0TG9hZExldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShyZXF1ZXN0RGVsYXksIHN0YXRzLmxvYWRlZCk7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG5cbiAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICAgIGZyYWcubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICBzdGF0czogc3RhdHNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIHBhcnQgPSBfcmVmLnBhcnQ7XG5cbiAgICBpZiAoZnJhZy50eXBlID09PSAnbWFpbicgJiYgT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWcuc24pKSB7XG4gICAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247IC8vIHN0b3AgbW9uaXRvcmluZyBidyBvbmNlIGZyYWcgbG9hZGVkXG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyBzdG9yZSBsZXZlbCBpZCBhZnRlciBzdWNjZXNzZnVsIGZyYWdtZW50IGxvYWRcblxuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDsgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcblxuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xOyAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgIHZhciBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHtcbiAgICAgICAgICBieXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHZhciBmcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG5cbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuXG5cbiAgICBpZiAoZnJhZy50eXBlICE9PSAnbWFpbicgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBVc2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBwYXJzaW5nIGFuZCByZXF1ZXN0IGluc3RlYWQgb2YgYnVmZmVyaW5nIGFuZCByZXF1ZXN0IHRvIGNvbXB1dGUgZnJhZ0xvYWRpbmdQcm9jZXNzaW5nO1xuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgIC8vIGlzIHVzZWQuIElmIHdlIHVzZWQgYnVmZmVyaW5nIGluIHRoYXQgY2FzZSwgb3VyIEJXIGVzdGltYXRlIHNhbXBsZSB3aWxsIGJlIHZlcnkgbGFyZ2UuXG5cblxuICAgIHZhciBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG5cbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gcHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gc3RvcCB0aW1lciBpbiBjYXNlIG9mIGZyYWcgbG9hZGluZyBlcnJvclxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyVGltZXIgPSBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICB9IC8vIHJldHVybiBuZXh0IGF1dG8gbGV2ZWxcbiAgO1xuXG4gIF9wcm90by5nZXROZXh0QUJSQXV0b0xldmVsID0gZnVuY3Rpb24gZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBtYXhBdXRvTGV2ZWwgPSBobHMubWF4QXV0b0xldmVsLFxuICAgICAgICBjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsLFxuICAgICAgICBtZWRpYSA9IGhscy5tZWRpYTtcbiAgICB2YXIgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICB2YXIgcG9zID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7IC8vIHBsYXliYWNrUmF0ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHBsYXliYWNrIHJhdGU7IGlmIG1lZGlhLnBsYXliYWNrUmF0ZSBpcyAwLCB3ZSB1c2UgMSB0byBsb2FkIGFzXG4gICAgLy8gaWYgd2UncmUgcGxheWluZyBiYWNrIGF0IHRoZSBub3JtYWwgcmF0ZS5cblxuICAgIHZhciBwbGF5YmFja1JhdGUgPSBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgIHZhciBhdmdidyA9IHRoaXMuYndFc3RpbWF0b3IgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTsgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cblxuICAgIHZhciBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSAoX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKG1lZGlhLCBwb3MsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKS5lbmQgLSBwb3MpIC8gcGxheWJhY2tSYXRlOyAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuXG4gICAgdmFyIGJlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgY29uZmlnLmFickJhbmRXaWR0aEZhY3RvciwgY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yKTtcblxuICAgIGlmIChiZXN0TGV2ZWwgPj0gMCkge1xuICAgICAgcmV0dXJuIGJlc3RMZXZlbDtcbiAgICB9XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0udHJhY2UoKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA/ICdyZWJ1ZmZlcmluZyBleHBlY3RlZCcgOiAnYnVmZmVyIGlzIGVtcHR5JykgKyBcIiwgZmluZGluZyBvcHRpbWFsIHF1YWxpdHkgbGV2ZWxcIik7IC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nIC4uLiBsZXQncyB0cnkgdG8gZmluZCBsZXZlbCB0aGF0IHdpbGwgZ3VhcmFudGVlIGxlc3MgdGhhbiBtYXhTdGFydmF0aW9uRGVsYXkgb2YgcmVidWZmZXJpbmdcbiAgICAvLyBpZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgbG9naWMgd2lsbCByZXR1cm4gMFxuXG4gICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgdmFyIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICB2YXIgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICB2YXIgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcblxuICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgdmFyIG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4TG9hZGluZ0RlbGF5KSA6IGNvbmZpZy5tYXhMb2FkaW5nRGVsYXk7XG4gICAgICAgIG1heFN0YXJ2YXRpb25EZWxheSA9IG1heExvYWRpbmdEZWxheSAtIGJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImxvZ2dlclwiXS50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiICsgTWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSkgKyBcIm1zLCBzZXQgZmlyc3QgZnJhZ21lbnQgbWF4IGZldGNoRHVyYXRpb24gdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXkpICsgXCIgbXNcIik7IC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuXG4gICAgICAgIGJ3RmFjdG9yID0gYndVcEZhY3RvciA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcik7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJlc3RMZXZlbCwgMCk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbmRCZXN0TGV2ZWwgPSBmdW5jdGlvbiBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIG1heEZldGNoRHVyYXRpb24sIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuXG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgcGFydEN1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50LFxuICAgICAgICBjdXJyZW50TGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbY3VycmVudExldmVsXTtcbiAgICB2YXIgbGl2ZSA9ICEhKGxldmVsICE9PSBudWxsICYmIGxldmVsICE9PSB2b2lkIDAgJiYgKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgIT09IG51bGwgJiYgX2xldmVsJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfbGV2ZWwkZGV0YWlscy5saXZlKTtcbiAgICB2YXIgY3VycmVudENvZGVjU2V0ID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsLmNvZGVjU2V0O1xuICAgIHZhciBjdXJyZW50RnJhZ0R1cmF0aW9uID0gcGFydEN1cnJlbnQgPyBwYXJ0Q3VycmVudC5kdXJhdGlvbiA6IGZyYWdDdXJyZW50ID8gZnJhZ0N1cnJlbnQuZHVyYXRpb24gOiAwO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKCFsZXZlbEluZm8gfHwgY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICB2YXIgYXZnRHVyYXRpb24gPSAocGFydEN1cnJlbnQgPyBsZXZlbERldGFpbHMgPT09IG51bGwgfHwgbGV2ZWxEZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICB2YXIgYWRqdXN0ZWRidyA9IHZvaWQgMDsgLy8gZm9sbG93IGFsZ29yaXRobSBjYXB0dXJlZCBmcm9tIHN0YWdlZnJpZ2h0IDpcbiAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAvLyBQaWNrIHRoZSBoaWdoZXN0IGJhbmR3aWR0aCBzdHJlYW0gYmVsb3cgb3IgZXF1YWwgdG8gZXN0aW1hdGVkIGJhbmR3aWR0aC5cbiAgICAgIC8vIGNvbnNpZGVyIG9ubHkgODAlIG9mIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoLCBidXQgaWYgd2UgYXJlIHN3aXRjaGluZyB1cCxcbiAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAvLyBzd2l0Y2hpbmcgYmFjay5cblxuICAgICAgaWYgKGkgPD0gY3VycmVudExldmVsKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICB2YXIgYml0cmF0ZSA9IGxldmVsc1tpXS5tYXhCaXRyYXRlO1xuICAgICAgdmFyIGZldGNoRHVyYXRpb24gPSBiaXRyYXRlICogYXZnRHVyYXRpb24gLyBhZGp1c3RlZGJ3O1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLnRyYWNlKFwibGV2ZWwvYWRqdXN0ZWRidy9iaXRyYXRlL2F2Z0R1cmF0aW9uL21heEZldGNoRHVyYXRpb24vZmV0Y2hEdXJhdGlvbjogXCIgKyBpICsgXCIvXCIgKyBNYXRoLnJvdW5kKGFkanVzdGVkYncpICsgXCIvXCIgKyBiaXRyYXRlICsgXCIvXCIgKyBhdmdEdXJhdGlvbiArIFwiL1wiICsgbWF4RmV0Y2hEdXJhdGlvbiArIFwiL1wiICsgZmV0Y2hEdXJhdGlvbik7IC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuXG4gICAgICBpZiAoYWRqdXN0ZWRidyA+IGJpdHJhdGUgJiYgKCAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IHN0YXJ0TGV2ZWwgPSAtMSAoYml0cmF0ZVRlc3QpIG9uIGxpdmUgc3RyZWFtcyA6IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgbm90IGV4aXQgbG9vcCBzbyB0aGF0IGZpbmRCZXN0TGV2ZWwgd2lsbCByZXR1cm4gLTFcbiAgICAgICFmZXRjaER1cmF0aW9uIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbikpIHtcbiAgICAgICAgLy8gYXMgd2UgYXJlIGxvb3BpbmcgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCwgdGhpcyB3aWxsIHJldHVybiB0aGUgYmVzdCBhY2hpZXZhYmxlIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfSAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuXG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEFickNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcIm5leHRBdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmb3JjZWRBdXRvTGV2ZWwgPSB0aGlzLl9uZXh0QXV0b0xldmVsO1xuICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjsgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcblxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEgJiYgKCFid0VzdGltYXRvciB8fCAhYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH0gLy8gY29tcHV0ZSBuZXh0IGxldmVsIHVzaW5nIEFCUiBsb2dpY1xuXG5cbiAgICAgIHZhciBuZXh0QUJSQXV0b0xldmVsID0gdGhpcy5nZXROZXh0QUJSQXV0b0xldmVsKCk7IC8vIGlmIGZvcmNlZCBhdXRvIGxldmVsIGhhcyBiZWVuIGRlZmluZWQsIHVzZSBpdCB0byBjYXAgQUJSIGNvbXB1dGVkIHF1YWxpdHkgbGV2ZWxcblxuICAgICAgaWYgKGZvcmNlZEF1dG9MZXZlbCAhPT0gLTEpIHtcbiAgICAgICAgbmV4dEFCUkF1dG9MZXZlbCA9IE1hdGgubWluKGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBYnJDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEFickNvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xldmVsICovIFwiLi9zcmMvdHlwZXMvbGV2ZWwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy90cmFuc211eGVyICovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtZmluZGVycyAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGlzY29udGludWl0aWVzICovIFwiLi9zcmMvdXRpbHMvZGlzY29udGludWl0aWVzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nYXBfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2FwLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXVkaW9TdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5yZXRyeURhdGUgPSAwO1xuICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy52aWRlb1RyYWNrQ0MgPSAtMTtcbiAgICBfdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgIF90aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICBfdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl0oaGxzLmNvbmZpZyk7XG5cbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBdWRpb1N0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9IC8vIElOSVRfUFRTX0ZPVU5EIGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB2aWRlbyB0cmFjayBwYXJzZWQgaW4gdGhlIHN0cmVhbS1jb250cm9sbGVyIGhhcyBhIG5ldyBQVFMgdmFsdWVcbiAgO1xuXG4gIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgICAgaW5pdFBUUyA9IF9yZWYuaW5pdFBUUztcblxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICB2YXIgY2MgPSBmcmFnLmNjO1xuICAgICAgdGhpcy5pbml0UFRTW2ZyYWcuY2NdID0gaW5pdFBUUztcbiAgICAgIHRoaXMubG9nKFwiSW5pdFBUUyBmb3IgY2M6IFwiICsgY2MgKyBcIiBmb3VuZCBmcm9tIG1haW46IFwiICsgaW5pdFBUUyk7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IGNjOyAvLyBJZiB3ZSBhcmUgd2FpdGluZywgdGljayBpbW1lZGlhdGVseSB0byB1bmJsb2NrIGF1ZGlvIGZyYWdtZW50IHRyYW5zbXV4aW5nXG5cbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uU1RPUFBFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcblxuICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA/IHRoaXMuc3RhcnRQb3NpdGlvbiA6IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfVFJBQ0s7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfVFJBQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyR0cmFja0lkO1xuXG4gICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxzID09PSBudWxsIHx8IGxldmVscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9sZXZlbHMkdHJhY2tJZCA9IGxldmVsc1t0cmFja0lkXSkgPT09IG51bGwgfHwgX2xldmVscyR0cmFja0lkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxzJHRyYWNrSWQuZGV0YWlscztcblxuICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG5cbiAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlOyAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPT0gbnVsbCAmJiBfdGhpcyRtZWRpYSAhPT0gdm9pZCAwICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdSZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgIHZhciB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG5cbiAgICAgICAgICBpZiAod2FpdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gd2FpdGluZ0RhdGEuZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0ID0gd2FpdGluZ0RhdGEucGFydCxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHdhaXRpbmdEYXRhLmNhY2hlLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gd2FpdGluZ0RhdGEuY29tcGxldGU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbZnJhZy5jY10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gY2FjaGUuZmx1c2goKTtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcblxuICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSB0aGlzLndhaXRpbmdWaWRlb0NDKSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiB2aWRlb1RyYWNrQ0MgaGFzIGNoYW5nZWQgc2luY2Ugd2FpdGluZ0ZyYWdtZW50IHdhcyBzZXQgYW5kIGluaXRQVFMgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fW1wibG9nZ2VyXCJdLmxvZyhcIldhaXRpbmcgZnJhZ21lbnQgY2MgKFwiICsgZnJhZy5jYyArIFwiKSBjYW5jZWxsZWQgYmVjYXVzZSB2aWRlbyBpcyBhdCBjYyBcIiArIHRoaXMudmlkZW9UcmFja0NDKTtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIGFuIGVhcmxpZXIgZnJhZ21lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHRoaXMubWVkaWEuY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICAgICAgICB2YXIgd2FpdGluZ0ZyYWdtZW50QXRQb3NpdGlvbiA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdFwiXSkoYnVmZmVySW5mby5lbmQsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpO1xuXG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bXCJsb2dnZXJcIl0ubG9nKFwiV2FpdGluZyBmcmFnbWVudCBjYyAoXCIgKyBmcmFnLmNjICsgXCIpIEAgXCIgKyBmcmFnLnN0YXJ0ICsgXCIgY2FuY2VsbGVkIGJlY2F1c2UgYW5vdGhlciBmcmFnbWVudCBhdCBcIiArIGJ1ZmZlckluZm8uZW5kICsgXCIgaXMgbmVlZGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJXYWl0aW5nRnJhZ21lbnQgPSBmdW5jdGlvbiBjbGVhcldhaXRpbmdGcmFnbWVudCgpIHtcbiAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuXG4gICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25UaWNrRW5kID0gZnVuY3Rpb24gb25UaWNrRW5kKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICBpZiAoIW1lZGlhIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IG1lZGlhO1xuICAgIHZhciBidWZmZXJlZCA9IG1lZGlhQnVmZmVyLmJ1ZmZlcmVkO1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfTtcblxuICBfcHJvdG8uZG9UaWNrSWRsZSA9IGZ1bmN0aW9uIGRvVGlja0lkbGUoKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhLCBfZnJhZyRkZWNyeXB0ZGF0YTI7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG4gICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgdmlkZW8gbm90IGF0dGFjaGVkIEFORFxuICAgIC8vIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3BcbiAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG5cblxuICAgIGlmICghbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG5cbiAgICBpZiAoIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShwb3MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVsc1t0cmFja0lkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbEluZm8gPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgdmFyIHRyYWNrRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuXG4gICAgaWYgKCF0cmFja0RldGFpbHMgfHwgdHJhY2tEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IHRyYWNrSWQgfHwgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKHRyYWNrRGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19UUkFDSztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IHRyYWNrRGV0YWlscy5pbml0U2VnbWVudDtcbiAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IDA7XG5cbiAgICBpZiAoIWZyYWcgfHwgZnJhZy5kYXRhKSB7XG4gICAgICB2YXIgbWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICB2YXIgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICB2YXIgbWF4QnVmZmVySG9sZSA9IHBvcyA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlID8gTWF0aC5tYXgoX2dhcF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wiTUFYX1NUQVJUX0dBUF9KVU1QXCJdLCBjb25maWcubWF4QnVmZmVySG9sZSkgOiBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKG1lZGlhQnVmZmVyLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgdmFyIG1haW5CdWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKHZpZGVvQnVmZmVyLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgICAgdmFyIGJ1ZmZlckxlbiA9IGJ1ZmZlckluZm8ubGVuO1xuICAgICAgdmFyIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgdmFyIG1heEJ1ZkxlbiA9IE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckluZm8ubGVuKTtcbiAgICAgIHZhciBhdWRpb1N3aXRjaCA9IHRoaXMuYXVkaW9Td2l0Y2g7IC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1ZkxlbiAmJiAhYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF1ZGlvU3dpdGNoICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIHRyYWNrRGV0YWlscykpIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkJVRkZFUl9FT1MsIHtcbiAgICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVOREVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgdmFyIHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdGFyZ2V0QnVmZmVyVGltZSA9IGJ1ZmZlckluZm8uZW5kO1xuXG4gICAgICBpZiAoYXVkaW9Td2l0Y2gpIHtcbiAgICAgICAgdGFyZ2V0QnVmZmVyVGltZSA9IHBvczsgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuXG4gICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdBbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcblxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpID09PSBudWxsIHx8IF9mcmFnJGRlY3J5cHRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQpID09PSAnaWRlbnRpdHknICYmICEoKF9mcmFnJGRlY3J5cHRkYXRhMiA9IGZyYWcuZGVjcnlwdGRhdGEpICE9PSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhMiAhPT0gdm9pZCAwICYmIF9mcmFnJGRlY3J5cHRkYXRhMi5rZXkpKSB7XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcga2V5IGZvciBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyB0cmFja0RldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIHRyYWNrRGV0YWlscy5lbmRTTiArIFwiXSx0cmFjayBcIiArIHRyYWNrSWQpO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5LRVlfTE9BRElORztcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5LRVlfTE9BRElORywge1xuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrc1VwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gX3JlZjIuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJMZXZlbFwiXShtZWRpYVBsYXlsaXN0KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrU3dpdGNoaW5nID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIHZhciBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgdGhpcy50cmFja0lkID0gZGF0YS5pZDtcbiAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuXG4gICAgaWYgKGZyYWdDdXJyZW50ICE9PSBudWxsICYmIGZyYWdDdXJyZW50ICE9PSB2b2lkIDAgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICBmcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7IC8vIGRlc3Ryb3kgdXNlbGVzcyB0cmFuc211eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgfSAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG5cblxuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgdGhpcy5hdWRpb1N3aXRjaCA9IHRydWU7IC8vIG1haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcblxuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlNUT1BQRUQ7XG4gICAgfVxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLm1haW5EZXRhaWxzID09PSBudWxsKSB7XG4gICAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90cmFjayRkZXRhaWxzO1xuXG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzLFxuICAgICAgICB0cmFja0lkID0gZGF0YS5pZDtcblxuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgdHJhY2tJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2coXCJUcmFjayBcIiArIHRyYWNrSWQgKyBcIiBsb2FkZWQgW1wiICsgbmV3RGV0YWlscy5zdGFydFNOICsgXCIsXCIgKyBuZXdEZXRhaWxzLmVuZFNOICsgXCJdLGR1cmF0aW9uOlwiICsgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICB2YXIgdHJhY2sgPSBsZXZlbHNbdHJhY2tJZF07XG4gICAgdmFyIHNsaWRpbmcgPSAwO1xuXG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX3RyYWNrJGRldGFpbHMgPSB0cmFjay5kZXRhaWxzKSAhPT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscyAhPT0gdm9pZCAwICYmIF90cmFjayRkZXRhaWxzLmxpdmUpIHtcbiAgICAgIHZhciBfdGhpcyRtYWluRGV0YWlscztcblxuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrLmRldGFpbHMgJiYgKF90aGlzJG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscykgIT09IG51bGwgJiYgX3RoaXMkbWFpbkRldGFpbHMgIT09IHZvaWQgMCAmJiBfdGhpcyRtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgT2JqZWN0KF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJhbGlnblBEVFwiXSkobmV3RGV0YWlscywgdGhpcy5tYWluRGV0YWlscyk7XG4gICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2tJZDsgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvblxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH0gLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcblxuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9kZXRhaWxzJGluaXRTZWdtZW50O1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQsXG4gICAgICAgIHBheWxvYWQgPSBkYXRhLnBheWxvYWQ7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkLFxuICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGNvbnNvbGUuYXNzZXJ0KHRyYWNrLCAnQXVkaW8gdHJhY2sgaXMgZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgdmFyIGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgIGNvbnNvbGUuYXNzZXJ0KGRldGFpbHMsICdBdWRpbyB0cmFjayBkZXRhaWxzIGFyZSBkZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3MnKTtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuXG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImRlZmF1bHRcIl0odGhpcy5obHMsIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLkFVRElPLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICB9IC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgIC8vIElmIG5vdCB3ZSBuZWVkIHRvIHdhaXQgZm9yIGl0XG5cblxuICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2RldGFpbHMkaW5pdFNlZ21lbnQgPSBkZXRhaWxzLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZGV0YWlscyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RldGFpbHMkaW5pdFNlZ21lbnQuZGF0YTtcblxuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBmYWxzZTsgLy8gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuXG4gICAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICAgIHZhciBwYXJ0aWFsID0gcGFydEluZGV4ICE9PSAtMTtcbiAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJDaHVua01ldGFkYXRhXCJdKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgJycsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fW1wibG9nZ2VyXCJdLmxvZyhcIlVua25vd24gdmlkZW8gUFRTIGZvciBjYyBcIiArIGZyYWcuY2MgKyBcIiwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnIFwiICsgZnJhZy5zbiArIFwiIG9mIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiICxcIiArIGRldGFpbHMuZW5kU04gKyBcIl0sdHJhY2sgXCIgKyB0cmFja0lkKTtcblxuICAgICAgdmFyIF90aGlzJHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IF9kZW11eF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZGVmYXVsdFwiXSgpLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICAgICAgY2FjaGUgPSBfdGhpcyR3YWl0aW5nRGF0YS5jYWNoZTtcblxuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRGF0YSkge1xuICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUuY2FsbCh0aGlzLCBmcmFnTG9hZGVkRGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2sgPSBkYXRhLnRyYWNrcy5hdWRpbztcblxuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEudHJhY2tzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuXG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUgb3IgY29uY2x1ZGluZyB0aGUgYXVkaW8gc3dpdGNoOyBvdGhlcndpc2UsIHRoZSBzd2l0Y2hlZC10byB0cmFjayB3aWxsIG5vdCBidWZmZXJcbiAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIsIGF1ZGlvU3dpdGNoOiBcIiArIHRoaXMuYXVkaW9Td2l0Y2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuYXVkaW9Td2l0Y2ggPSBmYWxzZTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB7XG4gICAgICAgIGlkOiB0aGlzLnRyYWNrSWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZzsgLy8gZG9uJ3QgaGFuZGxlIGZyYWcgZXJyb3Igbm90IHJlbGF0ZWQgdG8gYXVkaW8gZnJhZ21lbnRcblxuICAgIGlmIChmcmFnICYmIGZyYWcudHlwZSAhPT0gJ2F1ZGlvJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9mcmFnID0gZGF0YS5mcmFnOyAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBhdWRpbyBmcmFnbWVudFxuXG4gICAgICAgICAgaWYgKF9mcmFnICYmIF9mcmFnLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGF0YS5mYXRhbCkge1xuICAgICAgICAgICAgdmFyIGxvYWRFcnJvciA9IHRoaXMuZnJhZ0xvYWRFcnJvcjtcblxuICAgICAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgICBsb2FkRXJyb3IrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvYWRFcnJvciA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvYWRFcnJvciA8PSBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSkge1xuICAgICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSBsb2FkRXJyb3I7IC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dFxuXG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIGxvYWRFcnJvciAtIDEpICogY29uZmlnLmZyYWdMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKFwiRnJhZyBsb2FkaW5nIGZhaWxlZCwgcmV0cnkgaW4gXCIgKyBkZWxheSArIFwiIG1zXCIpO1xuICAgICAgICAgICAgICB0aGlzLnJldHJ5RGF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7IC8vIHJldHJ5IGxvYWRpbmcgc3RhdGVcblxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1tcImxvZ2dlclwiXS5lcnJvcihkYXRhLmRldGFpbHMgKyBcIiByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5cIik7IC8vIHN3aXRjaCBlcnJvciB0byBmYXRhbFxuXG4gICAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1tcIkVycm9yRGV0YWlsc1wiXS5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1wiRXJyb3JEZXRhaWxzXCJdLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAvLyAgd2hlbiBpbiBFUlJPUiBzdGF0ZSwgZG9uJ3Qgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpbiBjYXNlIGEgbm9uLWZhdGFsIGVycm9yIGlzIHJlY2VpdmVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRVJST1IgJiYgdGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlNUT1BQRUQpIHtcbiAgICAgICAgICAvLyBpZiBmYXRhbCBlcnJvciwgc3RvcCBwcm9jZXNzaW5nLCBvdGhlcndpc2UgbW92ZSB0byBJRExFIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICB0aGlzLnN0YXRlID0gZGF0YS5mYXRhbCA/IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FUlJPUiA6IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIHRoaXMud2FybihkYXRhLmRldGFpbHMgKyBcIiB3aGlsZSBsb2FkaW5nIGZyYWcsIHN3aXRjaGluZyB0byBcIiArIHRoaXMuc3RhdGUgKyBcIiBzdGF0ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIC8vIGlmIGluIGFwcGVuZGluZyBzdGF0ZVxuICAgICAgICBpZiAoZGF0YS5wYXJlbnQgPT09ICdhdWRpbycgJiYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTSU5HIHx8IHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5QQVJTRUQpKSB7XG4gICAgICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlcjtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgICAgIHZhciBtZWRpYUJ1ZmZlcmVkID0gbWVkaWEgJiYgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSkgJiYgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkJ1ZmZlckhlbHBlclwiXS5pc0J1ZmZlcmVkKG1lZGlhLCBjdXJyZW50VGltZSArIDAuNSk7IC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG5cbiAgICAgICAgICBpZiAobWVkaWFCdWZmZXJlZCkge1xuICAgICAgICAgICAgdmFyIF9jb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICAgICAgaWYgKF9jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IF9jb25maWcubWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgICAgICAgICBfY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgICAgICAgICB0aGlzLndhcm4oXCJSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gXCIgKyBfY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCArIFwic1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICAgICAgdGhpcy53YXJuKCdCdWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggYXVkaW8gYnVmZmVyJyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDsgLy8gZmx1c2ggZXZlcnl0aGluZ1xuXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuXG4gICAgLyogYWZ0ZXIgc3VjY2Vzc2Z1bCBidWZmZXIgZmx1c2hpbmcsIGZpbHRlciBmbHVzaGVkIGZyYWdtZW50cyBmcm9tIGJ1ZmZlcmVkRnJhZ3NcbiAgICAgIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWEgKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICAqL1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcblxuICAgIGlmIChtZWRpYSAmJiB0eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8pIHtcbiAgICAgIC8vIGZpbHRlciBmcmFnbWVudHMgcG90ZW50aWFsbHkgZXZpY3RlZCBmcm9tIGJ1ZmZlci4gdGhpcyBpcyB0byBhdm9pZCBtZW1sZWFrIG9uIGxpdmUgc3RyZWFtc1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8sIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpKTtcbiAgICB9IC8vIHJlc2V0IHJlZmVyZW5jZSB0byBmcmFnXG5cblxuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDsgLy8gbW92ZSB0byBJRExFIG9uY2UgZmx1c2ggY29tcGxldGUuIHRoaXMgc2hvdWxkIHRyaWdnZXIgbmV3IGZyYWdtZW50IGxvYWRpbmdcblxuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG5cbiAgICB2YXIgaWQgPSAnYXVkaW8nO1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0cmFuc211eFJlc3VsdC5yZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhID0gdHJhbnNtdXhSZXN1bHQuY2h1bmtNZXRhO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLndhcm4oXCJUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBjaHVua01ldGEubGV2ZWwgKyBcIi4gVGhpcyBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIHBhcnQgPSBjb250ZXh0LnBhcnQ7XG4gICAgdmFyIGF1ZGlvID0gcmVtdXhSZXN1bHQuYXVkaW8sXG4gICAgICAgIHRleHQgPSByZW11eFJlc3VsdC50ZXh0LFxuICAgICAgICBpZDMgPSByZW11eFJlc3VsdC5pZDMsXG4gICAgICAgIGluaXRTZWdtZW50ID0gcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7IC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNJTkc7XG5cbiAgICBpZiAodGhpcy5hdWRpb1N3aXRjaCAmJiBhdWRpbykge1xuICAgICAgdGhpcy5jb21wbGV0ZUF1ZGlvU3dpdGNoKCk7XG4gICAgfVxuXG4gICAgaWYgKGluaXRTZWdtZW50ICE9PSBudWxsICYmIGluaXRTZWdtZW50ICE9PSB2b2lkIDAgJiYgaW5pdFNlZ21lbnQudHJhY2tzKSB7XG4gICAgICB0aGlzLl9idWZmZXJJbml0U2VnbWVudChpbml0U2VnbWVudC50cmFja3MsIGZyYWcsIGNodW5rTWV0YSk7XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgIH0pOyAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICB9XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIHZhciBzdGFydFBUUyA9IGF1ZGlvLnN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyA9IGF1ZGlvLmVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyA9IGF1ZGlvLnN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUUyA9IGF1ZGlvLmVuZERUUztcblxuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU9dID0ge1xuICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFM6IGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTOiBlbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoYXVkaW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSk7XG4gICAgfVxuXG4gICAgaWYgKGlkMyAhPT0gbnVsbCAmJiBpZDMgIT09IHZvaWQgMCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9PSBudWxsICYmIF9pZDMkc2FtcGxlcyAhPT0gdm9pZCAwICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbWl0dGVkSUQzID0gX2V4dGVuZHMoe1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBpZDogaWRcbiAgICAgIH0sIGlkMyk7XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgZW1pdHRlZFRleHQgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGlkOiBpZFxuICAgICAgfSwgdGV4dCk7XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9idWZmZXJJbml0U2VnbWVudCA9IGZ1bmN0aW9uIF9idWZmZXJJbml0U2VnbWVudCh0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyB0cmFuc211eGVyXG5cblxuICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgfSAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuXG5cbiAgICB2YXIgdHJhY2sgPSB0cmFja3MuYXVkaW87XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJhY2subGV2ZWxDb2RlYyA9IHRyYWNrLmNvZGVjO1xuICAgIHRyYWNrLmlkID0gJ2F1ZGlvJztcbiAgICB0aGlzLmxvZyhcIkluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyB0cmFjay5jb250YWluZXIgKyBcIiwgY29kZWNzW3BhcnNlZF09W1wiICsgdHJhY2suY29kZWMgKyBcIl1cIik7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcblxuICAgIGlmIChpbml0U2VnbWVudCAhPT0gbnVsbCAmJiBpbml0U2VnbWVudCAhPT0gdm9pZCAwICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBkYXRhOiBpbml0U2VnbWVudCxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9IC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcblxuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZCBvciBpZiBpbiBhdWRpbyBzd2l0Y2hcbiAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7IC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcblxuICAgIGlmICh0aGlzLmF1ZGlvU3dpdGNoIHx8IGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tEZXRhaWxzLmxpdmUgJiYgIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLmluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciBcIiArIGZyYWcuY2MgKyBcIiBvZiBsaXZlIHN0cmVhbSBiZWZvcmUgbG9hZGluZyBhdWRpbyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIHRoaXMudHJhY2tJZCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19JTklUX1BUUztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydCArIGZyYWcuZHVyYXRpb247XG5cbiAgICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5sb2FkRnJhZ21lbnQuY2FsbCh0aGlzLCBmcmFnLCB0cmFja0RldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGxldGVBdWRpb1N3aXRjaCA9IGZ1bmN0aW9uIGNvbXBsZXRlQXVkaW9Td2l0Y2goKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLnRyYWNrSWQ7XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYXVkaW8gdHJhY2sgOiBmbHVzaGluZyBhbGwgYXVkaW8nKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB0eXBlOiAnYXVkaW8nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmF1ZGlvU3dpdGNoID0gZmFsc2U7XG4gICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB7XG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG59KF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBdWRpb1N0cmVhbUNvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYXVkaW8tdHJhY2stY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX3BsYXlsaXN0X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXG5cblxuXG5cbnZhciBBdWRpb1RyYWNrQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VQbGF5bGlzdENvbnRyb2xsKSB7XG4gIF9pbmhlcml0c0xvb3NlKEF1ZGlvVHJhY2tDb250cm9sbGVyLCBfQmFzZVBsYXlsaXN0Q29udHJvbGwpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tDb250cm9sbGVyKGhscykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICBfdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG5cbiAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEF1ZGlvVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgfTtcblxuICBfcHJvdG8ub25BdWRpb1RyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcblxuICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkIFwiICsgaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJEZXRhaWxzID0gY3VycmVudFRyYWNrLmRldGFpbHM7XG4gICAgY3VycmVudFRyYWNrLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdGhpcy5sb2coXCJhdWRpb1RyYWNrIFwiICsgaWQgKyBcIiBsb2FkZWQgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdXCIpO1xuXG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gYSBsZXZlbCBpcyBsb2FkaW5nLCBpZiBpdCBoYXMgcmVkdW5kYW50IGF1ZGlvR3JvdXBJZHMgKGluIHRoZSBzYW1lIG9yZGluYWxpdHkgYXMgaXQncyByZWR1bmRhbnQgVVJMcylcbiAgICogd2UgYXJlIHNldHRpbmcgb3VyIGF1ZGlvLWdyb3VwIElEIGludGVybmFsbHkgdG8gdGhlIG9uZSBzZXQsIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBncm91cCBJRCBjdXJyZW50bHkgc2V0LlxuICAgKlxuICAgKiBJZiBncm91cC1JRCBnb3QgdXBkYXRlLCB3ZSByZS1zZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGF1ZGlvLXRyYWNrIHdpdGggdGhpcyBncm91cC1JRCBtYXRjaGluZyB0aGUgY3VycmVudGx5XG4gICAqIHNlbGVjdGVkIG9uZSAoYmFzZWQgb24gTkFNRSBwcm9wZXJ0eSkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xuXG4gICAgaWYgKCEobGV2ZWxJbmZvICE9PSBudWxsICYmIGxldmVsSW5mbyAhPT0gdm9pZCAwICYmIGxldmVsSW5mby5hdWRpb0dyb3VwSWRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdWRpb0dyb3VwSWQgPSBsZXZlbEluZm8uYXVkaW9Hcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICB0aGlzLmdyb3VwSWQgPSBhdWRpb0dyb3VwSWQ7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9Hcm91cElkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDtcbiAgICAgIH0pOyAvLyBEaXNhYmxlIHNlbGVjdERlZmF1bHRUcmFjayBpZiB0aGVyZSBhcmUgbm8gZGVmYXVsdCB0cmFja3NcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suZGVmYXVsdDtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzVXBkYXRlZCA9IHtcbiAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBhdWRpbyB0cmFja3MsIFwiICsgYXVkaW9UcmFja3MubGVuZ3RoICsgXCIgdHJhY2socykgZm91bmQgaW4gXFxcIlwiICsgYXVkaW9Hcm91cElkICsgXCJcXFwiIGdyb3VwLWlkXCIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tTX1VQREFURUQsIGF1ZGlvVHJhY2tzVXBkYXRlZCk7XG4gICAgICB0aGlzLnNlbGVjdEluaXRpYWxUcmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMucmV0cnlMb2FkaW5nT3JGYWlsKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2V0QXVkaW9UcmFjayA9IGZ1bmN0aW9uIHNldEF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICB2YXIgX3RyYWNrcyRuZXdJZDtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7IC8vIG5vb3Agb24gc2FtZSBhdWRpbyB0cmFjayBpZCBhcyBhbHJlYWR5IHNldFxuXG4gICAgaWYgKHRoaXMudHJhY2tJZCA9PT0gbmV3SWQgJiYgKF90cmFja3MkbmV3SWQgPSB0cmFja3NbbmV3SWRdKSAhPT0gbnVsbCAmJiBfdHJhY2tzJG5ld0lkICE9PSB2b2lkIDAgJiYgX3RyYWNrcyRuZXdJZC5kZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcblxuXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oJ0ludmFsaWQgaWQgcGFzc2VkIHRvIGF1ZGlvLXRyYWNrIGNvbnRyb2xsZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuXG5cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB2YXIgbGFzdFRyYWNrID0gdHJhY2tzW3RoaXMudHJhY2tJZF07XG4gICAgdmFyIHRyYWNrID0gdHJhY2tzW25ld0lkXTtcbiAgICB0aGlzLmxvZyhcIk5vdyBzd2l0Y2hpbmcgdG8gYXVkaW8tdHJhY2sgaW5kZXggXCIgKyBuZXdJZCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdmFyIHVybCA9IHRyYWNrLnVybCxcbiAgICAgICAgdHlwZSA9IHRyYWNrLnR5cGUsXG4gICAgICAgIGlkID0gdHJhY2suaWQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENISU5HLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICB9O1xuXG4gIF9wcm90by5zZWxlY3RJbml0aWFsVHJhY2sgPSBmdW5jdGlvbiBzZWxlY3RJbml0aWFsVHJhY2soKSB7XG4gICAgdmFyIF9hdWRpb1RyYWNrcyR0aGlzJHRyYTtcblxuICAgIHZhciBhdWRpb1RyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zb2xlLmFzc2VydChhdWRpb1RyYWNrcy5sZW5ndGgsICdJbml0aWFsIGF1ZGlvIHRyYWNrIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRyYWNrcyBhcmUga25vd24nKTtcbiAgICB2YXIgY3VycmVudEF1ZGlvVHJhY2tOYW1lID0gKF9hdWRpb1RyYWNrcyR0aGlzJHRyYSA9IGF1ZGlvVHJhY2tzW3RoaXMudHJhY2tJZF0pID09PSBudWxsIHx8IF9hdWRpb1RyYWNrcyR0aGlzJHRyYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2F1ZGlvVHJhY2tzJHRoaXMkdHJhLm5hbWU7XG4gICAgdmFyIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRBdWRpb1RyYWNrTmFtZSkgfHwgdGhpcy5maW5kVHJhY2tJZCgpO1xuXG4gICAgaWYgKHRyYWNrSWQgIT09IC0xKSB7XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodHJhY2tJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihcIk5vIHRyYWNrIGZvdW5kIGZvciBydW5uaW5nIGF1ZGlvIGdyb3VwLUlEOiBcIiArIHRoaXMuZ3JvdXBJZCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmluZFRyYWNrSWQgPSBmdW5jdGlvbiBmaW5kVHJhY2tJZChuYW1lKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgfHwgdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFRyYWNrKGF1ZGlvVHJhY2spKSB7XG4gICAgICB2YXIgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgdmFyIGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gYXVkaW9UcmFjay51cmw7XG5cbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcblxuXG4gICAgICB0aGlzLmxvZyhcImxvYWRpbmcgYXVkaW8tdHJhY2sgcGxheWxpc3QgZm9yIGlkOiBcIiArIGlkKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhBdWRpb1RyYWNrQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwiYXVkaW9UcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgLy8gSWYgYXVkaW8gdHJhY2sgaXMgc2VsZWN0ZWQgZnJvbSBBUEkgdGhlbiBkb24ndCBjaG9vc2UgZnJvbSB0aGUgbWFuaWZlc3QgZGVmYXVsdCB0cmFja1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhuZXdJZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xufShfYmFzZV9wbGF5bGlzdF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBdWRpb1RyYWNrQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VQbGF5bGlzdENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGV2ZWwtaGVscGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcblxuXG5cblxuXG5cblxuXG52YXIgQmFzZVBsYXlsaXN0Q29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIoaGxzLCBsb2dQcmVmaXgpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nLmJpbmQoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgdGhpcy53YXJuID0gX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4uYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCYXNlUGxheWxpc3RDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgJiYgZGF0YS50eXBlID09PSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xlYXJUaW1lciA9IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9O1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9O1xuXG4gIF9wcm90by5zd2l0Y2hQYXJhbXMgPSBmdW5jdGlvbiBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzKSB7XG4gICAgdmFyIHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXMucmVuZGl0aW9uUmVwb3J0cztcblxuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbmRpdGlvblJlcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICB2YXIgdXJpID0gJycgKyBhdHRyLlVSSTtcblxuICAgICAgICBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zdWJzdHIoLXVyaS5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pO1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFyc2VJbnQoYXR0clsnTEFTVC1QQVJUJ10pO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzICYmIHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4ocHJldmlvdXMuYWdlIC0gcHJldmlvdXMucGFydFRhcmdldCwgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24pO1xuXG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtc24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiSGxzVXJsUGFyYW1ldGVyc1wiXShtc24sIE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShwYXJ0KSA/IHBhcnQgOiB1bmRlZmluZWQsIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiSGxzU2tpcFwiXS5Obyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge307XG5cbiAgX3Byb3RvLnNob3VsZExvYWRUcmFjayA9IGZ1bmN0aW9uIHNob3VsZExvYWRUcmFjayh0cmFjaykge1xuICAgIHJldHVybiB0aGlzLmNhbkxvYWQgJiYgdHJhY2sgJiYgISF0cmFjay51cmwgJiYgKCF0cmFjay5kZXRhaWxzIHx8IHRyYWNrLmRldGFpbHMubGl2ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsYXlsaXN0TG9hZGVkID0gZnVuY3Rpb24gcGxheWxpc3RMb2FkZWQoaW5kZXgsIGRhdGEsIHByZXZpb3VzRGV0YWlscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgc3RhdHMgPSBkYXRhLnN0YXRzOyAvLyBTZXQgbGFzdCB1cGRhdGVkIGRhdGUtdGltZVxuXG4gICAgdmFyIGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmVuZCA/IE1hdGgubWF4KDAsIHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGF0cy5sb2FkaW5nLmVuZCkgOiAwO1xuICAgIGRldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IERhdGUubm93KCkgLSBlbGFwc2VkOyAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG5cbiAgICBpZiAoZGV0YWlscy5saXZlIHx8IHByZXZpb3VzRGV0YWlscyAhPT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMgIT09IHZvaWQgMCAmJiBwcmV2aW91c0RldGFpbHMubGl2ZSkge1xuICAgICAgZGV0YWlscy5yZWxvYWRlZChwcmV2aW91c0RldGFpbHMpO1xuXG4gICAgICBpZiAocHJldmlvdXNEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMubG9nKFwibGl2ZSBwbGF5bGlzdCBcIiArIGluZGV4ICsgXCIgXCIgKyAoZGV0YWlscy5hZHZhbmNlZCA/ICdSRUZSRVNIRUQgJyArIGRldGFpbHMubGFzdFBhcnRTbiArICctJyArIGRldGFpbHMubGFzdFBhcnRJbmRleCA6ICdNSVNTRUQnKSk7XG4gICAgICB9IC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuXG5cbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJtZXJnZURldGFpbHNcIl0ocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcblxuICAgICAgICBpZiAoIWRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBwcmV2aW91c0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2FuTG9hZCB8fCAhZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiYgZGV0YWlscy5lbmRTTiAmJiBkZXRhaWxzLmFkdmFuY2VkKSB7XG4gICAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGk7XG5cbiAgICAgICAgLy8gTG9hZCBsZXZlbCB3aXRoIExMLUhMUyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIHZhciBsb3dMYXRlbmN5TW9kZSA9IHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0SW5kZXggPSBkZXRhaWxzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIHZhciBtc247XG4gICAgICAgIHZhciBwYXJ0O1xuXG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0SW5kZXggIT09IC0xID8gZGV0YWlscy5sYXN0UGFydFNuIDogZGV0YWlscy5lbmRTTiArIDE7XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0SW5kZXggIT09IC0xID8gbGFzdFBhcnRJbmRleCArIDEgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBwbGF5bGlzdCB1cGRhdGUgd2lsbCBiZSBsYXRlIGJ5IG9uZSBwYXJ0ICgwKS4gVGhlcmUgaXMgbm8gd2F5IHRvIGtub3cgdGhlIGxhc3QgcGFydCBudW1iZXIsXG4gICAgICAgICAgLy8gb3IgcmVxdWVzdCBqdXN0IHRoZSBuZXh0IHNuIHdpdGhvdXQgYSBwYXJ0IGluIG1vc3QgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgIG1zbiA9IGxhc3RQYXJ0SW5kZXggIT09IC0xID8gZGV0YWlscy5sYXN0UGFydFNuICsgMSA6IGRldGFpbHMuZW5kU04gKyAxO1xuICAgICAgICAgIHBhcnQgPSBsYXN0UGFydEluZGV4ICE9PSAtMSA/IDAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0gLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgLy8gVXBkYXRlIGRpcmVjdGl2ZXMgdG8gb2J0YWluIHRoZSBQbGF5bGlzdCB0aGF0IGhhcyB0aGUgZXN0aW1hdGVkIGFkZGl0aW9uYWwgZHVyYXRpb24gb2YgbWVkaWFcblxuXG4gICAgICAgIHZhciBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgdmFyIGNkbkFnZSA9IGxhc3RBZHZhbmNlZCArIGRldGFpbHMuYWdlSGVhZGVyO1xuICAgICAgICB2YXIgY3VycmVudEdvYWwgPSBNYXRoLm1pbihjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQsIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxLjUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50R29hbCA+IDApIHtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGF0dGVtcHRlZCB0byBnZXQgdGhlIG5leHQgb3IgbGF0ZXN0IHBsYXlsaXN0IHVwZGF0ZSwgYnV0IGN1cnJlbnRHb2FsIGluY3JlYXNlZCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZWl0aGVyIGNhbid0IGNhdGNodXAsIG9yIHRoZSBcImFnZVwiIGhlYWRlciBjYW5ub3QgYmUgdHJ1c3RlZC5cbiAgICAgICAgICAgIHRoaXMud2FybihcIkNETiBUdW5lLWluIGdvYWwgaW5jcmVhc2VkIGZyb206IFwiICsgcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwgKyBcIiB0bzogXCIgKyBjdXJyZW50R29hbCArIFwiIHdpdGggcGxheWxpc3QgYWdlOiBcIiArIGRldGFpbHMuYWdlKTtcbiAgICAgICAgICAgIGN1cnJlbnRHb2FsID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gTWF0aC5mbG9vcihjdXJyZW50R29hbCAvIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgbXNuICs9IHNlZ21lbnRzO1xuXG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IE1hdGgucm91bmQoY3VycmVudEdvYWwgJSBkZXRhaWxzLnRhcmdldGR1cmF0aW9uIC8gZGV0YWlscy5wYXJ0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgcGFydCArPSBwYXJ0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2coXCJDRE4gVHVuZS1pbiBhZ2U6IFwiICsgZGV0YWlscy5hZ2VIZWFkZXIgKyBcInMgbGFzdCBhZHZhbmNlZCBcIiArIGxhc3RBZHZhbmNlZC50b0ZpeGVkKDIpICsgXCJzIGdvYWw6IFwiICsgY3VycmVudEdvYWwgKyBcIiBza2lwIHNuIFwiICsgc2VnbWVudHMgKyBcIiB0byBwYXJ0IFwiICsgcGFydCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID0gY3VycmVudEdvYWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2tpcCA9IE9iamVjdChfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFNraXBWYWx1ZVwiXSkoZGV0YWlscywgbXNuKTtcblxuICAgICAgICBpZiAoKF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aSA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPT0gbnVsbCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkgIT09IHZvaWQgMCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkuc2tpcCkge1xuICAgICAgICAgIGlmIChkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgICAgICBtc24gPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICAgICAgICBwYXJ0ID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgICAgICAgIHNraXAgPSBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkhsc1NraXBcIl0uTm87XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QobmV3IF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiSGxzVXJsUGFyYW1ldGVyc1wiXShtc24sIHBhcnQsIHNraXApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29tcHV0ZVJlbG9hZEludGVydmFsXCJdKShkZXRhaWxzLCBzdGF0cyk7XG4gICAgICB0aGlzLmxvZyhcInJlbG9hZCBsaXZlIHBsYXlsaXN0IFwiICsgaW5kZXggKyBcIiBpbiBcIiArIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpICsgXCIgbXNcIik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgfSwgcmVsb2FkSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJldHJ5TG9hZGluZ09yRmFpbCA9IGZ1bmN0aW9uIHJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHZhciByZXRyeSA9IHRoaXMucmV0cnlDb3VudCA8IGNvbmZpZy5sZXZlbExvYWRpbmdNYXhSZXRyeTtcblxuICAgIGlmIChyZXRyeSkge1xuICAgICAgdmFyIF9lcnJvckV2ZW50JGNvbnRleHQ7XG5cbiAgICAgIHRoaXMucmV0cnlDb3VudCsrO1xuXG4gICAgICBpZiAoZXJyb3JFdmVudC5kZXRhaWxzLmluZGV4T2YoJ0xvYWRUaW1lT3V0JykgPiAtMSAmJiAoX2Vycm9yRXZlbnQkY29udGV4dCA9IGVycm9yRXZlbnQuY29udGV4dCkgIT09IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dCAhPT0gdm9pZCAwICYmIF9lcnJvckV2ZW50JGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oXCJyZXRyeSBwbGF5bGlzdCBsb2FkaW5nICNcIiArIHRoaXMucmV0cnlDb3VudCArIFwiIGFmdGVyIFxcXCJcIiArIGVycm9yRXZlbnQuZGV0YWlscyArIFwiXFxcIlwiKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgY2FwcGVkIHRvIG1heCByZXRyeSB0aW1lb3V0XG4gICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMucmV0cnlDb3VudCkgKiBjb25maWcubGV2ZWxMb2FkaW5nUmV0cnlEZWxheSwgY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dCk7IC8vIFNjaGVkdWxlIGxldmVsL3RyYWNrIHJlbG9hZFxuXG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIubG9hZFBsYXlsaXN0KCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgdGhpcy53YXJuKFwicmV0cnkgcGxheWxpc3QgbG9hZGluZyAjXCIgKyB0aGlzLnJldHJ5Q291bnQgKyBcIiBpbiBcIiArIGRlbGF5ICsgXCIgbXMgYWZ0ZXIgXFxcIlwiICsgZXJyb3JFdmVudC5kZXRhaWxzICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oXCJjYW5ub3QgcmVjb3ZlciBmcm9tIGVycm9yIFxcXCJcIiArIGVycm9yRXZlbnQuZGV0YWlscyArIFwiXFxcIlwiKTsgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG5cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpOyAvLyBzd2l0Y2ggZXJyb3IgdG8gZmF0YWxcblxuICAgICAgZXJyb3JFdmVudC5mYXRhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHJ5O1xuICB9O1xuXG4gIHJldHVybiBCYXNlUGxheWxpc3RDb250cm9sbGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFN0YXRlLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN0YXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3RhdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCYXNlU3RyZWFtQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGFza19sb29wX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90YXNrLWxvb3AgKi8gXCIuL3NyYy90YXNrLWxvb3AudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJhZ21lbnQtdHJhY2tlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvYnVmZmVyLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvdHJhbnNtdXhlciAqLyBcIi4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbXA0LXRvb2xzICovIFwiLi9zcmMvdXRpbHMvbXA0LXRvb2xzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kaXNjb250aW51aXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kaXNjb250aW51aXRpZXMgKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LWZpbmRlcnMgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY3J5cHQvZGVjcnlwdGVyICovIFwiLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190aW1lX3Jhbmdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RpbWUtcmFuZ2VzICovIFwiLi9zcmMvdXRpbHMvdGltZS1yYW5nZXMudHNcIik7XG5cblxuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgQkFDS1RSQUNLSU5HOiAnQkFDS1RSQUNLSU5HJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcblxudmFyIEJhc2VTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGFza0xvb3ApIHtcbiAgX2luaGVyaXRzTG9vc2UoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIF9UYXNrTG9vcCk7XG5cbiAgZnVuY3Rpb24gQmFzZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGxvZ1ByZWZpeCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1Rhc2tMb29wLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgX3RoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIF90aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIF90aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgX3RoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgX3RoaXMubWVkaWFCdWZmZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIF90aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgX3RoaXMubmV4dExvYWRQb3NpdGlvbiA9IDA7XG4gICAgX3RoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgX3RoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICBfdGhpcy5mcmFnTG9hZEVycm9yID0gMDtcbiAgICBfdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgIF90aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwO1xuICAgIF90aGlzLmxldmVsTGFzdExvYWRlZCA9IG51bGw7XG4gICAgX3RoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgX3RoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIF90aGlzLmluaXRQVFMgPSBbXTtcbiAgICBfdGhpcy5vbnZzZWVraW5nID0gbnVsbDtcbiAgICBfdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgX3RoaXMubG9nUHJlZml4ID0gJyc7XG4gICAgX3RoaXMubG9nID0gdm9pZCAwO1xuICAgIF90aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgX3RoaXMubG9nUHJlZml4ID0gbG9nUHJlZml4O1xuICAgIF90aGlzLmxvZyA9IF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImxvZ2dlclwiXS5sb2cuYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICBfdGhpcy53YXJuID0gX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wibG9nZ2VyXCJdLndhcm4uYmluZChfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJsb2dnZXJcIl0sIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICBfdGhpcy5obHMgPSBobHM7XG4gICAgX3RoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgX3RoaXMuZGVjcnlwdGVyID0gbmV3IF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJkZWZhdWx0XCJdKGhscywgaGxzLmNvbmZpZyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5LRVlfTE9BREVELCBfdGhpcy5vbktleUxvYWRlZCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9O1xuXG4gIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIDtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9O1xuXG4gIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmIChmcmFnKSB7XG4gICAgICBpZiAoZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgZnJhZy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICB9O1xuXG4gIF9wcm90by5fc3RyZWFtRW5kZWQgPSBmdW5jdGlvbiBfc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXI7IC8vIHdlIGp1c3QgZ290IGRvbmUgbG9hZGluZyB0aGUgZmluYWwgZnJhZ21lbnQgYW5kIHRoZXJlIGlzIG5vIG90aGVyIGJ1ZmZlcmVkIHJhbmdlIGFmdGVyIC4uLlxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGluIGNhc2UgdGhlcmUgYXJlIGFueSBidWZmZXJlZCByYW5nZXMgYWZ0ZXIsIGl0IG1lYW5zIHRoYXQgdGhlcmUgYXJlIHVuYnVmZmVyZWQgcG9ydGlvbiBpbiBiZXR3ZWVuXG4gICAgLy8gc28gd2Ugc2hvdWxkIG5vdCBzd2l0Y2ggdG8gRU5ERUQgaW4gdGhhdCBjYXNlLCB0byBiZSBhYmxlIHRvIGJ1ZmZlciB0aGVtXG5cbiAgICBpZiAoIWxldmVsRGV0YWlscy5saXZlICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBsZXZlbERldGFpbHMuZW5kU04gJiYgIWJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICB2YXIgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWdDdXJyZW50KTtcbiAgICAgIHJldHVybiBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwgfHwgZnJhZ1N0YXRlID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5PSztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgY29uZmlnLmF1dG9TdGFydExvYWQgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGFydExvYWQoY29uZmlnLnN0YXJ0UG9zaXRpb24pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmIChtZWRpYSAhPT0gbnVsbCAmJiBtZWRpYSAhPT0gdm9pZCAwICYmIG1lZGlhLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB9IC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcblxuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiBvbk1lZGlhU2Vla2luZygpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIsXG4gICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYSA/IG1lZGlhLmN1cnJlbnRUaW1lIDogbnVsbDtcbiAgICB2YXIgYnVmZmVySW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYUJ1ZmZlciB8fCBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLmxvZyhcIm1lZGlhIHNlZWtpbmcgdG8gXCIgKyAoT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGN1cnJlbnRUaW1lKSA/IGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgOiBjdXJyZW50VGltZSkgKyBcIiwgc3RhdGU6IFwiICsgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgLy8gaWYgc2Vla2luZyB0byB1bmJ1ZmZlcmVkIGFyZWEsIGNsZWFuIHVwIGZyYWdQcmV2aW91c1xuICAgICAgaWYgKCFidWZmZXJJbmZvLmxlbikge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgfSAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBjaGVjayBmb3IgcG90ZW50aWFsIG5ldyBmcmFnbWVudFxuXG5cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgc2Vla2luZyB0byBhIHVuYnVmZmVyZWQgYXJlYSBBTkQgaWYgZnJhZyBsb2FkaW5nIGlzIGluIHByb2dyZXNzXG4gICAgICB2YXIgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICB2YXIgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICB2YXIgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7IC8vIGNoZWNrIGlmIHdlIHNlZWsgcG9zaXRpb24gd2lsbCBiZSBvdXQgb2YgY3VycmVudGx5IGxvYWRlZCBmcmFnIHJhbmdlIDogaWYgb3V0IGNhbmNlbCBmcmFnIGxvYWQsIGlmIGluLCBkb24ndCBkbyBhbnl0aGluZ1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUgPCBmcmFnU3RhcnRPZmZzZXQgfHwgY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZygnc2Vla2luZyBvdXRzaWRlIG9mIGJ1ZmZlciB3aGlsZSBmcmFnbWVudCBsb2FkIGluIHByb2dyZXNzLCBjYW5jZWwgZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDsgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcblxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfSAvLyBpbiBjYXNlIHNlZWtpbmcgb2NjdXJzIGFsdGhvdWdoIG5vIG1lZGlhIGJ1ZmZlcmVkLCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiBhbmQgbmV4dExvYWRQb3NpdGlvbiB0byBzZWVrIHRhcmdldFxuXG5cbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IGN1cnJlbnRUaW1lO1xuICAgIH0gLy8gdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRW5kZWQgPSBmdW5jdGlvbiBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9O1xuXG4gIF9wcm90by5vbktleUxvYWRlZCA9IGZ1bmN0aW9uIG9uS2V5TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsc1tkYXRhLmZyYWcubGV2ZWxdLmRldGFpbHM7XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZGF0YS5mcmFnLCBsZXZlbERldGFpbHMsIGRhdGEuZnJhZy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG5cbiAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uS0VZX0xPQURFRCwgdGhpcy5vbktleUxvYWRlZCwgdGhpcyk7XG5cbiAgICBfVGFza0xvb3AucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgdGhpcy5fbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9O1xuXG4gIF9wcm90by5fbG9hZEZyYWdGb3JQbGF5YmFjayA9IGZ1bmN0aW9uIF9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHByb2dyZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiBwcm9ncmVzc0NhbGxiYWNrKGRhdGEpIHtcbiAgICAgIGlmIChfdGhpczIuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIF90aGlzMi53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgKGRhdGEucGFydCA/ICcgcDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5cIik7XG5cbiAgICAgICAgX3RoaXMyLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuXG4gICAgICBfdGhpczIuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgIH07XG5cbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgX3RoaXMyLmZyYWdMb2FkRXJyb3IgPSAwO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKF90aGlzMi5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8IF90aGlzMi5zdGF0ZSA9PT0gU3RhdGUuQkFDS1RSQUNLSU5HKSB7XG4gICAgICAgICAgX3RoaXMyLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcblxuICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgncGF5bG9hZCcgaW4gZGF0YSkge1xuICAgICAgICBfdGhpczIubG9nKFwiTG9hZGVkIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCk7XG5cbiAgICAgICAgX3RoaXMyLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgZGF0YSk7IC8vIFRyYWNrZXIgYmFja3RyYWNrIG11c3QgYmUgY2FsbGVkIGFmdGVyIG9uRnJhZ0xvYWRlZCB0byB1cGRhdGUgdGhlIGZyYWdtZW50IGVudGl0eSBzdGF0ZSB0byBCQUNLVFJBQ0tFRFxuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgYWZ0ZXIgaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSB3aGVuIHRoZSB3b3JrZXIgb3IgcHJvZ3Jlc3NpdmUgaXMgZGlzYWJsZWRcblxuXG4gICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IFN0YXRlLkJBQ0tUUkFDS0lORykge1xuICAgICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIuYmFja3RyYWNrKGZyYWcsIGRhdGEpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcblxuXG4gICAgICBfdGhpczIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaE1haW5CdWZmZXIgPSBmdW5jdGlvbiBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYWx0ZXJuYXRlIGF1ZGlvIGlzIHBsYXlpbmcsIHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGF1ZGlvIGJ1ZmZlci4gT3RoZXJ3aXNlLFxuICAgIC8vIHBhc3NpbmcgYSBudWxsIHR5cGUgZmx1c2hlcyBib3RoIGJ1ZmZlcnNcbiAgICB2YXIgZmx1c2hTY29wZSA9IHtcbiAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldDogZW5kT2Zmc2V0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07IC8vIFJlc2V0IGxvYWQgZXJyb3JzIG9uIGZsdXNoXG5cbiAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9sb2FkSW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfbG9hZEluaXRTZWdtZW50KGZyYWcpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhIHx8IF90aGlzMy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIV90aGlzMy5sZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gX3RoaXMzLmhscztcbiAgICAgIHZhciBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTsgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSBwYXlsb2FkIG5lZWRzIHRvIGJlIGRlY3J5cHRlZFxuXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTsgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5kZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgZGVjcnlwdERhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdERhdGEuaXYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgdmFyIGVuZFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gX3RoaXMzLmZyYWdDdXJyZW50LFxuICAgICAgICAgIGhscyA9IF90aGlzMy5obHMsXG4gICAgICAgICAgbGV2ZWxzID0gX3RoaXMzLmxldmVscztcblxuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbHNbZnJhZy5sZXZlbF0uZGV0YWlscztcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KGRldGFpbHMsICdMZXZlbCBkZXRhaWxzIGFyZSBkZWZpbmVkIHdoZW4gaW5pdCBzZWdtZW50IGlzIGxvYWRlZCcpO1xuICAgICAgdmFyIGluaXRTZWdtZW50ID0gZGV0YWlscy5pbml0U2VnbWVudDtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KGluaXRTZWdtZW50LCAnRnJhZ21lbnQgaW5pdFNlZ21lbnQgaXMgZGVmaW5lZCB3aGVuIGluaXQgc2VnbWVudCBpcyBsb2FkZWQnKTtcbiAgICAgIHZhciBzdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICBfdGhpczMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgX3RoaXMzLmZyYWdMb2FkRXJyb3IgPSAwO1xuICAgICAgaW5pdFNlZ21lbnQuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMuYnVmZmVyaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gc3RhdHMuYnVmZmVyaW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7IC8vIFNpbGVuY2UgRlJBR19CVUZGRVJFRCBldmVudCBpZiBmcmFnQ3VycmVudCBpcyBudWxsXG5cbiAgICAgIGlmIChkYXRhLmZyYWcgPT09IGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIGZyYWc6IGZyYWdDdXJyZW50LFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMzLnRpY2soKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBfdGhpczMud2FybihyZWFzb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mcmFnQ29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiBmcmFnQ29udGV4dENoYW5nZWQoZnJhZykge1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgcmV0dXJuICFmcmFnIHx8ICFmcmFnQ3VycmVudCB8fCBmcmFnLmxldmVsICE9PSBmcmFnQ3VycmVudC5sZXZlbCB8fCBmcmFnLnNuICE9PSBmcmFnQ3VycmVudC5zbiB8fCBmcmFnLnVybElkICE9PSBmcmFnQ3VycmVudC51cmxJZDtcbiAgfTtcblxuICBfcHJvdG8uZnJhZ0J1ZmZlcmVkQ29tcGxldGUgPSBmdW5jdGlvbiBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMubG9nKFwiQnVmZmVyZWQgXCIgKyBmcmFnLnR5cGUgKyBcIiBzbjogXCIgKyBmcmFnLnNuICsgKHBhcnQgPyAnIHBhcnQ6ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgXCIgKyAodGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snKSArIFwiIFwiICsgZnJhZy5sZXZlbCArIFwiIFwiICsgX3V0aWxzX3RpbWVfcmFuZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wiZGVmYXVsdFwiXS50b1N0cmluZyhfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiQnVmZmVySGVscGVyXCJdLmdldEJ1ZmZlcmVkKG1lZGlhKSkpO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZEVuZERhdGEpIHtcbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gZnJhZ0xvYWRlZEVuZERhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGZyYWdMb2FkZWRFbmREYXRhLnBhcnQsXG4gICAgICAgIHBhcnRzTG9hZGVkID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydHNMb2FkZWQ7IC8vIElmIHdlIGRpZCBub3QgbG9hZCBwYXJ0cywgb3IgbG9hZGVkIGFsbCBwYXJ0cywgd2UgaGF2ZSBjb21wbGV0ZSAobm90IHBhcnRpYWwpIGZyYWdtZW50IGRhdGFcblxuICAgIHZhciBjb21wbGV0ZSA9ICFwYXJ0c0xvYWRlZCB8fCBwYXJ0c0xvYWRlZCAmJiAocGFydHNMb2FkZWQubGVuZ3RoID09PSAwIHx8IHBhcnRzTG9hZGVkLnNvbWUoZnVuY3Rpb24gKGZyYWdMb2FkZWQpIHtcbiAgICAgIHJldHVybiAhZnJhZ0xvYWRlZDtcbiAgICB9KSk7XG4gICAgdmFyIGNodW5rTWV0YSA9IG5ldyBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiQ2h1bmtNZXRhZGF0YVwiXShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQgKyAxLCAwLCBwYXJ0ID8gcGFydC5pbmRleCA6IC0xLCAhY29tcGxldGUpO1xuICAgIHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIDtcblxuICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGZyYWcpIHt9O1xuXG4gIF9wcm90by5fZG9GcmFnTG9hZCA9IGZ1bmN0aW9uIF9kb0ZyYWdMb2FkKGZyYWcsIGRldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWxzJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0QnVmZmVyVGltZSA9IE1hdGgubWF4KGZyYWcuc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUgfHwgMCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZGV0YWlscykge1xuICAgICAgdmFyIHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdDtcblxuICAgICAgaWYgKHBhcnRMaXN0ICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHBhcnRJbmRleCA9IHRoaXMuZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpO1xuXG4gICAgICAgIGlmIChwYXJ0SW5kZXggPiAtMSkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbcGFydEluZGV4XTtcbiAgICAgICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgcGFydCBzbjogXCIgKyBmcmFnLnNuICsgXCIgcDogXCIgKyBwYXJ0LmluZGV4ICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIG9mIHBsYXlsaXN0IFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXSBwYXJ0cyBbMC1cIiArIHBhcnRJbmRleCArIFwiLVwiICsgKHBhcnRMaXN0Lmxlbmd0aCAtIDEpICsgXCJdIFwiICsgKHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJykgKyBcIjogXCIgKyBmcmFnLmxldmVsICsgXCIsIHRhcmdldDogXCIgKyBwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSkpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJFdmVudHNcIl0uRlJBR19MT0FESU5HLCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydExpc3RbcGFydEluZGV4XSxcbiAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydExpc3QsIHBhcnRJbmRleCwgcHJvZ3Jlc3NDYWxsYmFjaykuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LmhhbmRsZUZyYWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZyYWcudXJsIHx8IHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhwYXJ0TGlzdCwgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBoaW50IGhhcyBubyBwYXJ0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxvZyhcIkxvYWRpbmcgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIFwiICsgKGRldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnKSArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRElORywge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHRhcmdldEJ1ZmZlclRpbWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIHByb2dyZXNzQ2FsbGJhY2spLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5kb0ZyYWdQYXJ0c0xvYWQgPSBmdW5jdGlvbiBkb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydExpc3QsIHBhcnRJbmRleCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBwYXJ0c0xvYWRlZCA9IFtdO1xuXG4gICAgICB2YXIgbG9hZFBhcnRJbmRleCA9IGZ1bmN0aW9uIGxvYWRQYXJ0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0TGlzdFtpbmRleF07XG5cbiAgICAgICAgX3RoaXM1LmZyYWdtZW50TG9hZGVyLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKHBhcnRMb2FkZWREYXRhKSB7XG4gICAgICAgICAgcGFydHNMb2FkZWRbcGFydC5pbmRleF0gPSBwYXJ0TG9hZGVkRGF0YTtcbiAgICAgICAgICB2YXIgbG9hZGVkUGFydCA9IHBhcnRMb2FkZWREYXRhLnBhcnQ7XG5cbiAgICAgICAgICBfdGhpczUuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCBwYXJ0TG9hZGVkRGF0YSk7XG5cbiAgICAgICAgICB2YXIgbmV4dFBhcnQgPSBwYXJ0TGlzdFtpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXJ0ICYmIG5leHRQYXJ0LmZyYWdtZW50ID09PSBmcmFnKSB7XG4gICAgICAgICAgICBsb2FkUGFydEluZGV4KGluZGV4ICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgcGFydHNMb2FkZWQ6IHBhcnRzTG9hZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9O1xuXG4gICAgICBsb2FkUGFydEluZGV4KHBhcnRJbmRleCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUZyYWdFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdFcnJvcihfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGE7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaCA9IGZ1bmN0aW9uIF9oYW5kbGVUcmFuc211eGVyRmx1c2goY2h1bmtNZXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHRoaXMud2FybihcIlN0YXRlIGlzIGV4cGVjdGVkIHRvIGJlIFBBUlNJTkcgb24gdHJhbnNtdXhlciBmbHVzaCwgYnV0IGlzIFwiICsgdGhpcy5zdGF0ZSArIFwiLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZnJhZy5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcblxuICAgIGlmIChwYXJ0KSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0VELCB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5nZXRDdXJyZW50Q29udGV4dCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICB2YXIgbGV2ZWxJbmRleCA9IGNodW5rTWV0YS5sZXZlbCxcbiAgICAgICAgc24gPSBjaHVua01ldGEuc24sXG4gICAgICAgIHBhcnRJbmRleCA9IGNodW5rTWV0YS5wYXJ0O1xuXG4gICAgaWYgKCFsZXZlbHMgfHwgIWxldmVsc1tsZXZlbEluZGV4XSkge1xuICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50IFwiICsgc24gKyBcIiBvZiBsZXZlbCBcIiArIGxldmVsSW5kZXggKyBcIi4gVGhlIGN1cnJlbnQgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJnZXRQYXJ0V2l0aFwiXShsZXZlbCwgc24sIHBhcnRJbmRleCkgOiBudWxsO1xuICAgIHZhciBmcmFnID0gcGFydCA/IHBhcnQuZnJhZ21lbnQgOiBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJnZXRGcmFnbWVudFdpdGhTTlwiXShsZXZlbCwgc24pO1xuXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICBsZXZlbDogbGV2ZWxcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5idWZmZXJGcmFnbWVudERhdGEgPSBmdW5jdGlvbiBidWZmZXJGcmFnbWVudERhdGEoZGF0YSwgZnJhZywgcGFydCwgY2h1bmtNZXRhKSB7XG4gICAgaWYgKCFkYXRhIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YTEgPSBkYXRhLmRhdGExLFxuICAgICAgICBkYXRhMiA9IGRhdGEuZGF0YTI7XG4gICAgdmFyIGJ1ZmZlciA9IGRhdGExO1xuXG4gICAgaWYgKGRhdGExICYmIGRhdGEyKSB7XG4gICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgYnVmZmVyID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKGRhdGExLCBkYXRhMik7XG4gICAgfVxuXG4gICAgaWYgKCFidWZmZXIgfHwgIWJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGRhdGE6IGJ1ZmZlcixcbiAgICAgIGZyYWc6IGZyYWcsXG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRJTkcsIHNlZ21lbnQpO1xuXG4gICAgaWYgKGRhdGEuZHJvcHBlZCAmJiBkYXRhLmluZGVwZW5kZW50ICYmICFwYXJ0KSB7XG4gICAgICAvLyBDbGVhciBidWZmZXIgc28gdGhhdCB3ZSByZWxvYWQgcHJldmlvdXMgc2VnbWVudHMgc2VxdWVudGlhbGx5IGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldE5leHRGcmFnbWVudCA9IGZ1bmN0aW9uIGdldE5leHRGcmFnbWVudChwb3MsIGxldmVsRGV0YWlscykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgc3RhcnRGcmFnUmVxdWVzdGVkID0gdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQ7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGZpbmQgZnJhZ21lbnQgaW5kZXgsIGNvbnRpZ3VvdXMgd2l0aCBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uXG5cblxuICAgIHZhciBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICB2YXIgZnJhZzsgLy8gSWYgYW4gaW5pdFNlZ21lbnQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSBidWZmZXJlZCBmaXJzdFxuXG4gICAgaWYgKGxldmVsRGV0YWlscy5pbml0U2VnbWVudCAmJiAhbGV2ZWxEZXRhaWxzLmluaXRTZWdtZW50LmRhdGEpIHtcbiAgICAgIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgfSBlbHNlIGlmIChsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuXG4gICAgICBpZiAoZnJhZ0xlbiA8IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplKSB7XG4gICAgICAgIHRoaXMud2FybihcIk5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiBcIiArIGZyYWdMZW4gKyBcIiwgbmVlZDogXCIgKyBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFRoZSByZWFsIGZyYWdtZW50IHN0YXJ0IHRpbWVzIGZvciBhIGxpdmUgc3RyZWFtIGFyZSBvbmx5IGtub3duIGFmdGVyIHRoZSBQVFMgcmFuZ2UgZm9yIHRoYXQgbGV2ZWwgaXMga25vd24uXG4gICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgLy8gRG8gbm90IGxvYWQgdXNpbmcgbGl2ZSBsb2dpYyBpZiB0aGUgc3RhcnRpbmcgZnJhZyBpcyByZXF1ZXN0ZWQgLSB3ZSB3YW50IHRvIHVzZSBnZXRGcmFnbWVudEF0UG9zaXRpb24oKSBzbyB0aGF0XG4gICAgICAvLyB3ZSBnZXQgdGhlIGZyYWdtZW50IG1hdGNoaW5nIHRoYXQgc3RhcnQgdGltZVxuXG5cbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzLlBUU0tub3duICYmICFzdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gc3RhcnQpIHtcbiAgICAgIC8vIFZvRCBwbGF5bGlzdDogaWYgbG9hZFBvc2l0aW9uIGJlZm9yZSBzdGFydCBvZiBwbGF5bGlzdCwgbG9hZCBmaXJzdCBmcmFnbWVudFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICB9IC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuXG5cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHZhciBlbmQgPSBjb25maWcubG93TGF0ZW5jeU1vZGUgPyBsZXZlbERldGFpbHMucGFydEVuZCA6IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihwb3MsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfTtcblxuICBfcHJvdG8uZ2V0TmV4dFBhcnQgPSBmdW5jdGlvbiBnZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHZhciBuZXh0UGFydCA9IC0xO1xuICAgIHZhciBjb250aWd1b3VzID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG5cbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG5cbiAgICAgIGlmICghbG9hZGVkICYmIChjb250aWd1b3VzIHx8IHBhcnQuaW5kZXBlbmRlbnQpICYmIHBhcnQuZnJhZ21lbnQgPT09IGZyYWcpIHtcbiAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgfVxuXG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0UGFydDtcbiAgfTtcblxuICBfcHJvdG8ubG9hZGVkRW5kT2ZQYXJ0cyA9IGZ1bmN0aW9uIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdFBhcnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA+IGxhc3RQYXJ0LnN0YXJ0ICYmIGxhc3RQYXJ0LmxvYWRlZDtcbiAgfVxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIDtcblxuICBfcHJvdG8uZ2V0SW5pdGlhbExpdmVGcmFnbWVudCA9IGZ1bmN0aW9uIGdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIHZhciBmcmFnID0gbnVsbDtcblxuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogXCIgKyBmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lKTtcbiAgICAgICAgZnJhZyA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImZpbmRGcmFnbWVudEJ5UERUXCJdKShmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNOIGRvZXMgbm90IG5lZWQgdG8gYmUgYWNjdXJhdGUgYmV0d2VlbiByZW5kaXRpb25zLCBidXQgZGVwZW5kaW5nIG9uIHRoZSBwYWNrYWdpbmcgaXQgbWF5IGJlIHNvLlxuICAgICAgICB2YXIgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuXG4gICAgICAgIGlmICh0YXJnZXRTTiA+PSBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiB0YXJnZXRTTiA8PSBsZXZlbERldGFpbHMuZW5kU04pIHtcbiAgICAgICAgICB2YXIgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07IC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcblxuICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgLy8gd2lsbCBoYXZlIHRoZSB3cm9uZyBzdGFydCB0aW1lc1xuXG5cbiAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgZnJhZyA9IE9iamVjdChfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImZpbmRGcmFnV2l0aENDXCJdKShmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5jYyk7XG5cbiAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRGcmFnbWVudEF0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRGcmFnbWVudEF0UG9zaXRpb24oYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXM7XG4gICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgIGVuZFNOID0gbGV2ZWxEZXRhaWxzLmVuZFNOO1xuICAgIHZhciBmcmFnbWVudEhpbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICB2YXIgbG9hZGluZ1BhcnRzID0gISEoY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0TGlzdCAmJiBmcmFnbWVudEhpbnQpO1xuXG4gICAgaWYgKGxvYWRpbmdQYXJ0cyAmJiBmcmFnbWVudEhpbnQpIHtcbiAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgZW5kU04gPSBmcmFnbWVudEhpbnQuc247XG4gICAgfVxuXG4gICAgdmFyIGZyYWc7XG5cbiAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICB2YXIgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTsgLy8gUmVtb3ZlIHRoZSB0b2xlcmFuY2UgaWYgaXQgd291bGQgcHV0IHRoZSBidWZmZXJFbmQgcGFzdCB0aGUgYWN0dWFsIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuXG4gICAgICBmcmFnID0gT2JqZWN0KF9mcmFnbWVudF9maW5kZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZmluZEZyYWdtZW50QnlQVFNcIl0pKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBidWZmZXJFbmQsIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgZnJhZyA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgIHZhciBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgdmFyIG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICB2YXIgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG5cbiAgICAgIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJGcmFnbWVudFN0YXRlXCJdLkJBQ0tUUkFDS0VEKSB7XG4gICAgICAgIGZyYWcgPSBudWxsO1xuICAgICAgICB2YXIgaSA9IGN1clNOSWR4O1xuXG4gICAgICAgIHdoaWxlIChmcmFnbWVudHNbaV0gJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZ21lbnRzW2ldKSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkZyYWdtZW50U3RhdGVcIl0uQkFDS1RSQUNLRUQpIHtcbiAgICAgICAgICAvLyBXaGVuIGZyYWdQcmV2aW91cyBpcyBudWxsLCBiYWNrdHJhY2sgdG8gZmlyc3QgdGhlIGZpcnN0IGZyYWdtZW50IGlzIG5vdCBCQUNLVFJBQ0tFRCBmb3IgbG9hZGluZ1xuICAgICAgICAgIC8vIFdoZW4gZnJhZ1ByZXZpb3VzIGlzIHNldCwgd2Ugd2FudCB0aGUgZmlyc3QgQkFDS1RSQUNLRUQgZnJhZ21lbnQgZm9yIHBhcnNpbmcgYW5kIGJ1ZmZlcmluZ1xuICAgICAgICAgIGlmICghZnJhZ1ByZXZpb3VzKSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ21lbnRzWy0taV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnbWVudHNbaS0tXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbiAmJiAhbG9hZGluZ1BhcnRzKSB7XG4gICAgICAgIC8vIEZvcmNlIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWQgaWYgdGhlIHByZXZpb3VzIG9uZSB3YXMgYWxyZWFkeSBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjYXNpb25hbGx5IGhhcHBlbiB3aXRoXG4gICAgICAgIC8vIG5vbi11bmlmb3JtIGZyYWdtZW50IGR1cmF0aW9uc1xuICAgICAgICBpZiAoc2FtZUxldmVsKSB7XG4gICAgICAgICAgaWYgKGZyYWcuc24gPCBlbmRTTiAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShuZXh0RnJhZykgIT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJGcmFnbWVudFN0YXRlXCJdLk9LKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIlNOIFwiICsgZnJhZy5zbiArIFwiIGp1c3QgbG9hZGVkLCBsb2FkIG5leHQgb25lOiBcIiArIG5leHRGcmFnLnNuKTtcbiAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH07XG5cbiAgX3Byb3RvLnN5bmNocm9uaXplVG9MaXZlRWRnZSA9IGZ1bmN0aW9uIHN5bmNocm9uaXplVG9MaXZlRWRnZShsZXZlbERldGFpbHMpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG5cbiAgICBpZiAobGl2ZVN5bmNQb3NpdGlvbiAhPT0gbnVsbCAmJiBtZWRpYSAhPT0gbnVsbCAmJiBtZWRpYSAhPT0gdm9pZCAwICYmIG1lZGlhLnJlYWR5U3RhdGUgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uICYmIGxpdmVTeW5jUG9zaXRpb24gPiBjdXJyZW50VGltZSkge1xuICAgICAgdmFyIG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgdmFyIHN0YXJ0ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHZhciBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcblxuICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgTWF0aC5tYXgoc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZW5kIC0gbWF4TGF0ZW5jeSkpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiUGxheWJhY2s6IFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSArIFwiIGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiBcIiArIGVuZCArIFwiLCByZXNldCBjdXJyZW50VGltZSB0byA6IFwiICsgbGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpKTtcblxuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICByZXR1cm4gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uYWxpZ25QbGF5bGlzdHMgPSBmdW5jdGlvbiBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkO1xuICAgIHZhciBsYXN0TGV2ZWwgPSBsZXZlbExhc3RMb2FkZWQgIT09IG51bGwgPyBsZXZlbHNbbGV2ZWxMYXN0TG9hZGVkXSA6IG51bGw7IC8vIEZJWE1FOiBJZiBub3QgZm9yIGBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzYCByZXF1aXJpbmcgZnJhZ1ByZXZpb3VzLmNjLFxuICAgIC8vICB0aGlzIGNvdWxkIGFsbCBnbyBpbiBMZXZlbEhlbHBlci5tZXJnZURldGFpbHNcblxuICAgIHZhciBzbGlkaW5nID0gMDtcblxuICAgIGlmIChwcmV2aW91c0RldGFpbHMgJiYgZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgc2xpZGluZyA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuXG4gICAgICBpZiAoZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc2xpZGluZykpIHtcbiAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0IHNsaWRpbmc6XCIgKyBzbGlkaW5nLnRvRml4ZWQoMykpO1xuICAgICAgfSBlbHNlIGlmICghc2xpZGluZykge1xuICAgICAgICB0aGlzLndhcm4oXCJbXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIl0gTGl2ZSBwbGF5bGlzdCAtIG91dGRhdGVkIFBUUywgdW5rbm93biBzbGlkaW5nXCIpO1xuICAgICAgICBPYmplY3QoX3V0aWxzX2Rpc2NvbnRpbnVpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImFsaWduU3RyZWFtXCJdKSh0aGlzLmZyYWdQcmV2aW91cywgbGFzdExldmVsLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coJ0xpdmUgcGxheWxpc3QgLSBmaXJzdCBsb2FkLCB1bmtub3duIHNsaWRpbmcnKTtcbiAgICAgIE9iamVjdChfdXRpbHNfZGlzY29udGludWl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiYWxpZ25TdHJlYW1cIl0pKHRoaXMuZnJhZ1ByZXZpb3VzLCBsYXN0TGV2ZWwsIGRldGFpbHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nO1xuICB9O1xuXG4gIF9wcm90by53YWl0Rm9yQ2RuVHVuZUluID0gZnVuY3Rpb24gd2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSB7XG4gICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW4gdG8gZ2V0IGFuIHVwZGF0ZWQgcGxheWxpc3RcbiAgICB2YXIgYWR2YW5jZVBhcnRMaW1pdCA9IDM7XG4gICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMudHVuZUluR29hbCA+IE1hdGgubWF4KGRldGFpbHMucGFydEhvbGRCYWNrLCBkZXRhaWxzLnBhcnRUYXJnZXQgKiBhZHZhbmNlUGFydExpbWl0KTtcbiAgfTtcblxuICBfcHJvdG8uc2V0U3RhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgc2xpZGluZykge1xuICAgIC8vIGNvbXB1dGUgc3RhcnQgcG9zaXRpb24gaWYgc2V0IHRvIC0xLiB1c2UgaXQgc3RyYWlnaHQgYXdheSBpZiB2YWx1ZSBpcyBkZWZpbmVkXG4gICAgaWYgKHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgaWYgc3RhcnQgdGltZSBvZmZzZXQgaGFzIGJlZW4gc2V0IGluIHBsYXlsaXN0LCBpZiB5ZXMsIHVzZSB0aGlzIHZhbHVlXG4gICAgICB2YXIgc3RhcnRUaW1lT2Zmc2V0ID0gZGV0YWlscy5zdGFydFRpbWVPZmZzZXQ7XG5cbiAgICAgIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgIHRoaXMubG9nKFwiTmVnYXRpdmUgc3RhcnQgdGltZSBvZmZzZXQgXCIgKyBzdGFydFRpbWVPZmZzZXQgKyBcIiwgY291bnQgZnJvbSBlbmQgb2YgbGFzdCBmcmFnbWVudFwiKTtcbiAgICAgICAgICBzdGFydFRpbWVPZmZzZXQgPSBzbGlkaW5nICsgZGV0YWlscy50b3RhbGR1cmF0aW9uICsgc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2coXCJTdGFydCB0aW1lIG9mZnNldCBmb3VuZCBpbiBwbGF5bGlzdCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gdG8gXCIgKyBzdGFydFRpbWVPZmZzZXQpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgICAgIHRoaXMubG9nKFwiQ29uZmlndXJlIHN0YXJ0UG9zaXRpb24gdG8gXCIgKyB0aGlzLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb2FkUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRMb2FkUG9zaXRpb24oKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTsgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuXG4gICAgdmFyIHBvcyA9IDA7XG5cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVGcmFnTG9hZEFib3J0ZWQgPSBmdW5jdGlvbiBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5sb2coXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3YXMgYWJvcnRlZCwgZmx1c2hpbmcgdHJhbnNtdXhlclwiKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5mbHVzaChuZXcgX3R5cGVzX3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcIkNodW5rTWV0YWRhdGFcIl0oZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgcGFydCA/IHBhcnQuaW5kZXggOiAtMSwgdHJ1ZSkpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udXBkYXRlTGV2ZWxUaW1pbmcgPSBmdW5jdGlvbiB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBsZXZlbCwgcGFydGlhbCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGNvbnNvbGUuYXNzZXJ0KCEhZGV0YWlscywgJ2xldmVsLmRldGFpbHMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgT2JqZWN0LmtleXMoZnJhZy5lbGVtZW50YXJ5U3RyZWFtcykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGluZm8gPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICB2YXIgcGFyc2VkRHVyYXRpb24gPSBpbmZvLmVuZFBUUyAtIGluZm8uc3RhcnRQVFM7XG5cbiAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LCBwcmV2ZW50aW5nIHRoZSB0aW1lbGluZSBmcm9tIHNoaWZ0aW5nLlxuICAgICAgICAgIF90aGlzNi53YXJuKFwiQ291bGQgbm90IHBhcnNlIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIFwiICsgdHlwZSArIFwiIGR1cmF0aW9uIHJlbGlhYmx5IChcIiArIHBhcnNlZER1cmF0aW9uICsgXCIpIHJlc2V0dGluZyB0cmFuc211eGVyIHRvIGZhbGxiYWNrIHRvIHBsYXlsaXN0IHRpbWluZ1wiKTtcblxuICAgICAgICAgIGlmIChfdGhpczYudHJhbnNtdXhlcikge1xuICAgICAgICAgICAgX3RoaXM2LnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICBfdGhpczYudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyaWZ0ID0gcGFydGlhbCA/IDAgOiBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJ1cGRhdGVGcmFnUFRTRFRTXCJdKGRldGFpbHMsIGZyYWcsIGluZm8uc3RhcnRQVFMsIGluZm8uZW5kUFRTLCBpbmZvLnN0YXJ0RFRTLCBpbmZvLmVuZERUUyk7XG5cbiAgICAgICAgX3RoaXM2Lmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkV2ZW50c1wiXS5MRVZFTF9QVFNfVVBEQVRFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgIGRyaWZ0OiBkcmlmdCxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcInN0YXRlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dFN0YXRlKSB7XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlOyAvLyB0aGlzLmxvZyhgJHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVN0cmVhbUNvbnRyb2xsZXI7XG59KF90YXNrX2xvb3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCdWZmZXJDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFzb3VyY2VfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9idWZmZXJfb3BlcmF0aW9uX3F1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2J1ZmZlci1vcGVyYXRpb24tcXVldWUgKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1vcGVyYXRpb24tcXVldWUudHNcIik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgTWVkaWFTb3VyY2UgPSBPYmplY3QoX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZ2V0TWVkaWFTb3VyY2VcIl0pKCk7XG52YXIgVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UgPSAvKFtoYV12Yy4pKD86XFwuW14uLF0rKSsvO1xuXG52YXIgQnVmZmVyQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFRoZSBsZXZlbCBkZXRhaWxzIHVzZWQgdG8gZGV0ZXJtaW5lIGR1cmF0aW9uLCB0YXJnZXQtZHVyYXRpb24gYW5kIGxpdmVcbiAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgLy8gQSBxdWV1ZSBvZiBidWZmZXIgb3BlcmF0aW9ucyB3aGljaCByZXF1aXJlIHRoZSBTb3VyY2VCdWZmZXIgdG8gbm90IGJlIHVwZGF0aW5nIHVwb24gZXhlY3V0aW9uXG4gIC8vIFJlZmVyZW5jZXMgdG8gZXZlbnQgbGlzdGVuZXJzIGZvciBlYWNoIFNvdXJjZUJ1ZmZlciwgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGZvciBldmVudCByZW1vdmFsXG4gIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcbiAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkXG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhdHRhY2hlZCBtZWRpYSBlbGVtZW50XG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3RpdmUgbWVkaWEgc291cmNlXG4gIC8vIGNvdW50ZXJzXG4gIGZ1bmN0aW9uIEJ1ZmZlckNvbnRyb2xsZXIoX2hscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSAwO1xuICAgIHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuYXBwZW5kRXJyb3IgPSAwO1xuICAgIHRoaXMudHJhY2tzID0ge307XG4gICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgdGhpcy5zb3VyY2VCdWZmZXIgPSB2b2lkIDA7XG5cbiAgICB0aGlzLl9vbk1lZGlhU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBobHMgPSBfdGhpcy5obHMsXG4gICAgICAgICAgbWVkaWEgPSBfdGhpcy5tZWRpYSxcbiAgICAgICAgICBtZWRpYVNvdXJjZSA9IF90aGlzLm1lZGlhU291cmNlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcblxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHtcbiAgICAgICAgICBtZWRpYTogbWVkaWFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBfdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGNsb3NlZCcpO1xuICAgIH07XG5cbiAgICB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBNZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5obHMgPSBfaGxzO1xuXG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJ1ZmZlckNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRU9TLCB0aGlzLm9uQnVmZmVyRW9zLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTRUQsIHRoaXMub25GcmFnUGFyc2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgX2J1ZmZlcl9vcGVyYXRpb25fcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0odGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIC8vIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIDIgQlVGRkVSX0NPREVDUyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQsIG9uZSBwZXIgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgLy8gaW4gY2FzZSBhbHQgYXVkaW8gaXMgbm90IHVzZWQsIG9ubHkgb25lIEJVRkZFUl9DT0RFQyBldmVudCB3aWxsIGJlIGZpcmVkIGZyb20gbWFpbiBzdHJlYW0gY29udHJvbGxlclxuICAgIC8vIGl0IHdpbGwgY29udGFpbiB0aGUgZXhwZWN0ZWQgbmIgb2Ygc291cmNlIGJ1ZmZlcnMsIG5vIG5lZWQgdG8gY29tcHV0ZSBpdFxuICAgIHZhciBjb2RlY0V2ZW50cyA9IDI7XG5cbiAgICBpZiAoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbyB8fCAhZGF0YS5hbHRBdWRpbykge1xuICAgICAgY29kZWNFdmVudHMgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSBjb2RlY0V2ZW50cztcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2codGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkICsgXCIgYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRcIik7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICBpZiAobWVkaWEgJiYgTWVkaWFTb3VyY2UpIHtcbiAgICAgIHZhciBtcyA9IHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKTsgLy8gTWVkaWFTb3VyY2UgbGlzdGVuZXJzIGFyZSBhcnJvdyBmdW5jdGlvbnMgd2l0aCBhIGxleGljYWwgc2NvcGUsIGFuZCBkbyBub3QgbmVlZCB0byBiZSBib3VuZFxuXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpOyAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcblxuICAgICAgbWVkaWEuc3JjID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKG1zKTsgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcblxuICAgICAgdGhpcy5fb2JqZWN0VXJsID0gbWVkaWEuc3JjO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgX29iamVjdFVybCA9IHRoaXMuX29iamVjdFVybDtcblxuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgaWYgKG1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCByZWFsbHkgY2FyZSBhYm91dCBjaGVja2luZyBzb3VyY2VidWZmZXIgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBhcyB3ZSBhcmUgYW55d2F5IGRldGFjaGluZyB0aGUgTWVkaWFTb3VyY2VcbiAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogb25NZWRpYURldGFjaGluZzogXCIgKyBlcnIubWVzc2FnZSArIFwiIHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1cIik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2xlYW4gdXAgdGhlIFNvdXJjZUJ1ZmZlcnMgYnkgaW52b2tpbmcgb25CdWZmZXJSZXNldFxuXG5cbiAgICAgIHRoaXMub25CdWZmZXJSZXNldCgpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTsgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoX29iamVjdFVybCk7XG4gICAgICAgIH0gLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG5cblxuICAgICAgICBpZiAobWVkaWEuc3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ1tidWZmZXItY29udHJvbGxlcl06IG1lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSEVELCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlclJlc2V0ID0gZnVuY3Rpb24gb25CdWZmZXJSZXNldCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICBfdGhpczIucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpO1xuXG4gICAgICAgICAgaWYgKF90aGlzMi5tZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgX3RoaXMyLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgICAgfSAvLyBTeW5jaHJvbm91c2x5IHJlbW92ZSB0aGUgU0IgZnJvbSB0aGUgbWFwIGJlZm9yZSB0aGUgbmV4dCBjYWxsIGluIG9yZGVyIHRvIHByZXZlbnQgYW4gYXN5bmMgZnVuY3Rpb24gZnJvbVxuICAgICAgICAgIC8vIGFjY2Vzc2luZyBpdFxuXG5cbiAgICAgICAgICBzb3VyY2VCdWZmZXJbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZXNldCB0aGUgXCIgKyB0eXBlICsgXCIgYnVmZmVyXCIsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0U291cmNlQnVmZmVyKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyQ29kZWNzID0gZnVuY3Rpb24gb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBzb3VyY2VCdWZmZXJDb3VudCA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKS5sZW5ndGg7XG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgU291cmNlQnVmZmVyIGNvZGVjIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgICB2YXIgdHJhY2sgPSBfdGhpczMudHJhY2tzW3RyYWNrTmFtZV07XG5cbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfZGF0YSR0cmFja05hbWUgPSBkYXRhW3RyYWNrTmFtZV0sXG4gICAgICAgICAgICAgIGNvZGVjID0gX2RhdGEkdHJhY2tOYW1lLmNvZGVjLFxuICAgICAgICAgICAgICBsZXZlbENvZGVjID0gX2RhdGEkdHJhY2tOYW1lLmxldmVsQ29kZWMsXG4gICAgICAgICAgICAgIGNvbnRhaW5lciA9IF9kYXRhJHRyYWNrTmFtZS5jb250YWluZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRDb2RlYyA9ICh0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjKS5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQQUNFLCAnJDEnKTtcbiAgICAgICAgICB2YXIgbmV4dENvZGVjID0gKGxldmVsQ29kZWMgfHwgY29kZWMpLnJlcGxhY2UoVklERU9fQ09ERUNfUFJPRklMRV9SRVBBQ0UsICckMScpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRDb2RlYyAhPT0gbmV4dENvZGVjKSB7XG4gICAgICAgICAgICB2YXIgbWltZVR5cGUgPSBjb250YWluZXIgKyBcIjtjb2RlY3M9XCIgKyAobGV2ZWxDb2RlYyB8fCBjb2RlYyk7XG5cbiAgICAgICAgICAgIF90aGlzMy5hcHBlbmRDaGFuZ2VUeXBlKHRyYWNrTmFtZSwgbWltZVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgICAgIF90aGlzMy5wZW5kaW5nVHJhY2tzW3RyYWNrTmFtZV0gPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICB9XG4gICAgfSk7IC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuXG4gICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XG5cbiAgICBpZiAodGhpcy5tZWRpYVNvdXJjZSAmJiB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgdGhpcy5jaGVja1BlbmRpbmdUcmFja3MoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZENoYW5nZVR5cGUgPSBmdW5jdGlvbiBhcHBlbmRDaGFuZ2VUeXBlKHR5cGUsIG1pbWVUeXBlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICB2YXIgc2IgPSBfdGhpczQuc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBjaGFuZ2luZyBcIiArIHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgdHlwZSB0byBcIiArIG1pbWVUeXBlKTtcbiAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHt9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIGNoYW5nZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIgdHlwZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckFwcGVuZGluZyA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kaW5nKGV2ZW50LCBldmVudERhdGEpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlLFxuICAgICAgICB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICB2YXIgZGF0YSA9IGV2ZW50RGF0YS5kYXRhLFxuICAgICAgICB0eXBlID0gZXZlbnREYXRhLnR5cGUsXG4gICAgICAgIGZyYWcgPSBldmVudERhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGV2ZW50RGF0YS5wYXJ0LFxuICAgICAgICBjaHVua01ldGEgPSBldmVudERhdGEuY2h1bmtNZXRhO1xuICAgIHZhciBjaHVua1N0YXRzID0gY2h1bmtNZXRhLmJ1ZmZlcmluZ1t0eXBlXTtcbiAgICB2YXIgYnVmZmVyQXBwZW5kaW5nU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNodW5rU3RhdHMuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICB2YXIgZnJhZ0J1ZmZlcmluZyA9IGZyYWcuc3RhdHMuYnVmZmVyaW5nO1xuICAgIHZhciBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcblxuICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBmcmFnQnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRCdWZmZXJpbmcgJiYgcGFydEJ1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgcGFydEJ1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH0gLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG5cblxuICAgIHZhciBhdWRpb1RyYWNrID0gdHJhY2tzLmF1ZGlvO1xuICAgIHZhciBjaGVja1RpbWVzdGFtcE9mZnNldCA9IHR5cGUgPT09ICdhdWRpbycgJiYgY2h1bmtNZXRhLmlkID09PSAxICYmIChhdWRpb1RyYWNrID09PSBudWxsIHx8IGF1ZGlvVHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1ZGlvVHJhY2suY29udGFpbmVyKSA9PT0gJ2F1ZGlvL21wZWcnO1xuICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgaWYgKGNoZWNrVGltZXN0YW1wT2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIHNiID0gX3RoaXM1LnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gZnJhZy5zdGFydCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAwLjEpIHtcbiAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gXCIgKyBmcmFnLnN0YXJ0ICsgXCIgKGRlbHRhOiBcIiArIGRlbHRhICsgXCIpIHNuOiBcIiArIGZyYWcuc24gKyBcIilcIik7XG4gICAgICAgICAgICAgIHNiLnRpbWVzdGFtcE9mZnNldCA9IGZyYWcuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM1LmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7Ly8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVzdGFydGApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlZW5kYCk7XG4gICAgICAgIHZhciBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVFbmQgPSBjaHVua1N0YXRzLmVuZCA9IGVuZDtcblxuICAgICAgICBpZiAoZnJhZ0J1ZmZlcmluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICAgIGZyYWdCdWZmZXJpbmcuZmlyc3QgPSBlbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgcGFydEJ1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSBfdGhpczUuc291cmNlQnVmZmVyO1xuICAgICAgICB2YXIgdGltZVJhbmdlcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIF90eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIHRpbWVSYW5nZXNbX3R5cGVdID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChzb3VyY2VCdWZmZXJbX3R5cGVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNS5hcHBlbmRFcnJvciA9IDA7XG5cbiAgICAgICAgX3RoaXM1Lmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ERUQsIHtcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzOiB0aW1lUmFuZ2VzLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAvLyBpbiBjYXNlIGFueSBlcnJvciBvY2N1cmVkIHdoaWxlIGFwcGVuZGluZywgcHV0IGJhY2sgc2VnbWVudCBpbiBzZWdtZW50cyB0YWJsZVxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZXJyKTtcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgZXJyOiBlcnIsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM1LmFwcGVuZEVycm9yKys7XG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG5cbiAgICAgICAgICBpZiAoX3RoaXM1LmFwcGVuZEVycm9yID4gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIFwiICsgaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gc291cmNlQnVmZmVyXCIpO1xuICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuXG4gICAgdmFyIGZsdXNoT3BlcmF0aW9uID0gZnVuY3Rpb24gZmx1c2hPcGVyYXRpb24odHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhlY3V0ZTogX3RoaXM2LnJlbW92ZUV4ZWN1dG9yLmJpbmQoX3RoaXM2LCB0eXBlLCBkYXRhLnN0YXJ0T2Zmc2V0LCBkYXRhLmVuZE9mZnNldCksXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7Ly8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBTdGFydGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogRmluaXNoZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgICAgX3RoaXM2Lmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGUpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byByZW1vdmUgZnJvbSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGlmIChkYXRhLnR5cGUpIHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbihkYXRhLnR5cGUpLCBkYXRhLnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24oJ2F1ZGlvJyksICdhdWRpbycpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKCd2aWRlbycpLCAndmlkZW8nKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNlZCA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgdmFyIGJ1ZmZlcnNBcHBlbmRlZFRvID0gW107XG4gICAgdmFyIGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydCA/IHBhcnQuZWxlbWVudGFyeVN0cmVhbXMgOiBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuXG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRWxlbWVudGFyeVN0cmVhbVR5cGVzXCJdLlZJREVPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvblVuYmxvY2tlZCA9IGZ1bmN0aW9uIG9uVW5ibG9ja2VkKCkge1xuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG5cbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgICBfdGhpczcuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6IFwiICsgZnJhZy50eXBlICsgXCIgbGV2ZWw6IFwiICsgZnJhZy5sZXZlbCArIFwiIHNuOiBcIiArIGZyYWcuc24pO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVyc0FwcGVuZGVkVG8pO1xuICAgIHRoaXMuZmx1c2hMaXZlQmFja0J1ZmZlcigpO1xuICB9IC8vIG9uIEJVRkZFUl9FT1MgbWFyayBtYXRjaGluZyBzb3VyY2VidWZmZXIocykgYXMgZW5kZWQgYW5kIHRyaWdnZXIgY2hlY2tFb3MoKVxuICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXG4gIDtcblxuICBfcHJvdG8ub25CdWZmZXJFb3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckVvcyhldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLnNvdXJjZUJ1ZmZlcikge1xuICAgICAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgICAgIGlmIChzYiAmJiAhc2IuZW5kZWQpIHtcbiAgICAgICAgICBzYi5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVuZFN0cmVhbSA9IGZ1bmN0aW9uIGVuZFN0cmVhbSgpIHtcbiAgICAgIHZhciBtZWRpYVNvdXJjZSA9IF90aGlzOC5tZWRpYVNvdXJjZTtcblxuICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cblxuXG4gICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhlbmRTdHJlYW0pO1xuICB9O1xuXG4gIF9wcm90by5vbkxldmVsVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxVcGRhdGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG5cbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2hMaXZlQmFja0J1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoTGl2ZUJhY2tCdWZmZXIoKSB7XG4gICAgLy8gY2xlYXIgYmFjayBidWZmZXIgZm9yIGxpdmUgb25seVxuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcblxuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCB8fCBkZXRhaWxzLmxpdmUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpdmVCYWNrQnVmZmVyTGVuZ3RoID0gaGxzLmNvbmZpZy5saXZlQmFja0J1ZmZlckxlbmd0aDtcblxuICAgIGlmICghT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGxpdmVCYWNrQnVmZmVyTGVuZ3RoKSB8fCBsaXZlQmFja0J1ZmZlckxlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID0gY3VycmVudFRpbWUgLSBNYXRoLm1heChsaXZlQmFja0J1ZmZlckxlbmd0aCwgZGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uKTtcbiAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChzYik7IC8vIHdoZW4gdGFyZ2V0IGJ1ZmZlciBzdGFydCBleGNlZWRzIGFjdHVhbCBidWZmZXIgc3RhcnRcblxuICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID4gMCAmJiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPiBidWZmZXJlZC5zdGFydCgwKSkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbixcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5kZXRhaWxzIHx8ICF0aGlzLm1lZGlhIHx8ICF0aGlzLm1lZGlhU291cmNlIHx8IHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRldGFpbHMgPSB0aGlzLmRldGFpbHMsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICB2YXIgbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0ICsgZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIHZhciBtZWRpYUR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgdmFyIG1zRHVyYXRpb24gPSBPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiAwO1xuXG4gICAgaWYgKGRldGFpbHMubGl2ZSAmJiBobHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byBJbmZpbml0eScpO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudXBkYXRlU2Vla2FibGVSYW5nZShkZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsRHVyYXRpb24gPiBtc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYUR1cmF0aW9uIHx8ICFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkobWVkaWFEdXJhdGlvbikpIHtcbiAgICAgIC8vIGxldmVsRHVyYXRpb24gd2FzIHRoZSBsYXN0IHZhbHVlIHdlIHNldC5cbiAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgLy8gb25seSB1cGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIGlmIGl0cyB2YWx1ZSBpbmNyZWFzZSwgdGhpcyBpcyB0byBhdm9pZFxuICAgICAgLy8gZmx1c2hpbmcgYWxyZWFkeSBidWZmZXJlZCBwb3J0aW9uIHdoZW4gc3dpdGNoaW5nIGJldHdlZW4gcXVhbGl0eSBsZXZlbFxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiB0byBcIiArIGxldmVsRHVyYXRpb24udG9GaXhlZCgzKSk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVTZWVrYWJsZVJhbmdlID0gZnVuY3Rpb24gdXBkYXRlU2Vla2FibGVSYW5nZShsZXZlbERldGFpbHMpIHtcbiAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIHZhciBsZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAmJiBsZXZlbERldGFpbHMubGl2ZSAmJiBtZWRpYVNvdXJjZSAhPT0gbnVsbCAmJiBtZWRpYVNvdXJjZSAhPT0gdm9pZCAwICYmIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2hlY2tQZW5kaW5nVHJhY2tzID0gZnVuY3Rpb24gY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgIHZhciBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLFxuICAgICAgICBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWUsXG4gICAgICAgIHBlbmRpbmdUcmFja3MgPSB0aGlzLnBlbmRpbmdUcmFja3M7IC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuXG4gICAgdmFyIHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcblxuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9OyAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZVNvdXJjZUJ1ZmZlcnMgPSBmdW5jdGlvbiBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrcykge1xuICAgIHZhciBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcixcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuXG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuXG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcInNvdXJjZSBidWZmZXIgZXhpc3RzIGZvciB0cmFjayBcIiArIHRyYWNrTmFtZSArIFwiLCBob3dldmVyIHRyYWNrIGRvZXMgbm90XCIpO1xuICAgICAgICB9IC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG5cblxuICAgICAgICB2YXIgY29kZWMgPSB0cmFjay5sZXZlbENvZGVjIHx8IHRyYWNrLmNvZGVjO1xuICAgICAgICB2YXIgbWltZVR5cGUgPSB0cmFjay5jb250YWluZXIgKyBcIjtjb2RlY3M9XCIgKyBjb2RlYztcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcihcIiArIG1pbWVUeXBlICsgXCIpXCIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3RyYWNrTmFtZV0gPSBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpO1xuICAgICAgICAgIHZhciBzYk5hbWUgPSB0cmFja05hbWU7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVzdGFydCcsIHRoaXMuX29uU0JVcGRhdGVTdGFydCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICd1cGRhdGVlbmQnLCB0aGlzLl9vblNCVXBkYXRlRW5kKTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2Vycm9yJywgdGhpcy5fb25TQlVwZGF0ZUVycm9yKTtcbiAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgYnVmZmVyOiBzYixcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogdHJhY2suY29udGFpbmVyLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogdHJhY2subGV2ZWxDb2RlYyxcbiAgICAgICAgICAgIGlkOiB0cmFjay5pZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgIHRyYWNrczogdGhpcy50cmFja3NcbiAgICB9KTtcbiAgfSAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICA7XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlU3RhcnQgPSBmdW5jdGlvbiBfb25TQlVwZGF0ZVN0YXJ0KHR5cGUpIHtcbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgIG9wZXJhdGlvbi5vblN0YXJ0KCk7XG4gIH07XG5cbiAgX3Byb3RvLl9vblNCVXBkYXRlRW5kID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFbmQodHlwZSkge1xuICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5fb25TQlVwZGF0ZUVycm9yID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciBlcnJvclwiLCBldmVudCk7IC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IsXG4gICAgICBmYXRhbDogZmFsc2VcbiAgICB9KTsgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcblxuICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGV2ZW50KTtcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgO1xuXG4gIF9wcm90by5yZW1vdmVFeGVjdXRvciA9IGZ1bmN0aW9uIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZSA9IHRoaXMubWVkaWFTb3VyY2UsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgdmFyIHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuXG4gICAgaWYgKCFtZWRpYSB8fCAhbWVkaWFTb3VyY2UgfHwgIXNiKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIFwiICsgdHlwZSArIFwiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWFEdXJhdGlvbiA9IE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShtZWRpYS5kdXJhdGlvbikgPyBtZWRpYS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgIHZhciBtc0R1cmF0aW9uID0gT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogSW5maW5pdHk7XG4gICAgdmFyIHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIHZhciByZW1vdmVFbmQgPSBNYXRoLm1pbihlbmRPZmZzZXQsIG1lZGlhRHVyYXRpb24sIG1zRHVyYXRpb24pO1xuXG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0KSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogUmVtb3ZpbmcgW1wiICsgcmVtb3ZlU3RhcnQgKyBcIixcIiArIHJlbW92ZUVuZCArIFwiXSBmcm9tIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIik7XG4gICAgICBjb25zb2xlLmFzc2VydCghc2IudXBkYXRpbmcsIHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgbXVzdCBub3QgYmUgdXBkYXRpbmdcIik7XG4gICAgICBzYi5yZW1vdmUocmVtb3ZlU3RhcnQsIHJlbW92ZUVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN5Y2xlIHRoZSBxdWV1ZVxuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiBhcHBlbmQgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgO1xuXG4gIF9wcm90by5hcHBlbmRFeGVjdXRvciA9IGZ1bmN0aW9uIGFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpIHtcbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICBpZiAoIXNiKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEF0dGVtcHRpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICBjb25zb2xlLmFzc2VydCghc2IudXBkYXRpbmcsIHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgbXVzdCBub3QgYmUgdXBkYXRpbmdcIik7XG4gICAgc2IuYXBwZW5kQnVmZmVyKGRhdGEpO1xuICB9IC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgLy8gcmVzb2x2ZSwgdGhlIG9uVW5ibG9ja2VkIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLiBGdW5jdGlvbnMgY2FsbGluZyB0aGlzIG1ldGhvZCBkbyBub3QgbmVlZCB0byB1bmJsb2NrIHRoZSBxdWV1ZVxuICAvLyB1cG9uIGNvbXBsZXRpb24sIHNpbmNlIHdlIGFscmVhZHkgZG8gaXQgaGVyZVxuICA7XG5cbiAgX3Byb3RvLmJsb2NrQnVmZmVycyA9IGZ1bmN0aW9uIGJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVycykge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgaWYgKGJ1ZmZlcnMgPT09IHZvaWQgMCkge1xuICAgICAgYnVmZmVycyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVxdWVzdGVkLCBidXQgbm8gU291cmNlQnVmZmVycyBleGlzdCcpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlOyAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG5cbiAgICB2YXIgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUpO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc2IgPSBfdGhpczkuc291cmNlQnVmZmVyW3R5cGVdOyAvLyBPbmx5IGN5Y2xlIHRoZSBxdWV1ZSBpZiB0aGUgU0IgaXMgbm90IHVwZGF0aW5nLiBUaGVyZSdzIGEgYnVnIGluIENocm9tZSB3aGljaCBzZXRzIHRoZSBTQiB1cGRhdGluZyBmbGFnIHRvXG4gICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgYSB3b3JrYXJvdW5kLCBpdCdzIHByb2JhYmx5IHVzZWZ1bCB0byBoYXZlIGFyb3VuZFxuXG4gICAgICAgIGlmICghc2IgfHwgIXNiLnVwZGF0aW5nKSB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNvdXJjZUJ1ZmZlclR5cGVzID0gZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyVHlwZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc291cmNlQnVmZmVyKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkQnVmZmVyTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRCdWZmZXJMaXN0ZW5lcih0eXBlLCBldmVudCwgZm4pIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG5cbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lciA9IGZuLmJpbmQodGhpcywgdHlwZSk7XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVCdWZmZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcblxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2J1ZmZlci1vcGVyYXRpb24tcXVldWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyT3BlcmF0aW9uUXVldWU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG52YXIgQnVmZmVyT3BlcmF0aW9uUXVldWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRpb25RdWV1ZShzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5xdWV1ZXMgPSB7XG4gICAgICB2aWRlbzogW10sXG4gICAgICBhdWRpbzogW10sXG4gICAgICBhdWRpb3ZpZGVvOiBbXVxuICAgIH07XG4gICAgdGhpcy5idWZmZXJzID0gc291cmNlQnVmZmVyUmVmZXJlbmNlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJ1ZmZlck9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcblxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgdGhpcy5idWZmZXJzW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0QWJvcnQgPSBmdW5jdGlvbiBpbnNlcnRBYm9ydChvcGVyYXRpb24sIHR5cGUpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kQmxvY2tlciA9IGZ1bmN0aW9uIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgIHZhciBleGVjdXRlO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiBleGVjdXRlLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHt9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHt9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIF9wcm90by5leGVjdXRlTmV4dCA9IGZ1bmN0aW9uIGV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuYnVmZmVycyxcbiAgICAgICAgcXVldWVzID0gdGhpcy5xdWV1ZXM7XG4gICAgdmFyIHNiID0gYnVmZmVyc1t0eXBlXTtcbiAgICB2YXIgcXVldWUgPSBxdWV1ZXNbdHlwZV07XG5cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcXVldWVbMF07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9wZXJhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIHJlc3VsdCBpbiBhbiAndXBkYXRlZW5kJyBldmVudCBiZWluZyBmaXJlZC4gSWYgbm90LCB0aGUgcXVldWUgd2lsbCBsb2NrLiBPcGVyYXRpb25zXG4gICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICBvcGVyYXRpb24uZXhlY3V0ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ud2FybignW2J1ZmZlci1vcGVyYXRpb24tcXVldWVdOiBVbmhhbmRsZWQgZXhjZXB0aW9uIGV4ZWN1dGluZyB0aGUgY3VycmVudCBvcGVyYXRpb24nKTtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZSk7IC8vIE9ubHkgc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiwgb3RoZXJ3aXNlIHRoZSB1cGRhdGVlbmQgaGFuZGxlciB3aWxsIGRvIHRoaXMgZm9yIHVzXG5cbiAgICAgICAgaWYgKCFzYiB8fCAhc2IudXBkYXRpbmcpIHtcbiAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zaGlmdEFuZEV4ZWN1dGVOZXh0ID0gZnVuY3Rpb24gc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgdGhpcy5xdWV1ZXNbdHlwZV0uc2hpZnQoKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9O1xuXG4gIF9wcm90by5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVzW3R5cGVdWzBdO1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJPcGVyYXRpb25RdWV1ZTtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2NhcC1sZXZlbC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qXG4gKiBjYXAgc3RyZWFtIGxldmVsIHRvIG1lZGlhIHNpemUgZGltZW5zaW9uIGNvbnRyb2xsZXJcbiAqL1xuXG5cbnZhciBDYXBMZXZlbENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMubGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXBMZXZlbENvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRTdHJlYW1Db250cm9sbGVyID0gZnVuY3Rpb24gc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcblxuICAgIGlmICh0aGlzLmhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkZwc0Ryb3BMZXZlbENhcHBpbmcgPSBmdW5jdGlvbiBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgaWYgKENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZChkYXRhLmRyb3BwZWRMZXZlbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goZGF0YS5kcm9wcGVkTGV2ZWwpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG5cbiAgICBpZiAoaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSAmJiBkYXRhLnZpZGVvKSB7XG4gICAgICAvLyBTdGFydCBjYXBwaW5nIGltbWVkaWF0ZWx5IGlmIHRoZSBtYW5pZmVzdCBoYXMgc2lnbmFsZWQgdmlkZW8gY29kZWNzXG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfSAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAvLyB0byB0aGUgZmlyc3QgbGV2ZWxcbiAgO1xuXG4gIF9wcm90by5vbkJ1ZmZlckNvZGVjcyA9IGZ1bmN0aW9uIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLnN0b3BDYXBwaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRldGVjdFBsYXllclNpemUgPSBmdW5jdGlvbiBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgIGlmICh0aGlzLm1lZGlhICYmIHRoaXMubWVkaWFIZWlnaHQgPiAwICYmIHRoaXMubWVkaWFXaWR0aCA+IDApIHtcbiAgICAgIHZhciBsZXZlbHNMZW5ndGggPSB0aGlzLmxldmVscyA/IHRoaXMubGV2ZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChsZXZlbHNMZW5ndGgpIHtcbiAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzTGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgIC8vIGlmIGF1dG8gbGV2ZWwgY2FwcGluZyBoYXMgYSBoaWdoZXIgdmFsdWUgZm9yIHRoZSBwcmV2aW91cyBvbmUsIGZsdXNoIHRoZSBidWZmZXIgdXNpbmcgbmV4dExldmVsU3dpdGNoXG4gICAgICAgICAgLy8gdXN1YWxseSBoYXBwZW4gd2hlbiB0aGUgdXNlciBnbyB0byB0aGUgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IGhscy5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciB2YWxpZExldmVscyA9IHRoaXMubGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmlzTGV2ZWxBbGxvd2VkKGluZGV4LCBfdGhpcy5yZXN0cmljdGVkTGV2ZWxzKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKHZhbGlkTGV2ZWxzLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydENhcHBpbmcgPSBmdW5jdGlvbiBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy5obHMuZmlyc3RMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwodGhpcy5maXJzdExldmVsKTtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDEwMDApO1xuICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9O1xuXG4gIF9wcm90by5zdG9wQ2FwcGluZyA9IGZ1bmN0aW9uIHN0b3BDYXBwaW5nKCkge1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuY2xpZW50UmVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdDtcbiAgICB9XG5cbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB2YXIgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuXG4gICAgICBpZiAoIWJvdW5kc1JlY3Qud2lkdGggJiYgIWJvdW5kc1JlY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIG1lZGlhIGVsZW1lbnQgaGFzIG5vIHdpZHRoIG9yIGhlaWdodCAoZXF1aXZhbGVudCB0byBub3QgYmVpbmcgaW4gdGhlIERPTSksXG4gICAgICAgIC8vIHRoZW4gdXNlIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IGF0dHJpYnV0ZXMgKG1lZGlhLndpZHRoLCBtZWRpYS5oZWlnaHQpXG4gICAgICAgIGJvdW5kc1JlY3Qud2lkdGggPSBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0IHx8IG1lZGlhLndpZHRoIHx8IDA7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCB8fCBtZWRpYS5oZWlnaHQgfHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9O1xuXG4gIENhcExldmVsQ29udHJvbGxlci5pc0xldmVsQWxsb3dlZCA9IGZ1bmN0aW9uIGlzTGV2ZWxBbGxvd2VkKGxldmVsLCByZXN0cmljdGVkTGV2ZWxzKSB7XG4gICAgaWYgKHJlc3RyaWN0ZWRMZXZlbHMgPT09IHZvaWQgMCkge1xuICAgICAgcmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN0cmljdGVkTGV2ZWxzLmluZGV4T2YobGV2ZWwpID09PSAtMTtcbiAgfTtcblxuICBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSA9IGZ1bmN0aW9uIGdldE1heExldmVsQnlNZWRpYVNpemUobGV2ZWxzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFsZXZlbHMgfHwgbGV2ZWxzICYmICFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAvLyBMZXZlbHMgY2FuIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBidXQgZGlmZmVyaW5nIGJhbmR3aWR0aHMgLSBzaW5jZSBsZXZlbHMgYXJlIG9yZGVyZWQsIHdlIGNhbiBsb29rIHRvIHRoZSBuZXh0XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcblxuXG4gICAgdmFyIGF0R3JlYXRlc3RCYW5kaXdkdGggPSBmdW5jdGlvbiBhdEdyZWF0ZXN0QmFuZGl3ZHRoKGN1ckxldmVsLCBuZXh0TGV2ZWwpIHtcbiAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTsgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgLy8gdGhlIG1heCBsZXZlbFxuXG5cbiAgICB2YXIgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcblxuICAgICAgaWYgKChsZXZlbC53aWR0aCA+PSB3aWR0aCB8fCBsZXZlbC5oZWlnaHQgPj0gaGVpZ2h0KSAmJiBhdEdyZWF0ZXN0QmFuZGl3ZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKSkge1xuICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKENhcExldmVsQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibWVkaWFXaWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoICogQ2FwTGV2ZWxDb250cm9sbGVyLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVkaWFIZWlnaHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiBDYXBMZXZlbENvbnRyb2xsZXIuY29udGVudFNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbnRlbnRTY2FsZUZhY3RvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENhcExldmVsQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlciAqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQGF1dGhvciBTdGVwaGFuIEhlc3NlIDxkaXNwYXJhdEBnbWFpbC5jb20+IHwgPHRjaGFrYWJhbUBnbWFpbC5jb20+XG4gKlxuICogRFJNIHN1cHBvcnQgZm9yIEhscy5qc1xuICovXG5cblxuXG5cbnZhciBNQVhfTElDRU5TRV9SRVFVRVNUX0ZBSUxVUkVTID0gMztcbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdmlkZW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCB2aWRlbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtvYmplY3R9IGRybVN5c3RlbU9wdGlvbnMgT3B0aW9uYWwgcGFyYW1ldGVycy9yZXF1aXJlbWVudHMgZm9yIHRoZSBrZXktc3lzdGVtXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQW4gYXJyYXkgb2Ygc3VwcG9ydGVkIGNvbmZpZ3VyYXRpb25zXG4gKi9cblxudmFyIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyA9IGZ1bmN0aW9uIGNyZWF0ZVdpZGV2aW5lTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgLyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIHZhciBiYXNlQ29uZmlnID0ge1xuICAgIC8vIGluaXREYXRhVHlwZXM6IFsna2V5aWRzJywgJ21wNCddLFxuICAgIC8vIGxhYmVsOiBcIlwiLFxuICAgIC8vIHBlcnNpc3RlbnRTdGF0ZTogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIGRpc3RpbmN0aXZlSWRlbnRpZmllcjogXCJub3QtYWxsb3dlZFwiLCAvLyBvciBcInJlcXVpcmVkXCIgP1xuICAgIC8vIHNlc3Npb25UeXBlczogWyd0ZW1wb3JhcnknXSxcbiAgICBhdWRpb0NhcGFiaWxpdGllczogW10sXG4gICAgLy8geyBjb250ZW50VHlwZTogJ2F1ZGlvL21wNDsgY29kZWNzPVwibXA0YS40MC4yXCInIH1cbiAgICB2aWRlb0NhcGFiaWxpdGllczogW10gLy8geyBjb250ZW50VHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS40MkUwMUVcIicgfVxuXG4gIH07XG4gIGF1ZGlvQ29kZWNzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgYmFzZUNvbmZpZy5hdWRpb0NhcGFiaWxpdGllcy5wdXNoKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcImF1ZGlvL21wNDsgY29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIsXG4gICAgICByb2J1c3RuZXNzOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvUm9idXN0bmVzcyB8fCAnJ1xuICAgIH0pO1xuICB9KTtcbiAgdmlkZW9Db2RlY3MuZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBiYXNlQ29uZmlnLnZpZGVvQ2FwYWJpbGl0aWVzLnB1c2goe1xuICAgICAgY29udGVudFR5cGU6IFwidmlkZW8vbXA0OyBjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIixcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gW2Jhc2VDb25maWddO1xufTtcbi8qKlxuICogVGhlIGlkZWEgaGVyZSBpcyB0byBoYW5kbGUga2V5LXN5c3RlbSAoYW5kIHRoZWlyIHJlc3BlY3RpdmUgcGxhdGZvcm1zKSBzcGVjaWZpYyBjb25maWd1cmF0aW9uIGRpZmZlcmVuY2VzXG4gKiBpbiBvcmRlciB0byB3b3JrIHdpdGggdGhlIGxvY2FsIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBtZXRob2QuXG4gKlxuICogV2UgY2FuIGFsc28gcnVsZS1vdXQgcGxhdGZvcm0tcmVsYXRlZCBrZXktc3lzdGVtIHN1cHBvcnQgYXQgdGhpcyBwb2ludCBieSB0aHJvd2luZyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5U3lzdGVtIElkZW50aWZpZXIgZm9yIHRoZSBrZXktc3lzdGVtLCBzZWUgYEtleVN5c3RlbXNgIGVudW1cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXVkaW9Db2RlY3MgTGlzdCBvZiByZXF1aXJlZCBhdWRpbyBjb2RlY3MgdG8gc3VwcG9ydFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgYSB1bmtub3duIGtleSBzeXN0ZW0gaXMgcGFzc2VkXG4gKiBAcmV0dXJucyB7QXJyYXk8TWVkaWFTeXN0ZW1Db25maWd1cmF0aW9uPn0gQSBub24tZW1wdHkgQXJyYXkgb2YgTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9uIG9iamVjdHNcbiAqL1xuXG5cbnZhciBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zID0gZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucykge1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIktleVN5c3RlbXNcIl0uV0lERVZJTkU6XG4gICAgICByZXR1cm4gY3JlYXRlV2lkZXZpbmVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcywgZHJtU3lzdGVtT3B0aW9ucyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBrZXktc3lzdGVtOiBcIiArIGtleVN5c3RlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udHJvbGxlciB0byBkZWFsIHdpdGggZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMgKEVNRSlcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICpcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFTUVDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RzXG4gICAqIEBwYXJhbSB7SGxzfSBobHMgT3VyIEhscy5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gRU1FQ29udHJvbGxlcihobHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5fd2lkZXZpbmVMaWNlbnNlVXJsID0gdm9pZCAwO1xuICAgIHRoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbWVFbmFibGVkID0gdm9pZCAwO1xuICAgIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9kcm1TeXN0ZW1PcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuX2NvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0ID0gW107XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLm1lZGlhS2V5c1Byb21pc2UgPSBudWxsO1xuXG4gICAgdGhpcy5fb25NZWRpYUVuY3J5cHRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiTWVkaWEgaXMgZW5jcnlwdGVkIHVzaW5nIFxcXCJcIiArIGUuaW5pdERhdGFUeXBlICsgXCJcXFwiIGluaXQgZGF0YSB0eXBlXCIpO1xuXG4gICAgICBpZiAoIV90aGlzLm1lZGlhS2V5c1Byb21pc2UpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdGYXRhbDogTWVkaWEgaXMgZW5jcnlwdGVkIGJ1dCBubyBDRE0gYWNjZXNzIG9yIG5vIGtleXMgaGF2ZSBiZWVuIHJlcXVlc3RlZCcpO1xuXG4gICAgICAgIF90aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmFsbHlTZXRLZXlBbmRTdGFydFNlc3Npb24gPSBmdW5jdGlvbiBmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKG1lZGlhS2V5cykge1xuICAgICAgICBpZiAoIV90aGlzLl9tZWRpYSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9hdHRlbXB0U2V0TWVkaWFLZXlzKG1lZGlhS2V5cyk7XG5cbiAgICAgICAgX3RoaXMuX2dlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGUuaW5pdERhdGFUeXBlLCBlLmluaXREYXRhKTtcbiAgICAgIH07IC8vIENvdWxkIHVzZSBgUHJvbWlzZS5maW5hbGx5YCBidXQgc29tZSBQcm9taXNlIHBvbHlmaWxscyBhcmUgbWlzc2luZyBpdFxuXG5cbiAgICAgIF90aGlzLm1lZGlhS2V5c1Byb21pc2UudGhlbihmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKS5jYXRjaChmaW5hbGx5U2V0S2V5QW5kU3RhcnRTZXNzaW9uKTtcbiAgICB9O1xuXG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLl93aWRldmluZUxpY2Vuc2VVcmwgPSB0aGlzLl9jb25maWcud2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIHRoaXMuX2xpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuX2NvbmZpZy5saWNlbnNlWGhyU2V0dXA7XG4gICAgdGhpcy5fZW1lRW5hYmxlZCA9IHRoaXMuX2NvbmZpZy5lbWVFbmFibGVkO1xuICAgIHRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IHRoaXMuX2NvbmZpZy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuICAgIHRoaXMuX2RybVN5c3RlbU9wdGlvbnMgPSB0aGlzLl9jb25maWcuZHJtU3lzdGVtT3B0aW9ucztcblxuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRU1FQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVN5c3RlbSBJZGVudGlmaWVyIGZvciB0aGUga2V5LXN5c3RlbSwgc2VlIGBLZXlTeXN0ZW1zYCBlbnVtXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IExpY2Vuc2Ugc2VydmVyIFVSTCBmb3Iga2V5LXN5c3RlbSAoaWYgYW55IGNvbmZpZ3VyZWQsIG90aGVyd2lzZSBjYXVzZXMgZXJyb3IpXG4gICAqIEB0aHJvd3MgaWYgYSB1bnN1cHBvcnRlZCBrZXlzeXN0ZW0gaXMgcGFzc2VkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldExpY2Vuc2VTZXJ2ZXJVcmwgPSBmdW5jdGlvbiBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgIHN3aXRjaCAoa2V5U3lzdGVtKSB7XG4gICAgICBjYXNlIF91dGlsc19tZWRpYWtleXNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJLZXlTeXN0ZW1zXCJdLldJREVWSU5FOlxuICAgICAgICBpZiAoIXRoaXMuX3dpZGV2aW5lTGljZW5zZVVybCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZGV2aW5lTGljZW5zZVVybDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFjY2VzcyBvYmplY3QgYW5kIGFkZHMgaXQgdG8gb3VyIGxpc3QgdXBvbiBzdWNjZXNzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW0gU3lzdGVtIElEIChzZWUgYEtleVN5c3RlbXNgKVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF1ZGlvQ29kZWNzIExpc3Qgb2YgcmVxdWlyZWQgYXVkaW8gY29kZWNzIHRvIHN1cHBvcnRcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb0NvZGVjcyBMaXN0IG9mIHJlcXVpcmVkIHZpZGVvIGNvZGVjcyB0byBzdXBwb3J0XG4gICAqIEB0aHJvd3MgV2hlbiBhIHVuc3VwcG9ydGVkIEtleVN5c3RlbSBpcyBwYXNzZWRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2F0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiBfYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgIHZhciBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLl9kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdSZXF1ZXN0aW5nIGVuY3J5cHRlZCBtZWRpYSBrZXktc3lzdGVtIGFjY2VzcycpOyAvLyBleHBlY3RpbmcgaW50ZXJmYWNlIGxpa2Ugd2luZG93Lm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcblxuICAgIHZhciBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgIHRoaXMubWVkaWFLZXlzUHJvbWlzZSA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2UudGhlbihmdW5jdGlvbiAobWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHJldHVybiBfdGhpczIuX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZChrZXlTeXN0ZW0sIG1lZGlhS2V5U3lzdGVtQWNjZXNzKTtcbiAgICB9KTtcbiAgICBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIkZhaWxlZCB0byBvYnRhaW4ga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgYWNjZXNzOlwiLCBlcnIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9idGFpbmluZyBhY2Nlc3MgdG8gYSBrZXktc3lzdGVtXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlTeXN0ZW1cbiAgICogQHBhcmFtIHtNZWRpYUtleVN5c3RlbUFjY2Vzc30gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAqL1xuICBfcHJvdG8uX29uTWVkaWFLZXlTeXN0ZW1BY2Nlc3NPYnRhaW5lZCA9IGZ1bmN0aW9uIF9vbk1lZGlhS2V5U3lzdGVtQWNjZXNzT2J0YWluZWQoa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIkFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCIgb2J0YWluZWRcIik7XG4gICAgdmFyIG1lZGlhS2V5c0xpc3RJdGVtID0ge1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIG1lZGlhS2V5U3lzdGVtQWNjZXNzOiBtZWRpYUtleVN5c3RlbUFjY2VzcyxcbiAgICAgIG1lZGlhS2V5U3lzdGVtRG9tYWluOiBrZXlTeXN0ZW1cbiAgICB9O1xuXG4gICAgdGhpcy5fbWVkaWFLZXlzTGlzdC5wdXNoKG1lZGlhS2V5c0xpc3RJdGVtKTtcblxuICAgIHZhciBtZWRpYUtleXNQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVkaWFLZXlTeXN0ZW1BY2Nlc3MuY3JlYXRlTWVkaWFLZXlzKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAobWVkaWFLZXlzKSB7XG4gICAgICBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMgPSBtZWRpYUtleXM7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiTWVkaWEta2V5cyBjcmVhdGVkIGZvciBrZXktc3lzdGVtIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcblxuICAgICAgX3RoaXMzLl9vbk1lZGlhS2V5c0NyZWF0ZWQoKTtcblxuICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICB9KTtcbiAgICBtZWRpYUtleXNQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzOicsIGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lZGlhS2V5c1Byb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5LWNyZWF0aW9uIChyZXByZXNlbnRzIGFjY2VzcyB0byBDRE0pLiBXZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGtleS1zZXNzaW9ucyB1cG9uIHRoaXNcbiAgICogZm9yIGFsbCBleGlzdGluZyBrZXlzIHdoZXJlIG5vIHNlc3Npb24gZXhpc3RzIHlldC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX29uTWVkaWFLZXlzQ3JlYXRlZCA9IGZ1bmN0aW9uIF9vbk1lZGlhS2V5c0NyZWF0ZWQoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvLyBjaGVjayBmb3IgYWxsIGtleS1saXN0IGl0ZW1zIGlmIGEgc2Vzc2lvbiBleGlzdHMsIG90aGVyd2lzZSwgY3JlYXRlIG9uZVxuICAgIHRoaXMuX21lZGlhS2V5c0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWVkaWFLZXlzTGlzdEl0ZW0pIHtcbiAgICAgIGlmICghbWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAvLyBtZWRpYUtleXMgaXMgZGVmaW5pdGVseSBpbml0aWFsaXplZCBoZXJlXG4gICAgICAgIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXNMaXN0SXRlbS5tZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuXG4gICAgICAgIF90aGlzNC5fb25OZXdNZWRpYUtleVNlc3Npb24obWVkaWFLZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0ga2V5U2Vzc2lvblxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fb25OZXdNZWRpYUtleVNlc3Npb24gPSBmdW5jdGlvbiBfb25OZXdNZWRpYUtleVNlc3Npb24oa2V5U2Vzc2lvbikge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIk5ldyBrZXktc3lzdGVtIHNlc3Npb24gXCIgKyBrZXlTZXNzaW9uLnNlc3Npb25JZCk7XG4gICAga2V5U2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczUuX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgZXZlbnQubWVzc2FnZSk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01lZGlhS2V5U2Vzc2lvbn0ga2V5U2Vzc2lvblxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBtZXNzYWdlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9vbktleVNlc3Npb25NZXNzYWdlID0gZnVuY3Rpb24gX29uS2V5U2Vzc2lvbk1lc3NhZ2Uoa2V5U2Vzc2lvbiwgbWVzc2FnZSkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ0dvdCBFTUUgbWVzc2FnZSBldmVudCwgY3JlYXRpbmcgbGljZW5zZSByZXF1ZXN0Jyk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZShtZXNzYWdlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZyhcIlJlY2VpdmVkIGxpY2Vuc2UgZGF0YSAobGVuZ3RoOiBcIiArIChkYXRhID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YSkgKyBcIiksIHVwZGF0aW5nIGtleS1zZXNzaW9uXCIpO1xuICAgICAga2V5U2Vzc2lvbi51cGRhdGUoZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBlIHtNZWRpYUVuY3J5cHRlZEV2ZW50fVxuICAgKi9cbiAgO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb3RvLl9hdHRlbXB0U2V0TWVkaWFLZXlzID0gZnVuY3Rpb24gX2F0dGVtcHRTZXRNZWRpYUtleXMobWVkaWFLZXlzKSB7XG4gICAgaWYgKCF0aGlzLl9tZWRpYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gc2V0IG1lZGlhS2V5cyB3aXRob3V0IGZpcnN0IGF0dGFjaGluZyBhIG1lZGlhIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hhc1NldE1lZGlhS2V5cykge1xuICAgICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgICAgdmFyIGtleXNMaXN0SXRlbSA9IHRoaXMuX21lZGlhS2V5c0xpc3RbMF07XG5cbiAgICAgIGlmICgha2V5c0xpc3RJdGVtIHx8ICFrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8gQ0RNIGFjY2VzcyBvciBubyBrZXlzIGhhdmUgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdTZXR0aW5nIGtleXMgZm9yIGVuY3J5cHRlZCBtZWRpYScpO1xuXG4gICAgICB0aGlzLl9tZWRpYS5zZXRNZWRpYUtleXMoa2V5c0xpc3RJdGVtLm1lZGlhS2V5cyk7XG5cbiAgICAgIHRoaXMuX2hhc1NldE1lZGlhS2V5cyA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24gPSBmdW5jdGlvbiBfZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oaW5pdERhdGFUeXBlLCBpbml0RGF0YSkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gRklYTUU6IHNlZSBpZiB3ZSBjYW4vd2FudC9uZWVkLXRvIHJlYWxseSB0byBkZWFsIHdpdGggc2V2ZXJhbCBwb3RlbnRpYWwga2V5LXNlc3Npb25zP1xuICAgIHZhciBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuXG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWw6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm90IGFueSBrZXktc3lzdGVtIGFjY2VzcyBoYXMgYmVlbiBvYnRhaW5lZCB5ZXQnKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdLZXktU2Vzc2lvbiBhbHJlYWR5IGluaXRpYWxpemVkIGJ1dCByZXF1ZXN0ZWQgYWdhaW4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5U2Vzc2lvbiA9IGtleXNMaXN0SXRlbS5tZWRpYUtleXNTZXNzaW9uO1xuXG4gICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0ZhdGFsOiBNZWRpYSBpcyBlbmNyeXB0ZWQgYnV0IG5vIGtleS1zZXNzaW9uIGV4aXN0aW5nJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGluaXREYXRhIGlzIG51bGwgaWYgdGhlIG1lZGlhIGlzIG5vdCBDT1JTLXNhbWUtb3JpZ2luXG5cblxuICAgIGlmICghaW5pdERhdGEpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdGYXRhbDogaW5pdERhdGEgcmVxdWlyZWQgZm9yIGdlbmVyYXRpbmcgYSBrZXkgc2Vzc2lvbiBpcyBudWxsJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX05PX0lOSVRfREFUQSxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coXCJHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFxcXCJcIiArIGluaXREYXRhVHlwZSArIFwiXFxcIiBpbml0IGRhdGEgdHlwZVwiKTtcbiAgICBrZXlzTGlzdEl0ZW0ubWVkaWFLZXlzU2Vzc2lvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBrZXlTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5kZWJ1ZygnS2V5LXNlc3Npb24gZ2VuZXJhdGlvbiBzdWNjZWVkZWQnKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDonLCBlcnIpO1xuXG4gICAgICBfdGhpczYuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9TWVNURU1fTk9fU0VTU0lPTixcbiAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBMaWNlbnNlIHNlcnZlciBVUkxcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5TWVzc2FnZSBNZXNzYWdlIGRhdGEgaXNzdWVkIGJ5IGtleS1zeXN0ZW1cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gWEhSIGhhcyBzdWNjZWVkZWRcbiAgICogQHJldHVybnMge1hNTEh0dHBSZXF1ZXN0fSBVbnNlbnQgKGJ1dCBvcGVuZWQgc3RhdGUpIFhIUiBvYmplY3RcbiAgICogQHRocm93cyBpZiBYTUxIdHRwUmVxdWVzdCBjb25zdHJ1Y3Rpb24gZmFpbGVkXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9jcmVhdGVMaWNlbnNlWGhyID0gZnVuY3Rpb24gX2NyZWF0ZUxpY2Vuc2VYaHIodXJsLCBrZXlNZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbGljZW5zZVhoclNldHVwID0gdGhpcy5fbGljZW5zZVhoclNldHVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChsaWNlbnNlWGhyU2V0dXApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaWNlbnNlWGhyU2V0dXAoeGhyLCB1cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgbGljZW5zZVhoclNldHVwKHhociwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiBsaWNlbnNlWGhyU2V0dXAgZGlkIG5vdCB5ZXQgY2FsbCBvcGVuLCBsZXQncyBkbyBpdCBub3dcblxuXG4gICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpc3N1ZSBzZXR0aW5nIHVwIEtleVN5c3RlbSBsaWNlbnNlIFhIUiBcIiArIGUpO1xuICAgIH0gLy8gQmVjYXVzZSB3ZSBzZXQgcmVzcG9uc2VUeXBlIHRvIEFycmF5QnVmZmVyIGhlcmUsIGNhbGxiYWNrIGlzIHR5cGVkIGFzIGhhbmRsaW5nIG9ubHkgYXJyYXkgYnVmZmVyc1xuXG5cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UuYmluZCh0aGlzLCB4aHIsIHVybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB4aHI7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIExpY2Vuc2Ugc2VydmVyIFVSTFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBrZXlNZXNzYWdlIE1lc3NhZ2UgZGF0YSBpc3N1ZWQgYnkga2V5LXN5c3RlbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBYSFIgaGFzIHN1Y2NlZWRlZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBfb25MaWNlbnNlUmVxdWVzdFJlYWR5U3RhZ2VDaGFuZ2UoeGhyLCB1cmwsIGtleU1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwO1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5sb2coJ0xpY2Vuc2UgcmVxdWVzdCBzdWNjZWVkZWQnKTtcblxuICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUeXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybigneGhyIHJlc3BvbnNlIHR5cGUgd2FzIG5vdCBzZXQgdG8gdGhlIGV4cGVjdGVkIGFycmF5YnVmZmVyIGZvciBsaWNlbnNlIHJlcXVlc3QnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcihcIkxpY2Vuc2UgUmVxdWVzdCBYSFIgZmFpbGVkIChcIiArIHVybCArIFwiKS4gU3RhdHVzOiBcIiArIHhoci5zdGF0dXMgKyBcIiAoXCIgKyB4aHIuc3RhdHVzVGV4dCArIFwiKVwiKTtcbiAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID4gTUFYX0xJQ0VOU0VfUkVRVUVTVF9GQUlMVVJFUykge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGF0dGVtcHRzTGVmdCA9IE1BWF9MSUNFTlNFX1JFUVVFU1RfRkFJTFVSRVMgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oXCJSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsIFwiICsgYXR0ZW1wdHNMZWZ0ICsgXCIgYXR0ZW1wdHMgbGVmdFwiKTtcblxuICAgICAgICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlKGtleU1lc3NhZ2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNZWRpYUtleXNMaXN0SXRlbX0ga2V5c0xpc3RJdGVtXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleU1lc3NhZ2VcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBDaGFsbGVuZ2UgZGF0YSBwb3N0ZWQgdG8gbGljZW5zZSBzZXJ2ZXJcbiAgICogQHRocm93cyBpZiBLZXlTeXN0ZW0gaXMgdW5zdXBwb3J0ZWRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2dlbmVyYXRlTGljZW5zZVJlcXVlc3RDaGFsbGVuZ2UgPSBmdW5jdGlvbiBfZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZShrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpIHtcbiAgICBzd2l0Y2ggKGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbikge1xuICAgICAgLy8gY2FzZSBLZXlTeXN0ZW1zLlBMQVlSRUFEWTpcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdEVkZ2UvRGVtb3MvYmxvYi9tYXN0ZXIvZW1lL3NjcmlwdHMvZGVtby5qc1xuXG4gICAgICAvKlxuICAgICAgaWYgKHRoaXMubGljZW5zZVR5cGUgIT09IHRoaXMuTElDRU5TRV9UWVBFX1dJREVWSU5FKSB7XG4gICAgICAgIC8vIEZvciBQbGF5UmVhZHkgQ0RNcywgd2UgbmVlZCB0byBkaWcgdGhlIENoYWxsZW5nZSBvdXQgb2YgdGhlIFhNTC5cbiAgICAgICAgdmFyIGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGtleU1lc3NhZ2UpKSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICBpZiAoa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0pIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZSA9IGF0b2Ioa2V5TWVzc2FnZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnQ2hhbGxlbmdlJylbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmaW5kIDxDaGFsbGVuZ2U+IGluIGtleSBtZXNzYWdlJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyTmFtZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCduYW1lJyk7XG4gICAgICAgIHZhciBoZWFkZXJWYWx1ZXMgPSBrZXlNZXNzYWdlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2YWx1ZScpO1xuICAgICAgICBpZiAoaGVhZGVyTmFtZXMubGVuZ3RoICE9PSBoZWFkZXJWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAnTWlzbWF0Y2hlZCBoZWFkZXIgPG5hbWU+Lzx2YWx1ZT4gcGFpciBpbiBrZXkgbWVzc2FnZSc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZXNbaV0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUsIGhlYWRlclZhbHVlc1tpXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgICAgKi9cbiAgICAgIGNhc2UgX3V0aWxzX21lZGlha2V5c19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIktleVN5c3RlbXNcIl0uV0lERVZJTkU6XG4gICAgICAgIC8vIEZvciBXaWRldmluZSBDRE1zLCB0aGUgY2hhbGxlbmdlIGlzIHRoZSBrZXlNZXNzYWdlLlxuICAgICAgICByZXR1cm4ga2V5TWVzc2FnZTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktc3lzdGVtOiBcIiArIGtleXNMaXN0SXRlbS5tZWRpYUtleVN5c3RlbURvbWFpbik7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSBrZXlNZXNzYWdlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fcmVxdWVzdExpY2Vuc2UgPSBmdW5jdGlvbiBfcmVxdWVzdExpY2Vuc2Uoa2V5TWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdSZXF1ZXN0aW5nIGNvbnRlbnQgbGljZW5zZSBmb3Iga2V5LXN5c3RlbScpO1xuICAgIHZhciBrZXlzTGlzdEl0ZW0gPSB0aGlzLl9tZWRpYUtleXNMaXN0WzBdO1xuXG4gICAgaWYgKCFrZXlzTGlzdEl0ZW0pIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS5lcnJvcignRmF0YWwgZXJyb3I6IE1lZGlhIGlzIGVuY3J5cHRlZCBidXQgbm8ga2V5LXN5c3RlbSBhY2Nlc3MgaGFzIGJlZW4gb2J0YWluZWQgeWV0Jyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3VybCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChrZXlzTGlzdEl0ZW0ubWVkaWFLZXlTeXN0ZW1Eb21haW4pO1xuXG4gICAgICB2YXIgX3hociA9IHRoaXMuX2NyZWF0ZUxpY2Vuc2VYaHIoX3VybCwga2V5TWVzc2FnZSwgY2FsbGJhY2spO1xuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKFwiU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiBcIiArIF91cmwpO1xuXG4gICAgICB2YXIgY2hhbGxlbmdlID0gdGhpcy5fZ2VuZXJhdGVMaWNlbnNlUmVxdWVzdENoYWxsZW5nZShrZXlzTGlzdEl0ZW0sIGtleU1lc3NhZ2UpO1xuXG4gICAgICBfeGhyLnNlbmQoY2hhbGxlbmdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJGYWlsdXJlIHJlcXVlc3RpbmcgRFJNIGxpY2Vuc2U6IFwiICsgZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5fZW1lRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7IC8vIGtlZXAgcmVmZXJlbmNlIG9mIG1lZGlhXG5cbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgdmFyIG1lZGlhS2V5c0xpc3QgPSB0aGlzLl9tZWRpYUtleXNMaXN0O1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIHRoaXMuX29uTWVkaWFFbmNyeXB0ZWQpO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLl9tZWRpYUtleXNMaXN0ID0gW107IC8vIENsb3NlIGFsbCBzZXNzaW9ucyBhbmQgcmVtb3ZlIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cblxuICAgIFByb21pc2UuYWxsKG1lZGlhS2V5c0xpc3QubWFwKGZ1bmN0aW9uIChtZWRpYUtleXNMaXN0SXRlbSkge1xuICAgICAgaWYgKG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIG1lZGlhS2V5c0xpc3RJdGVtLm1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKS5jYXRjaChmdW5jdGlvbiAoKSB7Ly8gSWdub3JlIGVycm9ycyB3aGVuIGNsb3NpbmcgdGhlIHNlc3Npb25zLiBDbG9zaW5nIGEgc2Vzc2lvbiB0aGF0XG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIG5vIGtleSByZXF1ZXN0cyB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVkaWEuc2V0TWVkaWFLZXlzKG51bGwpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHsvLyBJZ25vcmUgYW55IGZhaWx1cmVzIHdoaWxlIHJlbW92aW5nIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXVkaW9Db2RlY3MgPSBkYXRhLmxldmVscy5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICByZXR1cm4gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGF1ZGlvQ29kZWMpIHtcbiAgICAgIHJldHVybiAhIWF1ZGlvQ29kZWM7XG4gICAgfSk7XG4gICAgdmFyIHZpZGVvQ29kZWNzID0gZGF0YS5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIGxldmVsLnZpZGVvQ29kZWM7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2aWRlb0NvZGVjKSB7XG4gICAgICByZXR1cm4gISF2aWRlb0NvZGVjO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhfdXRpbHNfbWVkaWFrZXlzX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiS2V5U3lzdGVtc1wiXS5XSURFVklORSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRU1FQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwicmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyBmdW5jdGlvbiBjb25maWd1cmVkJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3M7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVNRUNvbnRyb2xsZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRU1FQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxudmFyIEZQU0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcbiAgZnVuY3Rpb24gRlBTQ29udHJvbGxlcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGFzdFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IDA7XG4gICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IDA7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGUFNDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0U3RyZWFtQ29udHJvbGxlciA9IGZ1bmN0aW9uIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH07XG5cbiAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZyk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgIH1cblxuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICB2YXIgbWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2Ygc2VsZi5IVE1MVmlkZW9FbGVtZW50ID8gZGF0YS5tZWRpYSA6IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG5cbiAgICAgIGlmIChtZWRpYSAmJiB0eXBlb2YgbWVkaWEuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmNoZWNrRlBTSW50ZXJ2YWwuYmluZCh0aGlzKSwgY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrRlBTID0gZnVuY3Rpb24gY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGlmIChkZWNvZGVkRnJhbWVzKSB7XG4gICAgICBpZiAodGhpcy5sYXN0VGltZSkge1xuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgdmFyIGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXM7XG4gICAgICAgIHZhciBjdXJyZW50RGVjb2RlZCA9IGRlY29kZWRGcmFtZXMgLSB0aGlzLmxhc3REZWNvZGVkRnJhbWVzO1xuICAgICAgICB2YXIgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZQU19EUk9QLCB7XG4gICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoY3VycmVudERyb3BwZWQgPiBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLndhcm4oJ2Ryb3AgRlBTIHJhdGlvIGdyZWF0ZXIgdGhhbiBtYXggYWxsb3dlZCB2YWx1ZSBmb3IgY3VycmVudExldmVsOiAnICsgY3VycmVudExldmVsKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA+IDAgJiYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID09PSAtMSB8fCBobHMuYXV0b0xldmVsQ2FwcGluZyA+PSBjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jaGVja0ZQU0ludGVydmFsID0gZnVuY3Rpb24gY2hlY2tGUFNJbnRlcnZhbCgpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGUFNDb250cm9sbGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEZQU0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LWZpbmRlcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZmluZEZyYWdtZW50QnlQRFQsIGZpbmRGcmFnbWVudEJ5UFRTLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QsIHBkdFdpdGhpblRvbGVyYW5jZVRlc3QsIGZpbmRGcmFnV2l0aENDICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnbWVudEJ5UERUXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdtZW50QnlQRFQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnbWVudEJ5UFRTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdtZW50QnlQVFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGR0V2l0aGluVG9sZXJhbmNlVGVzdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBkdFdpdGhpblRvbGVyYW5jZVRlc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmRGcmFnV2l0aENDXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZyYWdXaXRoQ0M7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2JpbmFyeV9zZWFyY2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2JpbmFyeS1zZWFyY2ggKi8gXCIuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzXCIpO1xuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQuXG4gKiBAcGFyYW0ge0FycmF5PEZyYWdtZW50Pn0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFtQRFRWYWx1ZSA9IG51bGxdIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHsqfG51bGx9IGZyYWdtZW50IC0gVGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoUERUVmFsdWUgPT09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkoZnJhZ21lbnRzKSB8fCAhZnJhZ21lbnRzLmxlbmd0aCB8fCAhT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKFBEVFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuXG5cbiAgdmFyIHN0YXJ0UERUID0gZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTtcblxuICBpZiAoUERUVmFsdWUgPCAoc3RhcnRQRFQgfHwgMCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlbmRQRFQgPSBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLmVuZFByb2dyYW1EYXRlVGltZTtcblxuICBpZiAoUERUVmFsdWUgPj0gKGVuZFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcblxuICBmb3IgKHZhciBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgIHZhciBmcmFnID0gZnJhZ21lbnRzW3NlZ107XG5cbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kcyBhIGZyYWdtZW50IGJhc2VkIG9uIHRoZSBTTiBvZiB0aGUgcHJldmlvdXMgZnJhZ21lbnQ7IG9yIGJhc2VkIG9uIHRoZSBuZWVkcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAqIGJyZWFraW5nIGFueSB0cmFwcyB3aGljaCB3b3VsZCBjYXVzZSB0aGUgc2FtZSBmcmFnbWVudCB0byBiZSBjb250aW51b3VzbHkgc2VsZWN0ZWQgd2l0aGluIGEgc21hbGwgcmFuZ2UuXG4gKiBAcGFyYW0geyp9IGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gKiBAcGFyYW0ge0FycmF5fSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IFtidWZmZXJFbmQgPSAwXSAtIFRoZSBlbmQgb2YgdGhlIGNvbnRpZ3VvdXMgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgeyp9IGZvdW5kRnJhZyAtIFRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50XG4gKi9cblxuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICBpZiAoYnVmZmVyRW5kID09PSB2b2lkIDApIHtcbiAgICBidWZmZXJFbmQgPSAwO1xuICB9XG5cbiAgaWYgKG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwO1xuICB9XG5cbiAgdmFyIGZyYWdOZXh0ID0gbnVsbDtcblxuICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgZnJhZ05leHQgPSBmcmFnbWVudHNbZnJhZ1ByZXZpb3VzLnNuIC0gZnJhZ21lbnRzWzBdLnNuICsgMV07XG4gIH0gZWxzZSBpZiAoYnVmZmVyRW5kID09PSAwICYmIGZyYWdtZW50c1swXS5zdGFydCA9PT0gMCkge1xuICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzBdO1xuICB9IC8vIFByZWZlciB0aGUgbmV4dCBmcmFnbWVudCBpZiBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcblxuXG4gIGlmIChmcmFnTmV4dCAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkgPT09IDApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH0gLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuXG5cbiAgdmFyIGZvdW5kRnJhZ21lbnQgPSBfdXRpbHNfYmluYXJ5X3NlYXJjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5zZWFyY2goZnJhZ21lbnRzLCBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QuYmluZChudWxsLCBidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKTtcblxuICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgIHJldHVybiBmb3VuZEZyYWdtZW50O1xuICB9IC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCByZXR1cm4gdGhlIG5leHQgZnJhZ21lbnQgYWZ0ZXIgZnJhZ1ByZXZpb3VzLCBvciBudWxsXG5cblxuICByZXR1cm4gZnJhZ05leHQ7XG59XG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0geyp9IGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0ge251bWJlcn0gW2J1ZmZlckVuZCA9IDBdIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cblxuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlKSB7XG4gIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkge1xuICAgIGJ1ZmZlckVuZCA9IDA7XG4gIH1cblxuICBpZiAobWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gIH1cblxuICAvLyBvZmZzZXQgc2hvdWxkIGJlIHdpdGhpbiBmcmFnbWVudCBib3VuZGFyeSAtIGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlXG4gIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAvLyBidWZmZXJFbmQgPSA5Ljk5MVxuICAvLyBmcmFnW8OYXSA6IFswLDEwXVxuICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAvLyBidWZmZXJFbmQgaXMgd2l0aGluIGZyYWdbMF0gcmFuZ2UgLi4uIGFsdGhvdWdoIHdoYXQgd2UgYXJlIGV4cGVjdGluZyBpcyB0byByZXR1cm4gZnJhZ1sxXSBoZXJlXG4gIC8vICAgICAgICAgICAgICBmcmFnIHN0YXJ0ICAgICAgICAgICAgICAgZnJhZyBzdGFydCtkdXJhdGlvblxuICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgLy8gICAgICAgICAgICAgIDwtLS0+ICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0+XG4gIC8vICAuLi4tLS0tLS0tLT48LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+PC0tLS0tLS0tLS4uLi5cbiAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gIC8vICByZXR1cm4gLTEgICAgICAgICAgICAgcmV0dXJuIDAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gIC8vIGxvZ2dlci5sb2coYGxldmVsL3NuL3N0YXJ0L2VuZC9idWZFbmQ6JHtsZXZlbH0vJHtjYW5kaWRhdGUuc259LyR7Y2FuZGlkYXRlLnN0YXJ0fS8keyhjYW5kaWRhdGUuc3RhcnQrY2FuZGlkYXRlLmR1cmF0aW9uKX0vJHtidWZmZXJFbmR9YCk7XG4gIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuXG4gIGlmIChjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD0gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5UGR0J3MgQmluYXJ5U2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBiZXN0IG1hdGNoIHRvIHRoZSBjdXJyZW50IGJ1ZmZlciBjb25kaXRpb25zLlxuICogVGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUgY2FuZGlkYXRlJ3MgcHJvZ3JhbSBkYXRlIHRpbWUgdmFsdWVzLCBhcyByZXByZXNlbnRlZCBpbiBVbml4IHRpbWVcbiAqIEBwYXJhbSB7Kn0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGR0QnVmZmVyRW5kID0gMF0gLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gW21heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwXSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblxuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICB2YXIgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4obWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApKSAqIDEwMDA7IC8vIGVuZFByb2dyYW1EYXRlVGltZSBjYW4gYmUgbnVsbCwgZGVmYXVsdCB0byB6ZXJvXG5cbiAgdmFyIGVuZFByb2dyYW1EYXRlVGltZSA9IGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMDtcbiAgcmV0dXJuIGVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cbmZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgQ0MpIHtcbiAgcmV0dXJuIF91dGlsc19iaW5hcnlfc2VhcmNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgQ0MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gQ0MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEZyYWdtZW50U3RhdGUsIEZyYWdtZW50VHJhY2tlciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGcmFnbWVudFN0YXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRTdGF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRnJhZ21lbnRUcmFja2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRUcmFja2VyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG5cbnZhciBGcmFnbWVudFN0YXRlO1xuXG4oZnVuY3Rpb24gKEZyYWdtZW50U3RhdGUpIHtcbiAgRnJhZ21lbnRTdGF0ZVtcIk5PVF9MT0FERURcIl0gPSBcIk5PVF9MT0FERURcIjtcbiAgRnJhZ21lbnRTdGF0ZVtcIkJBQ0tUUkFDS0VEXCJdID0gXCJCQUNLVFJBQ0tFRFwiO1xuICBGcmFnbWVudFN0YXRlW1wiQVBQRU5ESU5HXCJdID0gXCJBUFBFTkRJTkdcIjtcbiAgRnJhZ21lbnRTdGF0ZVtcIlBBUlRJQUxcIl0gPSBcIlBBUlRJQUxcIjtcbiAgRnJhZ21lbnRTdGF0ZVtcIk9LXCJdID0gXCJPS1wiO1xufSkoRnJhZ21lbnRTdGF0ZSB8fCAoRnJhZ21lbnRTdGF0ZSA9IHt9KSk7XG5cbnZhciBGcmFnbWVudFRyYWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFnbWVudFRyYWNrZXIoaGxzKSB7XG4gICAgdGhpcy5hY3RpdmVGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVQYXJ0ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZyYWdtZW50VHJhY2tlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgd2l0aCBhbiBhcHBlbmRlZCByYW5nZSB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldEFwcGVuZGVkRnJhZyA9IGZ1bmN0aW9uIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgdmFyIGFjdGl2ZUZyYWdtZW50ID0gdGhpcy5hY3RpdmVGcmFnbWVudDtcblxuICAgIGlmICghYWN0aXZlRnJhZ21lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVGcmFnbWVudC5hcHBlbmRlZFBUUyAhPT0gdW5kZWZpbmVkICYmIGFjdGl2ZUZyYWdtZW50LnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGFjdGl2ZUZyYWdtZW50LmFwcGVuZGVkUFRTKSB7XG4gICAgICByZXR1cm4gYWN0aXZlRnJhZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAqIEEgYnVmZmVyZWQgRnJhZ21lbnQgaXMgb25lIHdob3NlIGxvYWRpbmcsIHBhcnNpbmcgYW5kIGFwcGVuZGluZyBpcyBkb25lIChjb21wbGV0ZWQgb3IgXCJwYXJ0aWFsXCIgbWVhbmluZyBhYm9ydGVkKS5cbiAgICogSWYgbm90IGZvdW5kIGFueSBGcmFnbWVudCwgcmV0dXJuIG51bGxcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICB2YXIgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG5cbiAgICAgIGlmICgoZnJhZ21lbnRFbnRpdHkgPT09IG51bGwgfHwgZnJhZ21lbnRFbnRpdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyYWdtZW50RW50aXR5LmJvZHkudHlwZSkgPT09IGxldmVsVHlwZSAmJiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICB2YXIgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG5cbiAgICAgICAgaWYgKGZyYWcuc3RhcnQgPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBQYXJ0aWFsIGZyYWdtZW50cyBlZmZlY3RlZCBieSBjb2RlZCBmcmFtZSBldmljdGlvbiB3aWxsIGJlIHJlbW92ZWRcbiAgICogVGhlIGJyb3dzZXIgd2lsbCB1bmxvYWQgcGFydHMgb2YgdGhlIGJ1ZmZlciB0byBmcmVlIHVwIG1lbW9yeSBmb3IgbmV3IGJ1ZmZlciBkYXRhXG4gICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRlY3RFdmljdGVkRnJhZ21lbnRzID0gZnVuY3Rpb24gZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhlbGVtZW50YXJ5U3RyZWFtLCB0aW1lUmFuZ2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8ICFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlc0RhdGEgPSBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXTtcblxuICAgICAgaWYgKCFlc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlc0RhdGEudGltZS5zb21lKGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHZhciBpc05vdEJ1ZmZlcmVkID0gIV90aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuXG4gICAgICAgIGlmIChpc05vdEJ1ZmZlcmVkKSB7XG4gICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgX3RoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNOb3RCdWZmZXJlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGVjdFBhcnRpYWxGcmFnbWVudHMgPSBmdW5jdGlvbiBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuXG4gICAgaWYgKCF0aW1lUmFuZ2VzIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIHZhciBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuXG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkID0gdHJ1ZTtcbiAgICBmcmFnbWVudEVudGl0eS5iYWNrdHJhY2sgPSBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgIHZhciBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcblxuICAgICAgaWYgKCFzdHJlYW1JbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICB2YXIgcGFydGlhbCA9IHBhcnQgIT09IG51bGwgfHwgc3RyZWFtSW5mby5wYXJ0aWFsID09PSB0cnVlO1xuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSBfdGhpczIuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5nZXRCdWZmZXJlZFRpbWVzID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRUaW1lcyhmcmFnbWVudCwgcGFydCwgcGFydGlhbCwgdGltZVJhbmdlKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsXG4gICAgfTtcbiAgICB2YXIgc3RhcnRQVFMgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWdtZW50LnN0YXJ0O1xuICAgIHZhciBlbmRQVFMgPSBwYXJ0ID8gcGFydC5lbmQgOiBmcmFnbWVudC5lbmQ7XG4gICAgdmFyIG1pbkVuZFBUUyA9IGZyYWdtZW50Lm1pbkVuZFBUUyB8fCBlbmRQVFM7XG4gICAgdmFyIG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIHZhciBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcblxuICAgICAgaWYgKG1heFN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBtaW5FbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyIHRpbWVSYW5nZSB0aW1lcyBzaW5jZSBpdCdzIGNvbXBsZXRlbHkgcGxheWFibGVcbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRQVFMgPCBlbmRUaW1lICYmIGVuZFBUUyA+IHN0YXJ0VGltZSkge1xuICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTsgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG5cbiAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgZW5kUFRTOiBNYXRoLm1pbihlbmRQVFMsIHRpbWVSYW5nZS5lbmQoaSkpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnRpYWwgZnJhZ21lbnQgZm9yIGEgY2VydGFpbiB0aW1lXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFBhcnRpYWxGcmFnbWVudCA9IGZ1bmN0aW9uIGdldFBhcnRpYWxGcmFnbWVudCh0aW1lKSB7XG4gICAgdmFyIGJlc3RGcmFnbWVudCA9IG51bGw7XG4gICAgdmFyIHRpbWVQYWRkaW5nO1xuICAgIHZhciBzdGFydFRpbWU7XG4gICAgdmFyIGVuZFRpbWU7XG4gICAgdmFyIGJlc3RPdmVybGFwID0gMDtcbiAgICB2YXIgYnVmZmVyUGFkZGluZyA9IHRoaXMuYnVmZmVyUGFkZGluZyxcbiAgICAgICAgZnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgT2JqZWN0LmtleXMoZnJhZ21lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuXG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZCArIGJ1ZmZlclBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHRpbWUgPj0gc3RhcnRUaW1lICYmIHRpbWUgPD0gZW5kVGltZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgZnJhZ21lbnQgdGhhdCBoYXMgdGhlIG1vc3QgcGFkZGluZyBmcm9tIHN0YXJ0IGFuZCBlbmQgdGltZVxuICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuXG4gICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICBiZXN0RnJhZ21lbnQgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgICAgYmVzdE92ZXJsYXAgPSB0aW1lUGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmVzdEZyYWdtZW50O1xuICB9O1xuXG4gIF9wcm90by5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgaWYgKGZyYWdtZW50RW50aXR5LmJhY2t0cmFjaykge1xuICAgICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkJBQ0tUUkFDS0VEO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HO1xuICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLlBBUlRJQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEO1xuICB9O1xuXG4gIF9wcm90by5iYWNrdHJhY2sgPSBmdW5jdGlvbiBiYWNrdHJhY2soZnJhZywgZGF0YSkge1xuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IGZyYWdtZW50RW50aXR5LmJhY2t0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZyYWdtZW50RW50aXR5LmJhY2t0cmFjayA9IGRhdGEgPyBkYXRhIDogZnJhZ21lbnRFbnRpdHkubG9hZGVkO1xuICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJhY2t0cmFja0RhdGEgPSBmdW5jdGlvbiBnZXRCYWNrdHJhY2tEYXRhKGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG5cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIHZhciBfYmFja3RyYWNrJHBheWxvYWQ7XG5cbiAgICAgIHZhciBiYWNrdHJhY2sgPSBmcmFnbWVudEVudGl0eS5iYWNrdHJhY2s7IC8vIElmIGRhdGEgd2FzIGFscmVhZHkgc2VudCB0byBXb3JrZXIgaXQgaXMgZGV0YWNoZWQgbm8gbG9uZ2VyIGF2YWlsYWJsZVxuXG4gICAgICBpZiAoYmFja3RyYWNrICE9PSBudWxsICYmIGJhY2t0cmFjayAhPT0gdm9pZCAwICYmIChfYmFja3RyYWNrJHBheWxvYWQgPSBiYWNrdHJhY2sucGF5bG9hZCkgIT09IG51bGwgJiYgX2JhY2t0cmFjayRwYXlsb2FkICE9PSB2b2lkIDAgJiYgX2JhY2t0cmFjayRwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGJhY2t0cmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5pc1RpbWVCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgIHZhciBzdGFydFRpbWU7XG4gICAgdmFyIGVuZFRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG5cbiAgICAgIGlmIChzdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgZW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDsgLy8gZG9uJ3QgdHJhY2sgaW5pdHNlZ21lbnQgKGZvciB3aGljaCBzbiBpcyBub3QgYSBudW1iZXIpXG4gICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cblxuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QgfHwgcGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICBib2R5OiBmcmFnLFxuICAgICAgcGFydDogcGFydCxcbiAgICAgIGxvYWRlZDogZGF0YSxcbiAgICAgIGJhY2t0cmFjazogbnVsbCxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJBcHBlbmRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQXBwZW5kZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICB0aW1lUmFuZ2VzID0gZGF0YS50aW1lUmFuZ2VzO1xuICAgIHRoaXMuYWN0aXZlRnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMuYWN0aXZlUGFydCA9IHBhcnQ7IC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuXG4gICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50YXJ5U3RyZWFtKSB7XG4gICAgICB2YXIgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcblxuICAgICAgX3RoaXMzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlKTtcblxuICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZnJhZy5hcHBlbmRlZFBUUyA9IE1hdGgubWF4KHRpbWVSYW5nZS5lbmQoaSksIGZyYWcuYXBwZW5kZWRQVFMgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKTtcbiAgfTtcblxuICBfcHJvdG8uaGFzRnJhZ21lbnQgPSBmdW5jdGlvbiBoYXNGcmFnbWVudChmcmFnbWVudCkge1xuICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVGcmFnbWVudCA9IGZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQuc3RhdHMubG9hZGVkID0gMDtcbiAgICBmcmFnbWVudC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVBbGxGcmFnbWVudHMgPSBmdW5jdGlvbiByZW1vdmVBbGxGcmFnbWVudHMoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBGcmFnbWVudFRyYWNrZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkge1xuICB2YXIgX2ZyYWdtZW50RW50aXR5JHJhbmdlLCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyO1xuXG4gIHJldHVybiBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiAoKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UgPSBmcmFnbWVudEVudGl0eS5yYW5nZS52aWRlbykgPT09IG51bGwgfHwgX2ZyYWdtZW50RW50aXR5JHJhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pID09PSBudWxsIHx8IF9mcmFnbWVudEVudGl0eSRyYW5nZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnbWVudEVudGl0eSRyYW5nZTIucGFydGlhbCkpO1xufVxuXG5mdW5jdGlvbiBnZXRGcmFnbWVudEtleShmcmFnbWVudCkge1xuICByZXR1cm4gZnJhZ21lbnQudHlwZSArIFwiX1wiICsgZnJhZ21lbnQubGV2ZWwgKyBcIl9cIiArIGZyYWdtZW50LnVybElkICsgXCJfXCIgKyBmcmFnbWVudC5zbjtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvZ2FwLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TLCBNQVhfU1RBUlRfR0FQX0pVTVAsIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTLCBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTUFYX1NUQVJUX0dBUF9KVU1QXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTUFYX1NUQVJUX0dBUF9KVU1QOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gR2FwQ29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2J1ZmZlci1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG52YXIgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbnZhciBNQVhfU1RBUlRfR0FQX0pVTVAgPSAyLjA7XG52YXIgU0tJUF9CVUZGRVJfSE9MRV9TVEVQX1NFQ09ORFMgPSAwLjE7XG52YXIgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuXG52YXIgR2FwQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdhcENvbnRyb2xsZXIoY29uZmlnLCBtZWRpYSwgZnJhZ21lbnRUcmFja2VyLCBobHMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5zZWVraW5nID0gZmFsc2U7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBsYXloZWFkIGlzIHN0dWNrIHdpdGhpbiBhIGdhcCwgYW5kIGlmIHNvLCBhdHRlbXB0cyB0byBmcmVlIGl0LlxuICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEN1cnJlbnRUaW1lIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBHYXBDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucG9sbCA9IGZ1bmN0aW9uIHBvbGwobGFzdEN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHN0YWxsZWQgPSB0aGlzLnN0YWxsZWQ7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgIHNlZWtpbmcgPSBtZWRpYS5zZWVraW5nO1xuICAgIHZhciBzZWVrZWQgPSB0aGlzLnNlZWtpbmcgJiYgIXNlZWtpbmc7XG4gICAgdmFyIGJlZ2luU2VlayA9ICF0aGlzLnNlZWtpbmcgJiYgc2Vla2luZztcbiAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nOyAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIHZhciBfc3RhbGxlZER1cmF0aW9uID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YWxsZWQ7XG5cbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybihcInBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEBcIiArIGN1cnJlbnRUaW1lICsgXCIsIGFmdGVyIFwiICsgTWF0aC5yb3VuZChfc3RhbGxlZER1cmF0aW9uKSArIFwibXNcIik7XG4gICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuXG5cbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICB9IC8vIFRoZSBwbGF5aGVhZCBzaG91bGQgbm90IGJlIG1vdmluZ1xuXG5cbiAgICBpZiAobWVkaWEucGF1c2VkIHx8IG1lZGlhLmVuZGVkIHx8IG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fCAhX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckluZm8gPSBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQnVmZmVySGVscGVyXCJdLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICB2YXIgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICB2YXIgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDsgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyIChzZWVrZWQsIHdhaXRpbmcgZm9yIGJ1ZmZlcilcblxuICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlZWtpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgdmFyIGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QOyAvLyBOZXh0IGJ1ZmZlcmVkIHJhbmdlIGlzIHRvbyBmYXIgYWhlYWQgdG8ganVtcCB0byB3aGlsZSBzdGlsbCBzZWVraW5nXG5cbiAgICAgIHZhciBub0J1ZmZlckdhcCA9ICFuZXh0U3RhcnQgfHwgbmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiYgIXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG5cbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBSZXNldCBtb3ZlZCBzdGF0ZSB3aGVuIHNlZWtpbmcgdG8gYSBwb2ludCBpbiBvciBiZWZvcmUgYSBnYXBcblxuXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfSAvLyBTa2lwIHN0YXJ0IGdhcHMgaWYgd2UgaGF2ZW4ndCBwbGF5ZWQsIGJ1dCB0aGUgbGFzdCBwb2xsIGRldGVjdGVkIHRoZSBzdGFydCBvZiBhIHN0YWxsXG4gICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuXG5cbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG5cbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcbiAgICAgIHZhciBzdGFydEp1bXAgPSBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTsgLy8gV2hlbiBqb2luaW5nIGEgbGl2ZSBzdHJlYW0gd2l0aCBhdWRpbyB0cmFja3MsIGFjY291bnQgZm9yIGxpdmUgcGxheWxpc3Qgd2luZG93IHNsaWRpbmcgYnkgYWxsb3dpbmdcbiAgICAgIC8vIGEgbGFyZ2VyIGp1bXAgb3ZlciBzdGFydCBnYXBzIGNhdXNlZCBieSB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgYnVmZmVyaW5nIGEgc3RhcnQgZnJhZ21lbnRcbiAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuXG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHMgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXSA6IG51bGw7XG4gICAgICB2YXIgaXNMaXZlID0gbGV2ZWwgPT09IG51bGwgfHwgbGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09PSBudWxsIHx8IF9sZXZlbCRkZXRhaWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5saXZlO1xuICAgICAgdmFyIG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuXG4gICAgICBpZiAoc3RhcnRKdW1wID4gMCAmJiBzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wKSB7XG4gICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKG51bGwpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcblxuXG4gICAgdmFyIHRub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKHN0YWxsZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuXG4gICAgaWYgKCFzZWVraW5nICYmIHN0YWxsZWREdXJhdGlvbiA+PSBTVEFMTF9NSU5JTVVNX0RVUkFUSU9OX01TKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgdGhpcy5fcmVwb3J0U3RhbGwoYnVmZmVySW5mby5sZW4pO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJlZFdpdGhIb2xlcyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcblxuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIHBhcnRpYWwgPSBmcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIHZhciB0YXJnZXRUaW1lID0gdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbCk7IC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgZG9uJ3QgaGFuZGxlIGEgcGFydGlhbCBmcmFnbWVudFxuXG5cbiAgICAgIGlmICh0YXJnZXRUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgIC8vIHdlIG1heSBqdXN0IGhhdmUgdG8gXCJudWRnZVwiIHRoZSBwbGF5bGlzdCBhcyB0aGUgYnJvd3NlciBkZWNvZGluZy9yZW5kZXJpbmcgZW5naW5lXG4gICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG5cblxuICAgIGlmIChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlICYmIHN0YWxsZWREdXJhdGlvbk1zID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS53YXJuKCdUcnlpbmcgdG8gbnVkZ2UgcGxheWhlYWQgb3ZlciBidWZmZXItaG9sZScpOyAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuXG4gICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3JlcG9ydFN0YWxsID0gZnVuY3Rpb24gX3JlcG9ydFN0YWxsKGJ1ZmZlckxlbikge1xuICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzdGFsbFJlcG9ydGVkID0gdGhpcy5zdGFsbFJlcG9ydGVkO1xuXG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJQbGF5YmFjayBzdGFsbGluZyBhdCBAXCIgKyBtZWRpYS5jdXJyZW50VGltZSArIFwiIGR1ZSB0byBsb3cgYnVmZmVyIChidWZmZXI9XCIgKyBidWZmZXJMZW4gKyBcIilcIik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyTGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGZpeCBidWZmZXIgc3RhbGxzIGJ5IGp1bXBpbmcgb3ZlciBrbm93biBnYXBzIGNhdXNlZCBieSBwYXJ0aWFsIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3RyeVNraXBCdWZmZXJIb2xlID0gZnVuY3Rpb24gX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIGxhc3RFbmRUaW1lID0gMDsgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcblxuICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUgKyBjb25maWcubWF4QnVmZmVySG9sZSA+PSBsYXN0RW5kVGltZSAmJiBjdXJyZW50VGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBtZWRpYS5jdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcblxuICAgICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfU0VFS19PVkVSX0hPTEUsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246IFwiZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gXCIgKyBjdXJyZW50VGltZSArIFwiIHRvIFwiICsgdGFyZ2V0VGltZSxcbiAgICAgICAgICAgIGZyYWc6IHBhcnRpYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRUaW1lO1xuICAgICAgfVxuXG4gICAgICBsYXN0RW5kVGltZSA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl90cnlOdWRnZUJ1ZmZlciA9IGZ1bmN0aW9uIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgdmFyIG51ZGdlUmV0cnkgPSAodGhpcy5udWRnZVJldHJ5IHx8IDApICsgMTtcbiAgICB0aGlzLm51ZGdlUmV0cnkgPSBudWRnZVJldHJ5O1xuXG4gICAgaWYgKG51ZGdlUmV0cnkgPCBjb25maWcubnVkZ2VNYXhSZXRyeSkge1xuICAgICAgdmFyIHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIG51ZGdlUmV0cnkgKiBjb25maWcubnVkZ2VPZmZzZXQ7IC8vIHBsYXliYWNrIHN0YWxsZWQgaW4gYnVmZmVyZWQgYXJlYSAuLi4gbGV0J3MgbnVkZ2UgY3VycmVudFRpbWUgdG8gdHJ5IHRvIG92ZXJjb21lIHRoaXNcblxuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLndhcm4oXCJOdWRnaW5nICdjdXJyZW50VGltZScgZnJvbSBcIiArIGN1cnJlbnRUaW1lICsgXCIgdG8gXCIgKyB0YXJnZXRUaW1lKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gdGFyZ2V0VGltZTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX05VREdFX09OX1NUQUxMLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEBcIiArIGN1cnJlbnRUaW1lICsgXCIgYWZ0ZXIgXCIgKyBjb25maWcubnVkZ2VNYXhSZXRyeSArIFwiIG51ZGdlc1wiKTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEdhcENvbnRyb2xsZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2lkMy10cmFjay1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3RleHR0cmFjay11dGlscyAqLyBcIi4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG5cblxuXG52YXIgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5cbnZhciBJRDNUcmFja0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5obHMgPSBobHM7XG5cbiAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElEM1RyYWNrQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9IC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICA7XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkodGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldElEM1RyYWNrID0gZnVuY3Rpb24gZ2V0SUQzVHJhY2sodGV4dFRyYWNrcykge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG5cbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInNlbmRBZGRUcmFja0V2ZW50XCJdKSh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZnJhZztcbiAgICB2YXIgc2FtcGxlcyA9IGRhdGEuc2FtcGxlczsgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG5cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmdldElEM1RyYWNrKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICB0aGlzLmlkM1RyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICB9IC8vIEF0dGVtcHQgdG8gcmVjcmVhdGUgU2FmYXJpIGZ1bmN0aW9uYWxpdHkgYnkgY3JlYXRpbmdcbiAgICAvLyBXZWJLaXREYXRhQ3VlIG9iamVjdHMgd2hlbiBhdmFpbGFibGUgYW5kIHN0b3JlIHRoZSBkZWNvZGVkXG4gICAgLy8gSUQzIGRhdGEgaW4gdGhlIHZhbHVlIHByb3BlcnR5IG9mIHRoZSBjdWVcblxuXG4gICAgdmFyIEN1ZSA9IHNlbGYuV2ViS2l0RGF0YUN1ZSB8fCBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZyYW1lcyA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImdldElEM0ZyYW1lc1wiXShzYW1wbGVzW2ldLmRhdGEpO1xuXG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBzYW1wbGVzW2ldLnB0cztcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBpIDwgc2FtcGxlcy5sZW5ndGggLSAxID8gc2FtcGxlc1tpICsgMV0ucHRzIDogZnJhZ21lbnQuZW5kO1xuICAgICAgICB2YXIgdGltZURpZmYgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tqXTsgLy8gU2FmYXJpIGRvZXNuJ3QgcHV0IHRoZSB0aW1lc3RhbXAgZnJhbWUgaW4gdGhlIFRleHRUcmFja1xuXG4gICAgICAgICAgaWYgKCFfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJpc1RpbWVTdGFtcEZyYW1lXCJdKGZyYW1lKSkge1xuICAgICAgICAgICAgdmFyIGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gICAgICAgICAgICBjdWUudmFsdWUgPSBmcmFtZTtcbiAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgX3JlZikge1xuICAgIHZhciBzdGFydE9mZnNldCA9IF9yZWYuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWYuZW5kT2Zmc2V0LFxuICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIC8vIGlkMyBjdWVzIGNvbWUgZnJvbSBwYXJzZWQgYXVkaW8gb25seSByZW1vdmUgY3VlcyB3aGVuIGF1ZGlvIGJ1ZmZlciBpcyBjbGVhcmVkXG4gICAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuXG4gICAgICBpZiAoIWlkM1RyYWNrIHx8ICFpZDNUcmFjay5jdWVzIHx8ICFpZDNUcmFjay5jdWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdWVzID0gT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldEN1ZXNJblJhbmdlXCJdKShpZDNUcmFjay5jdWVzLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIElEM1RyYWNrQ29udHJvbGxlcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChJRDNUcmFja0NvbnRyb2xsZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMYXRlbmN5Q29udHJvbGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxudmFyIExhdGVuY3lDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGF0ZW5jeUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuXG4gICAgdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGF0ZW5jeUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZyk7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nKTtcbiAgICB0aGlzLmhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQpO1xuICAgIHRoaXMuaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvcik7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoZXZlbnQsIF9yZWYpIHtcbiAgICB2YXIgZGV0YWlscyA9IF9yZWYuZGV0YWlscztcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRhaWxzLmxpdmUgJiYgdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmRldGFpbHMgIT09IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhbGxDb3VudCsrO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdbcGxheWJhY2stcmF0ZS1jb250cm9sbGVyXTogU3RhbGwgZGV0ZWN0ZWQsIGFkanVzdGluZyB0YXJnZXQgbGF0ZW5jeScpO1xuICB9O1xuXG4gIF9wcm90by50aW1ldXBkYXRlID0gZnVuY3Rpb24gdGltZXVwZGF0ZSgpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcblxuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB2YXIgbGF0ZW5jeSA9IHRoaXMuY29tcHV0ZUxhdGVuY3koKTtcblxuICAgIGlmIChsYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7IC8vIEFkYXB0IHBsYXliYWNrUmF0ZSB0byBtZWV0IHRhcmdldCBsYXRlbmN5IGluIGxvdy1sYXRlbmN5IG1vZGVcblxuICAgIHZhciBfdGhpcyRjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbG93TGF0ZW5jeU1vZGUgPSBfdGhpcyRjb25maWcubG93TGF0ZW5jeU1vZGUsXG4gICAgICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlID0gX3RoaXMkY29uZmlnLm1heExpdmVTeW5jUGxheWJhY2tSYXRlO1xuXG4gICAgaWYgKCFsb3dMYXRlbmN5TW9kZSB8fCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuXG4gICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7IC8vIE9ubHkgYWRqdXN0IHBsYXliYWNrUmF0ZSB3aGVuIHdpdGhpbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRhcmdldExhdGVuY3lcbiAgICAvLyBhbmQgbW9yZSB0aGFuIG9uZSBzZWNvbmQgZnJvbSB1bmRlci1idWZmZXJpbmcuXG4gICAgLy8gUGxheWJhY2sgZnVydGhlciB0aGFuIG9uZSB0YXJnZXQgZHVyYXRpb24gZnJvbSB0YXJnZXQgY2FuIGJlIGNvbnNpZGVyZWQgRFZSIHBsYXliYWNrLlxuXG4gICAgdmFyIGxpdmVNaW5MYXRlbmN5RHVyYXRpb24gPSBNYXRoLm1pbih0aGlzLm1heExhdGVuY3ksIHRhcmdldExhdGVuY3kgKyBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgIHZhciBpbkxpdmVSYW5nZSA9IGRpc3RhbmNlRnJvbVRhcmdldCA8IGxpdmVNaW5MYXRlbmN5RHVyYXRpb247XG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUgJiYgaW5MaXZlUmFuZ2UgJiYgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJiB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxKSB7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5taW4oMiwgTWF0aC5tYXgoMS4wLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSkpO1xuICAgICAgdmFyIHJhdGUgPSBNYXRoLnJvdW5kKDIgLyAoMSArIE1hdGguZXhwKC0wLjc1ICogZGlzdGFuY2VGcm9tVGFyZ2V0IC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5lc3RpbWF0ZUxpdmVFZGdlID0gZnVuY3Rpb24gZXN0aW1hdGVMaXZlRWRnZSgpIHtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmVkZ2UgKyBsZXZlbERldGFpbHMuYWdlO1xuICB9O1xuXG4gIF9wcm90by5jb21wdXRlTGF0ZW5jeSA9IGZ1bmN0aW9uIGNvbXB1dGVMYXRlbmN5KCkge1xuICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuXG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGl2ZUVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMYXRlbmN5Q29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXZlbERldGFpbHMgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFyZ2V0TGF0ZW5jeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9sZEJhY2sgPSBsZXZlbERldGFpbHMuaG9sZEJhY2ssXG4gICAgICAgICAgcGFydEhvbGRCYWNrID0gbGV2ZWxEZXRhaWxzLnBhcnRIb2xkQmFjayxcbiAgICAgICAgICB0YXJnZXRkdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgIHZhciBfdGhpcyRjb25maWcyID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbiA9IF90aGlzJGNvbmZpZzIubGl2ZVN5bmNEdXJhdGlvbixcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQgPSBfdGhpcyRjb25maWcyLmxpdmVTeW5jRHVyYXRpb25Db3VudCxcbiAgICAgICAgICBsb3dMYXRlbmN5TW9kZSA9IF90aGlzJGNvbmZpZzIubG93TGF0ZW5jeU1vZGU7XG4gICAgICB2YXIgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IGxvd0xhdGVuY3lNb2RlID8gcGFydEhvbGRCYWNrIHx8IGhvbGRCYWNrIDogaG9sZEJhY2s7XG5cbiAgICAgIGlmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gMCkge1xuICAgICAgICB0YXJnZXRMYXRlbmN5ID0gbGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gbGl2ZVN5bmNEdXJhdGlvbiA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICB2YXIgbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSAxLjA7XG4gICAgICByZXR1cm4gdGFyZ2V0TGF0ZW5jeSArIE1hdGgubWluKHRoaXMuc3RhbGxDb3VudCAqIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlLCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgICAgdmFyIHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG5cbiAgICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCB8fCB0YXJnZXRMYXRlbmN5ID09PSBudWxsIHx8IHRoaXMubGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5sZXZlbERldGFpbHMuZWRnZSwgbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VTdGFsbGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhMZXZlbFVwZGF0ZUFnZSA9ICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICAgIHJldHVybiBNYXRoLm1heChsZXZlbERldGFpbHMuYWdlIC0gbWF4TGV2ZWxVcGRhdGVBZ2UsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3J3YXJkQnVmZmVyTGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJlZFJhbmdlcyA9IG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgIHJldHVybiBidWZmZXJlZFJhbmdlcyA/IG1lZGlhLmJ1ZmZlcmVkLmVuZChidWZmZXJlZFJhbmdlcyAtIDEpIDogbGV2ZWxEZXRhaWxzLmVkZ2UgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXRlbmN5Q29udHJvbGxlcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBMZXZlbENvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sZXZlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbGV2ZWwgKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvZGVjcyAqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xldmVsLWhlbHBlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGV2ZWwtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYXNlX3BsYXlsaXN0X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHlwZXMvbG9hZGVyICovIFwiLi9zcmMvdHlwZXMvbG9hZGVyLnRzXCIpO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLypcbiAqIExldmVsIENvbnRyb2xsZXJcbiAqL1xuXG5cblxuXG5cblxuXG52YXIgY2hyb21lT3JGaXJlZm94ID0gL2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cbnZhciBMZXZlbENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUGxheWxpc3RDb250cm9sbCkge1xuICBfaW5oZXJpdHNMb29zZShMZXZlbENvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG5cbiAgZnVuY3Rpb24gTGV2ZWxDb250cm9sbGVyKGhscykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW2xldmVsLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5fbGV2ZWxzID0gW107XG4gICAgX3RoaXMuX2ZpcnN0TGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5fc3RhcnRMZXZlbCA9IHZvaWQgMDtcbiAgICBfdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIF90aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICBfdGhpcy5vblBhcnNlZENvbXBsZXRlID0gdm9pZCAwO1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7IC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG5cbiAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgfSk7XG5cbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLnN0YXJ0TG9hZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGVkID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSBbXTtcbiAgICB2YXIgc3VidGl0bGVUcmFja3MgPSBbXTtcbiAgICB2YXIgYml0cmF0ZVN0YXJ0O1xuICAgIHZhciBsZXZlbFNldCA9IHt9O1xuICAgIHZhciBsZXZlbEZyb21TZXQ7XG4gICAgdmFyIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIHZhciBhdWRpb0NvZGVjRm91bmQgPSBmYWxzZTsgLy8gcmVncm91cCByZWR1bmRhbnQgbGV2ZWxzIHRvZ2V0aGVyXG5cbiAgICBkYXRhLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbFBhcnNlZCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcbiAgICAgIHZpZGVvQ29kZWNGb3VuZCA9IHZpZGVvQ29kZWNGb3VuZCB8fCAhIWxldmVsUGFyc2VkLnZpZGVvQ29kZWM7XG4gICAgICBhdWRpb0NvZGVjRm91bmQgPSBhdWRpb0NvZGVjRm91bmQgfHwgISFsZXZlbFBhcnNlZC5hdWRpb0NvZGVjOyAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgLy8gZGVtdXhlciB3aWxsIGF1dG9kZXRlY3QgY29kZWMgYW5kIGZhbGxiYWNrIHRvIG1wZWcvYXVkaW9cblxuICAgICAgaWYgKGNocm9tZU9yRmlyZWZveCAmJiBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjICYmIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4zNCcpICE9PSAtMSkge1xuICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsZXZlbEZyb21TZXQgPSBsZXZlbFNldFtsZXZlbFBhcnNlZC5iaXRyYXRlXTsgLy8gRklYTUU6IHdlIHdvdWxkIGFsc28gaGF2ZSB0byBtYXRjaCB0aGUgcmVzb2x1dGlvbiBoZXJlXG5cbiAgICAgIGlmICghbGV2ZWxGcm9tU2V0KSB7XG4gICAgICAgIGxldmVsRnJvbVNldCA9IG5ldyBfdHlwZXNfbGV2ZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkxldmVsXCJdKGxldmVsUGFyc2VkKTtcbiAgICAgICAgbGV2ZWxTZXRbbGV2ZWxQYXJzZWQuYml0cmF0ZV0gPSBsZXZlbEZyb21TZXQ7XG4gICAgICAgIGxldmVscy5wdXNoKGxldmVsRnJvbVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbEZyb21TZXQudXJsLnB1c2gobGV2ZWxQYXJzZWQudXJsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuQVVESU8pIHtcbiAgICAgICAgICBPYmplY3QoX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkR3JvdXBJZFwiXSkobGV2ZWxGcm9tU2V0LCAnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLlNVQlRJVExFUykge1xuICAgICAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhZGRHcm91cElkXCJdKShsZXZlbEZyb21TZXQsICd0ZXh0JywgYXR0cmlidXRlcy5TVUJUSVRMRVMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vIHJlbW92ZSBhdWRpby1vbmx5IGxldmVsIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCBhdWRpbyt2aWRlbyBjb2RlY3Mgc2lnbmFsbGVkXG5cbiAgICBpZiAodmlkZW9Db2RlY0ZvdW5kICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmlkZW9Db2RlYyA9IF9yZWYudmlkZW9Db2RlYztcbiAgICAgICAgcmV0dXJuICEhdmlkZW9Db2RlYztcbiAgICAgIH0pO1xuICAgIH0gLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcblxuXG4gICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gX3JlZjIuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjID0gX3JlZjIudmlkZW9Db2RlYztcbiAgICAgIHJldHVybiAoIWF1ZGlvQ29kZWMgfHwgT2JqZWN0KF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiXSkoYXVkaW9Db2RlYywgJ2F1ZGlvJykpICYmICghdmlkZW9Db2RlYyB8fCBPYmplY3QoX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiaXNDb2RlY1N1cHBvcnRlZEluTXA0XCJdKSh2aWRlb0NvZGVjLCAndmlkZW8nKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgYXVkaW9UcmFja3MgPSBkYXRhLmF1ZGlvVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IE9iamVjdChfdXRpbHNfY29kZWNzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJpc0NvZGVjU3VwcG9ydGVkSW5NcDRcIl0pKHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycpO1xuICAgICAgfSk7IC8vIEFzc2lnbiBpZHMgYWZ0ZXIgZmlsdGVyaW5nIGFzIGFycmF5IGluZGljZXMgYnkgZ3JvdXAtaWRcblxuICAgICAgT2JqZWN0KF9sZXZlbF9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFzc2lnblRyYWNrSWRzQnlHcm91cFwiXSkoYXVkaW9UcmFja3MpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnN1YnRpdGxlcykge1xuICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgIE9iamVjdChfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJhc3NpZ25UcmFja0lkc0J5R3JvdXBcIl0pKHN1YnRpdGxlVHJhY2tzKTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICBiaXRyYXRlU3RhcnQgPSBsZXZlbHNbMF0uYml0cmF0ZTsgLy8gc29ydCBsZXZlbCBvbiBiaXRyYXRlXG5cbiAgICAgIGxldmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmJpdHJhdGUgLSBiLmJpdHJhdGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVsczsgLy8gZmluZCBpbmRleCBvZiBmaXJzdCBsZXZlbCBpbiBzb3J0ZWQgbGV2ZWxzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZXZlbHNbaV0uYml0cmF0ZSA9PT0gYml0cmF0ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgICAgdGhpcy5sb2coXCJtYW5pZmVzdCBsb2FkZWQsIFwiICsgbGV2ZWxzLmxlbmd0aCArIFwiIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiBcIiArIGJpdHJhdGVTdGFydCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgICAvLyBhbmQgdGhpcyBpcyBub3QgYW4gYXVkaW8tb25seSBzdHJlYW0gd2hlcmUgbGV2ZWxzIGNvbnRhaW4gYXVkaW8tb25seVxuXG5cbiAgICAgIHZhciBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICAgIHZhciBlZGF0YSA9IHtcbiAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcyxcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzLFxuICAgICAgICBmaXJzdExldmVsOiB0aGlzLl9maXJzdExldmVsLFxuICAgICAgICBzdGF0czogZGF0YS5zdGF0cyxcbiAgICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgICAgdmlkZW86IHZpZGVvQ29kZWNGb3VuZCxcbiAgICAgICAgYWx0QXVkaW86ICFhdWRpb09ubHkgJiYgYXVkaW9UcmFja3Muc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhIXQudXJsO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuICAgICAgdGhpcy5vblBhcnNlZENvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yVHlwZXNcIl0uTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gU3dpdGNoIHRvIHJlZHVuZGFudCBsZXZlbCB3aGVuIHRyYWNrIGZhaWxzIHRvIGxvYWRcblxuXG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO1xuXG4gICAgaWYgKGNvbnRleHQgJiYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSyAmJiBsZXZlbC5hdWRpb0dyb3VwSWRzICYmIGNvbnRleHQuZ3JvdXBJZCA9PT0gbGV2ZWwuYXVkaW9Hcm91cElkc1tsZXZlbC51cmxJZF0gfHwgY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLICYmIGxldmVsLnRleHRHcm91cElkcyAmJiBjb250ZXh0Lmdyb3VwSWQgPT09IGxldmVsLnRleHRHcm91cElkc1tsZXZlbC51cmxJZF0pKSB7XG4gICAgICB0aGlzLnJlZHVuZGFudEZhaWxvdmVyKHRoaXMuY3VycmVudExldmVsSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsZXZlbEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGZyYWdtZW50RXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgbGV2ZWxTd2l0Y2ggPSB0cnVlO1xuICAgIHZhciBsZXZlbEluZGV4OyAvLyB0cnkgdG8gcmVjb3ZlciBub3QgZmF0YWwgZXJyb3JzXG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IGRpc3Rpbmd1aXNoZXMgdGhlc2UgZnJhZ21lbnQgZXZlbnRzIGZyb20gbGV2ZWwgb3IgdHJhY2sgZnJhZ21lbnRzP1xuICAgICAgICAvLyAgIFdlIHNob3VsZG4ndCByZWNvdmVyIGEgbGV2ZWwgaWYgdGhlIGZyYWdtZW50IG9yIGtleSBpcyBmb3IgYSBtZWRpYSB0cmFja1xuICAgICAgICBjb25zb2xlLmFzc2VydChkYXRhLmZyYWcsICdFdmVudCBoYXMgYSBmcmFnbWVudCBkZWZpbmVkLicpO1xuICAgICAgICBsZXZlbEluZGV4ID0gZGF0YS5mcmFnLmxldmVsO1xuICAgICAgICBmcmFnbWVudEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIC8vIERvIG5vdCBwZXJmb3JtIGxldmVsIHN3aXRjaCBpZiBhbiBlcnJvciBvY2N1cnJlZCB1c2luZyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gcmVsb2FkIGxldmVsIHdpdGhvdXQgZGlyZWN0aXZlcyBmaXJzdFxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykge1xuICAgICAgICAgICAgbGV2ZWxTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXZlbEluZGV4ID0gY29udGV4dC5sZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldmVsRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICAgIGxldmVsSW5kZXggPSBkYXRhLmxldmVsO1xuICAgICAgICBsZXZlbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxldmVsSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5yZWNvdmVyTGV2ZWwoZGF0YSwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvciwgbGV2ZWxTd2l0Y2gpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3dpdGNoIHRvIGEgcmVkdW5kYW50IHN0cmVhbSBpZiBhbnkgYXZhaWxhYmxlLlxuICAgKiBJZiByZWR1bmRhbnQgc3RyZWFtIGlzIG5vdCBhdmFpbGFibGUsIGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBBQlIgbW9kZSBpcyBlbmFibGVkLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWNvdmVyTGV2ZWwgPSBmdW5jdGlvbiByZWNvdmVyTGV2ZWwoZXJyb3JFdmVudCwgbGV2ZWxJbmRleCwgbGV2ZWxFcnJvciwgZnJhZ21lbnRFcnJvciwgbGV2ZWxTd2l0Y2gpIHtcbiAgICB2YXIgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgIHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbEluZGV4XTtcbiAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZnJhZ21lbnRFcnJvcjtcblxuICAgIGlmIChsZXZlbEVycm9yKSB7XG4gICAgICB2YXIgcmV0cnlpbmcgPSB0aGlzLnJldHJ5TG9hZGluZ09yRmFpbChlcnJvckV2ZW50KTtcblxuICAgICAgaWYgKHJldHJ5aW5nKSB7XG4gICAgICAgIC8vIGJvb2xlYW4gdXNlZCB0byBpbmZvcm0gc3RyZWFtIGNvbnRyb2xsZXIgbm90IHRvIHN3aXRjaCBiYWNrIHRvIElETEUgb24gbm9uIGZhdGFsIGVycm9yXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIFRyeSBhbnkgcmVkdW5kYW50IHN0cmVhbXMgaWYgYXZhaWxhYmxlIGZvciBib3RoIGVycm9yczogbGV2ZWwgYW5kIGZyYWdtZW50XG4gICAgLy8gSWYgbGV2ZWwubG9hZEVycm9yIHJlYWNoZXMgcmVkdW5kYW50TGV2ZWxzIGl0IG1lYW5zIHRoYXQgd2UgdHJpZWQgdGhlbSBhbGwsIG5vIGhvcGUgID0+IGxldCdzIHN3aXRjaCBkb3duXG5cblxuICAgIGlmIChsZXZlbFN3aXRjaCAmJiAobGV2ZWxFcnJvciB8fCBmcmFnbWVudEVycm9yKSkge1xuICAgICAgdmFyIHJlZHVuZGFudExldmVscyA9IGxldmVsLnVybC5sZW5ndGg7XG5cbiAgICAgIGlmIChyZWR1bmRhbnRMZXZlbHMgPiAxICYmIGxldmVsLmxvYWRFcnJvciA8IHJlZHVuZGFudExldmVscykge1xuICAgICAgICB0aGlzLnJlZHVuZGFudEZhaWxvdmVyKGxldmVsSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhdmFpbGFibGUgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXaGVuIGxvd2VzdCBsZXZlbCBoYXMgYmVlbiByZWFjaGVkLCBsZXQncyBzdGFydCBodW50IGZyb20gdGhlIHRvcFxuICAgICAgICAgIHZhciBuZXh0TGV2ZWwgPSBsZXZlbEluZGV4ID09PSAwID8gdGhpcy5fbGV2ZWxzLmxlbmd0aCAtIDEgOiBsZXZlbEluZGV4IC0gMTtcblxuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ICE9PSBuZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgIGZyYWdtZW50RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud2FybihlcnJvckRldGFpbHMgKyBcIjogc3dpdGNoIHRvIFwiICsgbmV4dExldmVsKTtcbiAgICAgICAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV4dExldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgLy8gQWxsb3cgZnJhZ21lbnQgcmV0cnkgYXMgbG9uZyBhcyBjb25maWd1cmF0aW9uIGFsbG93cy5cbiAgICAgICAgICAvLyByZXNldCB0aGlzLl9sZXZlbCBzbyB0aGF0IGFub3RoZXIgY2FsbCB0byBzZXQgbGV2ZWwoKSB3aWxsIHRyaWdnZXIgYWdhaW4gYSBmcmFnIGxvYWRcbiAgICAgICAgICB0aGlzLndhcm4oZXJyb3JEZXRhaWxzICsgXCI6IHJlbG9hZCBhIGZyYWdtZW50XCIpO1xuICAgICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVkdW5kYW50RmFpbG92ZXIgPSBmdW5jdGlvbiByZWR1bmRhbnRGYWlsb3ZlcihsZXZlbEluZGV4KSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIHZhciByZWR1bmRhbnRMZXZlbHMgPSBsZXZlbC51cmwubGVuZ3RoO1xuXG4gICAgaWYgKHJlZHVuZGFudExldmVscyA+IDEpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgdXJsIGlkIG9mIGFsbCBsZXZlbHMgc28gdGhhdCB3ZSBzdGF5IG9uIHRoZSBzYW1lIHNldCBvZiB2YXJpYW50cyB3aGVuIGxldmVsIHN3aXRjaGluZ1xuICAgICAgdmFyIG5ld1VybElkID0gKGxldmVsLnVybElkICsgMSkgJSByZWR1bmRhbnRMZXZlbHM7XG4gICAgICB0aGlzLndhcm4oXCJTd2l0Y2hpbmcgdG8gcmVkdW5kYW50IFVSTC1pZCBcIiArIG5ld1VybElkKTtcblxuICAgICAgdGhpcy5fbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIGxldmVsLnVybElkID0gbmV3VXJsSWQ7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsSW5kZXg7XG4gICAgfVxuICB9IC8vIHJlc2V0IGVycm9ycyBvbiB0aGUgc3VjY2Vzc2Z1bCBsb2FkIG9mIGEgZnJhZ21lbnRcbiAgO1xuXG4gIF9wcm90by5vbkZyYWdMb2FkZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkZWQoZXZlbnQsIF9yZWYzKSB7XG4gICAgdmFyIGZyYWcgPSBfcmVmMy5mcmFnO1xuXG4gICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgdmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gZmFsc2U7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuXG4gICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKCFjdXJMZXZlbCkge1xuICAgICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTtcblxuICAgICAgdGhpcy53YXJuKFwiSW52YWxpZCBsZXZlbCBpbmRleCBcIiArIGxldmVsKTtcblxuICAgICAgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcykgIT09IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpICE9PSB2b2lkIDAgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcblxuXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmICghY3VyTGV2ZWwuZnJhZ21lbnRFcnJvcikge1xuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKChfZGF0YSRkZWxpdmVyeURpcmVjdGkyID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9PSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIgIT09IHZvaWQgMCAmJiBfZGF0YSRkZWxpdmVyeURpcmVjdGkyLnNraXApIHtcbiAgICAgIC8vIHJlY2VpdmVkIGEgZGVsdGEgcGxheWxpc3QgdXBkYXRlIHRoYXQgY2Fubm90IGJlIG1lcmdlZFxuICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuaGxzLmxldmVsc1t0aGlzLmN1cnJlbnRMZXZlbEluZGV4XTtcblxuICAgIGlmICghY3VycmVudExldmVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzKSB7XG4gICAgICB2YXIgdXJsSWQgPSAtMTtcbiAgICAgIHZhciBhdWRpb0dyb3VwSWQgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tkYXRhLmlkXS5ncm91cElkO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbC5hdWRpb0dyb3VwSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwuYXVkaW9Hcm91cElkc1tpXSA9PT0gYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgdXJsSWQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmxJZCAhPT0gY3VycmVudExldmVsLnVybElkKSB7XG4gICAgICAgIGN1cnJlbnRMZXZlbC51cmxJZCA9IHVybElkO1xuICAgICAgICB0aGlzLnN0YXJ0TG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIHZhciBjdXJyZW50TGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuXG4gICAgaWYgKHRoaXMuY2FuTG9hZCAmJiBjdXJyZW50TGV2ZWwgJiYgY3VycmVudExldmVsLnVybC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaWQgPSBjdXJyZW50TGV2ZWwudXJsSWQ7XG4gICAgICB2YXIgdXJsID0gY3VycmVudExldmVsLnVybFtpZF07XG5cbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwiQXR0ZW1wdCBsb2FkaW5nIGxldmVsIGluZGV4IFwiICsgbGV2ZWwgKyAoaGxzVXJsUGFyYW1ldGVycyA/ICcgYXQgc24gJyArIGhsc1VybFBhcmFtZXRlcnMubXNuICsgJyBwYXJ0ICcgKyBobHNVcmxQYXJhbWV0ZXJzLnBhcnQgOiAnJykgKyBcIiB3aXRoIFVSTC1pZCBcIiArIGlkICsgXCIgXCIgKyB1cmwpOyAvLyBjb25zb2xlLmxvZygnQ3VycmVudCBhdWRpbyB0cmFjayBncm91cCBJRDonLCB0aGlzLmhscy5hdWRpb1RyYWNrc1t0aGlzLmhscy5hdWRpb1RyYWNrXS5ncm91cElkKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbE9iamVjdC5hdHRycy5BVURJTywgbGV2ZWwpO1xuXG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVMZXZlbCA9IGZ1bmN0aW9uIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKSB7XG4gICAgdmFyIGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXggPSBmdW5jdGlvbiBmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KHVybCwgaWQpIHtcbiAgICAgIHJldHVybiBpZCAhPT0gdXJsSWQ7XG4gICAgfTtcblxuICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHMuZmlsdGVyKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCAhPT0gbGV2ZWxJbmRleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsLnVybC5sZW5ndGggPiAxICYmIHVybElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwudXJsID0gbGV2ZWwudXJsLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcblxuICAgICAgICBpZiAobGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMgPSBsZXZlbC5hdWRpb0dyb3VwSWRzLmZpbHRlcihmaWx0ZXJMZXZlbEFuZEdyb3VwQnlJZEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgICBsZXZlbC50ZXh0R3JvdXBJZHMgPSBsZXZlbC50ZXh0R3JvdXBJZHMuZmlsdGVyKGZpbHRlckxldmVsQW5kR3JvdXBCeUlkSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV2ZWwudXJsSWQgPSAwO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pLm1hcChmdW5jdGlvbiAobGV2ZWwsIGluZGV4KSB7XG4gICAgICB2YXIgZGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG5cbiAgICAgIGlmIChkZXRhaWxzICE9PSBudWxsICYmIGRldGFpbHMgIT09IHZvaWQgMCAmJiBkZXRhaWxzLmZyYWdtZW50cykge1xuICAgICAgICBkZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxTX1VQREFURUQsIHtcbiAgICAgIGxldmVsczogbGV2ZWxzXG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fbGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2xldmVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHZhciBfbGV2ZWxzJG5ld0xldmVsO1xuXG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiYgKF9sZXZlbHMkbmV3TGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdKSAhPT0gbnVsbCAmJiBfbGV2ZWxzJG5ld0xldmVsICE9PSB2b2lkIDAgJiYgX2xldmVscyRuZXdMZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG5cblxuICAgICAgaWYgKG5ld0xldmVsIDwgMCB8fCBuZXdMZXZlbCA+PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246ICdpbnZhbGlkIGxldmVsIGlkeCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG5cblxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB2YXIgbGFzdExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgdmFyIGxhc3RMZXZlbCA9IGxldmVsc1tsYXN0TGV2ZWxJbmRleF07XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgICAgdGhpcy5sb2coXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXdMZXZlbCArIFwiIGZyb20gXCIgKyBsYXN0TGV2ZWxJbmRleCk7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG5cbiAgICAgIHZhciBsZXZlbFN3aXRjaGluZ0RhdGEgPSBfZXh0ZW5kcyh7fSwgbGV2ZWwsIHtcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBtYXhCaXRyYXRlOiBsZXZlbC5tYXhCaXRyYXRlLFxuICAgICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgICAgdXJsSWQ6IGxldmVsLnVybElkXG4gICAgICB9KTsgLy8gQHRzLWlnbm9yZVxuXG5cbiAgICAgIGRlbGV0ZSBsZXZlbFN3aXRjaGluZ0RhdGEuX3VybElkO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpOyAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGxvYWQgcGxheWxpc3QgZm9yIHRoaXMgbGV2ZWxcblxuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG5cbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgdmFyIGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbCA9PT0gbnVsbCB8fCBsYXN0TGV2ZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RMZXZlbC5kZXRhaWxzKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hbnVhbExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuXG4gICAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICB0aGlzLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gaGxzLnN0YXJ0TGV2ZWwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNvbmZpZy5zdGFydExldmVsXG4gICAgICAvLyBpZiBub25lIG9mIHRoZXNlIHZhbHVlcyBhcmUgZGVmaW5lZCwgZmFsbGJhY2sgb24gdGhpcy5fZmlyc3RMZXZlbCAoZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gdmFyaWFudCBtYW5pZmVzdClcbiAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcblxuICAgICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dExvYWRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV4dExldmVsO1xuXG4gICAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXZlbENvbnRyb2xsZXI7XG59KF9iYXNlX3BsYXlsaXN0X2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9sZXZlbC1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYWRkR3JvdXBJZCwgYXNzaWduVHJhY2tJZHNCeUdyb3VwLCB1cGRhdGVQVFMsIHVwZGF0ZUZyYWdQVFNEVFMsIG1lcmdlRGV0YWlscywgbWFwUGFydEludGVyc2VjdGlvbiwgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24sIGFkanVzdFNsaWRpbmcsIGNvbXB1dGVSZWxvYWRJbnRlcnZhbCwgZ2V0RnJhZ21lbnRXaXRoU04sIGdldFBhcnRXaXRoICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkZEdyb3VwSWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRHcm91cElkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhc3NpZ25UcmFja0lkc0J5R3JvdXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhc3NpZ25UcmFja0lkc0J5R3JvdXA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVwZGF0ZVBUU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVwZGF0ZVBUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXBkYXRlRnJhZ1BUU0RUU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVwZGF0ZUZyYWdQVFNEVFM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1lcmdlRGV0YWlsc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlRGV0YWlsczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFwUGFydEludGVyc2VjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1hcFBhcnRJbnRlcnNlY3Rpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1hcEZyYWdtZW50SW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFkanVzdFNsaWRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGp1c3RTbGlkaW5nOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlUmVsb2FkSW50ZXJ2YWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wdXRlUmVsb2FkSW50ZXJ2YWw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEZyYWdtZW50V2l0aFNOXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RnJhZ21lbnRXaXRoU047IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFBhcnRXaXRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UGFydFdpdGg7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG5cblxuLyoqXG4gKiBAbW9kdWxlIExldmVsSGVscGVyXG4gKiBQcm92aWRpbmcgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqICovXG5cbmZ1bmN0aW9uIGFkZEdyb3VwSWQobGV2ZWwsIHR5cGUsIGlkKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGlmICghbGV2ZWwuYXVkaW9Hcm91cElkcykge1xuICAgICAgICBsZXZlbC5hdWRpb0dyb3VwSWRzID0gW107XG4gICAgICB9XG5cbiAgICAgIGxldmVsLmF1ZGlvR3JvdXBJZHMucHVzaChpZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgaWYgKCFsZXZlbC50ZXh0R3JvdXBJZHMpIHtcbiAgICAgICAgbGV2ZWwudGV4dEdyb3VwSWRzID0gW107XG4gICAgICB9XG5cbiAgICAgIGxldmVsLnRleHRHcm91cElkcy5wdXNoKGlkKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25UcmFja0lkc0J5R3JvdXAodHJhY2tzKSB7XG4gIHZhciBncm91cHMgPSB7fTtcbiAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgdmFyIGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgZ3JvdXBzW2dyb3VwSWRdKys7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlUFRTKGZyYWdtZW50cywgZnJvbUlkeCwgdG9JZHgpIHtcbiAgdmFyIGZyYWdGcm9tID0gZnJhZ21lbnRzW2Zyb21JZHhdO1xuICB2YXIgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XTtcbiAgdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tLCBmcmFnVG8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb20sIGZyYWdUbykge1xuICB2YXIgZnJhZ1RvUFRTID0gZnJhZ1RvLnN0YXJ0UFRTOyAvLyBpZiB3ZSBrbm93IHN0YXJ0UFRTW3RvSWR4XVxuXG4gIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIHZhciBmcmFnO1xuXG4gICAgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgZnJhZyA9IGZyYWdGcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgZnJhZyA9IGZyYWdUbztcbiAgICB9IC8vIFRPRE8/IERyaWZ0IGNhbiBnbyBlaXRoZXIgd2F5LCBvciB0aGUgcGxheWxpc3QgY291bGQgYmUgY29tcGxldGVseSBhY2N1cmF0ZVxuICAgIC8vIGNvbnNvbGUuYXNzZXJ0KGR1cmF0aW9uID4gMCxcbiAgICAvLyAgIGBkdXJhdGlvbiBvZiAke2R1cmF0aW9ufSBjb21wdXRlZCBmb3IgZnJhZyAke2ZyYWcuc259LCBsZXZlbCAke2ZyYWcubGV2ZWx9LCB0aGVyZSBzaG91bGQgYmUgc29tZSBkdXJhdGlvbiBkcmlmdCBiZXR3ZWVuIHBsYXlsaXN0IGFuZCBmcmFnbWVudCFgKTtcblxuXG4gICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfSAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG5cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIHZhciBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYzsgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgdmFyIHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcblxuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG5cbiAgdmFyIG1heFN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gIHZhciBtaW5FbmRQVFMgPSBlbmRQVFM7XG4gIHZhciBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICB2YXIgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTO1xuXG4gIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZ1N0YXJ0UHRzKSkge1xuICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgIHZhciBkZWx0YVBUUyA9IE1hdGguYWJzKGZyYWdTdGFydFB0cyAtIHN0YXJ0UFRTKTtcblxuICAgIGlmICghT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGZyYWcuZGVsdGFQVFMpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyk7XG4gICAgfVxuXG4gICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydFBUUyA9IE1hdGgubWluKHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0RFRTID0gTWF0aC5taW4oc3RhcnREVFMsIGZyYWcuc3RhcnREVFMpO1xuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuXG4gIGZyYWcuZHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgdmFyIGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBmcmFnLmFwcGVuZGVkUFRTID0gZW5kUFRTO1xuICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gIGZyYWcubWluRW5kUFRTID0gbWluRW5kUFRTO1xuICBmcmFnLmVuZERUUyA9IGVuZERUUztcbiAgdmFyIHNuID0gZnJhZy5zbjsgLy8gJ2luaXRTZWdtZW50J1xuICAvLyBleGl0IGlmIHNuIG91dCBvZiByYW5nZVxuXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7IC8vIHVwZGF0ZSBmcmFnIHJlZmVyZW5jZSBpbiBmcmFnbWVudHMgYXJyYXlcbiAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgZnJhZ21lbnRzIGFycmF5IG1pZ2h0IG5vdCBjb250YWluIHRoaXMgZnJhZyBvYmplY3QuXG4gIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAvLyBpZiB3ZSBkb24ndCB1cGRhdGUgZnJhZywgd2Ugd29uJ3QgYmUgYWJsZSB0byBwcm9wYWdhdGUgUFRTIGluZm8gb24gdGhlIHBsYXlsaXN0XG4gIC8vIHJlc3VsdGluZyBpbiBpbnZhbGlkIHNsaWRpbmcgY29tcHV0YXRpb25cblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnOyAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG5cbiAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpIC0gMV0pO1xuICB9IC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG5cblxuICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHVwZGF0ZUZyb21Ub1BUUyhmcmFnbWVudHNbaV0sIGZyYWdtZW50c1tpICsgMV0pO1xuICB9XG5cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgfVxuXG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgLy8gcG90ZW50aWFsbHkgcmV0cmlldmUgY2FjaGVkIGluaXRzZWdtZW50XG4gIGlmIChuZXdEZXRhaWxzLmluaXRTZWdtZW50ICYmIG9sZERldGFpbHMuaW5pdFNlZ21lbnQpIHtcbiAgICBuZXdEZXRhaWxzLmluaXRTZWdtZW50ID0gb2xkRGV0YWlscy5pbml0U2VnbWVudDtcbiAgfVxuXG4gIGlmIChvbGREZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICB9IC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG5cblxuICB2YXIgY2NPZmZzZXQgPSAwO1xuICB2YXIgUFRTRnJhZztcbiAgbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscywgbmV3RGV0YWlscywgZnVuY3Rpb24gKG9sZEZyYWcsIG5ld0ZyYWcpIHtcbiAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuXG4gICAgaWYgKE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShvbGRGcmFnLnN0YXJ0UFRTKSAmJiBPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkob2xkRnJhZy5lbmRQVFMpKSB7XG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLnN0YXJ0RFRTID0gb2xkRnJhZy5zdGFydERUUztcbiAgICAgIG5ld0ZyYWcuYXBwZW5kZWRQVFMgPSBvbGRGcmFnLmFwcGVuZGVkUFRTO1xuICAgICAgbmV3RnJhZy5tYXhTdGFydFBUUyA9IG9sZEZyYWcubWF4U3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgbmV3RnJhZy5lbmREVFMgPSBvbGRGcmFnLmVuZERUUztcbiAgICAgIG5ld0ZyYWcubWluRW5kUFRTID0gb2xkRnJhZy5taW5FbmRQVFM7XG4gICAgICBuZXdGcmFnLmR1cmF0aW9uID0gb2xkRnJhZy5lbmRQVFMgLSBvbGRGcmFnLnN0YXJ0UFRTO1xuXG4gICAgICBpZiAobmV3RnJhZy5kdXJhdGlvbikge1xuICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgIH0gLy8gUFRTIGlzIGtub3duIHdoZW4gYW55IHNlZ21lbnQgaGFzIHN0YXJ0UFRTIGFuZCBlbmRQVFNcblxuXG4gICAgICBuZXdEZXRhaWxzLlBUU0tub3duID0gbmV3RGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgbmV3RnJhZy5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZEZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICBuZXdGcmFnLnN0YXRzID0gb2xkRnJhZy5zdGF0cztcbiAgICBuZXdGcmFnLnVybElkID0gb2xkRnJhZy51cmxJZDtcbiAgfSk7XG5cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLnNvbWUoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgIHJldHVybiAhZnJhZztcbiAgICB9KTtcblxuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ud2FybignW2xldmVsLWhlbHBlcl0gUHJldmlvdXMgcGxheWxpc3QgbWlzc2luZyBzZWdtZW50cyBza2lwcGVkIGluIGRlbHRhIHBsYXlsaXN0Jyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaS0tOykge1xuICAgICAgICBuZXdEZXRhaWxzLmZyYWdtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuXG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0U04gPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zbjtcbiAgICAgIG5ld0RldGFpbHMuc3RhcnRDQyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLmNjO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoY2NPZmZzZXQpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJsb2dnZXJcIl0ubG9nKCdkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnQnKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBuZXdGcmFnbWVudHNbX2ldLmNjICs9IGNjT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIGlmICghbmV3RGV0YWlscy5pbml0U2VnbWVudCkge1xuICAgICAgbmV3RGV0YWlscy5pbml0U2VnbWVudCA9IG9sZERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gIH0gLy8gTWVyZ2UgcGFydHNcblxuXG4gIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscy5wYXJ0TGlzdCwgbmV3RGV0YWlscy5wYXJ0TGlzdCwgZnVuY3Rpb24gKG9sZFBhcnQsIG5ld1BhcnQpIHtcbiAgICBuZXdQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkUGFydC5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBuZXdQYXJ0LnN0YXRzID0gb2xkUGFydC5zdGF0cztcbiAgfSk7IC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuXG4gIGlmIChQVFNGcmFnKSB7XG4gICAgdXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLCBQVFNGcmFnLCBQVFNGcmFnLnN0YXJ0UFRTLCBQVFNGcmFnLmVuZFBUUywgUFRTRnJhZy5zdGFydERUUywgUFRTRnJhZy5lbmREVFMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRGcmFnbWVudHMgcmFuZ2VcbiAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgfVxuXG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG59XG5mdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgdmFyIGRlbHRhID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvbGRQYXJ0cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBfb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgdmFyIF9uZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcblxuICAgICAgaWYgKF9vbGRQYXJ0ICYmIF9uZXdQYXJ0ICYmIF9vbGRQYXJ0LmluZGV4ID09PSBfbmV3UGFydC5pbmRleCAmJiBfb2xkUGFydC5mcmFnbWVudC5zbiA9PT0gX25ld1BhcnQuZnJhZ21lbnQuc24pIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uRm4oX29sZFBhcnQsIF9uZXdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhLS07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICB2YXIgc2tpcHBlZFNlZ21lbnRzID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7XG4gIHZhciBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgdmFyIGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICB2YXIgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIHZhciBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICB2YXIgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICB2YXIgX29sZEZyYWcgPSBvbGRGcmFnc1tkZWx0YSArIGldO1xuICAgIHZhciBfbmV3RnJhZyA9IG5ld0ZyYWdzW2ldO1xuXG4gICAgaWYgKHNraXBwZWRTZWdtZW50cyAmJiAhX25ld0ZyYWcgJiYgaSA8IHNraXBwZWRTZWdtZW50cykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBfbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gX29sZEZyYWc7XG4gICAgfVxuXG4gICAgaWYgKF9vbGRGcmFnICYmIF9uZXdGcmFnKSB7XG4gICAgICBpbnRlcnNlY3Rpb25Gbihfb2xkRnJhZywgX25ld0ZyYWcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIHZhciBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiArIG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICB2YXIgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIHZhciBuZXdGcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcblxuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGxheWxpc3RTdGFydE9mZnNldCA9IG9sZEZyYWdtZW50c1tkZWx0YV0uc3RhcnQ7XG5cbiAgaWYgKHBsYXlsaXN0U3RhcnRPZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5zdGFydCArPSBwbGF5bGlzdFN0YXJ0T2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgbmV3RGV0YWlscy5mcmFnbWVudEhpbnQuc3RhcnQgKz0gcGxheWxpc3RTdGFydE9mZnNldDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVSZWxvYWRJbnRlcnZhbChuZXdEZXRhaWxzLCBzdGF0cykge1xuICB2YXIgcmVsb2FkSW50ZXJ2YWwgPSAxMDAwICogbmV3RGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICB2YXIgcmVsb2FkSW50ZXJ2YWxBZnRlck1pc3MgPSByZWxvYWRJbnRlcnZhbCAvIDI7XG4gIHZhciB0aW1lU2luY2VMYXN0TW9kaWZpZWQgPSBuZXdEZXRhaWxzLmFnZTtcbiAgdmFyIHVzZUxhc3RNb2RpZmllZCA9IHRpbWVTaW5jZUxhc3RNb2RpZmllZCA+IDAgJiYgdGltZVNpbmNlTGFzdE1vZGlmaWVkIDwgcmVsb2FkSW50ZXJ2YWwgKiAzO1xuICB2YXIgcm91bmRUcmlwID0gc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICB2YXIgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gcmVsb2FkSW50ZXJ2YWw7XG4gIHZhciBhdmFpbGFiaWxpdHlEZWxheSA9IG5ld0RldGFpbHMuYXZhaWxhYmlsaXR5RGVsYXk7IC8vIGxldCBlc3RpbWF0ZSA9ICdhdmVyYWdlJztcblxuICBpZiAobmV3RGV0YWlscy51cGRhdGVkID09PSBmYWxzZSkge1xuICAgIGlmICh1c2VMYXN0TW9kaWZpZWQpIHtcbiAgICAgIC8vIGVzdGltYXRlID0gJ21pc3Mgcm91bmQgdHJpcCc7XG4gICAgICAvLyBXZSBzaG91bGQgaGF2ZSBoYWQgYSBoaXQgc28gdHJ5IGFnYWluIGluIHRoZSB0aW1lIGl0IHRha2VzIHRvIGdldCBhIHJlc3BvbnNlLFxuICAgICAgLy8gYnV0IG5vIGxlc3MgdGhhbiAxLzMgc2Vjb25kLlxuICAgICAgdmFyIG1pblJldHJ5ID0gMzMzICogbmV3RGV0YWlscy5taXNzZXM7XG4gICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSBNYXRoLm1heChNYXRoLm1pbihyZWxvYWRJbnRlcnZhbEFmdGVyTWlzcywgcm91bmRUcmlwICogMiksIG1pblJldHJ5KTtcbiAgICAgIG5ld0RldGFpbHMuYXZhaWxhYmlsaXR5RGVsYXkgPSAobmV3RGV0YWlscy5hdmFpbGFiaWxpdHlEZWxheSB8fCAwKSArIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgICAgLy8gZm9sbG93IEhMUyBTcGVjLCBJZiB0aGUgY2xpZW50IHJlbG9hZHMgYSBQbGF5bGlzdCBmaWxlIGFuZCBmaW5kcyB0aGF0IGl0IGhhcyBub3RcbiAgICAgIC8vIGNoYW5nZWQgdGhlbiBpdCBNVVNUIHdhaXQgZm9yIGEgcGVyaW9kIG9mIG9uZS1oYWxmIHRoZSB0YXJnZXRcbiAgICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSA9IHJlbG9hZEludGVydmFsQWZ0ZXJNaXNzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh1c2VMYXN0TW9kaWZpZWQpIHtcbiAgICAvLyBlc3RpbWF0ZSA9ICduZXh0IG1vZGlmaWVkIGRhdGUnO1xuICAgIC8vIEdldCB0aGUgY2xvc2VzdCB3ZSd2ZSBiZWVuIHRvIHRpbWVTaW5jZUxhc3RNb2RpZmllZCBvbiB1cGRhdGVcbiAgICBhdmFpbGFiaWxpdHlEZWxheSA9IE1hdGgubWluKGF2YWlsYWJpbGl0eURlbGF5IHx8IHJlbG9hZEludGVydmFsIC8gMiwgdGltZVNpbmNlTGFzdE1vZGlmaWVkKTtcbiAgICBuZXdEZXRhaWxzLmF2YWlsYWJpbGl0eURlbGF5ID0gYXZhaWxhYmlsaXR5RGVsYXk7XG4gICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gYXZhaWxhYmlsaXR5RGVsYXkgKyByZWxvYWRJbnRlcnZhbCAtIHRpbWVTaW5jZUxhc3RNb2RpZmllZDtcbiAgfSBlbHNlIHtcbiAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSByZWxvYWRJbnRlcnZhbCAtIHJvdW5kVHJpcDtcbiAgfSAvLyBjb25zb2xlLmxvZyhgW2NvbXB1dGVSZWxvYWRJbnRlcnZhbF0gbGl2ZSByZWxvYWQgJHtuZXdEZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfWAsXG4gIC8vICAgJ1xcbiAgbWV0aG9kJywgZXN0aW1hdGUsXG4gIC8vICAgJ1xcbiAgZXN0aW1hdGVkIHRpbWUgdW50aWwgdXBkYXRlID0+JywgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlLFxuICAvLyAgICdcXG4gIGF2ZXJhZ2UgdGFyZ2V0IGR1cmF0aW9uJywgcmVsb2FkSW50ZXJ2YWwsXG4gIC8vICAgJ1xcbiAgdGltZSBzaW5jZSBtb2RpZmllZCcsIHRpbWVTaW5jZUxhc3RNb2RpZmllZCxcbiAgLy8gICAnXFxuICB0aW1lIHJvdW5kIHRyaXAnLCByb3VuZFRyaXAsXG4gIC8vICAgJ1xcbiAgYXZhaWxhYmlsaXR5IGRlbGF5JywgYXZhaWxhYmlsaXR5RGVsYXkpO1xuXG5cbiAgcmV0dXJuIE1hdGgucm91bmQoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKGxldmVsLCBzbikge1xuICBpZiAoIWxldmVsIHx8ICFsZXZlbC5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgdmFyIGZyYWdtZW50ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tzbiAtIGxldmVsRGV0YWlscy5zdGFydFNOXTtcblxuICBpZiAoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG5cbiAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgaWYgKCFsZXZlbCB8fCAhbGV2ZWwuZGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcnRMaXN0ID0gbGV2ZWwuZGV0YWlscy5wYXJ0TGlzdDtcblxuICBpZiAocGFydExpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W2ldO1xuXG4gICAgICBpZiAocGFydC5pbmRleCA9PT0gcGFydEluZGV4ICYmIHBhcnQuZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9zdHJlYW0tY29udHJvbGxlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFN0cmVhbUNvbnRyb2xsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcmMvcG9seWZpbGxzL251bWJlciAqLyBcIi4vc3JjL3BvbHlmaWxscy9udW1iZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pcy1zdXBwb3J0ZWQgKi8gXCIuL3NyYy9pcy1zdXBwb3J0ZWQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2FkZXIvZnJhZ21lbnQgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9mcmFnbWVudC1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX2ludGVyZmFjZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLWludGVyZmFjZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy90eXBlcy90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nYXBfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2FwLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2dhcC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcblxuXG5cblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHJlYW1Db250cm9sbGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0cmVhbUNvbnRyb2xsZXIsIF9CYXNlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgZnVuY3Rpb24gU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgX3RoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgX3RoaXMubGV2ZWwgPSAtMTtcbiAgICBfdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBfdGhpcy5yZXRyeURhdGUgPSAwO1xuICAgIF90aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgX3RoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgX3RoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnBsYXlpbmcgPSBudWxsO1xuICAgIF90aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgX3RoaXMuZnJhZ0xhc3RLYnBzID0gMDtcbiAgICBfdGhpcy5zdGFsbGVkID0gZmFsc2U7XG4gICAgX3RoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGZhbHNlO1xuICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5mcmFnbWVudExvYWRlciA9IG5ldyBfbG9hZGVyX2ZyYWdtZW50X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXShobHMuY29uZmlnKTtcbiAgICBfdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuXG4gICAgX3RoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICBpZiAodGhpcy5sZXZlbHMpIHtcbiAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICB0aGlzLmZyYWdMb2FkRXJyb3IgPSAwO1xuXG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIHZhciBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG5cbiAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKGhscy5jb25maWcudGVzdEJhbmR3aWR0aCkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAvLyBobHMubmV4dExvYWRMZXZlbCByZW1haW5zIHVudGlsIGl0IGlzIHNldCB0byBhIG5ldyB2YWx1ZSBvciB1bnRpbCBhIG5ldyBmcmFnIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcblxuXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH0gLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcblxuXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSB0cnVlO1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyRsZXZlbDtcblxuICAgICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWxzID09PSBudWxsIHx8IGxldmVscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9sZXZlbHMkbGV2ZWwgPSBsZXZlbHNbbGV2ZWxdKSA9PT0gbnVsbCB8fCBfbGV2ZWxzJGxldmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGV2ZWxzJGxldmVsLmRldGFpbHM7XG5cbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gdGhpcy5sZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuXG4gICAgICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgdmFyIHJldHJ5RGF0ZSA9IHRoaXMucmV0cnlEYXRlOyAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuXG4gICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPT0gbnVsbCAmJiBfdGhpcyRtZWRpYSAhPT0gdm9pZCAwICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBjaGVjayBidWZmZXJcbiAgICAvLyBjaGVjay91cGRhdGUgY3VycmVudCBmcmFnbWVudFxuXG5cbiAgICB0aGlzLm9uVGlja0VuZCgpO1xuICB9O1xuXG4gIF9wcm90by5vblRpY2tFbmQgPSBmdW5jdGlvbiBvblRpY2tFbmQoKSB7XG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblRpY2tFbmQuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRvVGlja0lkbGUgPSBmdW5jdGlvbiBkb1RpY2tJZGxlKCkge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YSwgX2ZyYWckZGVjcnlwdGRhdGEyO1xuXG4gICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgbGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbDsgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuXG4gICAgaWYgKGxldmVsTGFzdExvYWRlZCA9PT0gbnVsbCB8fCAhbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgXCJtYWluXCIgbGV2ZWwgaXMgYXVkaW8tb25seSBidXQgd2UgYXJlIGxvYWRpbmcgYW4gYWx0ZXJuYXRlIHRyYWNrIGluIHRoZSBzYW1lIGdyb3VwLCBkbyBub3QgbG9hZCBhbnl0aGluZ1xuXG5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbGV2ZWxzIHx8ICFsZXZlbHNbbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07IC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG5cbiAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7IC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgLy8gaWYgbGl2ZSBwbGF5bGlzdCwgZW5zdXJlIHRoYXQgbmV3IHBsYXlsaXN0IGhhcyBiZWVuIHJlZnJlc2hlZCB0byBhdm9pZCBsb2FkaW5nL3RyeSB0byBsb2FkXG4gICAgLy8gYSB1c2VsZXNzIGFuZCBvdXRkYXRlZCBmcmFnbWVudCAodGhhdCBtaWdodCBldmVuIGludHJvZHVjZSBsb2FkIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgb3V0IG9mIHRoZSBsaXZlIHBsYXlsaXN0KVxuXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUwgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLldBSVRJTkdfTEVWRUw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG5cbiAgICBpZiAoIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShwb3MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyYWcgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQ7XG4gICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSAwO1xuXG4gICAgaWYgKCFmcmFnIHx8IGZyYWcuZGF0YSkge1xuICAgICAgLy8gY29tcHV0ZSBtYXggQnVmZmVyIExlbmd0aCB0aGF0IHdlIGNvdWxkIGdldCBmcm9tIHRoaXMgbG9hZCBsZXZlbCwgYmFzZWQgb24gbGV2ZWwgYml0cmF0ZS4gZG9uJ3QgYnVmZmVyIG1vcmUgdGhhbiA2MCBNQiBhbmQgbW9yZSB0aGFuIDMwc1xuICAgICAgdmFyIGxldmVsQml0cmF0ZSA9IGxldmVsSW5mby5tYXhCaXRyYXRlO1xuICAgICAgdmFyIG1heEJ1ZkxlbjtcblxuICAgICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heCg4ICogY29uZmlnLm1heEJ1ZmZlclNpemUgLyBsZXZlbEJpdHJhdGUsIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbWF4QnVmTGVuID0gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTsgLy8gZGV0ZXJtaW5lIG5leHQgY2FuZGlkYXRlIGZyYWdtZW50IHRvIGJlIGxvYWRlZCwgYmFzZWQgb24gY3VycmVudCBwb3NpdGlvbiBhbmQgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgICAgLy8gZW5zdXJlIHVwIHRvIGBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoYCBvZiBidWZmZXIgdXBmcm9udFxuXG4gICAgICB2YXIgbWF4QnVmZmVySG9sZSA9IHBvcyA8IGNvbmZpZy5tYXhCdWZmZXJIb2xlID8gTWF0aC5tYXgoX2dhcF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiTUFYX1NUQVJUX0dBUF9KVU1QXCJdLCBjb25maWcubWF4QnVmZmVySG9sZSkgOiBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogbWVkaWEsIHBvcywgbWF4QnVmZmVySG9sZSk7XG4gICAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47IC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuXG4gICAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX0VPUywgZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRU5ERUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0QnVmZmVyVGltZSA9IGJ1ZmZlckluZm8uZW5kO1xuICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRhcmdldEJ1ZmZlclRpbWUsIGxldmVsRGV0YWlscyk7IC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nXG4gICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIGltcHJvdmVkIHRvIHNpbXBseSBwaWNrIG5leHQgc24gZnJhZ21lbnRcblxuICAgICAgaWYgKGZyYWcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLk9LICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRoaXMubmV4dExvYWRQb3NpdGlvbiwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIFdlIHdhbnQgdG8gbG9hZCB0aGUga2V5IGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBpZGVudGl0eSBrZXksIGJlY2F1c2Ugd2Ugd2lsbCBkZWNyeXB0XG4gICAgLy8gdGhpcyBjb250ZW50IHVzaW5nIHRoZSBrZXkgd2UgZmV0Y2guIE90aGVyIGtleXMgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBEUk0gQ0RNIHZpYSBFTUUuXG5cblxuICAgIGlmICgoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgPT09IG51bGwgfHwgX2ZyYWckZGVjcnlwdGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mcmFnJGRlY3J5cHRkYXRhLmtleUZvcm1hdCkgPT09ICdpZGVudGl0eScgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEyID0gZnJhZy5kZWNyeXB0ZGF0YSkgIT09IG51bGwgJiYgX2ZyYWckZGVjcnlwdGRhdGEyICE9PSB2b2lkIDAgJiYgX2ZyYWckZGVjcnlwdGRhdGEyLmtleSkpIHtcbiAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBrZXkgZm9yIFwiICsgZnJhZy5zbiArIFwiIG9mIFtcIiArIGxldmVsRGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBsZXZlbERldGFpbHMuZW5kU04gKyBcIl0sIGxldmVsIFwiICsgbGV2ZWwpO1xuICAgICAgdGhpcy5sb2FkS2V5KGZyYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZEtleSA9IGZ1bmN0aW9uIGxvYWRLZXkoZnJhZykge1xuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uS0VZX0xPQURJTkc7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uS0VZX0xPQURJTkcsIHtcbiAgICAgIGZyYWc6IGZyYWdcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHZhciBfdGhpcyRtZWRpYTI7XG5cbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgdmFyIGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnOyAvLyBEb24ndCB1cGRhdGUgbmV4dExvYWRQb3NpdGlvbiBmb3IgZnJhZ21lbnRzIHdoaWNoIGFyZSBub3QgYnVmZmVyZWRcblxuICAgIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5zbikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH0gLy8gVXNlIGRhdGEgZnJvbSBsb2FkZWQgYmFja3RyYWNrZWQgZnJhZ21lbnQgaWYgYXZhaWxhYmxlXG5cblxuICAgIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLkJBQ0tUUkFDS0VEKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJhY2t0cmFja0RhdGEoZnJhZyk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdTdGF0ZSA9IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLk5PVF9MT0FERUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIkZyYWdtZW50U3RhdGVcIl0uTk9UX0xPQURFRCB8fCBmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLlBBUlRJQUwpIHtcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2coXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG5cbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIGxldmVsRGV0YWlscywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcmFnU3RhdGUgPT09IF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJGcmFnbWVudFN0YXRlXCJdLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGlmICh0aGlzLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGgoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoKF90aGlzJG1lZGlhMiA9IHRoaXMubWVkaWEpID09PSBudWxsIHx8IF90aGlzJG1lZGlhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbWVkaWEyLmJ1ZmZlcmVkLmxlbmd0aCkgPT09IDApIHtcbiAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uTUFJTik7XG4gIH07XG5cbiAgX3Byb3RvLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhmcmFnLmVuZCArIDAuNSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLypcbiAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgLSBwYXVzZSBwbGF5YmFjayBpZiBwbGF5aW5nXG4gICAgIC0gY2FuY2VsIGFueSBwZW5kaW5nIGxvYWQgcmVxdWVzdFxuICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICovXG4gIDtcblxuICBfcHJvdG8uaW1tZWRpYXRlTGV2ZWxTd2l0Y2ggPSBmdW5jdGlvbiBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG4gIC8qKlxuICAgKiB0cnkgdG8gc3dpdGNoIEFTQVAgd2l0aG91dCBicmVha2luZyB2aWRlbyBwbGF5YmFjazpcbiAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgKiB3ZSBuZWVkIHRvIGZpbmQgdGhlIG5leHQgZmx1c2hhYmxlIGJ1ZmZlciByYW5nZVxuICAgKiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgbmV3IHNlZ21lbnQgZmV0Y2ggdGltZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5uZXh0TGV2ZWxTd2l0Y2ggPSBmdW5jdGlvbiBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7IC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG5cbiAgICBpZiAobWVkaWEgIT09IG51bGwgJiYgbWVkaWEgIT09IHZvaWQgMCAmJiBtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICB2YXIgZmV0Y2hkZWxheTtcbiAgICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG5cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgdmFyIG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgdmFyIG5leHRMZXZlbCA9IGxldmVsc1tuZXh0TGV2ZWxJZF07XG4gICAgICAgIHZhciBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcblxuICAgICAgICBpZiAoZnJhZ0xhc3RLYnBzICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gdGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlIC8gKDEwMDAgKiBmcmFnTGFzdEticHMpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hkZWxheSA9IDA7XG4gICAgICB9IC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcblxuXG4gICAgICB2YXIgYnVmZmVyZWRGcmFnID0gdGhpcy5nZXRCdWZmZXJlZEZyYWcobWVkaWEuY3VycmVudFRpbWUgKyBmZXRjaGRlbGF5KTtcblxuICAgICAgaWYgKGJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgIHZhciBuZXh0QnVmZmVyZWRGcmFnID0gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoYnVmZmVyZWRGcmFnKTtcblxuICAgICAgICBpZiAobmV4dEJ1ZmZlcmVkRnJhZykge1xuICAgICAgICAgIC8vIGlmIHdlIGFyZSBoZXJlLCB3ZSBjYW4gYWxzbyBjYW5jZWwgYW55IGxvYWRpbmcvZGVtdXhpbmcgaW4gcHJvZ3Jlc3MsIGFzIHRoZXkgYXJlIHVzZWxlc3NcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTsgLy8gc3RhcnQgZmx1c2ggcG9zaXRpb24gaXMgdGhlIHN0YXJ0IFBUUyBvZiBuZXh0IGJ1ZmZlcmVkIGZyYWcuXG4gICAgICAgICAgLy8gd2UgdXNlIGZyYWcubmF4U3RhcnRQVFMgd2hpY2ggaXMgbWF4KGF1ZGlvIHN0YXJ0UFRTLCB2aWRlbyBzdGFydFBUUykuXG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBhIHNtYWxsIFBUUyBEZWx0YSBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbywgdXNpbmcgbWF4U3RhcnRQVFMgYXZvaWRzIGZsdXNoaW5nIGxhc3Qgc2FtcGxlcyBmcm9tIGN1cnJlbnQgZnJhZ21lbnRcblxuICAgICAgICAgIHZhciBtYXhTdGFydCA9IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTIDogbmV4dEJ1ZmZlcmVkRnJhZy5zdGFydDtcbiAgICAgICAgICB2YXIgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb24pKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWJvcnRDdXJyZW50RnJhZyA9IGZ1bmN0aW9uIGFib3J0Q3VycmVudEZyYWcoKSB7XG4gICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcblxuICAgIGlmIChmcmFnQ3VycmVudCAhPT0gbnVsbCAmJiBmcmFnQ3VycmVudCAhPT0gdm9pZCAwICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoTWFpbkJ1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5mbHVzaE1haW5CdWZmZXIuY2FsbCh0aGlzLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0aGlzLmFsdEF1ZGlvID8gJ3ZpZGVvJyA6IG51bGwpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hlZC5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcblxuICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbk1lZGlhUGxheWluZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252c2Vla2VkID0gdGhpcy5vbk1lZGlhU2Vla2VkLmJpbmQodGhpcyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBfZ2FwX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJkZWZhdWx0XCJdKHRoaXMuY29uZmlnLCBtZWRpYSwgdGhpcy5mcmFnbWVudFRyYWNrZXIsIHRoaXMuaGxzKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFQbGF5aW5nID0gZnVuY3Rpb24gb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhU2Vla2VkID0gZnVuY3Rpb24gb25NZWRpYVNlZWtlZCgpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuXG4gICAgaWYgKE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMubG9nKFwiTWVkaWEgc2Vla2VkIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgfSAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIHJlc2V0IGJ1ZmZlciBvbiBtYW5pZmVzdCBsb2FkaW5nXG4gICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uQlVGRkVSX1JFU0VULCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgYWFjID0gZmFsc2U7XG4gICAgdmFyIGhlYWFjID0gZmFsc2U7XG4gICAgdmFyIGNvZGVjO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAvLyBkZXRlY3QgaWYgd2UgaGF2ZSBkaWZmZXJlbnQga2luZCBvZiBhdWRpbyBjb2RlY3MgdXNlZCBhbW9uZ3N0IHBsYXlsaXN0c1xuICAgICAgY29kZWMgPSBsZXZlbC5hdWRpb0NvZGVjO1xuXG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgaWYgKGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMSkge1xuICAgICAgICAgIGFhYyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgaGVhYWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFPYmplY3QoX2lzX3N1cHBvcnRlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY2hhbmdlVHlwZVN1cHBvcnRlZFwiXSkoKTtcblxuICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMgfHwgdGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbZGF0YS5sZXZlbF07XG5cbiAgICBpZiAoIWxldmVsLmRldGFpbHMgfHwgbGV2ZWwuZGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBkYXRhLmxldmVsIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbihsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX0xFVkVMO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2N1ckxldmVsJGRldGFpbHM7XG5cbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgdmFyIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIHZhciBuZXdEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHZhciBkdXJhdGlvbiA9IG5ld0RldGFpbHMudG90YWxkdXJhdGlvbjtcblxuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgbmV3TGV2ZWxJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2coXCJMZXZlbCBcIiArIG5ld0xldmVsSWQgKyBcIiBsb2FkZWQgW1wiICsgbmV3RGV0YWlscy5zdGFydFNOICsgXCIsXCIgKyBuZXdEZXRhaWxzLmVuZFNOICsgXCJdLCBjYyBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0Q0MgKyBcIiwgXCIgKyBuZXdEZXRhaWxzLmVuZENDICsgXCJdIGR1cmF0aW9uOlwiICsgZHVyYXRpb24pO1xuICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG5cbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5GUkFHX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSkge1xuICAgICAgaWYgKGZyYWdDdXJyZW50LmxldmVsICE9PSBkYXRhLmxldmVsICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgIGZyYWdDdXJyZW50LmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJMZXZlbCA9IGxldmVsc1tuZXdMZXZlbElkXTtcbiAgICB2YXIgc2xpZGluZyA9IDA7XG5cbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfY3VyTGV2ZWwkZGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHMpICE9PSBudWxsICYmIF9jdXJMZXZlbCRkZXRhaWxzICE9PSB2b2lkIDAgJiYgX2N1ckxldmVsJGRldGFpbHMubGl2ZSkge1xuICAgICAgaWYgKCFuZXdEZXRhaWxzLmZyYWdtZW50c1swXSkge1xuICAgICAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IC8vIG92ZXJyaWRlIGxldmVsIGluZm9cblxuXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBuZXdMZXZlbElkO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBsZXZlbDogbmV3TGV2ZWxJZFxuICAgIH0pOyAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5XQUlUSU5HX0xFVkVMKSB7XG4gICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKG5ld0RldGFpbHMpKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5zeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobmV3RGV0YWlscyk7XG4gICAgfSAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG5cblxuICAgIHRoaXMudGljaygpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZGV0YWlscyRpbml0U2VnbWVudDtcblxuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICB2YXIgZGV0YWlscyA9IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuXG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oXCJEcm9wcGluZyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYzsgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG5cbiAgICB2YXIgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIHZhciBpbml0U2VnbWVudERhdGEgPSAoX2RldGFpbHMkaW5pdFNlZ21lbnQgPSBkZXRhaWxzLmluaXRTZWdtZW50KSA9PT0gbnVsbCB8fCBfZGV0YWlscyRpbml0U2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RldGFpbHMkaW5pdFNlZ21lbnQuZGF0YTtcblxuICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5fZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpOyAvLyB0cmFuc211eCB0aGUgTVBFRy1UUyBkYXRhIHRvIElTTy1CTUZGIHNlZ21lbnRzXG4gICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuXG5cbiAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciB8fCBuZXcgX2RlbXV4X3RyYW5zbXV4ZXJfaW50ZXJmYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJkZWZhdWx0XCJdKHRoaXMuaGxzLCBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdExldmVsVHlwZVwiXS5NQUlOLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICB2YXIgcGFydEluZGV4ID0gcGFydCA/IHBhcnQuaW5kZXggOiAtMTtcbiAgICB2YXIgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgdmFyIGNodW5rTWV0YSA9IG5ldyBfdHlwZXNfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcIkNodW5rTWV0YWRhdGFcIl0oZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZGV0YWlscy50b3RhbGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgaW5pdFBUUyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0VHJhbnNtdXhlciA9IGZ1bmN0aW9uIHJlc2V0VHJhbnNtdXhlcigpIHtcbiAgICBpZiAodGhpcy50cmFuc211eGVyKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIC8vIGlmIGFueSBVUkwgZm91bmQgb24gbmV3IGF1ZGlvIHRyYWNrLCBpdCBpcyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICB2YXIgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHZhciB0cmFja0lkID0gZGF0YS5pZDsgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcblxuICAgIGlmICghYWx0QXVkaW8pIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDsgLy8gd2UgbmVlZCB0byByZWZpbGwgYXVkaW8gYnVmZmVyIGZyb20gbWFpbjogY2FuY2VsIGFueSBmcmFnIGxvYWRpbmcgdG8gc3BlZWQgdXAgYXVkaW8gc3dpdGNoXG5cbiAgICAgICAgaWYgKGZyYWdDdXJyZW50ICE9PSBudWxsICYmIGZyYWdDdXJyZW50ICE9PSB2b2lkIDAgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsOyAvLyBkZXN0cm95IHRyYW5zbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG5cbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTsgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcblxuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzOyAvLyBJZiBzd2l0Y2hpbmcgZnJvbSBhbHQgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG5cbiAgICAgIGlmIChmcm9tQWx0QXVkaW8pIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19TV0lUQ0hFRCwge1xuICAgICAgICBpZDogdHJhY2tJZFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgIHZhciBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuXG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICB2YXIgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyOyAvLyBpZiB3ZSBzd2l0Y2hlZCBvbiBhbHRlcm5hdGUgYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCB2aWRlbyBzb3VyY2VidWZmZXIgYnVmZmVyZWRcblxuICAgICAgaWYgKHZpZGVvQnVmZmVyICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IHZpZGVvQnVmZmVyKSB7XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgb24gYWx0ZXJuYXRlIGF1ZGlvLCB1c2UgdmlkZW8uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQnVmZmVyQ3JlYXRlZCA9IGZ1bmN0aW9uIG9uQnVmZmVyQ3JlYXRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciB0cmFja3MgPSBkYXRhLnRyYWNrcztcbiAgICB2YXIgbWVkaWFUcmFjaztcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIHRyYWNrcykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuXG4gICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICBuYW1lID0gdHlwZTtcbiAgICAgICAgbWVkaWFUcmFjayA9IHRyYWNrOyAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB2YXIgdmlkZW9UcmFjayA9IHRyYWNrc1t0eXBlXTtcblxuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgdGhpcy5sb2coXCJBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSBcIiArIG5hbWUgKyBcIi5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIik7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuXG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSAnbWFpbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSwgc2luY2UgdGhhdCB3aWxsIGludGVyZmVyZSB3aXRoIGEgbGV2ZWwgc3dpdGNoXG4gICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyB8fCB0aGlzLmZyYWdDdXJyZW50OyAvLyBkb24ndCBoYW5kbGUgZnJhZyBlcnJvciBub3QgcmVsYXRlZCB0byBtYWluIGZyYWdtZW50XG5cbiAgICBpZiAoZnJhZyAmJiBmcmFnLnR5cGUgIT09ICdtYWluJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG5cblxuICAgIHZhciBtZWRpYUJ1ZmZlcmVkID0gISF0aGlzLm1lZGlhICYmIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lKSAmJiBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiQnVmZmVySGVscGVyXCJdLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArIDAuNSk7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIkVycm9yRGV0YWlsc1wiXS5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAoIWRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICAgICAgICBpZiAodGhpcy5mcmFnTG9hZEVycm9yICsgMSA8PSB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5KSB7XG4gICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBjb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXRcbiAgICAgICAgICAgIHZhciBkZWxheSA9IE1hdGgubWluKE1hdGgucG93KDIsIHRoaXMuZnJhZ0xvYWRFcnJvcikgKiB0aGlzLmNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksIHRoaXMuY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTsgLy8gQHRzLWlnbm9yZSAtIGZyYWcgaXMgcG90ZW50aWFsbHkgbnVsbCBhY2NvcmRpbmcgdG8gVFMgaGVyZVxuXG4gICAgICAgICAgICB0aGlzLndhcm4oXCJGcmFnbWVudCBcIiArIChmcmFnID09PSBudWxsIHx8IGZyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyYWcuc24pICsgXCIgb2YgbGV2ZWwgXCIgKyAoZnJhZyA9PT0gbnVsbCB8fCBmcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcmFnLmxldmVsKSArIFwiIGZhaWxlZCB0byBsb2FkLCByZXRyeWluZyBpbiBcIiArIGRlbGF5ICsgXCJtc1wiKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlEYXRlID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5OyAvLyByZXRyeSBsb2FkaW5nIHN0YXRlXG4gICAgICAgICAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCByZXNldCBzdGFydEZyYWdSZXF1ZXN0ZWQgZmxhZ1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZyYWdMb2FkRXJyb3IrKztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJsb2dnZXJcIl0uZXJyb3IoXCJbc3RyZWFtLWNvbnRyb2xsZXJdOiBcIiArIGRhdGEuZGV0YWlscyArIFwiIHJlYWNoZXMgbWF4IHJldHJ5LCByZWRpc3BhdGNoIGFzIGZhdGFsIC4uLlwiKTsgLy8gc3dpdGNoIGVycm9yIHRvIGZhdGFsXG5cbiAgICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5FUlJPUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJFcnJvckRldGFpbHNcIl0uTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLkVSUk9SKSB7XG4gICAgICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgICAgIC8vIGlmIGZhdGFsIGVycm9yLCBzdG9wIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHRoaXMud2FybihcIlwiICsgZGF0YS5kZXRhaWxzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uRVJST1I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwgLCBzd2l0Y2ggYmFjayB0byBJRExFXG4gICAgICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uV0FJVElOR19MRVZFTCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIkVycm9yRGV0YWlsc1wiXS5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICAgIGlmIChkYXRhLnBhcmVudCA9PT0gJ21haW4nICYmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0VEKSkge1xuICAgICAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICAgICAgaWYgKG1lZGlhQnVmZmVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZHVjZU1heEJ1ZmZlckxlbmd0aCh0aGlzLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGgpO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIG9uIElFL0VkZ2UsIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL3B1bGwvNzA4XG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgICB0aGlzLndhcm4oJ2J1ZmZlciBmdWxsIGVycm9yIGFsc28gbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBldmVyeXRoaW5nJyk7IC8vIGZsdXNoIGV2ZXJ5dGhpbmdcblxuICAgICAgICAgICAgdGhpcy5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZWR1Y2VNYXhCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiBfcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG1pbkxlbmd0aCkge1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICB0aGlzLndhcm4oXCJSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gXCIgKyBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoICsgXCJzXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENoZWNrcyB0aGUgaGVhbHRoIG9mIHRoZSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlc29sdmUgcGxheWJhY2sgc3RhbGxzLlxuICA7XG5cbiAgX3Byb3RvLmNoZWNrQnVmZmVyID0gZnVuY3Rpb24gY2hlY2tCdWZmZXIoKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgZ2FwQ29udHJvbGxlciA9IHRoaXMuZ2FwQ29udHJvbGxlcjtcblxuICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2hlY2sgY29tYmluZWQgYnVmZmVyXG5cblxuICAgIHZhciBidWZmZXJlZCA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uZ2V0QnVmZmVyZWQobWVkaWEpO1xuXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmIGJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3NlZWtUb1N0YXJ0UG9zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBnYXBDb250cm9sbGVyLnBvbGwodGhpcy5sYXN0Q3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFOyAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcblxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRpY2soKTtcbiAgfTtcblxuICBfcHJvdG8ub25CdWZmZXJGbHVzaGVkID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGVkKGV2ZW50LCBfcmVmKSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG5cbiAgICAvKiBhZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFnc1xuICAgICAgdXNlIG1lZGlhQnVmZmVyZWQgaW5zdGVhZCBvZiBtZWRpYSAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgICovXG4gICAgdmFyIG1lZGlhID0gKHR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhICYmIHR5cGUgIT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTykge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyh0eXBlLCBfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiQnVmZmVySGVscGVyXCJdLmdldEJ1ZmZlcmVkKG1lZGlhKSk7XG4gICAgfSAvLyByZXNldCByZWZlcmVuY2UgdG8gZnJhZ1xuXG5cbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7IC8vIG1vdmUgdG8gSURMRSBvbmNlIGZsdXNoIGNvbXBsZXRlLiB0aGlzIHNob3VsZCB0cmlnZ2VyIG5ldyBmcmFnbWVudCBsb2FkaW5nXG5cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLklETEU7XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH07XG5cbiAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG4gIC8qKlxuICAgKiBTZWVrcyB0byB0aGUgc2V0IHN0YXJ0UG9zaXRpb24gaWYgbm90IGVxdWFsIHRvIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9zZWVrVG9TdGFydFBvcyA9IGZ1bmN0aW9uIF9zZWVrVG9TdGFydFBvcygpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uOyAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgLy8gYXQgdGhhdCBzdGFnZSwgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJ1ZmZlcmVkIHJhbmdlLCBhcyB3ZSByZWFjaCB0aGF0IGNvZGUgYWZ0ZXIgZmlyc3QgZnJhZ21lbnQgaGFzIGJlZW4gYnVmZmVyZWRcblxuICAgIGlmIChzdGFydFBvc2l0aW9uID49IDAgJiYgY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wibG9nZ2VyXCJdLmxvZyhcImNvdWxkIG5vdCBzZWVrIHRvIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiLCBhbHJlYWR5IHNlZWtpbmcgYXQgXCIgKyBjdXJyZW50VGltZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlcmVkID0gX3V0aWxzX2J1ZmZlcl9oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkJ1ZmZlckhlbHBlclwiXS5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICB2YXIgYnVmZmVyU3RhcnQgPSBidWZmZXJlZC5sZW5ndGggPyBidWZmZXJlZC5zdGFydCgwKSA6IDA7XG4gICAgICB2YXIgZGVsdGEgPSBidWZmZXJTdGFydCAtIHN0YXJ0UG9zaXRpb247XG5cbiAgICAgIGlmIChkZWx0YSA+IDAgJiYgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXCJsb2dnZXJcIl0ubG9nKFwiYWRqdXN0aW5nIHN0YXJ0IHBvc2l0aW9uIGJ5IFwiICsgZGVsdGEgKyBcIiB0byBtYXRjaCBidWZmZXIgc3RhcnRcIik7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gKz0gZGVsdGE7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nKFwic2VlayB0byB0YXJnZXQgc3RhcnQgcG9zaXRpb24gXCIgKyBzdGFydFBvc2l0aW9uICsgXCIgZnJvbSBjdXJyZW50IHRpbWUgXCIgKyBjdXJyZW50VGltZSk7XG4gICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fZ2V0QXVkaW9Db2RlYyA9IGZ1bmN0aW9uIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgIHZhciBhdWRpb0NvZGVjID0gdGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWMgfHwgY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG5cbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcblxuICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXVkaW9Db2RlYztcbiAgfTtcblxuICBfcHJvdG8uX2xvYWRCaXRyYXRlVGVzdEZyYWcgPSBmdW5jdGlvbiBfbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBobHMgPSBfdGhpczIuaGxzO1xuXG4gICAgICBpZiAoIWRhdGEgfHwgaGxzLm5leHRMb2FkTGV2ZWwgfHwgX3RoaXMyLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzMi5mcmFnTG9hZEVycm9yID0gMDtcbiAgICAgIF90aGlzMi5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgX3RoaXMyLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMyLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICBmcmFnLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICB2YXIgc3RhdHMgPSBmcmFnLnN0YXRzOyAvLyBCaXRyYXRlIHRlc3RzIGZyYWdtZW50cyBhcmUgbmVpdGhlciBwYXJzZWQgbm9yIGJ1ZmZlcmVkXG5cbiAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBpZDogJ21haW4nXG4gICAgICB9KTtcblxuICAgICAgX3RoaXMyLnRpY2soKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG5cbiAgICB2YXIgaWQgPSAnbWFpbic7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciByZW11eFJlc3VsdCA9IHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGEgPSB0cmFuc211eFJlc3VsdC5jaHVua01ldGE7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMud2FybihcIlRoZSBsb2FkaW5nIGNvbnRleHQgY2hhbmdlZCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIgKyBjaHVua01ldGEuc24gKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCArIFwiLiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgcGFydCA9IGNvbnRleHQucGFydCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsO1xuICAgIHZhciB2aWRlbyA9IHJlbXV4UmVzdWx0LnZpZGVvLFxuICAgICAgICB0ZXh0ID0gcmVtdXhSZXN1bHQudGV4dCxcbiAgICAgICAgaWQzID0gcmVtdXhSZXN1bHQuaWQzLFxuICAgICAgICBpbml0U2VnbWVudCA9IHJlbXV4UmVzdWx0LmluaXRTZWdtZW50OyAvLyBUaGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgaGFuZGxlcyBhdWRpbyBidWZmZXJpbmcgaWYgSGxzLmpzIGlzIHBsYXlpbmcgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG5cbiAgICB2YXIgYXVkaW8gPSB0aGlzLmFsdEF1ZGlvID8gdW5kZWZpbmVkIDogcmVtdXhSZXN1bHQuYXVkaW87IC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IGZyYWdtZW50IGhhcyBiZWVuIGFib3J0ZWQuIFdlIGNoZWNrIHRoaXMgYnkgZmlyc3Qgc2VlaW5nIGlmIHdlJ3JlIHN0aWxsIHBsYXlpbmcgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlN0YXRlXCJdLlBBUlNJTkc7XG5cbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgZnJhZywgY2h1bmtNZXRhKTtcblxuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBUaGlzIHdvdWxkIGJlIG5pY2UgaWYgTnVtYmVyLmlzRmluaXRlIGFjdGVkIGFzIGEgdHlwZWd1YXJkLCBidXQgaXQgZG9lc24ndC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEwMDM4XG5cblxuICAgICAgdmFyIGluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTO1xuICAgICAgdmFyIHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZTtcblxuICAgICAgaWYgKE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShpbml0UFRTKSkge1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSBpbml0UFRTO1xuICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBpbml0UFRTOiBpbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gQXZvaWQgYnVmZmVyaW5nIGlmIGJhY2t0cmFja2luZyB0aGlzIGZyYWdtZW50XG5cblxuICAgIGlmICh2aWRlbyAmJiByZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgIHZhciBzdGFydFBUUyA9IHZpZGVvLnN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTID0gdmlkZW8uZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFMgPSB2aWRlby5zdGFydERUUyxcbiAgICAgICAgICAgIGVuZERUUyA9IHZpZGVvLmVuZERUUztcblxuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUzogc3RhcnRQVFMsXG4gICAgICAgICAgICBlbmRQVFM6IGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICAgIGVuZERUUzogZW5kRFRTXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhdCBjdXJyZW50VGltZVxuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpICsgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcblxuICAgICAgICAgIGlmIChwb3MgPiBmcmFnLnN0YXJ0ICYmIHBvcyA8IHN0YXJ0UFRTKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFNldCB2aWRlbyBzdHJlYW0gc3RhcnQgdG8gZnJhZ21lbnQgc3RhcnQgc28gdGhhdCB0cnVuY2F0ZWQgc2FtcGxlcyBkbyBub3QgZGlzdG9ydCB0aGUgdGltZWxpbmUsIGFuZCBtYXJrIGl0IHBhcnRpYWxcblxuXG4gICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBmcmFnLnN0YXJ0LCBlbmRQVFMsIGZyYWcuc3RhcnQsIGVuZERUUywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YSh2aWRlbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICB2YXIgX3N0YXJ0UFRTID0gYXVkaW8uc3RhcnRQVFMsXG4gICAgICAgICAgX2VuZFBUUyA9IGF1ZGlvLmVuZFBUUyxcbiAgICAgICAgICBfc3RhcnREVFMgPSBhdWRpby5zdGFydERUUyxcbiAgICAgICAgICBfZW5kRFRTID0gYXVkaW8uZW5kRFRTO1xuXG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zW19sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJT10gPSB7XG4gICAgICAgICAgc3RhcnRQVFM6IF9zdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFM6IF9lbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFM6IF9zdGFydERUUyxcbiAgICAgICAgICBlbmREVFM6IF9lbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8sIF9zdGFydFBUUywgX2VuZFBUUywgX3N0YXJ0RFRTLCBfZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cblxuICAgIGlmIChpZDMgIT09IG51bGwgJiYgaWQzICE9PSB2b2lkIDAgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPT0gbnVsbCAmJiBfaWQzJHNhbXBsZXMgIT09IHZvaWQgMCAmJiBfaWQzJHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgZW1pdHRlZElEMyA9IHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgZW1pdHRlZFRleHQgPSB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2J1ZmZlckluaXRTZWdtZW50ID0gZnVuY3Rpb24gX2J1ZmZlckluaXRTZWdtZW50KGN1cnJlbnRMZXZlbCwgdHJhY2tzLCBmcmFnLCBjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU3RhdGVcIl0uUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0cmFja3MuYXVkaW8gJiYgIXRyYWNrcy52aWRlbzsgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG5cbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiAhdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgfSAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuXG5cbiAgICB2YXIgYXVkaW8gPSB0cmFja3MuYXVkaW8sXG4gICAgICAgIHZpZGVvID0gdHJhY2tzLnZpZGVvLFxuICAgICAgICBhdWRpb3ZpZGVvID0gdHJhY2tzLmF1ZGlvdmlkZW87XG5cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2l0Y2gpIHtcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAvLyBmb3JjZSBIRS1BQUMsIGFzIGl0IHNlZW1zIHRoYXQgbW9zdCBicm93c2VycyBwcmVmZXJzIGl0LlxuICAgICAgICAvLyBkb24ndCBmb3JjZSBIRS1BQUMgaWYgbW9ubyBzdHJlYW0sIG9yIGluIEZpcmVmb3hcblxuXG4gICAgICAgIGlmIChhdWRpby5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfSAvLyBIRS1BQUMgaXMgYnJva2VuIG9uIEFuZHJvaWQsIGFsd2F5cyBzaWduYWwgYXVkaW8gY29kZWMgYXMgQUFDIGV2ZW4gaWYgdmFyaWFudCBtYW5pZmVzdCBzdGF0ZXMgb3RoZXJ3aXNlXG5cblxuICAgICAgaWYgKHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiYgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgICAgLy8gRXhjbHVkZSBtcGVnIGF1ZGlvXG4gICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgdGhpcy5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIiArIGF1ZGlvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudExldmVsLmF1ZGlvQ29kZWMgJiYgY3VycmVudExldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coXCJTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcXFwiXCIgKyBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyArIFwiXFxcIiBmb3IgXFxcIlwiICsgYXVkaW9Db2RlYyArIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgYXVkaW8ubGV2ZWxDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgICBhdWRpby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIGF1ZGlvLmNvbnRhaW5lciArIFwiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIgKyAoYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8ubGV2ZWxDb2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuICAgICAgdmlkZW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhcIkluaXQgdmlkZW8gYnVmZmVyLCBjb250YWluZXI6XCIgKyB2aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnKSArIFwiL1wiICsgdmlkZW8uY29kZWMgKyBcIl1cIik7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvdmlkZW8pIHtcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgYXVkaW92aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgKGN1cnJlbnRMZXZlbC5hdHRycy5DT0RFQ1MgfHwgJycpICsgXCIvXCIgKyBhdWRpb3ZpZGVvLmNvZGVjICsgXCJdXCIpO1xuICAgIH1cblxuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7IC8vIGxvb3AgdGhyb3VnaCB0cmFja3MgdGhhdCBhcmUgZ29pbmcgdG8gYmUgcHJvdmlkZWQgdG8gYnVmZmVyQ29udHJvbGxlclxuXG4gICAgT2JqZWN0LmtleXModHJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja05hbWUpIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgdmFyIGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG5cbiAgICAgIGlmIChpbml0U2VnbWVudCAhPT0gbnVsbCAmJiBpbml0U2VnbWVudCAhPT0gdm9pZCAwICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgX3RoaXMzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTsgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuXG4gICAgdGhpcy50aWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmJhY2t0cmFjayA9IGZ1bmN0aW9uIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5iYWNrdHJhY2soZnJhZyk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdGF0ZVwiXS5CQUNLVFJBQ0tJTkc7XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrRnJhZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgdmFyIHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICB2YXIgZnJhZ1BsYXlpbmdDdXJyZW50ID0gbnVsbDtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5yZWFkeVN0YXRlID4gMSAmJiB2aWRlby5zZWVraW5nID09PSBmYWxzZSkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChfdXRpbHNfYnVmZmVyX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiQnVmZmVySGVscGVyXCJdLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJCdWZmZXJIZWxwZXJcIl0uaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUgKyAwLjEpKSB7XG4gICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICB3aGVuIGZpcnN0IHZpZGVvIGZyYW1lIGlzIGRpc3BsYXllZCBhbmQgcGxheWJhY2sgaXMgcGF1c2VkLlxuICAgICAgICAgIGFkZCBhIHRvbGVyYW5jZSBvZiAxMDBtcywgaW4gY2FzZSBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCxcbiAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgZm9yIEZSQUdfQ0hBTkdFRCBldmVudCByZXBvcnRpbmcgKi9cbiAgICAgICAgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoY3VycmVudFRpbWUgKyAwLjEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIHZhciBmcmFnUGxheWluZyA9IHRoaXMuZnJhZ1BsYXlpbmc7XG4gICAgICAgIHZhciBmcmFnQ3VycmVudExldmVsID0gZnJhZ1BsYXlpbmdDdXJyZW50LmxldmVsO1xuXG4gICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmdDdXJyZW50LnNuICE9PSBmcmFnUGxheWluZy5zbiB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCB8fCBmcmFnUGxheWluZ0N1cnJlbnQudXJsSWQgIT09IGZyYWdQbGF5aW5nLnVybElkKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJFdmVudHNcIl0uRlJBR19DSEFOR0VELCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnUGxheWluZ0N1cnJlbnRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkxFVkVMX1NXSVRDSEVELCB7XG4gICAgICAgICAgICAgIGxldmVsOiBmcmFnQ3VycmVudExldmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgIGtleTogXCJuZXh0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5uZXh0QnVmZmVyZWRGcmFnO1xuXG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICByZXR1cm4gZnJhZy5sZXZlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRCdWZmZXJlZEZyYWdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAvLyBmaXJzdCBnZXQgZW5kIHJhbmdlIG9mIGN1cnJlbnQgZnJhZ21lbnRcbiAgICAgICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWdQbGF5aW5nQ3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VTdGFydExvYWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtQ29udHJvbGxlcjtcbn0oX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9idWZmZXItaGVscGVyICovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZnJhZ21lbnRfZmluZGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudC1maW5kZXJzICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC1maW5kZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZyYWdtZW50LXRyYWNrZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2ZyYWdtZW50LXRyYWNrZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYmFzZS1zdHJlYW0tY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvYmFzZS1zdHJlYW0tY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2ZyYWdtZW50X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC1sb2FkZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sZXZlbCAqLyBcIi4vc3JjL3R5cGVzL2xldmVsLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuXG5cblxuXG5cblxuXG5cbnZhciBUSUNLX0lOVEVSVkFMID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG52YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlcikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsICdbc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICBfdGhpcy5sZXZlbHMgPSBbXTtcbiAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnRyYWNrc0J1ZmZlcmVkID0gdm9pZCAwO1xuICAgIF90aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgX3RoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIF90aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgX3RoaXMubWVkaWEgPSBudWxsO1xuICAgIF90aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICBfdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJTdGF0ZVwiXS5TVE9QUEVEO1xuICAgIF90aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgX2xvYWRlcl9mcmFnbWVudF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0oaGxzLmNvbmZpZyk7XG5cbiAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlN0YXRlXCJdLklETEU7IC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHRyYWNrIHdpdGggbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcblxuICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcblxuICAgIGlmIChjdXJyZW50VHJhY2sgIT09IG51bGwgJiYgY3VycmVudFRyYWNrICE9PSB2b2lkIDAgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3llZCA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3llZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlN0YXRlXCJdLlNUT1BQRUQ7XG5cbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3M7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiU3RhdGVcIl0uSURMRTtcblxuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG5cbiAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDcmVhdGUvdXBkYXRlIGEgYnVmZmVyZWQgYXJyYXkgbWF0Y2hpbmcgdGhlIGludGVyZmFjZSB1c2VkIGJ5IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm9cbiAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXZlIGJlZW4gYnVmZmVyZWRcblxuXG4gICAgdmFyIHRpbWVSYW5nZTtcbiAgICB2YXIgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICB0aW1lUmFuZ2UgPSBidWZmZXJlZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcblxuICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgIHRpbWVSYW5nZS5lbmQgPSBmcmFnRW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiBmcmFnU3RhcnQsXG4gICAgICAgIGVuZDogZnJhZ0VuZFxuICAgICAgfTtcbiAgICAgIGJ1ZmZlcmVkLnB1c2godGltZVJhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgX3JlZikge1xuICAgIHZhciBtZWRpYSA9IF9yZWYubWVkaWE7XG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMuc3RhdGUgPSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiU3RhdGVcIl0uSURMRTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XG4gICAgdGhpcy5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIF90aGlzMi50cmFja3NCdWZmZXJlZFtsZXZlbC5pZF0gPSBbXTtcbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlN0YXRlXCJdLlNUT1BQRUQ7XG4gIH0gLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICA7XG5cbiAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGZyYWdDdXJyZW50O1xuXG4gICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7IC8vIGRvbid0IGhhbmRsZSBlcnJvciBub3QgcmVsYXRlZCB0byBzdWJ0aXRsZSBmcmFnbWVudFxuXG4gICAgaWYgKCFmcmFnIHx8IGZyYWcudHlwZSAhPT0gJ3N1YnRpdGxlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgoX3RoaXMkZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50KSAhPT0gbnVsbCAmJiBfdGhpcyRmcmFnQ3VycmVudCAhPT0gdm9pZCAwICYmIF90aGlzJGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgdGhpcy5mcmFnQ3VycmVudC5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlN0YXRlXCJdLklETEU7XG4gIH0gLy8gR290IGFsbCBuZXcgc3VidGl0bGUgbGV2ZWxzLlxuICA7XG5cbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIF9yZWYyKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc3VidGl0bGVUcmFja3MgPSBfcmVmMi5zdWJ0aXRsZVRyYWNrcztcbiAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgdGhpcy5sZXZlbHMgPSBzdWJ0aXRsZVRyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgIHJldHVybiBuZXcgX3R5cGVzX2xldmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJMZXZlbFwiXShtZWRpYVBsYXlsaXN0KTtcbiAgICB9KTtcbiAgICB0aGlzLmxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgX3RoaXMzLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgIH0pO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcblxuICAgIGlmICghdGhpcy5sZXZlbHMubGVuZ3RoIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENoZWNrIGlmIHRyYWNrIGhhcyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgdG8gbG9hZCBmcmFnbWVudHNcblxuXG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMubGV2ZWxzW3RoaXMuY3VycmVudFRyYWNrSWRdO1xuXG4gICAgaWYgKGN1cnJlbnRUcmFjayAhPT0gbnVsbCAmJiBjdXJyZW50VHJhY2sgIT09IHZvaWQgMCAmJiBjdXJyZW50VHJhY2suZGV0YWlscykge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICB9IC8vIEdvdCBhIG5ldyBzZXQgb2Ygc3VidGl0bGUgZnJhZ21lbnRzLlxuICA7XG5cbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfY3VycmVudFRyYWNrJGRldGFpbHM7XG5cbiAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBkZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHZhciBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoIHx8ICFkZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG5cbiAgICBpZiAoaWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCBpZCAhPT0gY3VycmVudFRyYWNrSWQgfHwgIWN1cnJlbnRUcmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcblxuICAgIGlmIChkZXRhaWxzLmxpdmUgfHwgKF9jdXJyZW50VHJhY2skZGV0YWlscyA9IGN1cnJlbnRUcmFjay5kZXRhaWxzKSAhPT0gbnVsbCAmJiBfY3VycmVudFRyYWNrJGRldGFpbHMgIT09IHZvaWQgMCAmJiBfY3VycmVudFRyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgaWYgKGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUT0RPOiBTdWJ0aXRsZSBGcmFnbWVudHMgc2hvdWxkIGJlIGFzc2lnbmVkIHN0YXJ0UFRTIGFuZCBlbmRQVFMgb25jZSBWVFQvVFRNTCBpcyBwYXJzZWRcbiAgICAgIC8vICBvdGhlcndpc2UgdGhpcyBkZXBlbmRzIG9uIERJU0NPTlRJTlVJVFkgb3IgUFJPR1JBTS1EQVRFLVRJTUUgdGFncyB0byBhbGlnbiBwbGF5bGlzdHNcblxuXG4gICAgICB0aGlzLmFsaWduUGxheWxpc3RzKGRldGFpbHMsIGN1cnJlbnRUcmFjay5kZXRhaWxzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBpZDtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICB9O1xuXG4gIF9wcm90by5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWREYXRhLmZyYWcsXG4gICAgICAgIHBheWxvYWQgPSBmcmFnTG9hZGVkRGF0YS5wYXlsb2FkO1xuICAgIHZhciBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG5cblxuICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuYnl0ZUxlbmd0aCA+IDAgJiYgZGVjcnlwdERhdGEgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIGRlY3J5cHQgdGhlIHN1YnRpdGxlc1xuXG4gICAgICB0aGlzLmRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkZSQUdfREVDUllQVEVELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZG9UaWNrID0gZnVuY3Rpb24gZG9UaWNrKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IF9iYXNlX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJTdGF0ZVwiXS5JRExFO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiU3RhdGVcIl0uSURMRSkge1xuICAgICAgdmFyIF9mb3VuZEZyYWc7XG5cbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBjdXJyZW50VHJhY2tJZCA9IHRoaXMuY3VycmVudFRyYWNrSWQsXG4gICAgICAgICAgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIsXG4gICAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgICBpZiAoIWxldmVscy5sZW5ndGggfHwgIWxldmVsc1tjdXJyZW50VHJhY2tJZF0gfHwgIWxldmVsc1tjdXJyZW50VHJhY2tJZF0uZGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhCdWZmZXJIb2xlID0gY29uZmlnLm1heEJ1ZmZlckhvbGUsXG4gICAgICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgdmFyIG1heENvbmZpZ0J1ZmZlciA9IE1hdGgubWluKGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IF91dGlsc19idWZmZXJfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJCdWZmZXJIZWxwZXJcIl0uYnVmZmVyZWRJbmZvKHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzLCBtZWRpYS5jdXJyZW50VGltZSwgbWF4QnVmZmVySG9sZSk7XG4gICAgICB2YXIgdGFyZ2V0QnVmZmVyVGltZSA9IGJ1ZmZlcmVkSW5mby5lbmQsXG4gICAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyZWRJbmZvLmxlbjtcblxuICAgICAgaWYgKGJ1ZmZlckxlbiA+IG1heENvbmZpZ0J1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFja0RldGFpbHMgPSBsZXZlbHNbY3VycmVudFRyYWNrSWRdLmRldGFpbHM7XG4gICAgICBjb25zb2xlLmFzc2VydCh0cmFja0RldGFpbHMsICdTdWJ0aXRsZSB0cmFjayBkZXRhaWxzIGFyZSBkZWZpbmVkIG9uIGlkbGUgc3VidGl0bGUgc3RyZWFtIGNvbnRyb2xsZXIgdGljaycpO1xuICAgICAgdmFyIGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICB2YXIgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZW5kID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXS5zdGFydCArIGZyYWdtZW50c1tmcmFnTGVuIC0gMV0uZHVyYXRpb247XG4gICAgICB2YXIgZm91bmRGcmFnO1xuICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuXG4gICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA8IGVuZCkge1xuICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIHRyYWNrRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBPYmplY3QoX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImZpbmRGcmFnbWVudEJ5UERUXCJdKShmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZEZyYWcpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBPYmplY3QoX2ZyYWdtZW50X2ZpbmRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImZpbmRGcmFnbWVudEJ5UFRTXCJdKShmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgdGFyZ2V0QnVmZmVyVGltZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGlmICgoX2ZvdW5kRnJhZyA9IGZvdW5kRnJhZykgIT09IG51bGwgJiYgX2ZvdW5kRnJhZyAhPT0gdm9pZCAwICYmIF9mb3VuZEZyYWcuZW5jcnlwdGVkKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImxvZ2dlclwiXS5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmb3VuZEZyYWcuc24pO1xuICAgICAgICB0aGlzLnN0YXRlID0gX2Jhc2Vfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcIlN0YXRlXCJdLktFWV9MT0FESU5HO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5LRVlfTE9BRElORywge1xuICAgICAgICAgIGZyYWc6IGZvdW5kRnJhZ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRGcmFnICYmIGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmb3VuZEZyYWcpID09PSBfZnJhZ21lbnRfdHJhY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiRnJhZ21lbnRTdGF0ZVwiXS5OT1RfTE9BREVEKSB7XG4gICAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZvdW5kRnJhZywgdHJhY2tEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRGcmFnbWVudCA9IGZ1bmN0aW9uIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbERldGFpbHMsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcblxuICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgbGV2ZWxEZXRhaWxzLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfTtcblxuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG5cbiAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICBrZXk6IFwibWVkaWFCdWZmZXJUaW1lUmFuZ2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xufShfYmFzZV9zdHJlYW1fY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci9zdWJ0aXRsZS10cmFjay1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdGV4dHRyYWNrX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90ZXh0dHJhY2stdXRpbHMgKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2Jhc2UtcGxheWxpc3QtY29udHJvbGxlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90eXBlcy9sb2FkZXIgKi8gXCIuL3NyYy90eXBlcy9sb2FkZXIudHNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5cblxuXG5cblxudmFyIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG5cbiAgLy8gRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVBsYXlsaXN0Q29udHJvbGwuY2FsbCh0aGlzLCBobHMsICdbc3VidGl0bGUtdHJhY2stY29udHJvbGxlcl0nKSB8fCB0aGlzO1xuICAgIF90aGlzLm1lZGlhID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICBfdGhpcy5ncm91cElkID0gbnVsbDtcbiAgICBfdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgIF90aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgX3RoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG5cbiAgICBfdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9IGZhbHNlO1xuICAgIF90aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgX3RoaXMuc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcblxuICAgIF90aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcblxuICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfSAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICA7XG5cbiAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSkge1xuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIH1cblxuICAgIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyA9ICEodGhpcy5tZWRpYS50ZXh0VHJhY2tzICYmICdvbmNoYW5nZScgaW4gdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcblxuICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnRyYWNrQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICAgIH0sIDUwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnRyYWNrQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy50cmFja0NoYW5nZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTsgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuXG4gICAgdGV4dFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKHRyYWNrKTtcbiAgICB9KTsgLy8gRGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzIGJlZm9yZSBkZXRhY2htZW50IHNvIHdoZW4gcmVhdHRhY2hlZCBvbmx5IHRyYWNrcyBpbiB0aGF0IGNvbnRlbnQgYXJlIGVuYWJsZWQuXG5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICB9IC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgO1xuXG4gIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB2YXIgdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NJbkdyb3VwW3RyYWNrSWRdO1xuXG4gICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgIHRoaXMud2FybihcIkludmFsaWQgc3VidGl0bGUgdHJhY2sgaWQgXCIgKyBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1ckRldGFpbHMgPSBjdXJyZW50VHJhY2suZGV0YWlscztcbiAgICBjdXJyZW50VHJhY2suZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB0aGlzLmxvZyhcInN1YnRpdGxlIHRyYWNrIFwiICsgaWQgKyBcIiBsb2FkZWQgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdXCIpO1xuXG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2RhdGEubGV2ZWxdO1xuXG4gICAgaWYgKCEobGV2ZWxJbmZvICE9PSBudWxsICYmIGxldmVsSW5mbyAhPT0gdm9pZCAwICYmIGxldmVsSW5mby50ZXh0R3JvdXBJZHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRHcm91cElkID0gbGV2ZWxJbmZvLnRleHRHcm91cElkc1tsZXZlbEluZm8udXJsSWRdO1xuXG4gICAgaWYgKHRoaXMuZ3JvdXBJZCAhPT0gdGV4dEdyb3VwSWQpIHtcbiAgICAgIHZhciBsYXN0VHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXAgPyB0aGlzLnRyYWNrc0luR3JvdXBbdGhpcy50cmFja0lkXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpbml0aWFsVHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLm5hbWUpIHx8IHRoaXMuZmluZFRyYWNrSWQoKTtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IHRoaXMudHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuICF0ZXh0R3JvdXBJZCB8fCB0cmFjay5ncm91cElkID09PSB0ZXh0R3JvdXBJZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncm91cElkID0gdGV4dEdyb3VwSWQ7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBzdWJ0aXRsZVRyYWNrcztcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgIHN1YnRpdGxlVHJhY2tzOiBzdWJ0aXRsZVRyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKFwiVXBkYXRpbmcgc3VidGl0bGUgdHJhY2tzLCBcIiArIHN1YnRpdGxlVHJhY2tzLmxlbmd0aCArIFwiIHRyYWNrKHMpIGZvdW5kIGluIFxcXCJcIiArIHRleHRHcm91cElkICsgXCJcXFwiIGdyb3VwLWlkXCIpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG5cbiAgICAgIGlmIChpbml0aWFsVHJhY2tJZCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKGluaXRpYWxUcmFja0lkLCBsYXN0VHJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmluZFRyYWNrSWQgPSBmdW5jdGlvbiBmaW5kVHJhY2tJZChuYW1lKSB7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gYXVkaW9UcmFja3NbaV07XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgfHwgdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gdHJhY2submFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmFjay5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLm9uRXJyb3IuY2FsbCh0aGlzLCBldmVudCwgZGF0YSk7XG5cbiAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmIGRhdGEuY29udGV4dC5ncm91cElkID09PSB0aGlzLmdyb3VwSWQpIHtcbiAgICAgIHRoaXMucmV0cnlMb2FkaW5nT3JGYWlsKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICA7XG5cbiAgX3Byb3RvLmxvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZFRyYWNrKGN1cnJlbnRUcmFjaykpIHtcbiAgICAgIHZhciBpZCA9IGN1cnJlbnRUcmFjay5pZDtcbiAgICAgIHZhciBncm91cElkID0gY3VycmVudFRyYWNrLmdyb3VwSWQ7XG4gICAgICB2YXIgdXJsID0gY3VycmVudFRyYWNrLnVybDtcblxuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIHN1YnRpdGxlIHBsYXlsaXN0IGZvciBpZCBcIiArIGlkKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9nZ2xlVHJhY2tNb2RlcyA9IGZ1bmN0aW9uIHRvZ2dsZVRyYWNrTW9kZXMobmV3SWQpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHN1YnRpdGxlRGlzcGxheSA9IHRoaXMuc3VidGl0bGVEaXNwbGF5LFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdmFyIGdyb3VwVHJhY2tzID0gdGV4dFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2suZ3JvdXBJZCA9PT0gX3RoaXMzLmdyb3VwSWQ7XG4gICAgfSk7XG5cbiAgICBpZiAobmV3SWQgPT09IC0xKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRUcmFjayA9IGdyb3VwVHJhY2tzW3RyYWNrSWRdO1xuXG4gICAgICBpZiAob2xkVHJhY2spIHtcbiAgICAgICAgb2xkVHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRUcmFjayA9IGdyb3VwVHJhY2tzW25ld0lkXTtcblxuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIG5leHRUcmFjay5tb2RlID0gc3VidGl0bGVEaXNwbGF5ID8gJ3Nob3dpbmcnIDogJ2hpZGRlbic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRTdWJ0aXRsZVRyYWNrID0gZnVuY3Rpb24gc2V0U3VidGl0bGVUcmFjayhuZXdJZCwgbGFzdFRyYWNrKSB7XG4gICAgdmFyIF90cmFja3MkbmV3SWQ7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwOyAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcbiAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxuXG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IG5ld0lkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyYWNrSWQgIT09IG5ld0lkKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRyYWNrTW9kZXMobmV3SWQpO1xuICAgIH0gLy8gZXhpdCBpZiB0cmFjayBpZCBhcyBhbHJlYWR5IHNldCBvciBpbnZhbGlkXG5cblxuICAgIGlmICh0aGlzLnRyYWNrSWQgPT09IG5ld0lkICYmIChuZXdJZCA9PT0gLTEgfHwgKF90cmFja3MkbmV3SWQgPSB0cmFja3NbbmV3SWRdKSAhPT0gbnVsbCAmJiBfdHJhY2tzJG5ld0lkICE9PSB2b2lkIDAgJiYgX3RyYWNrcyRuZXdJZC5kZXRhaWxzKSB8fCBuZXdJZCA8IC0xIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHN0b3BwaW5nIGxpdmUgcmVsb2FkaW5nIHRpbWVyIGlmIGFueVxuXG5cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB2YXIgdHJhY2sgPSB0cmFja3NbbmV3SWRdO1xuICAgIHRoaXMubG9nKFwiU3dpdGNoaW5nIHRvIHN1YnRpdGxlIHRyYWNrIFwiICsgbmV3SWQpO1xuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB2YXIgdXJsID0gdHJhY2sudXJsLFxuICAgICAgICAgIHR5cGUgPSB0cmFjay50eXBlLFxuICAgICAgICAgIGlkID0gdHJhY2suaWQ7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1cmw6IHVybFxuICAgICAgfSk7XG4gICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09PSBudWxsIHx8IGxhc3RUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3aXRjaCB0byAtMVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgIGlkOiBuZXdJZFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gb25UZXh0VHJhY2tzQ2hhbmdlZCgpIHtcbiAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgaWYgKCF0aGlzLm1lZGlhIHx8ICF0aGlzLmhscy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrSWQgPSAtMTtcbiAgICB2YXIgdHJhY2tzID0gZmlsdGVyU3VidGl0bGVUcmFja3ModGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcblxuICAgIGZvciAodmFyIGlkID0gMDsgaWQgPCB0cmFja3MubGVuZ3RoOyBpZCsrKSB7XG4gICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgIHRyYWNrSWQgPSBpZDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgdHJhY2tJZCA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIFNldHRpbmcgY3VycmVudCBzdWJ0aXRsZVRyYWNrIHdpbGwgaW52b2tlIGNvZGUuXG5cblxuICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRyYWNrSWQ7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICB9XG4gICAgLyoqIGdldCBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKSAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnRpdGxlVHJhY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gICAgfVxuICAgIC8qKiBzZWxlY3QgYSBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKiovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0lkKSB7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgdmFyIGxhc3RUcmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cCA/IHRoaXMudHJhY2tzSW5Hcm91cFt0aGlzLnRyYWNrSWRdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKG5ld0lkLCBsYXN0VHJhY2spO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbn0oX2Jhc2VfcGxheWxpc3RfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSk7XG5cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgdmFyIHRyYWNrcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07IC8vIEVkZ2UgYWRkcyBhIHRyYWNrIHdpdGhvdXQgYSBsYWJlbDsgd2UgZG9uJ3Qgd2FudCB0byB1c2UgaXRcblxuICAgIGlmICh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYWNrcztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbnRyb2xsZXIvdGltZWxpbmUtY29udHJvbGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBUaW1lbGluZUNvbnRyb2xsZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGltZWxpbmVDb250cm9sbGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGltZWxpbmVDb250cm9sbGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY2VhXzYwOF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NlYS02MDgtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvY2VhLTYwOC1wYXJzZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL291dHB1dC1maWx0ZXIgKi8gXCIuL3NyYy91dGlscy9vdXRwdXQtZmlsdGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc193ZWJ2dHRfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy93ZWJ2dHQtcGFyc2VyICovIFwiLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzICovIFwiLi9zcmMvdXRpbHMvdGV4dHRyYWNrLXV0aWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvaW1zYzEtdHRtbC1wYXJzZXIgKi8gXCIuL3NyYy91dGlscy9pbXNjMS10dG1sLXBhcnNlci50c1wiKTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBUaW1lbGluZUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaW1lbGluZUNvbnRyb2xsZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLkN1ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB0aGlzLnRpbWVzY2FsZSA9IFtdO1xuICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gdm9pZCAwO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dFRyYWNrMToge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrMzoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlXG4gICAgICB9LFxuICAgICAgdGV4dFRyYWNrNDoge1xuICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWwsXG4gICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucykge1xuICAgICAgdmFyIGNoYW5uZWwxID0gbmV3IF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMsICd0ZXh0VHJhY2sxJyk7XG4gICAgICB2YXIgY2hhbm5lbDIgPSBuZXcgX3V0aWxzX291dHB1dF9maWx0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcywgJ3RleHRUcmFjazInKTtcbiAgICAgIHZhciBjaGFubmVsMyA9IG5ldyBfdXRpbHNfb3V0cHV0X2ZpbHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh0aGlzLCAndGV4dFRyYWNrMycpO1xuICAgICAgdmFyIGNoYW5uZWw0ID0gbmV3IF91dGlsc19vdXRwdXRfZmlsdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKHRoaXMsICd0ZXh0VHJhY2s0Jyk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSBuZXcgX3V0aWxzX2NlYV82MDhfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKDEsIGNoYW5uZWwxLCBjaGFubmVsMik7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSBuZXcgX3V0aWxzX2NlYV82MDhfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKDMsIGNoYW5uZWwzLCBjaGFubmVsNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUaW1lbGluZUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkZEN1ZXMgPSBmdW5jdGlvbiBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIHZhciBtZXJnZWQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSBjdWVSYW5nZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB2YXIgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICB2YXIgb3ZlcmxhcCA9IGludGVyc2VjdGlvbihjdWVSYW5nZVswXSwgY3VlUmFuZ2VbMV0sIHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG92ZXJsYXAgLyAoZW5kVGltZSAtIHN0YXJ0VGltZSkgPiAwLjUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnY2FwdGlvbnMnLFxuICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIDtcblxuICBfcHJvdG8ub25Jbml0UHRzRm91bmQgPSBmdW5jdGlvbiBvbkluaXRQdHNGb3VuZChldmVudCwgX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZnJhZyA9IF9yZWYuZnJhZyxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBpbml0UFRTID0gX3JlZi5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUgPSBfcmVmLnRpbWVzY2FsZTtcbiAgICB2YXIgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcblxuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSBpbml0UFRTO1xuICAgICAgdGhpcy50aW1lc2NhbGVbZnJhZy5jY10gPSB0aW1lc2NhbGU7XG4gICAgfSAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuXG5cbiAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdO1xuICAgICAgdW5wYXJzZWRWdHRGcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIF90aGlzLm9uRnJhZ0xvYWRlZChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRFeGlzdGluZ1RyYWNrID0gZnVuY3Rpb24gZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG5cbiAgICAgICAgaWYgKHRleHRUcmFja1t0cmFja05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVDYXB0aW9uc1RyYWNrID0gZnVuY3Rpb24gY3JlYXRlQ2FwdGlvbnNUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICB0aGlzLmNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZU5hdGl2ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYXB0aW9uc1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllcyxcbiAgICAgICAgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgdmFyIF9jYXB0aW9uc1Byb3BlcnRpZXMkdCA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdLFxuICAgICAgICBsYWJlbCA9IF9jYXB0aW9uc1Byb3BlcnRpZXMkdC5sYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlID0gX2NhcHRpb25zUHJvcGVydGllcyR0Lmxhbmd1YWdlQ29kZTsgLy8gRW5hYmxlIHJldXNlIG9mIGV4aXN0aW5nIHRleHQgdHJhY2suXG5cbiAgICB2YXIgZXhpc3RpbmdUcmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdUcmFjayh0cmFja05hbWUpO1xuXG4gICAgaWYgKCFleGlzdGluZ1RyYWNrKSB7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5jcmVhdGVUZXh0VHJhY2soJ2NhcHRpb25zJywgbGFiZWwsIGxhbmd1YWdlQ29kZSk7XG5cbiAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IGV4aXN0aW5nVHJhY2s7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wic2VuZEFkZFRyYWNrRXZlbnRcIl0pKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIG1lZGlhKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZU5vbk5hdGl2ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcblxuXG4gICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzW3RyYWNrTmFtZV07XG5cbiAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYWJlbCA9IHRyYWNrUHJvcGVydGllcy5sYWJlbDtcbiAgICB2YXIgdHJhY2sgPSB7XG4gICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICBjbG9zZWRDYXB0aW9uczogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhXG4gICAgfTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5OT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5ELCB7XG4gICAgICB0cmFja3M6IFt0cmFja11cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVkaWEuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9O1xuXG4gIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgdGhpcy5fY2xlYW5UcmFja3MoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdmFyIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcztcbiAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICBPYmplY3QoX3V0aWxzX3RleHR0cmFja191dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiY2xlYXJDdXJyZW50Q3Vlc1wiXSkoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSk7XG4gICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICB9KTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5sYXN0U24gPSAtMTsgLy8gRGV0ZWN0IGRpc2NvbnRpbnVpdHkgaW4gZnJhZ21lbnQgcGFyc2luZ1xuXG4gICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpOyAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiBzdWJ0aXRsZSBtYW5pZmVzdHNcblxuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG5cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzIHx8IFtdO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMudGltZXNjYWxlID0gW107XG5cbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jbGVhblRyYWNrcyA9IGZ1bmN0aW9uIF9jbGVhblRyYWNrcygpIHtcbiAgICAvLyBjbGVhciBvdXRkYXRlZCBzdWJ0aXRsZXNcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcblxuICAgIGlmICh0ZXh0VHJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT2JqZWN0KF91dGlsc190ZXh0dHJhY2tfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImNsZWFyQ3VycmVudEN1ZXNcIl0pKHRleHRUcmFja3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgdmFyIHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgdmFyIGhhc0lNU0MxID0gdHJhY2tzLnNvbWUoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sudGV4dENvZGVjID09PSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIklNU0MxX0NPREVDXCJdO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCB8fCBoYXNJTVNDMSAmJiB0aGlzLmNvbmZpZy5lbmFibGVJTVNDMSkge1xuICAgICAgdmFyIHNhbWVUcmFja3MgPSB0aGlzLnRyYWNrcyAmJiB0cmFja3MgJiYgdGhpcy50cmFja3MubGVuZ3RoID09PSB0cmFja3MubGVuZ3RoO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3MgfHwgW107XG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgdmFyIGluVXNlVHJhY2tzID0gdGhpcy5tZWRpYSA/IHRoaXMubWVkaWEudGV4dFRyYWNrcyA6IFtdO1xuICAgICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5Vc2VUcmFjayA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5Vc2VUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2tzW2ldLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgICBpblVzZVRyYWNrID0gaW5Vc2VUcmFja3NbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcblxuXG4gICAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2sgPSBpblVzZVRyYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGV4dFRyYWNrKSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSBfdGhpczIuY3JlYXRlVGV4dFRyYWNrKCdzdWJ0aXRsZXMnLCB0cmFjay5uYW1lLCB0cmFjay5sYW5nKTtcblxuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgdGV4dFRyYWNrLmdyb3VwSWQgPSB0cmFjay5ncm91cElkO1xuXG4gICAgICAgICAgICBfdGhpczIudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIXNhbWVUcmFja3MgJiYgdGhpcy50cmFja3MgJiYgdGhpcy50cmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgdHJhY2tzIGZvciB0aGUgcHJvdmlkZXIgdG8gY29uc3VtZVxuICAgICAgICB2YXIgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IHRyYWNrLm5hbWUsXG4gICAgICAgICAgICBraW5kOiB0cmFjay50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBkZWZhdWx0OiB0cmFjay5kZWZhdWx0LFxuICAgICAgICAgICAgc3VidGl0bGVUcmFjazogdHJhY2tcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgIHRyYWNrczogdHJhY2tzTGlzdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjYXB0aW9uc1RyYWNrKSB7XG4gICAgICAgIHZhciBpbnN0cmVhbUlkTWF0Y2ggPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKGNhcHRpb25zVHJhY2suaW5zdHJlYW1JZCk7XG5cbiAgICAgICAgaWYgKCFpbnN0cmVhbUlkTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2tOYW1lID0gXCJ0ZXh0VHJhY2tcIiArIGluc3RyZWFtSWRNYXRjaFsxXTtcbiAgICAgICAgdmFyIHRyYWNrUHJvcGVydGllcyA9IF90aGlzMy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcblxuICAgICAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5sYWJlbCA9IGNhcHRpb25zVHJhY2submFtZTtcblxuICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgYXR0cmlidXRlXG4gICAgICAgICAgdHJhY2tQcm9wZXJ0aWVzLmxhbmd1YWdlQ29kZSA9IGNhcHRpb25zVHJhY2subGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgIHZhciBjZWE2MDhQYXJzZXIxID0gdGhpcy5jZWE2MDhQYXJzZXIxLFxuICAgICAgICBjZWE2MDhQYXJzZXIyID0gdGhpcy5jZWE2MDhQYXJzZXIyLFxuICAgICAgICBpbml0UFRTID0gdGhpcy5pbml0UFRTLFxuICAgICAgICBsYXN0U24gPSB0aGlzLmxhc3RTbixcbiAgICAgICAgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcblxuICAgIGlmIChmcmFnLnR5cGUgPT09ICdtYWluJykge1xuICAgICAgdmFyIHNuID0gZnJhZy5zbjsgLy8gaWYgdGhpcyBmcmFnIGlzbid0IGNvbnRpZ3VvdXMsIGNsZWFyIHRoZSBwYXJzZXIgc28gY3VlcyB3aXRoIGJhZCBzdGFydC9lbmQgdGltZXMgYXJlbid0IGFkZGVkIHRvIHRoZSB0ZXh0VHJhY2tcblxuICAgICAgaWYgKHNuICE9PSBsYXN0U24gKyAxKSB7XG4gICAgICAgIGlmIChjZWE2MDhQYXJzZXIxICYmIGNlYTYwOFBhcnNlcjIpIHtcbiAgICAgICAgICBjZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICAgICAgY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgfSBlbHNlIGlmIChmcmFnLnR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWQuXG4gICAgICAgIGlmICghT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGluaXRQVFNbZnJhZy5jY10pKSB7XG4gICAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuXG4gICAgICAgICAgaWYgKGluaXRQVFMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2ggdW5zdWNjZXNzZnVsbHksIG90aGVyd2lzZSB0aGUgc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXIgY291bGQgYmUgYmxvY2tlZCBmcm9tIGxvYWRpbmcgbmV3IGZyYWdzLlxuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ01pc3NpbmcgaW5pdGlhbCBzdWJ0aXRsZSBQVFMnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTsgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuXG4gICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8IGRlY3J5cHREYXRhLmtleSA9PSBudWxsIHx8IGRlY3J5cHREYXRhLm1ldGhvZCAhPT0gJ0FFUy0xMjgnKSB7XG4gICAgICAgICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIHZhciB2dHRDQ3MgPSB0aGlzLnZ0dENDcztcblxuICAgICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBwcmV2Q0M6IHRoaXMucHJldkNDLFxuICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBfdXRpbHNfaW1zYzFfdHRtbF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIklNU0MxX0NPREVDXCJdKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVZUVHMoZnJhZywgcGF5bG9hZCwgdnR0Q0NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlSU1TQzEgPSBmdW5jdGlvbiBfcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgT2JqZWN0KF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wicGFyc2VJTVNDMVwiXSkocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSwgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgIF90aGlzNC5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcblxuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBJTVNDMTogXCIgKyBlcnJvcik7XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVZUVHMgPSBmdW5jdGlvbiBfcGFyc2VWVFRzKGZyYWcsIHBheWxvYWQsIHZ0dENDcykge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIGhscyA9IHRoaXMuaGxzOyAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG5cbiAgICBPYmplY3QoX3V0aWxzX3dlYnZ0dF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInBhcnNlV2ViVlRUXCJdKShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudGltZXNjYWxlW2ZyYWcuY2NdLCB2dHRDQ3MsIGZyYWcuY2MsIGZyYWcuc3RhcnQsIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICBfdGhpczUuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG5cbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIF90aGlzNS5fZmFsbGJhY2tUb0lNU0MxKGZyYWcsIHBheWxvYWQpOyAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cblxuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKFwiRmFpbGVkIHRvIHBhcnNlIFZUVCBjdWU6IFwiICsgZXJyb3IpO1xuICAgICAgaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZmFsbGJhY2tUb0lNU0MxID0gZnVuY3Rpb24gX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgIHZhciB0cmFja1BsYXlsaXN0TWVkaWEgPSB0aGlzLnRyYWNrc1tmcmFnLmxldmVsXTtcblxuICAgIGlmICghdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYykge1xuICAgICAgT2JqZWN0KF91dGlsc19pbXNjMV90dG1sX3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wicGFyc2VJTVNDMVwiXSkocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnRpbWVzY2FsZVtmcmFnLmNjXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID0gX3V0aWxzX2ltc2MxX3R0bWxfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJJTVNDMV9DT0RFQ1wiXTtcblxuICAgICAgICBfdGhpczYuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hcHBlbmRDdWVzID0gZnVuY3Rpb24gX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMudGV4dFRyYWNrc1tmcmFnTGV2ZWxdOyAvLyBXZWJWVFRQYXJzZXIucGFyc2UgaXMgYW4gYXN5bmMgbWV0aG9kIGFuZCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgdHJhY2sgbW9kZSBpcyBzZXQgdG8gXCJkaXNhYmxlZFwiXG4gICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBCZWNhdXNlIHdlIGNoZWNrIGlmIHRoZSBtb2RlIGlzIGRpYWJsZWQsIHdlIGNhbiBmb3JjZSBjaGVjayBgY3Vlc2AgYmVsb3cuIFRoZXkgY2FuJ3QgYmUgbnVsbC5cblxuICAgICAgaWYgKHRleHRUcmFjay5tb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAgIC8vIGN1ZSBjYW4gYXBwZWFyIG1vcmUgdGhhbiBvbmNlIGluIGRpZmZlcmVudCB2dHQgZmlsZXMuXG4gICAgICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cblxuXG4gICAgICBjdWVzLmZpbHRlcihmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIHJldHVybiAhdGV4dFRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGV4dFRyYWNrLmFkZEN1ZShjdWUpO1xuXG4gICAgICAgICAgaWYgKCF0ZXh0VHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEN1ZSBpcyBmYWlsZWQgZm9yOiBcIiArIGN1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0uZGVidWcoXCJGYWlsZWQgb2NjdXJyZWQgb24gYWRkaW5nIGN1ZXM6IFwiICsgZXJyKTtcbiAgICAgICAgICB2YXIgdGV4dFRyYWNrQ3VlID0gbmV3IHNlbGYuVGV4dFRyYWNrQ3VlKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCBjdWUudGV4dCk7XG4gICAgICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgICAgIHRleHRUcmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1tmcmFnTGV2ZWxdO1xuICAgICAgdmFyIHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnc3VidGl0bGVzJyxcbiAgICAgICAgY3VlczogY3VlcyxcbiAgICAgICAgdHJhY2s6IHRyYWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRnJhZ0RlY3J5cHRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0RlY3J5cHRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuXG4gICAgaWYgKGZyYWcudHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgaWYgKCFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5pbml0UFRTW2ZyYWcuY2NdKSkge1xuICAgICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uRnJhZ0xvYWRlZChfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19MT0FERUQsIGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCgpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgfTtcblxuICBfcHJvdG8ub25GcmFnUGFyc2luZ1VzZXJkYXRhID0gZnVuY3Rpb24gb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjEsXG4gICAgICAgIGNlYTYwOFBhcnNlcjIgPSB0aGlzLmNlYTYwOFBhcnNlcjI7XG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhKGNlYTYwOFBhcnNlcjEgJiYgY2VhNjA4UGFyc2VyMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZSBldmVudCBjb250YWlucyBjYXB0aW9ucyAoZm91bmQgaW4gdGhlIGJ5dGVzIHByb3BlcnR5KSwgcHVzaCBhbGwgYnl0ZXMgaW50byB0aGUgcGFyc2VyIGltbWVkaWF0ZWx5XG4gICAgLy8gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIHRoZSBQVFMgdmFsdWVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjY0J5dGVzID0gZGF0YS5zYW1wbGVzW2ldLmJ5dGVzO1xuXG4gICAgICBpZiAoY2NCeXRlcykge1xuICAgICAgICB2YXIgY2NkYXRhcyA9IHRoaXMuZXh0cmFjdENlYTYwOERhdGEoY2NCeXRlcyk7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEuYWRkRGF0YShkYXRhLnNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzBdKTtcbiAgICAgICAgY2VhNjA4UGFyc2VyMi5hZGREYXRhKGRhdGEuc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZXh0cmFjdENlYTYwOERhdGEgPSBmdW5jdGlvbiBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICB2YXIgY291bnQgPSBieXRlQXJyYXlbMF0gJiAzMTtcbiAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgIHZhciBhY3R1YWxDQ0J5dGVzID0gW1tdLCBbXV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgIHZhciB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgdmFyIGNjYnl0ZTEgPSAweDdmICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgdmFyIGNjYnl0ZTIgPSAweDdmICYgYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgdmFyIGNjVmFsaWQgPSAoNCAmIHRtcEJ5dGUpICE9PSAwO1xuICAgICAgdmFyIGNjVHlwZSA9IDMgJiB0bXBCeXRlO1xuXG4gICAgICBpZiAoY2NieXRlMSA9PT0gMCAmJiBjY2J5dGUyID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICBpZiAoY2NUeXBlID09PSAwIHx8IGNjVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdHVhbENDQnl0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjtcbn0oKTtcblxuZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICByZXR1cm4gaW5Vc2VUcmFjayAmJiBpblVzZVRyYWNrLmxhYmVsID09PSBtYW5pZmVzdFRyYWNrLm5hbWUgJiYgIShpblVzZVRyYWNrLnRleHRUcmFjazEgfHwgaW5Vc2VUcmFjay50ZXh0VHJhY2syKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHJldHVybiBNYXRoLm1pbih4MiwgeTIpIC0gTWF0aC5tYXgoeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gbmV3VlRUQ0NzKCkge1xuICByZXR1cm4ge1xuICAgIGNjT2Zmc2V0OiAwLFxuICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAwOiB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIHByZXZDQzogLTEsXG4gICAgICBuZXc6IGZhbHNlXG4gICAgfVxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvYWVzLWNyeXB0by50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFFU0NyeXB0bzsgfSk7XG52YXIgQUVTQ3J5cHRvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUVTQ3J5cHRvKHN1YnRsZSwgaXYpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFlc0lWID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBRVNDcnlwdG8ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7XG4gICAgICBuYW1lOiAnQUVTLUNCQycsXG4gICAgICBpdjogdGhpcy5hZXNJVlxuICAgIH0sIGtleSwgZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIEFFU0NyeXB0bztcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2Flcy1kZWNyeXB0b3IudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVtb3ZlUGFkZGluZywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZW1vdmVQYWRkaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVtb3ZlUGFkZGluZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFFU0RlY3J5cHRvcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuIC8vIFBLQ1M3XG5cbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcoYXJyYXkpIHtcbiAgdmFyIG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgdmFyIHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG5cbiAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgIHJldHVybiBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzbGljZVVpbnQ4XCJdKShhcnJheSwgMCwgb3V0cHV0Qnl0ZXMgLSBwYWRkaW5nQnl0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgQUVTRGVjcnlwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUVTRGVjcnlwdG9yKCkge1xuICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildO1xuICAgIHRoaXMuaW52U3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICB0aGlzLmtleSA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICB0aGlzLmtzUm93cyA9IDA7XG4gICAgdGhpcy5rZXlTaXplID0gMDtcbiAgICB0aGlzLmtleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0VGFibGUoKTtcbiAgfSAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG5cblxuICB2YXIgX3Byb3RvID0gQUVTRGVjcnlwdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8udWludDhBcnJheVRvVWludDMyQXJyYXlfID0gZnVuY3Rpb24gdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH07XG5cbiAgX3Byb3RvLmluaXRUYWJsZSA9IGZ1bmN0aW9uIGluaXRUYWJsZSgpIHtcbiAgICB2YXIgc0JveCA9IHRoaXMuc0JveDtcbiAgICB2YXIgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICB2YXIgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgdmFyIHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgdmFyIHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgdmFyIHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgdmFyIHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIHZhciBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIHZhciBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB4aSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgdmFyIHN4ID0geGkgXiB4aSA8PCAxIF4geGkgPDwgMiBeIHhpIDw8IDMgXiB4aSA8PCA0O1xuICAgICAgc3ggPSBzeCA+Pj4gOCBeIHN4ICYgMHhmZiBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7IC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblxuICAgICAgdmFyIHgyID0gZFt4XTtcbiAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgdmFyIHg4ID0gZFt4NF07IC8vIENvbXB1dGUgc3ViL2ludlN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cbiAgICAgIHZhciB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICAgICAgc3ViTWl4MFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgc3ViTWl4MVt4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIHN1Yk1peDJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgIHN1Yk1peDNbeF0gPSB0OyAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblxuICAgICAgdCA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICBpbnZTdWJNaXgyW3N4XSA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0OyAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgIHhpIF49IGRbZFt4aV1dO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZXhwYW5kS2V5ID0gZnVuY3Rpb24gZXhwYW5kS2V5KGtleUJ1ZmZlcikge1xuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgdmFyIGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgdmFyIHNhbWVLZXkgPSB0cnVlO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGtleS5sZW5ndGggJiYgc2FtZUtleSkge1xuICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgaWYgKHNhbWVLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB2YXIga2V5U2l6ZSA9IHRoaXMua2V5U2l6ZSA9IGtleS5sZW5ndGg7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIHZhciBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICB2YXIga3NSb3c7XG4gICAgdmFyIGludktzUm93O1xuICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKTtcbiAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KGtzUm93cyk7XG4gICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgdmFyIHJjb24gPSB0aGlzLnJjb247XG4gICAgdmFyIGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIHZhciBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgIHZhciBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIHZhciBwcmV2O1xuICAgIHZhciB0O1xuXG4gICAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIHByZXYgPSBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlba3NSb3ddO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdCA9IHByZXY7XG5cbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgdCA9IHQgPDwgOCB8IHQgPj4+IDI0OyAvLyBTdWIgd29yZFxuXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTsgLy8gTWl4IFJjb25cblxuICAgICAgICB0IF49IHJjb25ba3NSb3cgLyBrZXlTaXplIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG5cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cblxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXiBpbnZTdWJNaXgxW3Nib3hbdCA+Pj4gMTYgJiAweGZmXV0gXiBpbnZTdWJNaXgyW3Nib3hbdCA+Pj4gOCAmIDB4ZmZdXSBeIGludlN1Yk1peDNbc2JveFt0ICYgMHhmZl1dO1xuICAgICAgfVxuXG4gICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPj4+IDA7XG4gICAgfVxuICB9IC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIDtcblxuICBfcHJvdG8ubmV0d29ya1RvSG9zdE9yZGVyU3dhcCA9IGZ1bmN0aW9uIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiB3b3JkIDw8IDI0IHwgKHdvcmQgJiAweGZmMDApIDw8IDggfCAod29yZCAmIDB4ZmYwMDAwKSA+PiA4IHwgd29yZCA+Pj4gMjQ7XG4gIH07XG5cbiAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYpIHtcbiAgICB2YXIgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgdmFyIGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgdmFyIGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgdmFyIGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgdmFyIGluaXRWZWN0b3IwID0gaW5pdFZlY3RvclswXTtcbiAgICB2YXIgaW5pdFZlY3RvcjEgPSBpbml0VmVjdG9yWzFdO1xuICAgIHZhciBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgdmFyIGluaXRWZWN0b3IzID0gaW5pdFZlY3RvclszXTtcbiAgICB2YXIgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIHZhciBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICB2YXIgdDAsIHQxLCB0MiwgdDM7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgIHZhciBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICB2YXIga3NSb3csIGk7XG4gICAgdmFyIHN3YXBXb3JkID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XG4gICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XG4gICAgICBrc1JvdyA9IDQ7IC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cblxuICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICB0MCA9IGludlN1Yk1peDBbczAgPj4+IDI0XSBeIGludlN1Yk1peDFbczEgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczIgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9IGludlN1Yk1peDBbczEgPj4+IDI0XSBeIGludlN1Yk1peDFbczIgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczMgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMCA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMSA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdOyAvLyBVcGRhdGUgc3RhdGVcblxuICAgICAgICBzMCA9IHQwO1xuICAgICAgICBzMSA9IHQxO1xuICAgICAgICBzMiA9IHQyO1xuICAgICAgICBzMyA9IHQzO1xuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH0gLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cblxuICAgICAgdDAgPSBpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MxID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MyID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMyAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPSBpbnZTQk9YW3MxID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MyID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MzID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMCAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAxXTtcbiAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICB0MyA9IGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczAgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczEgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MyICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAga3NSb3cgPSBrc1JvdyArIDM7IC8vIFdyaXRlXG5cbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTsgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG5cbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRJbnQzMi5idWZmZXI7XG4gIH07XG5cbiAgcmV0dXJuIEFFU0RlY3J5cHRvcjtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NyeXB0L2RlY3J5cHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY3J5cHQvZGVjcnlwdGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEZWNyeXB0ZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1jcnlwdG8gKi8gXCIuL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mYXN0X2Flc19rZXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFzdC1hZXMta2V5ICovIFwiLi9zcmMvY3J5cHQvZmFzdC1hZXMta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZXNfZGVjcnlwdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Flcy1kZWNyeXB0b3IgKi8gXCIuL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxudmFyIENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbnZhciBEZWNyeXB0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywgX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPSBfcmVmLnJlbW92ZVBLQ1M3UGFkZGluZyxcbiAgICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nID0gX3JlZiRyZW1vdmVQS0NTN1BhZGRpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyZW1vdmVQS0NTN1BhZGRpO1xuXG4gICAgdGhpcy5sb2dFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZzsgLy8gYnVpbHQgaW4gZGVjcnlwdG9yIGV4cGVjdHMgUEtDUzcgcGFkZGluZ1xuXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcblxuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIG5vLW9wICovXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IERlY3J5cHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3luYyA9IGZ1bmN0aW9uIGlzU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVM7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIGN1cnJlbnRSZXN1bHQgPSB0aGlzLmN1cnJlbnRSZXN1bHQ7XG5cbiAgICBpZiAoIWN1cnJlbnRSZXN1bHQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgcmV0dXJuIE9iamVjdChfYWVzX2RlY3J5cHRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wicmVtb3ZlUGFkZGluZ1wiXSkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRJViA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNvZnR3YXJlRGVjcnlwdCA9IGZ1bmN0aW9uIHNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgdmFyIGN1cnJlbnRJViA9IHRoaXMuY3VycmVudElWLFxuICAgICAgICBjdXJyZW50UmVzdWx0ID0gdGhpcy5jdXJyZW50UmVzdWx0LFxuICAgICAgICByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTsgLy8gVGhlIG91dHB1dCBpcyBzdGFnZ2VyZWQgZHVyaW5nIHByb2dyZXNzaXZlIHBhcnNpbmcgLSB0aGUgY3VycmVudCByZXN1bHQgaXMgY2FjaGVkLCBhbmQgZW1pdHRlZCBvbiB0aGUgbmV4dCBjYWxsXG4gICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgIC8vIHRoZSBlbmQgb24gZmx1c2goKSwgYnV0IGJ5IHRoYXQgdGltZSB3ZSBoYXZlIGFscmVhZHkgcmVjZWl2ZWQgYWxsIGJ5dGVzIGZvciB0aGUgc2VnbWVudC5cbiAgICAvLyBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBXZWJDcnlwdG9cblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9IC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG5cblxuICAgIHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldFZhbGlkQ2h1bmsoZGF0YSk7XG5cbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cblxuICAgIHZhciBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG5cbiAgICBpZiAoIXNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgX2Flc19kZWNyeXB0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IE9iamVjdChfdXRpbHNfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInNsaWNlVWludDhcIl0pKGN1cnJlbnRDaHVuaywgLTE2KS5idWZmZXI7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ud2ViQ3J5cHRvRGVjcnlwdCA9IGZ1bmN0aW9uIHdlYkNyeXB0b0RlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG5cbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBfZmFzdF9hZXNfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKHN1YnRsZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oZnVuY3Rpb24gKGFlc0tleSkge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyeXB0byA9IG5ldyBfYWVzX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzdWJ0bGUsIGl2KTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gX3RoaXMub25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbldlYkNyeXB0b0Vycm9yID0gZnVuY3Rpb24gb25XZWJDcnlwdG9FcnJvcihlcnIsIGRhdGEsIGtleSwgaXYpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignW2RlY3J5cHRlci50c106IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJOicsIGVycik7XG4gICAgdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWxpZENodW5rID0gZnVuY3Rpb24gZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgdmFyIHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcblxuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gT2JqZWN0KF91dGlsc190eXBlZF9hcnJheV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wic2xpY2VVaW50OFwiXSkoZGF0YSwgMCwgc3BsaXRQb2ludCk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCBzcGxpdFBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENodW5rO1xuICB9O1xuXG4gIF9wcm90by5sb2dPbmNlID0gZnVuY3Rpb24gbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5sb2coXCJbZGVjcnlwdGVyLnRzXTogXCIgKyBtc2cpO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jcnlwdC9mYXN0LWFlcy1rZXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRmFzdEFFU0tleTsgfSk7XG52YXIgRmFzdEFFU0tleSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZhc3RBRVNLZXkoc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGYXN0QUVTS2V5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhwYW5kS2V5ID0gZnVuY3Rpb24gZXhwYW5kS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH07XG5cbiAgcmV0dXJuIEZhc3RBRVNLZXk7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWFjZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWR0cyAqLyBcIi4vc3JjL2RlbXV4L2FkdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cblxuXG5cblxuXG52YXIgQUFDRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIGZ1bmN0aW9uIEFBQ0RlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VBdWRpb0RlbXV4ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIF90aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICBfdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIF90aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQUFDRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgX0Jhc2VBdWRpb0RlbXV4ZXIucHJvdG90eXBlLnJlc2V0SW5pdFNlZ21lbnQuY2FsbCh0aGlzLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbik7XG5cbiAgICB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgaWQ6IDAsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBpc0FBQzogdHJ1ZSxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9IC8vIFNvdXJjZSBmb3IgcHJvYmUgaW5mbyAtIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gIDtcblxuICBBQUNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgZm9yIHRoZSBBRFRTIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuXG5cbiAgICB2YXIgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldElEM0RhdGFcIl0oZGF0YSwgMCkgfHwgW107XG4gICAgdmFyIG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicHJvYmVcIl0oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJpbml0VHJhY2tDb25maWdcIl0odHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdHJhY2subWFuaWZlc3RDb2RlYyk7XG4gICAgcmV0dXJuIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJhcHBlbmRGcmFtZVwiXSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmluaXRQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gIH07XG5cbiAgcmV0dXJuIEFBQ0RlbXV4ZXI7XG59KF9iYXNlX2F1ZGlvX2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG5BQUNEZW11eGVyLm1pblByb2JlQnl0ZUxlbmd0aCA9IDk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEFBQ0RlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9hZHRzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYWR0cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGdldEF1ZGlvQ29uZmlnLCBpc0hlYWRlclBhdHRlcm4sIGdldEhlYWRlckxlbmd0aCwgZ2V0RnVsbEZyYW1lTGVuZ3RoLCBjYW5HZXRGcmFtZUxlbmd0aCwgaXNIZWFkZXIsIGNhblBhcnNlLCBwcm9iZSwgaW5pdFRyYWNrQ29uZmlnLCBnZXRGcmFtZUR1cmF0aW9uLCBwYXJzZUZyYW1lSGVhZGVyLCBhcHBlbmRGcmFtZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRBdWRpb0NvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEF1ZGlvQ29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclBhdHRlcm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hlYWRlclBhdHRlcm47IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEhlYWRlckxlbmd0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEhlYWRlckxlbmd0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0RnVsbEZyYW1lTGVuZ3RoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RnVsbEZyYW1lTGVuZ3RoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjYW5HZXRGcmFtZUxlbmd0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbkdldEZyYW1lTGVuZ3RoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjYW5QYXJzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhblBhcnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwcm9iZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByb2JlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbml0VHJhY2tDb25maWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbml0VHJhY2tDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldEZyYW1lRHVyYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRGcmFtZUR1cmF0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZUZyYW1lSGVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VGcmFtZUhlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXBwZW5kRnJhbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBlbmRGcmFtZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKipcbiAqIEFEVFMgcGFyc2VyIGhlbHBlclxuICogQGxpbmsgaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICB2YXIgYWR0c09iamVjdFR5cGU7XG4gIHZhciBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXg7XG4gIHZhciBhZHRzQ2hhbmVsQ29uZmlnO1xuICB2YXIgY29uZmlnO1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gIHZhciBhZHRzU2FtcGxlaW5nUmF0ZXMgPSBbOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LCA4MDAwLCA3MzUwXTsgLy8gYnl0ZSAyXG5cbiAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweGMwKSA+Pj4gNikgKyAxO1xuICB2YXIgYWR0c1NhbXBsZWluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcblxuICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID4gYWR0c1NhbXBsZWluZ1JhdGVzLmxlbmd0aCAtIDEpIHtcbiAgICBvYnNlcnZlci50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIHJlYXNvbjogXCJpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6XCIgKyBhZHRzU2FtcGxlaW5nSW5kZXhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhZHRzQ2hhbmVsQ29uZmlnID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyOyAvLyBieXRlIDNcblxuICBhZHRzQ2hhbmVsQ29uZmlnIHw9IChkYXRhW29mZnNldCArIDNdICYgMHhjMCkgPj4+IDY7XG4gIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIiArIGF1ZGlvQ29kZWMgKyBcIixBRFRTIGRhdGE6dHlwZTpcIiArIGFkdHNPYmplY3RUeXBlICsgXCIsc2FtcGxlaW5nSW5kZXg6XCIgKyBhZHRzU2FtcGxlaW5nSW5kZXggKyBcIltcIiArIGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdICsgXCJIel0sY2hhbm5lbENvbmZpZzpcIiArIGFkdHNDaGFuZWxDb25maWcpOyAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcblxuICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICBpZiAoYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTsgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcblxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4IC0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICAgIH0gLy8gQW5kcm9pZCA6IGFsd2F5cyB1c2UgQUFDXG5cbiAgfSBlbHNlIGlmICh1c2VyQWdlbnQuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSkge1xuICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4ID0gYWR0c1NhbXBsZWluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7IC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuXG4gICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsZWluZ0luZGV4ID49IDYpIHtcbiAgICAgIC8vIEhFLUFBQyB1c2VzIFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbikgLCBoaWdoIGZyZXF1ZW5jaWVzIGFyZSBjb25zdHJ1Y3RlZCBmcm9tIGxvdyBmcmVxdWVuY2llc1xuICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgIC8vIG11bHRpcGx5IGZyZXF1ZW5jeSBieSAyIChzZWUgdGFibGUgYmVsb3csIGVxdWl2YWxlbnQgdG8gc3Vic3RyYWN0IDMpXG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggPSBhZHRzU2FtcGxlaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGVpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEgfHwgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFuZWxDb25maWcgPT09IDEpIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG5cbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGVpbmdJbmRleCA9IGFkdHNTYW1wbGVpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuXG5cbiAgY29uZmlnWzBdID0gYWR0c09iamVjdFR5cGUgPDwgMzsgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuXG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsZWluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgY29uZmlnWzFdIHw9IChhZHRzU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3OyAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuXG4gIGNvbmZpZ1sxXSB8PSBhZHRzQ2hhbmVsQ29uZmlnIDw8IDM7XG5cbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsZWluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICAgIGNvbmZpZ1syXSA9IChhZHRzRXh0ZW5zaW9uU2FtcGxlaW5nSW5kZXggJiAweDAxKSA8PCA3OyAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG5cbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGVpbmdSYXRlc1thZHRzU2FtcGxlaW5nSW5kZXhdLFxuICAgIGNoYW5uZWxDb3VudDogYWR0c0NoYW5lbENvbmZpZyxcbiAgICBjb2RlYzogJ21wNGEuNDAuJyArIGFkdHNPYmplY3RUeXBlLFxuICAgIG1hbmlmZXN0Q29kZWM6IG1hbmlmZXN0Q29kZWNcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0XSA9PT0gMHhmZiAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZjYpID09PSAweGYwO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDEgPyA3IDogOTtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDNdICYgMHgwMykgPDwgMTEgfCBkYXRhW29mZnNldCArIDRdIDw8IDMgfCAoZGF0YVtvZmZzZXQgKyA1XSAmIDB4ZTApID4+PiA1O1xufVxuZnVuY3Rpb24gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0hlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSA8IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuZnVuY3Rpb24gcHJvYmUoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCk7XG5cbiAgICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBBRFRTIGZyYW1lIExlbmd0aFxuXG5cbiAgICB2YXIgZnJhbWVMZW5ndGggPSBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcblxuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICB2YXIgY29uZmlnID0gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYyk7XG5cbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2coXCJwYXJzZWQgY29kZWM6XCIgKyB0cmFjay5jb2RlYyArIFwiLHJhdGU6XCIgKyBjb25maWcuc2FtcGxlcmF0ZSArIFwiLG5iIGNoYW5uZWw6XCIgKyBjb25maWcuY2hhbm5lbENvdW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RnJhbWVEdXJhdGlvbihzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCwgZnJhbWVEdXJhdGlvbikge1xuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuXG4gIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTsgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuXG4gIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICBmcmFtZUxlbmd0aCAtPSBoZWFkZXJMZW5ndGg7XG5cbiAgaWYgKGZyYW1lTGVuZ3RoID4gMCAmJiBvZmZzZXQgKyBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjsgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXJMZW5ndGg6IGhlYWRlckxlbmd0aCxcbiAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgIHN0YW1wOiBzdGFtcFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICB2YXIgZnJhbWVEdXJhdGlvbiA9IGdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSk7XG4gIHZhciBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4LCBmcmFtZUR1cmF0aW9uKTtcblxuICBpZiAoaGVhZGVyKSB7XG4gICAgdmFyIHN0YW1wID0gaGVhZGVyLnN0YW1wO1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoO1xuICAgIHZhciBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDsgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofS8keyhzdGFtcC85MCkudG9GaXhlZCgwKX1gKTtcblxuICAgIHZhciBhYWNTYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgaGVhZGVyTGVuZ3RoICsgZnJhbWVMZW5ndGgpLFxuICAgICAgcHRzOiBzdGFtcCxcbiAgICAgIGR0czogc3RhbXBcbiAgICB9O1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaChhYWNTYW1wbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGU6IGFhY1NhbXBsZSxcbiAgICAgIGxlbmd0aDogZnJhbWVMZW5ndGggKyBoZWFkZXJMZW5ndGhcbiAgICB9O1xuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2Jhc2UtYXVkaW8tZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvYmFzZS1hdWRpby1kZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpbml0UFRTRm4sIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW5pdFBUU0ZuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5pdFBUU0ZuOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdW1teS1kZW11eGVkLXRyYWNrICovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy90eXBlZC1hcnJheSAqLyBcIi4vc3JjL3V0aWxzL3R5cGVkLWFycmF5LnRzXCIpO1xuXG5cblxuXG5cblxudmFyIEJhc2VBdWRpb0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQXVkaW9EZW11eGVyKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7XG4gICAgICB0eXBlOiAnaWQzJyxcbiAgICAgIGlkOiAwLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuXG4gIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7fTtcblxuICBfcHJvdG8uY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge30gLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICA7XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYXBwZW5kVWludDhBcnJheVwiXSkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGlkM0RhdGEgPSBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRJRDNEYXRhXCJdKGRhdGEsIDApO1xuICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhID8gaWQzRGF0YS5sZW5ndGggOiAwO1xuICAgIHZhciBsYXN0RGF0YUluZGV4O1xuICAgIHZhciBwdHM7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICB2YXIgdGltZXN0YW1wID0gaWQzRGF0YSA/IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFRpbWVTdGFtcFwiXShpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5mcmFtZUluZGV4ID09PSAwIHx8IHRoaXMuaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCk7XG4gICAgfSAvLyBtb3JlIGV4cHJlc3NpdmUgdGhhbiBhbHRlcm5hdGl2ZTogaWQzRGF0YT8ubGVuZ3RoXG5cblxuICAgIGlmIChpZDNEYXRhICYmIGlkM0RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgcHRzOiB0aGlzLmluaXRQVFMsXG4gICAgICAgIGR0czogdGhpcy5pbml0UFRTLFxuICAgICAgICBkYXRhOiBpZDNEYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwdHMgPSB0aGlzLmluaXRQVFM7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgcHRzID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldElEM0RhdGFcIl0oZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoICYmIGxhc3REYXRhSW5kZXggIT09IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFydGlhbERhdGEgPSBPYmplY3QoX3V0aWxzX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCBsYXN0RGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHBhcnRpYWxEYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgYXZjVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBkZWNyeXB0RGF0YSwgdGltZU9mZnNldCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJbXCIgKyB0aGlzICsgXCJdIFRoaXMgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNhbXBsZS1BRVMgZGVjcnlwdGlvblwiKSk7XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2godGltZU9mZnNldCkge1xuICAgIC8vIFBhcnNlIGNhY2hlIGluIGNhc2Ugb2YgcmVtYWluaW5nIGZyYW1lcy5cbiAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmRlbXV4KHRoaXMuY2FjaGVkRGF0YSwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgYXZjVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICByZXR1cm4gQmFzZUF1ZGlvRGVtdXhlcjtcbn0oKTtcbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xuXG5cbnZhciBpbml0UFRTRm4gPSBmdW5jdGlvbiBpbml0UFRTRm4odGltZXN0YW1wLCB0aW1lT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGltZXN0YW1wKSA/IHRpbWVzdGFtcCAqIDkwIDogdGltZU9mZnNldCAqIDkwMDAwO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmFzZUF1ZGlvRGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENodW5rQ2FjaGU7IH0pO1xudmFyIENodW5rQ2FjaGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDaHVua0NhY2hlKCkge1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaHVua0NhY2hlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2h1bmspIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGFMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBjaHVua3MgPSB0aGlzLmNodW5rcyxcbiAgICAgICAgZGF0YUxlbmd0aCA9IHRoaXMuZGF0YUxlbmd0aDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKCFjaHVua3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaHVua3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9O1xuXG4gIHJldHVybiBDaHVua0NhY2hlO1xufSgpO1xuXG5cblxuZnVuY3Rpb24gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L2R1bW15LWRlbXV4ZWQtdHJhY2sudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkdW1teVRyYWNrICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImR1bW15VHJhY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkdW1teVRyYWNrOyB9KTtcbmZ1bmN0aW9uIGR1bW15VHJhY2soKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJycsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwXG4gIH07XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2V4cC1nb2xvbWIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9leHAtZ29sb21iLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5cblxudmFyIEV4cEdvbG9tYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cEdvbG9tYihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTsgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG5cbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoOyAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG5cbiAgICB0aGlzLndvcmQgPSAwOyAvLyA6dWludFxuICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgfSAvLyAoKTp2b2lkXG5cblxuICB2YXIgX3Byb3RvID0gRXhwR29sb21iLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubG9hZFdvcmQgPSBmdW5jdGlvbiBsb2FkV29yZCgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYnl0ZXNBdmFpbGFibGUgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlO1xuICAgIHZhciBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIHZhciB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICB2YXIgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCBieXRlc0F2YWlsYWJsZSk7XG5cbiAgICBpZiAoYXZhaWxhYmxlQnl0ZXMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYnl0ZXMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTsgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9IC8vIChjb3VudDppbnQpOnZvaWRcbiAgO1xuXG4gIF9wcm90by5za2lwQml0cyA9IGZ1bmN0aW9uIHNraXBCaXRzKGNvdW50KSB7XG4gICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuXG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gc2tpcEJ5dGVzID4+IDM7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9IC8vIChzaXplOmludCk6dWludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRCaXRzID0gZnVuY3Rpb24gcmVhZEJpdHMoc2l6ZSkge1xuICAgIHZhciBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcblxuICAgIHZhciB2YWx1ID0gdGhpcy53b3JkID4+PiAzMiAtIGJpdHM7IC8vIDp1aW50XG5cbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0uZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuXG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMud29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuXG4gICAgaWYgKGJpdHMgPiAwICYmIHRoaXMuYml0c0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHZhbHUgPDwgYml0cyB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfSAvLyAoKTp1aW50XG4gIDtcblxuICBfcHJvdG8uc2tpcExaID0gZnVuY3Rpb24gc2tpcExaKCkge1xuICAgIHZhciBsZWFkaW5nWmVyb0NvdW50OyAvLyA6dWludFxuXG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmIDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfSAvLyB3ZSBleGhhdXN0ZWQgd29yZCBhbmQgc3RpbGwgaGF2ZSBub3QgZm91bmQgYSAxXG5cblxuICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICByZXR1cm4gbGVhZGluZ1plcm9Db3VudCArIHRoaXMuc2tpcExaKCk7XG4gIH0gLy8gKCk6dm9pZFxuICA7XG5cbiAgX3Byb3RvLnNraXBVRUcgPSBmdW5jdGlvbiBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9IC8vICgpOnZvaWRcbiAgO1xuXG4gIF9wcm90by5za2lwRUcgPSBmdW5jdGlvbiBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH0gLy8gKCk6dWludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRVRUcgPSBmdW5jdGlvbiByZWFkVUVHKCkge1xuICAgIHZhciBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuXG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9IC8vICgpOmludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRFRyA9IGZ1bmN0aW9uIHJlYWRFRygpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG5cbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuIDEgKyB2YWx1ID4+PiAxOyAvLyBhZGQgMSB0byBtYWtlIGl0IGV2ZW4sIGFuZCBkaXZpZGUgYnkgMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTEgKiAodmFsdSA+Pj4gMSk7IC8vIGRpdmlkZSBieSB0d28gdGhlbiBtYWtlIGl0IG5lZ2F0aXZlXG4gICAgfVxuICB9IC8vIFNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG4gIC8vIDpCb29sZWFuXG4gIDtcblxuICBfcHJvdG8ucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfSAvLyAoKTppbnRcbiAgO1xuXG4gIF9wcm90by5yZWFkVUJ5dGUgPSBmdW5jdGlvbiByZWFkVUJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH0gLy8gKCk6aW50XG4gIDtcblxuICBfcHJvdG8ucmVhZFVTaG9ydCA9IGZ1bmN0aW9uIHJlYWRVU2hvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9IC8vICgpOmludFxuICA7XG5cbiAgX3Byb3RvLnJlYWRVSW50ID0gZnVuY3Rpb24gcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAc2VlIFJlY29tbWVuZGF0aW9uIElUVS1UIEguMjY0LCBTZWN0aW9uIDcuMy4yLjEuMS4xXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgIHZhciBsYXN0U2NhbGUgPSA4O1xuICAgIHZhciBuZXh0U2NhbGUgPSA4O1xuICAgIHZhciBkZWx0YVNjYWxlO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY2FsZSA9IG5leHRTY2FsZSA9PT0gMCA/IGxhc3RTY2FsZSA6IG5leHRTY2FsZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcGFyYW0gZGF0YSB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGFuIG9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gcGFyc2VkIGZyb20gdGhlXG4gICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICogYXNzb2NpYXRlZCB2aWRlbyBmcmFtZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlYWRTUFMgPSBmdW5jdGlvbiByZWFkU1BTKCkge1xuICAgIHZhciBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwO1xuICAgIHZhciBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwO1xuICAgIHZhciBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSAwO1xuICAgIHZhciBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGU7XG4gICAgdmFyIHNjYWxpbmdMaXN0Q291bnQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpO1xuICAgIHZhciByZWFkVUVHID0gdGhpcy5yZWFkVUVHLmJpbmQodGhpcyk7XG4gICAgdmFyIHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcEVHID0gdGhpcy5za2lwRUcuYmluZCh0aGlzKTtcbiAgICB2YXIgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIHZhciBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuICAgIHJlYWRVQnl0ZSgpO1xuICAgIHZhciBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG5cbiAgICByZWFkQml0cyg1KTsgLy8gcHJvZmlsZUNvbXBhdCBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcblxuICAgIHNraXBCaXRzKDMpOyAvLyByZXNlcnZlZF96ZXJvXzNiaXRzIHUoMyksXG5cbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcblxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcblxuICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgdmFyIGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcblxuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuXG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG5cbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcblxuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gc2VxX3NjYWxpbmdfbWF0cml4X3ByZXNlbnRfZmxhZ1xuICAgICAgICBzY2FsaW5nTGlzdENvdW50ID0gY2hyb21hRm9ybWF0SWRjICE9PSAzID8gOCA6IDEyO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuXG4gICAgdmFyIHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcblxuICAgIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDApIHtcbiAgICAgIHJlYWRVRUcoKTsgLy8gbG9nMl9tYXhfcGljX29yZGVyX2NudF9sc2JfbWludXM0XG4gICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBkZWx0YV9waWNfb3JkZXJfYWx3YXlzX3plcm9fZmxhZ1xuXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG5cbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSA9IHJlYWRVRUcoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG5cbiAgICB9XG5cbiAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuXG4gICAgdmFyIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgdmFyIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgdmFyIGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcblxuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBza2lwQml0cygxKTtcbiAgICB9IC8vIG1iX2FkYXB0aXZlX2ZyYW1lX2ZpZWxkX2ZsYWdcblxuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcblxuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSBbMSwgMV07XG5cbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvSWRjID0gcmVhZFVCeXRlKCk7XG5cbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxMCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyNCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs4MCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFs2NCwgMzNdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMsIDJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpLCByZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5jZWlsKChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSxcbiAgICAgIGhlaWdodDogKDIgLSBmcmFtZU1ic09ubHlGbGFnKSAqIChwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxICsgMSkgKiAxNiAtIChmcmFtZU1ic09ubHlGbGFnID8gMiA6IDQpICogKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVhZFNsaWNlVHlwZSA9IGZ1bmN0aW9uIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpOyAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG5cbiAgICB0aGlzLnJlYWRVRUcoKTsgLy8gcmV0dXJuIHNsaWNlX3R5cGVcblxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfTtcblxuICByZXR1cm4gRXhwR29sb21iO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEV4cEdvbG9tYik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvaWQzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0hlYWRlciwgaXNGb290ZXIsIGdldElEM0RhdGEsIGNhblBhcnNlLCBnZXRUaW1lU3RhbXAsIGlzVGltZVN0YW1wRnJhbWUsIGdldElEM0ZyYW1lcywgZGVjb2RlRnJhbWUsIHV0ZjhBcnJheVRvU3RyLCB0ZXN0YWJsZXMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hlYWRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNGb290ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Zvb3RlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SUQzRGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldElEM0RhdGE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNhblBhcnNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FuUGFyc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFRpbWVTdGFtcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFRpbWVTdGFtcDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNUaW1lU3RhbXBGcmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzVGltZVN0YW1wRnJhbWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldElEM0ZyYW1lc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldElEM0ZyYW1lczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVjb2RlRnJhbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWNvZGVGcmFtZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXRmOEFycmF5VG9TdHJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1dGY4QXJyYXlUb1N0cjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidGVzdGFibGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGVzdGFibGVzOyB9KTtcbi8vIGJyZWFraW5nIHVwIHRob3NlIHR3byB0eXBlcyBpbiBvcmRlciB0byBjbGFyaWZ5IHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoZSBkZWNvZGluZyBwYXRoLlxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgaGVhZGVyIGlzIGZvdW5kXG4gKi9cbnZhciBpc0hlYWRlciA9IGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvKlxuICAgKiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjBcbiAgICogWzBdICAgICA9ICdJJ1xuICAgKiBbMV0gICAgID0gJ0QnXG4gICAqIFsyXSAgICAgPSAnMydcbiAgICogWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgKiBbNV0gICAgID0ge0ZsYWdzfVxuICAgKiBbNi05XSAgID0ge0lEMyBTaXplfVxuICAgKlxuICAgKiBBbiBJRDN2MiB0YWcgY2FuIGJlIGRldGVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgKiAgJDQ5IDQ0IDMzIHl5IHl5IHh4IHp6IHp6IHp6IHp6XG4gICAqIFdoZXJlIHl5IGlzIGxlc3MgdGhhbiAkRkYsIHh4IGlzIHRoZSAnZmxhZ3MnIGJ5dGUgYW5kIHp6IGlzIGxlc3MgdGhhbiAkODBcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDQ5ICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzMykge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGlzIGZvdW5kXG4gKi9cblxudmFyIGlzRm9vdGVyID0gZnVuY3Rpb24gaXNGb290ZXIoZGF0YSwgb2Zmc2V0KSB7XG4gIC8qXG4gICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICovXG4gIGlmIChvZmZzZXQgKyAxMCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICBpZiAoZGF0YVtvZmZzZXRdID09PSAweDMzICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NDQgJiYgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OSkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA3XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA4XSA8IDB4ODAgJiYgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9IC0gVGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKi9cblxudmFyIGdldElEM0RhdGEgPSBmdW5jdGlvbiBnZXRJRDNEYXRhKGRhdGEsIG9mZnNldCkge1xuICB2YXIgZnJvbnQgPSBvZmZzZXQ7XG4gIHZhciBsZW5ndGggPSAwO1xuXG4gIHdoaWxlIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gSUQzIGhlYWRlciBpcyAxMCBieXRlc1xuICAgIGxlbmd0aCArPSAxMDtcbiAgICB2YXIgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuXG4gICAgaWYgKGlzRm9vdGVyKGRhdGEsIG9mZnNldCArIDEwKSkge1xuICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgbGVuZ3RoICs9IDEwO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxudmFyIHJlYWRTaXplID0gZnVuY3Rpb24gcmVhZFNpemUoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG52YXIgY2FuUGFyc2UgPSBmdW5jdGlvbiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkgJiYgcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNikgKyAxMCA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn07XG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZvdW5kIGluIHRoZSBJRDMgZGF0YSBjaHVua1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKiBAcmV0dXJuIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIHRpbWVzdGFtcFxuICovXG5cbnZhciBnZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAoZGF0YSkge1xuICB2YXIgZnJhbWVzID0gZ2V0SUQzRnJhbWVzKGRhdGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICogQHBhcmFtIHtJRDMgZnJhbWV9IGZyYW1lXG4gKi9cblxudmFyIGlzVGltZVN0YW1wRnJhbWUgPSBmdW5jdGlvbiBpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSB7XG4gIHJldHVybiBmcmFtZSAmJiBmcmFtZS5rZXkgPT09ICdQUklWJyAmJiBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnO1xufTtcblxudmFyIGdldEZyYW1lRGF0YSA9IGZ1bmN0aW9uIGdldEZyYW1lRGF0YShkYXRhKSB7XG4gIC8qXG4gIEZyYW1lIElEICAgICAgICR4eCB4eCB4eCB4eCAoZm91ciBjaGFyYWN0ZXJzKVxuICBTaXplICAgICAgICAgICAkeHggeHggeHggeHhcbiAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICovXG4gIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgdmFyIHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTsgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG5cbiAgdmFyIG9mZnNldCA9IDEwO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSlcbiAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgSUQzIGZyYW1lcyBmb3VuZCBpbiBhbGwgdGhlIElEMyB0YWdzIGluIHRoZSBpZDNEYXRhXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICogQHJldHVybiB7SUQzLkZyYW1lW119IC0gQXJyYXkgb2YgSUQzIGZyYW1lIG9iamVjdHNcbiAqL1xuXG5cbnZhciBnZXRJRDNGcmFtZXMgPSBmdW5jdGlvbiBnZXRJRDNGcmFtZXMoaWQzRGF0YSkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGZyYW1lcyA9IFtdO1xuXG4gIHdoaWxlIChpc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgdmFyIHNpemUgPSByZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTsgLy8gc2tpcCBwYXN0IElEMyBoZWFkZXJcblxuICAgIG9mZnNldCArPSAxMDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTsgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuXG4gICAgd2hpbGUgKG9mZnNldCArIDggPCBlbmQpIHtcbiAgICAgIHZhciBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIHZhciBmcmFtZSA9IGRlY29kZUZyYW1lKGZyYW1lRGF0YSk7XG5cbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9IC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG5cblxuICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhbWVzO1xufTtcbnZhciBkZWNvZGVGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZUZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICByZXR1cm4gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuXG52YXIgZGVjb2RlUHJpdkZyYW1lID0gZnVuY3Rpb24gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKSB7XG4gIC8qXG4gIEZvcm1hdDogPHRleHQgc3RyaW5nPlxcMDxiaW5hcnkgZGF0YT5cbiAgKi9cbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICB2YXIgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogb3duZXIsXG4gICAgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyXG4gIH07XG59O1xuXG52YXIgZGVjb2RlVGV4dEZyYW1lID0gZnVuY3Rpb24gZGVjb2RlVGV4dEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1RYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VmFsdWV9XG4gICAgKi9cbiAgICB2YXIgaW5kZXggPSAxO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpLCB0cnVlKTtcbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIHZhciB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cblxuXG4gIHZhciB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBmcmFtZS50eXBlLFxuICAgIGRhdGE6IHRleHRcbiAgfTtcbn07XG5cbnZhciBkZWNvZGVVUkxGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZVVSTEZyYW1lKGZyYW1lKSB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gMTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICB2YXIgdmFsdWUgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgIGluZm86IGRlc2NyaXB0aW9uLFxuICAgICAgZGF0YTogdmFsdWVcbiAgICB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzAtP10gPSB7VVJMfVxuICAqL1xuXG5cbiAgdmFyIHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn07XG5cbnZhciByZWFkVGltZVN0YW1wID0gZnVuY3Rpb24gcmVhZFRpbWVTdGFtcCh0aW1lU3RhbXBGcmFtZSkge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh0aW1lU3RhbXBGcmFtZS5kYXRhKTsgLy8gdGltZXN0YW1wIGlzIDMzIGJpdCBleHByZXNzZWQgYXMgYSBiaWctZW5kaWFuIGVpZ2h0LW9jdGV0IG51bWJlcixcbiAgICAvLyB3aXRoIHRoZSB1cHBlciAzMSBiaXRzIHNldCB0byB6ZXJvLlxuXG4gICAgdmFyIHB0czMzQml0ID0gZGF0YVszXSAmIDB4MTtcbiAgICB2YXIgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgIHRpbWVzdGFtcCAvPSA0NTtcblxuICAgIGlmIChwdHMzM0JpdCkge1xuICAgICAgdGltZXN0YW1wICs9IDQ3NzIxODU4Ljg0O1xuICAgIH0gLy8gMl4zMiAvIDkwXG5cblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTsgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbi8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG5cbi8qIHV0Zi5qcyAtIFVURi04IDw9PiBVVEYtMTYgY29udmVydGlvblxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gKiBWZXJzaW9uOiAxLjBcbiAqIExhc3RNb2RpZmllZDogRGVjIDI1IDE5OTlcbiAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAqL1xuXG5cbnZhciB1dGY4QXJyYXlUb1N0ciA9IGZ1bmN0aW9uIHV0ZjhBcnJheVRvU3RyKGFycmF5LCBleGl0T25OdWxsKSB7XG4gIGlmIChleGl0T25OdWxsID09PSB2b2lkIDApIHtcbiAgICBleGl0T25OdWxsID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZGVjb2RlciA9IGdldFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKGRlY29kZXIpIHtcbiAgICB2YXIgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGFycmF5KTtcblxuICAgIGlmIChleGl0T25OdWxsKSB7XG4gICAgICAvLyBncmFiIHVwIHRvIHRoZSBmaXJzdCBudWxsXG4gICAgICB2YXIgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfSAvLyByZW1vdmUgYW55IG51bGwgY2hhcmFjdGVyc1xuXG5cbiAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGM7XG4gIHZhciBjaGFyMjtcbiAgdmFyIGNoYXIzO1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGMgPSBhcnJheVtpKytdO1xuXG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMgPj4gNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICAvLyAweHh4eHh4eFxuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDB4MWYpIDw8IDYgfCBjaGFyMiAmIDB4M2YpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG52YXIgdGVzdGFibGVzID0ge1xuICBkZWNvZGVUZXh0RnJhbWU6IGRlY29kZVRleHRGcmFtZVxufTtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVyO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXAzZGVtdXhlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jhc2VfYXVkaW9fZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iYXNlLWF1ZGlvLWRlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9iYXNlLWF1ZGlvLWRlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVtdXgvaWQzICovIFwiLi9zcmMvZGVtdXgvaWQzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXBlZ2F1ZGlvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wZWdhdWRpbyAqLyBcIi4vc3JjL2RlbXV4L21wZWdhdWRpby50c1wiKTtcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cblxuXG5cblxuXG52YXIgTVAzRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoTVAzRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuXG4gIGZ1bmN0aW9uIE1QM0RlbXV4ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlQXVkaW9EZW11eGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBNUDNEZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pIHtcbiAgICBfQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudC5jYWxsKHRoaXMsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcblxuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMCxcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIGlzQUFDOiBmYWxzZSxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9O1xuXG4gIE1QM0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG5cblxuICAgIHZhciBpZDNEYXRhID0gX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0SUQzRGF0YVwiXShkYXRhLCAwKSB8fCBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gaWQzRGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInByb2JlXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNhblBhcnNlXCJdKGRhdGEsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmluaXRQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYXBwZW5kRnJhbWVcIl0odHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5pbml0UFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBNUDNEZW11eGVyO1xufShfYmFzZV9hdWRpb19kZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuTVAzRGVtdXhlci5taW5Qcm9iZUJ5dGVMZW5ndGggPSA0O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChNUDNEZW11eGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L21wNGRlbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdW1teS1kZW11eGVkLXRyYWNrICovIFwiLi9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50c1wiKTtcbi8qKlxuICogTVA0IGRlbXV4ZXJcbiAqL1xuXG5cblxudmFyIE1QNERlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDREZW11eGVyKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1QNERlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKCkge307XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KCkge307XG5cbiAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHt9O1xuXG4gIE1QNERlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgLy8gZW5zdXJlIHdlIGZpbmQgYSBtb29mIGJveCBpbiB0aGUgZmlyc3QgMTYga0JcbiAgICByZXR1cm4gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImZpbmRCb3hcIl0pKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogTWF0aC5taW4oZGF0YS5sZW5ndGgsIDE2Mzg0KVxuICAgIH0sIFsnbW9vZiddKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by5kZW11eCA9IGZ1bmN0aW9uIGRlbXV4KGRhdGEpIHtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgdmFyIGF2Y1NhbXBsZXMgPSBkYXRhO1xuICAgIHZhciBhdmNUcmFjayA9IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIGF2Y1NhbXBsZXMgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYXBwZW5kVWludDhBcnJheVwiXSkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRlZERhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2VnbWVudFZhbGlkUmFuZ2VcIl0pKGF2Y1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICBhdmNUcmFjay5zYW1wbGVzID0gc2VnbWVudGVkRGF0YS52YWxpZCB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdmNUcmFjay5zYW1wbGVzID0gYXZjU2FtcGxlcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpLFxuICAgICAgYXZjVHJhY2s6IGF2Y1RyYWNrLFxuICAgICAgaWQzVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIHRleHRUcmFjazogT2JqZWN0KF9kdW1teV9kZW11eGVkX3RyYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkdW1teVRyYWNrXCJdKSgpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgYXZjVHJhY2sgPSBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImR1bW15VHJhY2tcIl0pKCk7XG4gICAgYXZjVHJhY2suc2FtcGxlcyA9IHRoaXMucmVtYWluZGVyRGF0YSB8fCBuZXcgVWludDhBcnJheSgpO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1ZGlvVHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKSxcbiAgICAgIGF2Y1RyYWNrOiBhdmNUcmFjayxcbiAgICAgIGlkM1RyYWNrOiBPYmplY3QoX2R1bW15X2RlbXV4ZWRfdHJhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImR1bW15VHJhY2tcIl0pKCksXG4gICAgICB0ZXh0VHJhY2s6IE9iamVjdChfZHVtbXlfZGVtdXhlZF90cmFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZHVtbXlUcmFja1wiXSkoKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb24nKSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG5cbiAgcmV0dXJuIE1QNERlbXV4ZXI7XG59KCk7XG5cbk1QNERlbXV4ZXIubWluUHJvYmVCeXRlTGVuZ3RoID0gMTAyNDtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoTVA0RGVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L21wZWdhdWRpby50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBhcHBlbmRGcmFtZSwgcGFyc2VIZWFkZXIsIGlzSGVhZGVyUGF0dGVybiwgaXNIZWFkZXIsIGNhblBhcnNlLCBwcm9iZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhcHBlbmRGcmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFwcGVuZEZyYW1lOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZUhlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlSGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0hlYWRlclBhdHRlcm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hlYWRlclBhdHRlcm47IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzSGVhZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNIZWFkZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNhblBhcnNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FuUGFyc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInByb2JlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvYmU7IH0pO1xuLyoqXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gKi9cbnZhciBjaHJvbWVWZXJzaW9uID0gbnVsbDtcbnZhciBCaXRyYXRlc01hcCA9IFszMiwgNjQsIDk2LCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMjg4LCAzMjAsIDM1MiwgMzg0LCA0MTYsIDQ0OCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzODQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MCwgMTc2LCAxOTIsIDIyNCwgMjU2LCA4LCAxNiwgMjQsIDMyLCA0MCwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjBdO1xudmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xudmFyIFNhbXBsZXNDb2VmZmljaWVudHMgPSBbLy8gTVBFRyAyLjVcblswLCAvLyBSZXNlcnZlZFxuNzIsIC8vIExheWVyM1xuMTQ0LCAvLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXSwgLy8gUmVzZXJ2ZWRcblswLCAvLyBSZXNlcnZlZFxuMCwgLy8gTGF5ZXIzXG4wLCAvLyBMYXllcjJcbjAgLy8gTGF5ZXIxXG5dLCAvLyBNUEVHIDJcblswLCAvLyBSZXNlcnZlZFxuNzIsIC8vIExheWVyM1xuMTQ0LCAvLyBMYXllcjJcbjEyIC8vIExheWVyMVxuXSwgLy8gTVBFRyAxXG5bMCwgLy8gUmVzZXJ2ZWRcbjE0NCwgLy8gTGF5ZXIzXG4xNDQsIC8vIExheWVyMlxuMTIgLy8gTGF5ZXIxXG5dXTtcbnZhciBCeXRlc0luU2xvdCA9IFswLCAvLyBSZXNlcnZlZFxuMSwgLy8gTGF5ZXIzXG4xLCAvLyBMYXllcjJcbjQgLy8gTGF5ZXIxXG5dO1xuZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG5cbiAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCAvIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgIHZhciBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wXG4gICAgfTtcbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlOiBzYW1wbGUsXG4gICAgICBsZW5ndGg6IGhlYWRlci5mcmFtZUxlbmd0aFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICB2YXIgbXBlZ1ZlcnNpb24gPSBkYXRhW29mZnNldCArIDFdID4+IDMgJiAzO1xuICB2YXIgbXBlZ0xheWVyID0gZGF0YVtvZmZzZXQgKyAxXSA+PiAxICYgMztcbiAgdmFyIGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICB2YXIgc2FtcGxlUmF0ZUluZGV4ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAyICYgMztcblxuICBpZiAobXBlZ1ZlcnNpb24gIT09IDEgJiYgYml0UmF0ZUluZGV4ICE9PSAwICYmIGJpdFJhdGVJbmRleCAhPT0gMTUgJiYgc2FtcGxlUmF0ZUluZGV4ICE9PSAzKSB7XG4gICAgdmFyIHBhZGRpbmdCaXQgPSBkYXRhW29mZnNldCArIDJdID4+IDEgJiAxO1xuICAgIHZhciBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICB2YXIgY29sdW1uSW5CaXRyYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMyAtIG1wZWdMYXllciA6IG1wZWdMYXllciA9PT0gMyA/IDMgOiA0O1xuICAgIHZhciBiaXRSYXRlID0gQml0cmF0ZXNNYXBbY29sdW1uSW5CaXRyYXRlcyAqIDE0ICsgYml0UmF0ZUluZGV4IC0gMV0gKiAxMDAwO1xuICAgIHZhciBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICB2YXIgc2FtcGxlUmF0ZSA9IFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIHNhbXBsZVJhdGVJbmRleF07XG4gICAgdmFyIGNoYW5uZWxDb3VudCA9IGNoYW5uZWxNb2RlID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcblxuICAgIHZhciBzYW1wbGVDb2VmZmljaWVudCA9IFNhbXBsZXNDb2VmZmljaWVudHNbbXBlZ1ZlcnNpb25dW21wZWdMYXllcl07XG4gICAgdmFyIGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICB2YXIgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gTWF0aC5mbG9vcihzYW1wbGVDb2VmZmljaWVudCAqIGJpdFJhdGUgLyBzYW1wbGVSYXRlICsgcGFkZGluZ0JpdCkgKiBieXRlc0luU2xvdDtcblxuICAgIGlmIChjaHJvbWVWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIHZhciByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG5cbiAgICB2YXIgbmVlZENocm9tZUZpeCA9ICEhY2hyb21lVmVyc2lvbiAmJiBjaHJvbWVWZXJzaW9uIDw9IDg3O1xuXG4gICAgaWYgKG5lZWRDaHJvbWVGaXggJiYgbXBlZ0xheWVyID09PSAyICYmIGJpdFJhdGUgPj0gMjI0MDAwICYmIGNoYW5uZWxNb2RlID09PSAwKSB7XG4gICAgICAvLyBXb3JrIGFyb3VuZCBidWcgaW4gQ2hyb21pdW0gYnkgc2V0dGluZyBjaGFubmVsTW9kZSB0byBkdWFsLWNoYW5uZWwgKDAxKSBpbnN0ZWFkIG9mIHN0ZXJlbyAoMDApXG4gICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZVJhdGU6IHNhbXBsZVJhdGUsXG4gICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudCxcbiAgICAgIGZyYW1lTGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgIHNhbXBsZXNQZXJGcmFtZTogc2FtcGxlc1BlckZyYW1lXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBoZWFkZXJTaXplID0gNDtcbiAgcmV0dXJuIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpICYmIGRhdGEubGVuZ3RoIC0gb2Zmc2V0ID49IGhlYWRlclNpemU7XG59XG5mdW5jdGlvbiBwcm9iZShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IDQ7IC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG5cbiAgICB2YXIgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG5cbiAgICBpZiAoaGVhZGVyICE9PSBudWxsICYmIGhlYWRlciAhPT0gdm9pZCAwICYmIGhlYWRlci5mcmFtZUxlbmd0aCkge1xuICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3NhbXBsZS1hZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC9zYW1wbGUtYWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jcnlwdC9kZWNyeXB0ZXIgKi8gXCIuL3NyYy9jcnlwdC9kZWNyeXB0ZXIudHNcIik7XG4vKipcbiAqIFNBTVBMRS1BRVMgZGVjcnlwdGVyXG4gKi9cblxuXG52YXIgU2FtcGxlQWVzRGVjcnlwdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2FtcGxlQWVzRGVjcnlwdGVyKG9ic2VydmVyLCBjb25maWcsIGRlY3J5cHRkYXRhLCBkaXNjYXJkRVBCKSB7XG4gICAgdGhpcy5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xuICAgIHRoaXMuZGlzY2FyZEVQQiA9IGRpc2NhcmRFUEI7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgX2NyeXB0X2RlY3J5cHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShvYnNlcnZlciwgY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2FtcGxlQWVzRGVjcnlwdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVjcnlwdEJ1ZmZlciA9IGZ1bmN0aW9uIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMuZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgdGhpcy5kZWNyeXB0ZGF0YS5pdi5idWZmZXIsIGNhbGxiYWNrKTtcbiAgfSAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICA7XG5cbiAgX3Byb3RvLmRlY3J5cHRBYWNTYW1wbGUgPSBmdW5jdGlvbiBkZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaywgc3luYykge1xuICAgIHZhciBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgdmFyIGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCwgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuICAgIHZhciBsb2NhbHRoaXMgPSB0aGlzO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlY3J5cHRBYWNTYW1wbGVzID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdC5sZW5ndGggPCAzMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmMgPSB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKTtcbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2ssIHN5bmMpO1xuXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICA7XG5cbiAgX3Byb3RvLmdldEF2Y0VuY3J5cHRlZERhdGEgPSBmdW5jdGlvbiBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgdmFyIGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBJbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUxlbik7XG4gICAgdmFyIG91dHB1dFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpbnB1dFBvcyA9IDMyOyBpbnB1dFBvcyA8PSBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KGRlY29kZWREYXRhLnN1YmFycmF5KGlucHV0UG9zLCBpbnB1dFBvcyArIDE2KSwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jcnlwdGVkRGF0YTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXZjRGVjcnlwdGVkVW5pdCA9IGZ1bmN0aW9uIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgdmFyIGlucHV0UG9zID0gMDtcblxuICAgIGZvciAodmFyIG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPD0gZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICBkZWNvZGVkRGF0YS5zZXQoZGVjcnlwdGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0QXZjU2FtcGxlID0gZnVuY3Rpb24gZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCwgc3luYykge1xuICAgIHZhciBkZWNvZGVkRGF0YSA9IHRoaXMuZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgIHZhciBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICB2YXIgbG9jYWx0aGlzID0gdGhpcztcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIsIGZ1bmN0aW9uIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICBjdXJVbml0LmRhdGEgPSBsb2NhbHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChkZWNvZGVkRGF0YSwgZGVjcnlwdGVkRGF0YSk7XG5cbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBsb2NhbHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVjcnlwdEF2Y1NhbXBsZXMgPSBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1clVuaXRzID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdHM7XG5cbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcblxuICAgICAgICBpZiAoY3VyVW5pdC5kYXRhLmxlbmd0aCA8PSA0OCB8fCBjdXJVbml0LnR5cGUgIT09IDEgJiYgY3VyVW5pdC50eXBlICE9PSA1KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3luYyA9IHRoaXMuZGVjcnlwdGVyLmlzU3luYygpO1xuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQsIHN5bmMpO1xuXG4gICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2FtcGxlQWVzRGVjcnlwdGVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFNhbXBsZUFlc0RlY3J5cHRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4ZXJJbnRlcmZhY2U7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd2Vid29ya2lmeS13ZWJwYWNrICovIFwiLi9ub2RlX21vZHVsZXMvd2Vid29ya2lmeS13ZWJwYWNrL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHdlYndvcmtpZnlfd2VicGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L3RyYW5zbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyICovIFwiLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuXG5cblxuXG5cblxuXG52YXIgTWVkaWFTb3VyY2UgPSBPYmplY3QoX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZ2V0TWVkaWFTb3VyY2VcIl0pKCkgfHwge1xuICBpc1R5cGVTdXBwb3J0ZWQ6IGZ1bmN0aW9uIGlzVHlwZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBUcmFuc211eGVySW50ZXJmYWNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNtdXhlckludGVyZmFjZShobHMsIGlkLCBvblRyYW5zbXV4Q29tcGxldGUsIG9uRmx1c2gpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgdGhpcy5wYXJ0ID0gbnVsbDtcbiAgICB0aGlzLndvcmtlciA9IHZvaWQgMDtcbiAgICB0aGlzLm9ud21zZyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gdm9pZCAwO1xuICAgIHRoaXMub25GbHVzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICB2YXIgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGV2LCBkYXRhKSB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IF90aGlzLmZyYWc7XG4gICAgICBkYXRhLmlkID0gX3RoaXMuaWQ7XG4gICAgICBobHMudHJpZ2dlcihldiwgZGF0YSk7XG4gICAgfTsgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcblxuXG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJFdmVudEVtaXR0ZXJcIl0oKTtcbiAgICB0aGlzLm9ic2VydmVyLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSB7XG4gICAgICBtcDQ6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0JyksXG4gICAgICBtcGVnOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wZWcnKSxcbiAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJylcbiAgICB9OyAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG5cbiAgICB2YXIgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcblxuICAgIGlmIChjb25maWcuZW5hYmxlV29ya2VyICYmIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKCdkZW11eGluZyBpbiB3ZWJ3b3JrZXInKTtcbiAgICAgIHZhciB3b3JrZXI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyID0gd2Vid29ya2lmeV93ZWJwYWNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18oLypyZXF1aXJlLnJlc29sdmUqLygvKiEgLi4vZGVtdXgvdHJhbnNtdXhlci13b3JrZXIudHMgKi8gXCIuL3NyYy9kZW11eC90cmFuc211eGVyLXdvcmtlci50c1wiKSk7XG4gICAgICAgIHRoaXMub253bXNnID0gdGhpcy5vbldvcmtlck1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG5cbiAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yVHlwZXNcIl0uT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgZXJyOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgKyAnICgnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8gKyAnKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IHR5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgdmVuZG9yOiB2ZW5kb3IsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybignRXJyb3IgaW4gd29ya2VyOicsIGVycik7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImxvZ2dlclwiXS5lcnJvcignRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZScpO1xuXG4gICAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlci5vYmplY3RVUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHRoaXMub2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc211eGVySW50ZXJmYWNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmtlcjtcblxuICAgIGlmICh3KSB7XG4gICAgICB3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgICAgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIsXG4gICAgICAgIHdvcmtlciA9IHRoaXMud29ya2VyO1xuICAgIHZhciB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgdmFyIGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIHZhciBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgdmFyIHRyYWNrU3dpdGNoID0gIShsYXN0RnJhZyAmJiBjaHVua01ldGEubGV2ZWwgPT09IGxhc3RGcmFnLmxldmVsKTtcbiAgICB2YXIgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIHZhciBwYXJ0RGlmZiA9IHRoaXMucGFydCA/IGNodW5rTWV0YS5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogMTtcbiAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiAoc25EaWZmID09PSAxIHx8IHNuRGlmZiA9PT0gMCAmJiBwYXJ0RGlmZiA9PT0gMSk7XG4gICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cblxuICAgIGlmIChwYXJ0ICYmIChwYXJ0RGlmZiB8fCAhY29udGlndW91cykpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBuZXcgX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIlRyYW5zbXV4U3RhdGVcIl0oZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCk7XG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgZGlzY29udGludWl0eSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLmxvZyhcIlt0cmFuc211eGVyLWludGVyZmFjZSwgXCIgKyBmcmFnLnR5cGUgKyBcIl06IFN0YXJ0aW5nIG5ldyB0cmFuc211eCBzZXNzaW9uIGZvciBzbjogXCIgKyBjaHVua01ldGEuc24gKyBcIiBwOiBcIiArIGNodW5rTWV0YS5wYXJ0ICsgXCIgbGV2ZWw6IFwiICsgY2h1bmtNZXRhLmxldmVsICsgXCIgaWQ6IFwiICsgY2h1bmtNZXRhLmlkICsgXCJcXG4gICAgICAgIGRpc2NvbnRpbnVpdHk6IFwiICsgZGlzY29udGludWl0eSArIFwiXFxuICAgICAgICB0cmFja1N3aXRjaDogXCIgKyB0cmFja1N3aXRjaCArIFwiXFxuICAgICAgICBjb250aWd1b3VzOiBcIiArIGNvbnRpZ3VvdXMgKyBcIlxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBcIiArIGFjY3VyYXRlVGltZU9mZnNldCArIFwiXFxuICAgICAgICB0aW1lT2Zmc2V0OiBcIiArIHRpbWVPZmZzZXQpO1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiVHJhbnNtdXhDb25maWdcIl0oYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQVFMpO1xuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICB0aGlzLnBhcnQgPSBwYXJ0OyAvLyBGcmFncyB3aXRoIHNuIG9mICdpbml0U2VnbWVudCcgYXJlIG5vdCB0cmFuc211eGVkXG5cbiAgICBpZiAod29ya2VyKSB7XG4gICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHZhciBfdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpO1xuXG4gICAgICBpZiAoT2JqZWN0KF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJpc1Byb21pc2VcIl0pKF90cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgX3RyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBfdGhpczIuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoX3RyYW5zbXV4UmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyLFxuICAgICAgICB3b3JrZXIgPSB0aGlzLndvcmtlcjtcblxuICAgIGlmICh3b3JrZXIpIHtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2ZsdXNoJyxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgdmFyIF90cmFuc211eFJlc3VsdDIgPSB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG5cbiAgICAgIGlmIChPYmplY3QoX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImlzUHJvbWlzZVwiXSkoX3RyYW5zbXV4UmVzdWx0MikpIHtcbiAgICAgICAgX3RyYW5zbXV4UmVzdWx0Mi50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgX3RoaXMzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChfdHJhbnNtdXhSZXN1bHQyLCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRmx1c2hSZXN1bHQgPSBmdW5jdGlvbiBoYW5kbGVGbHVzaFJlc3VsdChyZXN1bHRzLCBjaHVua01ldGEpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBfdGhpczQuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIHRoaXMub25GbHVzaChjaHVua01ldGEpO1xuICB9O1xuXG4gIF9wcm90by5vbldvcmtlck1lc3NhZ2UgPSBmdW5jdGlvbiBvbldvcmtlck1lc3NhZ2UoZXYpIHtcbiAgICB2YXIgZGF0YSA9IGV2LmRhdGE7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuXG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy53b3JrZXIub2JqZWN0VVJMKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMub25GbHVzaChkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgICBkYXRhLmRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbmZpZ3VyZVRyYW5zbXV4ZXIgPSBmdW5jdGlvbiBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZykge1xuICAgIHZhciB3b3JrZXIgPSB0aGlzLndvcmtlcixcbiAgICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcblxuICAgIGlmICh3b3JrZXIpIHtcbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2NvbmZpZ3VyZScsXG4gICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpIHtcbiAgICByZXN1bHQuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNtdXhlckludGVyZmFjZTtcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItd29ya2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RlbXV4L3RyYW5zbXV4ZXItd29ya2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4ZXJXb3JrZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF90cmFuc211eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90cmFuc211eGVyICovIFwiLi9zcmMvZGVtdXgvdHJhbnNtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGV2ZW50ZW1pdHRlcjMgKi8gXCIuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuXG5cblxuXG5mdW5jdGlvbiBUcmFuc211eGVyV29ya2VyKHNlbGYpIHtcbiAgdmFyIG9ic2VydmVyID0gbmV3IGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50RW1pdHRlclwiXSgpO1xuXG4gIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGV2LCBkYXRhKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogZXYsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH07IC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG5cblxuICBvYnNlcnZlci5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgb2JzZXJ2ZXIub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBkYXRhID0gZXYuZGF0YTtcblxuICAgIHN3aXRjaCAoZGF0YS5jbWQpIHtcbiAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04ucGFyc2UoZGF0YS5jb25maWcpO1xuICAgICAgICAgIHNlbGYudHJhbnNtdXhlciA9IG5ldyBfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcsIGRhdGEudmVuZG9yKTtcbiAgICAgICAgICBPYmplY3QoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZW5hYmxlTG9nc1wiXSkoY29uZmlnLmRlYnVnKTtcbiAgICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2NvbmZpZ3VyZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIuY29uZmlndXJlKGRhdGEuY29uZmlnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHJhbnNtdXhSZXN1bHQgPSBzZWxmLnRyYW5zbXV4ZXIucHVzaChkYXRhLmRhdGEsIGRhdGEuZGVjcnlwdGRhdGEsIGRhdGEuY2h1bmtNZXRhLCBkYXRhLnN0YXRlKTtcblxuICAgICAgICAgIGlmIChPYmplY3QoX2RlbXV4X3RyYW5zbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzUHJvbWlzZVwiXSkodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgICB0cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhLmNodW5rTWV0YTtcblxuICAgICAgICAgIHZhciBfdHJhbnNtdXhSZXN1bHQgPSBzZWxmLnRyYW5zbXV4ZXIuZmx1c2goaWQpO1xuXG4gICAgICAgICAgaWYgKE9iamVjdChfZGVtdXhfdHJhbnNtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNQcm9taXNlXCJdKShfdHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgICBfdHJhbnNtdXhSZXN1bHQudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICBoYW5kbGVGbHVzaFJlc3VsdChzZWxmLCByZXN1bHRzLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgX3RyYW5zbXV4UmVzdWx0LCBpZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpIHtcbiAgaWYgKGlzRW1wdHlSZXN1bHQodHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHRyYW5zZmVyYWJsZSA9IFtdO1xuICB2YXIgX3RyYW5zbXV4UmVzdWx0JHJlbXV4ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQsXG4gICAgICBhdWRpbyA9IF90cmFuc211eFJlc3VsdCRyZW11eC5hdWRpbyxcbiAgICAgIHZpZGVvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LnZpZGVvO1xuXG4gIGlmIChhdWRpbykge1xuICAgIGFkZFRvVHJhbnNmZXJhYmxlKHRyYW5zZmVyYWJsZSwgYXVkaW8pO1xuICB9XG5cbiAgaWYgKHZpZGVvKSB7XG4gICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCB2aWRlbyk7XG4gIH1cblxuICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgIGRhdGE6IHRyYW5zbXV4UmVzdWx0XG4gIH0sIHRyYW5zZmVyYWJsZSk7XG59IC8vIENvbnZlcnRzIGRhdGEgdG8gYSB0cmFuc2ZlcmFibGUgb2JqZWN0IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpXG4vLyBpbiBvcmRlciB0byBtaW5pbWl6ZSBtZXNzYWdlIHBhc3Npbmcgb3ZlcmhlYWRcblxuXG5mdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHRyYWNrKSB7XG4gIGlmICh0cmFjay5kYXRhMSkge1xuICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGExLmJ1ZmZlcik7XG4gIH1cblxuICBpZiAodHJhY2suZGF0YTIpIHtcbiAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMi5idWZmZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIHJlc3VsdCk7XG4gIH0pO1xuICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogJ2ZsdXNoJyxcbiAgICBkYXRhOiBjaHVua01ldGFcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlSZXN1bHQocmVtdXhSZXN1bHQpIHtcbiAgcmV0dXJuICFyZW11eFJlc3VsdC5hdWRpbyAmJiAhcmVtdXhSZXN1bHQudmlkZW8gJiYgIXJlbXV4UmVzdWx0LnRleHQgJiYgIXJlbXV4UmVzdWx0LmlkMyAmJiAhcmVtdXhSZXN1bHQuaW5pdFNlZ21lbnQ7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RyYW5zbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kZW11eC90cmFuc211eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCwgaXNQcm9taXNlLCBUcmFuc211eENvbmZpZywgVHJhbnNtdXhTdGF0ZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhbnNtdXhlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNQcm9taXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNQcm9taXNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUcmFuc211eENvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRyYW5zbXV4Q29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUcmFuc211eFN0YXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJhbnNtdXhTdGF0ZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3J5cHRfZGVjcnlwdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jcnlwdC9kZWNyeXB0ZXIgKi8gXCIuL3NyYy9jcnlwdC9kZWNyeXB0ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2FhY2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2FhY2RlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9hYWNkZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9tcDRkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9tcDRkZW11eGVyICovIFwiLi9zcmMvZGVtdXgvbXA0ZGVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfdHNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC90c2RlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC90c2RlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X21wM2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L21wM2RlbXV4ZXIgKi8gXCIuL3NyYy9kZW11eC9tcDNkZW11eGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vcmVtdXgvbXA0LXJlbXV4ZXIgKi8gXCIuL3NyYy9yZW11eC9tcDQtcmVtdXhlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVtdXhfcGFzc3Rocm91Z2hfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vcmVtdXgvcGFzc3Rocm91Z2gtcmVtdXhlciAqLyBcIi4vc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NodW5rLWNhY2hlICovIFwiLi9zcmMvZGVtdXgvY2h1bmstY2FjaGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIG5vdzsgLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG5cbnRyeSB7XG4gIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIChlcnIpIHtcbiAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcImxvZ2dlclwiXS5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBzZWxmLkRhdGUubm93O1xufVxuXG52YXIgbXV4Q29uZmlnID0gW3tcbiAgZGVtdXg6IF9kZW11eF90c2RlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sXG4gIHJlbXV4OiBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl1cbn0sIHtcbiAgZGVtdXg6IF9kZW11eF9tcDRkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLFxuICByZW11eDogX3JlbXV4X3Bhc3N0aHJvdWdoX3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl1cbn0sIHtcbiAgZGVtdXg6IF9kZW11eF9hYWNkZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLFxuICByZW11eDogX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdXG59LCB7XG4gIGRlbXV4OiBfZGVtdXhfbXAzZGVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSxcbiAgcmVtdXg6IF9yZW11eF9tcDRfcmVtdXhlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXVxufV07XG52YXIgbWluUHJvYmVCeXRlTGVuZ3RoID0gMTAyNDtcbm11eENvbmZpZy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkZW11eCA9IF9yZWYuZGVtdXg7XG4gIG1pblByb2JlQnl0ZUxlbmd0aCA9IE1hdGgubWF4KG1pblByb2JlQnl0ZUxlbmd0aCwgZGVtdXgubWluUHJvYmVCeXRlTGVuZ3RoKTtcbn0pO1xuXG52YXIgVHJhbnNtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zbXV4ZXIob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5kZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2JlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNhY2hlID0gbmV3IF9jaHVua19jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZGVmYXVsdFwiXSgpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb25maWd1cmUgPSBmdW5jdGlvbiBjb25maWd1cmUodHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG5cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIHVpbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcbiAgICAgICAgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgdHJhbnNtdXhDb25maWcgPSB0aGlzLnRyYW5zbXV4Q29uZmlnO1xuXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIGVuY3J5cHRpb25UeXBlID0gZ2V0RW5jcnlwdGlvblR5cGUodWludERhdGEsIGRlY3J5cHRkYXRhKTtcblxuICAgIGlmIChlbmNyeXB0aW9uVHlwZSA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTsgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBzeW5jaHJvbm91czsgd2ViQ3J5cHRvIGlzIG5vdFxuXG4gICAgICBpZiAoY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKSB7XG4gICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gICAgICAgIC8vIGRhdGEgaXMgaGFuZGxlZCBpbiB0aGUgZmx1c2goKSBjYWxsXG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLnNvZnR3YXJlRGVjcnlwdCh1aW50RGF0YSwgZGVjcnlwdGRhdGEua2V5LmJ1ZmZlciwgZGVjcnlwdGRhdGEuaXYuYnVmZmVyKTtcblxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IGRlY3J5cHRlci53ZWJDcnlwdG9EZWNyeXB0KHVpbnREYXRhLCBkZWNyeXB0ZGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0ZGF0YS5pdi5idWZmZXIpLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHB1c2ggaGVyZSBpcyBpbXBvcnRhbnQ7IGlmIGZsdXNoKCkgaXMgY2FsbGVkIHdoaWxlIHRoaXMgaXMgc3RpbGwgcmVzb2x2aW5nLCB0aGlzIGVuc3VyZXMgdGhhdFxuICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnB1c2goZGVjcnlwdGVkRGF0YSwgbnVsbCwgY2h1bmtNZXRhKTtcblxuICAgICAgICAgIF90aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9yZWYyID0gc3RhdGUgfHwgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGNvbnRpZ3VvdXMgPSBfcmVmMi5jb250aWd1b3VzLFxuICAgICAgICBkaXNjb250aW51aXR5ID0gX3JlZjIuZGlzY29udGludWl0eSxcbiAgICAgICAgdHJhY2tTd2l0Y2ggPSBfcmVmMi50cmFja1N3aXRjaCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gX3JlZjIuYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICB0aW1lT2Zmc2V0ID0gX3JlZjIudGltZU9mZnNldDtcblxuICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLnZpZGVvQ29kZWMsXG4gICAgICAgIGRlZmF1bHRJbml0UHRzID0gdHJhbnNtdXhDb25maWcuZGVmYXVsdEluaXRQdHMsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhbnNtdXhDb25maWcuZHVyYXRpb24sXG4gICAgICAgIGluaXRTZWdtZW50RGF0YSA9IHRyYW5zbXV4Q29uZmlnLmluaXRTZWdtZW50RGF0YTsgLy8gUmVzZXQgbXV4ZXJzIGJlZm9yZSBwcm9iaW5nIHRvIGVuc3VyZSB0aGF0IHRoZWlyIHN0YXRlIGlzIGNsZWFuLCBldmVuIGlmIGZsdXNoaW5nIG9jY3VycyBiZWZvcmUgYSBzdWNjZXNzZnVsIHByb2JlXG5cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCB0cmFja1N3aXRjaCkge1xuICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChkaXNjb250aW51aXR5KSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIH1cblxuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgaWYgKHRoaXMubmVlZHNQcm9iaW5nKHVpbnREYXRhLCBkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkpIHtcbiAgICAgIGlmIChjYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZWREYXRhID0gY2FjaGUuZmx1c2goKTtcbiAgICAgICAgdWludERhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImFwcGVuZFVpbnQ4QXJyYXlcIl0pKGNhY2hlZERhdGEsIHVpbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJGNvbmZpZ3VyZVRyYW5zbSA9IHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSwgdHJhbnNtdXhDb25maWcpO1xuXG4gICAgICBkZW11eGVyID0gX3RoaXMkY29uZmlndXJlVHJhbnNtLmRlbXV4ZXI7XG4gICAgICByZW11eGVyID0gX3RoaXMkY29uZmlndXJlVHJhbnNtLnJlbXV4ZXI7XG4gICAgfVxuXG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICBjYWNoZS5wdXNoKHVpbnREYXRhKTtcbiAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnRyYW5zbXV4KHVpbnREYXRhLCBkZWNyeXB0ZGF0YSwgZW5jcnlwdGlvblR5cGUsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjdXJyZW50U3RhdGUuY29udGlndW91cyA9IHRydWU7XG4gICAgY3VycmVudFN0YXRlLmRpc2NvbnRpbnVpdHkgPSBmYWxzZTtcbiAgICBjdXJyZW50U3RhdGUudHJhY2tTd2l0Y2ggPSBmYWxzZTtcbiAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICA7XG5cbiAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyLFxuICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgZGVjcnlwdGlvblByb21pc2UgPSB0aGlzLmRlY3J5cHRpb25Qcm9taXNlLFxuICAgICAgICBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgdmFyIHRyYW5zbXV4UmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZmx1c2goY2h1bmtNZXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBjdXJyZW50VHJhbnNtdXhTdGF0ZS5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBjdXJyZW50VHJhbnNtdXhTdGF0ZS50aW1lT2Zmc2V0O1xuXG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLmZsdXNoKCk7XG5cbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2godGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBieXRlc1NlZW4gPSBjYWNoZS5kYXRhTGVuZ3RoO1xuICAgIGNhY2hlLnJlc2V0KCk7XG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG5cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIC8vIElmIHByb2JpbmcgZmFpbGVkLCBhbmQgZWFjaCBkZW11eGVyIHNhdyBlbm91Z2ggYnl0ZXMgdG8gYmUgYWJsZSB0byBwcm9iZSwgdGhlbiBIbHMuanMgaGFzIGJlZW4gZ2l2ZW4gY29udGVudCBpdHMgbm90IGFibGUgdG8gaGFuZGxlXG4gICAgICBpZiAoYnl0ZXNTZWVuID49IG1pblByb2JlQnl0ZUxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgIHJlYXNvbjogJ25vIGRlbXV4IG1hdGNoaW5nIHdpdGggY29udGVudCBmb3VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgIHJldHVybiBbZW1wdHlSZXN1bHQoY2h1bmtNZXRhKV07XG4gICAgfVxuXG4gICAgdmFyIF9kZW11eGVyJGZsdXNoID0gZGVtdXhlci5mbHVzaCh0aW1lT2Zmc2V0KSxcbiAgICAgICAgYXVkaW9UcmFjayA9IF9kZW11eGVyJGZsdXNoLmF1ZGlvVHJhY2ssXG4gICAgICAgIGF2Y1RyYWNrID0gX2RlbXV4ZXIkZmx1c2guYXZjVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gX2RlbXV4ZXIkZmx1c2guaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eGVyJGZsdXNoLnRleHRUcmFjaztcblxuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJsb2dnZXJcIl0ubG9nKFwiW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgKGNodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHA6ICcgKyBjaHVua01ldGEucGFydCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgY2h1bmtNZXRhLmxldmVsKTtcbiAgICB2YXIgcmVtdXhSZXN1bHQgPSByZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIGF2Y1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRydWUpO1xuICAgIHRyYW5zbXV4UmVzdWx0cy5wdXNoKHtcbiAgICAgIHJlbXV4UmVzdWx0OiByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfSk7XG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0SW5pdGlhbFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cykge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmVtdXhlci5yZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcblxuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgcmVtdXhlci5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbikge1xuICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuXG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW11eGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJhbnNtdXggPSBmdW5jdGlvbiB0cmFuc211eChkYXRhLCBkZWNyeXB0RGF0YSwgZW5jcnlwdGlvblR5cGUsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChlbmNyeXB0aW9uVHlwZSA9PT0gJ1NBTVBMRS1BRVMnKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNtdXhVbmVuY3J5cHRlZCA9IGZ1bmN0aW9uIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICB2YXIgX2RlbXV4ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlKSxcbiAgICAgICAgYXVkaW9UcmFjayA9IF9kZW11eC5hdWRpb1RyYWNrLFxuICAgICAgICBhdmNUcmFjayA9IF9kZW11eC5hdmNUcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBfZGVtdXguaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eC50ZXh0VHJhY2s7XG5cbiAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgYXZjVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGE6IGNodW5rTWV0YVxuICAgIH07XG4gIH0gLy8gVE9ETzogSGFuZGxlIGZsdXNoIHdpdGggU2FtcGxlLUFFU1xuICA7XG5cbiAgX3Byb3RvLnRyYW5zbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5kZW11eGVyLmRlbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0KS50aGVuKGZ1bmN0aW9uIChkZW11eFJlc3VsdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtdXhSZXN1bHQ6IF90aGlzMy5yZW11eGVyLnJlbXV4KGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssIGRlbXV4UmVzdWx0LmF2Y1RyYWNrLCBkZW11eFJlc3VsdC5pZDNUcmFjaywgZGVtdXhSZXN1bHQudGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlKSxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbmZpZ3VyZVRyYW5zbXV4ZXIgPSBmdW5jdGlvbiBjb25maWd1cmVUcmFuc211eGVyKGRhdGEsIHRyYW5zbXV4Q29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgIHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICAgIHZlbmRvciA9IHRoaXMudmVuZG9yO1xuICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgICAgZGVmYXVsdEluaXRQdHMgPSB0cmFuc211eENvbmZpZy5kZWZhdWx0SW5pdFB0cyxcbiAgICAgICAgZHVyYXRpb24gPSB0cmFuc211eENvbmZpZy5kdXJhdGlvbixcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhID0gdHJhbnNtdXhDb25maWcuaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICB2aWRlb0NvZGVjID0gdHJhbnNtdXhDb25maWcudmlkZW9Db2RlYzsgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuXG4gICAgdmFyIG11eDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG11eCA9IG11eENvbmZpZ1tpXTtcblxuICAgICAgaWYgKG11eC5kZW11eC5wcm9iZShkYXRhKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11eCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtdXhlcjogdW5kZWZpbmVkLFxuICAgICAgICBkZW11eGVyOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcblxuXG4gICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgdmFyIFJlbXV4ZXIgPSBtdXgucmVtdXg7XG4gICAgdmFyIERlbXV4ZXIgPSBtdXguZGVtdXg7XG5cbiAgICBpZiAoIXJlbXV4ZXIgfHwgIShyZW11eGVyIGluc3RhbmNlb2YgUmVtdXhlcikpIHtcbiAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXIgPSBuZXcgUmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpO1xuICAgIH1cblxuICAgIGlmICghZGVtdXhlciB8fCAhKGRlbXV4ZXIgaW5zdGFuY2VvZiBEZW11eGVyKSkge1xuICAgICAgZGVtdXhlciA9IHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfSAvLyBFbnN1cmUgdGhhdCBtdXhlcnMgYXJlIGFsd2F5cyBpbml0aWFsaXplZCB3aXRoIGFuIGluaXRTZWdtZW50XG5cblxuICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKTtcbiAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlbXV4ZXI6IGRlbXV4ZXIsXG4gICAgICByZW11eGVyOiByZW11eGVyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ubmVlZHNQcm9iaW5nID0gZnVuY3Rpb24gbmVlZHNQcm9iaW5nKGRhdGEsIGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gIXRoaXMuZGVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWNyeXB0ZXIgPSBmdW5jdGlvbiBnZXREZWNyeXB0ZXIoKSB7XG4gICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyO1xuXG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IF9jcnlwdF9kZWNyeXB0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNyeXB0ZXI7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zbXV4ZXI7XG59KCk7XG5cblxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uVHlwZShkYXRhLCBkZWNyeXB0RGF0YSkge1xuICB2YXIgZW5jcnlwdGlvblR5cGUgPSBudWxsO1xuXG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICE9IG51bGwpIHtcbiAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhLm1ldGhvZDtcbiAgfVxuXG4gIHJldHVybiBlbmNyeXB0aW9uVHlwZTtcbn1cblxudmFyIGVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKSB7XG4gIHJldHVybiB7XG4gICAgcmVtdXhSZXN1bHQ6IHt9LFxuICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG52YXIgVHJhbnNtdXhDb25maWcgPSBmdW5jdGlvbiBUcmFuc211eENvbmZpZyhhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFB0cykge1xuICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgdGhpcy5pbml0U2VnbWVudERhdGEgPSB2b2lkIDA7XG4gIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gIHRoaXMuZGVmYXVsdEluaXRQdHMgPSB2b2lkIDA7XG4gIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cztcbn07XG52YXIgVHJhbnNtdXhTdGF0ZSA9IGZ1bmN0aW9uIFRyYW5zbXV4U3RhdGUoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCkge1xuICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gIHRoaXMuY29udGlndW91cyA9IHZvaWQgMDtcbiAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSB2b2lkIDA7XG4gIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gIHRoaXMudGltZU9mZnNldCA9IHZvaWQgMDtcbiAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgdGhpcy5hY2N1cmF0ZVRpbWVPZmZzZXQgPSBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RlbXV4L3RzZGVtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGVtdXgvdHNkZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hZHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkdHMgKi8gXCIuL3NyYy9kZW11eC9hZHRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXBlZ2F1ZGlvICovIFwiLi9zcmMvZGVtdXgvbXBlZ2F1ZGlvLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9leHAtZ29sb21iICovIFwiLi9zcmMvZGVtdXgvZXhwLWdvbG9tYi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2FtcGxlX2Flc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zYW1wbGUtYWVzICovIFwiLi9zcmMvZGVtdXgvc2FtcGxlLWFlcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKipcbiAqIGhpZ2hseSBvcHRpbWl6ZWQgVFMgZGVtdXhlcjpcbiAqIHBhcnNlIFBBVCwgUE1UXG4gKiBleHRyYWN0IFBFUyBwYWNrZXQgZnJvbSBhdWRpbyBhbmQgdmlkZW8gUElEc1xuICogZXh0cmFjdCBBVkMvSDI2NCBOQUwgdW5pdHMgYW5kIEFBQy9BRFRTIHNhbXBsZXMgZnJvbSBQRVMgcGFja2V0XG4gKiB0cmlnZ2VyIHRoZSByZW11eGVyIHVwb24gcGFyc2luZyBjb21wbGV0aW9uXG4gKiBpdCBhbHNvIHRyaWVzIHRvIHdvcmthcm91bmQgYXMgYmVzdCBhcyBpdCBjYW4gYXVkaW8gY29kZWMgc3dpdGNoIChIRS1BQUMgdG8gQUFDIGFuZCB2aWNlIHZlcnNhKSwgd2l0aG91dCBoYXZpbmcgdG8gcmVzdGFydCB0aGUgTWVkaWFTb3VyY2UuXG4gKiBpdCBhbHNvIGNvbnRyb2xzIHRoZSByZW11eGluZyBwcm9jZXNzIDpcbiAqIHVwb24gZGlzY29udGludWl0eSBvciBsZXZlbCBzd2l0Y2ggZGV0ZWN0aW9uLCBpdCB3aWxsIGFsc28gbm90aWZpZXMgdGhlIHJlbXV4ZXIgc28gdGhhdCBpdCBjYW4gcmVzZXQgaXRzIHN0YXRlLlxuICovXG5cblxuXG5cblxuXG5cblxuXG4vLyBXZSBhcmUgdXNpbmcgZml4ZWQgdHJhY2sgSURzIGZvciBkcml2aW5nIHRoZSBNUDQgcmVtdXhlclxuLy8gaW5zdGVhZCBvZiBmb2xsb3dpbmcgdGhlIFRTIFBJRHMuXG4vLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4vLyBtYXkgbm90IGxpa2UgaWYgdGhlcmUgYXJlIFRyYWNrSUQgXCJzd2l0Y2hlc1wiXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzEzMzFcbi8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbi8vIFdpdGggTVNFIGN1cnJlbnRseSBvbmUgY2FuIG9ubHkgaGF2ZSBvbmUgdHJhY2sgb2YgZWFjaCwgYW5kIHdlIGFyZSBtdXhpbmdcbi8vIHdoYXRldmVyIHZpZGVvL2F1ZGlvIHJlbmRpdGlvbiBpbiB0aGVtLlxudmFyIFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcblxudmFyIFRTRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRTRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jb250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hYWNMYXN0UFRTID0gbnVsbDtcbiAgICB0aGlzLl9pbml0UFRTID0gbnVsbDtcbiAgICB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdHh0VHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gIH1cblxuICBUU0RlbXV4ZXIucHJvYmUgPSBmdW5jdGlvbiBwcm9iZShkYXRhKSB7XG4gICAgdmFyIHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQoZGF0YSk7XG5cbiAgICBpZiAoc3luY09mZnNldCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN5bmNPZmZzZXQpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0IFwiICsgc3luY09mZnNldCArIFwiLCBqdW5rIGFoZWFkID9cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBUU0RlbXV4ZXIuX3N5bmNPZmZzZXQgPSBmdW5jdGlvbiBfc3luY09mZnNldChkYXRhKSB7XG4gICAgLy8gc2NhbiAxMDAwIGZpcnN0IGJ5dGVzXG4gICAgdmFyIHNjYW53aW5kb3cgPSBNYXRoLm1pbigxMDAwLCBkYXRhLmxlbmd0aCAtIDMgKiAxODgpO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgc2NhbndpbmRvdykge1xuICAgICAgLy8gYSBUUyBmcmFnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAzIFRTIHBhY2tldHMsIGEgUEFULCBhIFBNVCwgYW5kIG9uZSBQSUQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMHg0NyAmJiBkYXRhW2kgKyAxODhdID09PSAweDQ3ICYmIGRhdGFbaSArIDIgKiAxODhdID09PSAweDQ3KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRTRGVtdXhlcidzIGludGVybmFsIHRyYWNrIG1vZGVsXG4gICAqL1xuICA7XG5cbiAgVFNEZW11eGVyLmNyZWF0ZVRyYWNrID0gZnVuY3Rpb24gY3JlYXRlVHJhY2sodHlwZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluaXQgc2VnbWVudCBvbiB0aGUgZGVtdXhlci9yZW11eGVyIGludGVyZmFjZS4gTmVlZGVkIGZvciBkaXNjb250aW51aXRpZXMvdHJhY2stc3dpdGNoZXMgKG9yIGF0IHN0cmVhbSBzdGFydClcbiAgICogUmVzZXRzIGFsbCBpbnRlcm5hbCB0cmFjayBpbnN0YW5jZXMgb2YgdGhlIGRlbXV4ZXIuXG4gICAqL1xuICA7XG5cbiAgdmFyIF9wcm90byA9IFRTRGVtdXhlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGR1cmF0aW9uKSB7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX2F2Y1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIGR1cmF0aW9uKTtcbiAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJywgZHVyYXRpb24pO1xuICAgIHRoaXMuX3R4dFRyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd0ZXh0JywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2suaXNBQUMgPSB0cnVlOyAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG5cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuYXZjU2FtcGxlID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuXG4gIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdmFyIF9hdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgX2F2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2ssXG4gICAgICAgIF9pZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuXG4gICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICBfYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoX2F2Y1RyYWNrKSB7XG4gICAgICBfYXZjVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgX2lkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMuYWFjTGFzdFBUUyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMsIGZsdXNoKSB7XG4gICAgaWYgKGlzU2FtcGxlQWVzID09PSB2b2lkIDApIHtcbiAgICAgIGlzU2FtcGxlQWVzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZsdXNoID09PSB2b2lkIDApIHtcbiAgICAgIGZsdXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3R0O1xuICAgIHZhciBwaWQ7XG4gICAgdmFyIGF0ZjtcbiAgICB2YXIgb2Zmc2V0O1xuICAgIHZhciBwZXM7XG4gICAgdmFyIGF2Y1RyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG4gICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgIHZhciBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIHZhciBhdmNJZCA9IGF2Y1RyYWNrLnBpZDtcbiAgICB2YXIgYXZjRGF0YSA9IGF2Y1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIGF1ZGlvSWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICB2YXIgaWQzSWQgPSBpZDNUcmFjay5waWQ7XG4gICAgdmFyIGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICB2YXIgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIHVua25vd25QSURzID0gZmFsc2U7XG4gICAgdmFyIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgIHZhciBwbXRJZCA9IHRoaXMuX3BtdElkO1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLnJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiYXBwZW5kVWludDhBcnJheVwiXSkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobGVuIDwgMTg4ICYmICFmbHVzaCkge1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvVHJhY2s6IGF1ZGlvVHJhY2ssXG4gICAgICAgIGF2Y1RyYWNrOiBhdmNUcmFjayxcbiAgICAgICAgaWQzVHJhY2s6IGlkM1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLl9zeW5jT2Zmc2V0KGRhdGEpKTtcbiAgICBsZW4gLT0gKGxlbiArIHN5bmNPZmZzZXQpICUgMTg4O1xuXG4gICAgaWYgKGxlbiA8IGRhdGEuYnl0ZUxlbmd0aCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBsZW4sIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW4pO1xuICAgIH0gLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcblxuXG4gICAgZm9yIChzdGFydCA9IHN5bmNPZmZzZXQ7IHN0YXJ0IDwgbGVuOyBzdGFydCArPSAxODgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTsgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuXG4gICAgICAgIHBpZCA9ICgoZGF0YVtzdGFydCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW3N0YXJ0ICsgMl07XG4gICAgICAgIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0OyAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cblxuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTsgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG5cbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIDE4OCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAocGlkKSB7XG4gICAgICAgICAgY2FzZSBhdmNJZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF2Y0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF2Y0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQVZDUEVTKHBlcywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYXZjRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdmNEYXRhKSB7XG4gICAgICAgICAgICAgIGF2Y0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICBhdmNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBhdWRpb0lkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFBQ1BFUyhwZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZU1QRUdQRVMocGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdWRpb0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5kYXRhLnB1c2goZGF0YS5zdWJhcnJheShvZmZzZXQsIHN0YXJ0ICsgMTg4KSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgMTg4IC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgaWQzSWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlEM1BFUyhwZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIDE4OCkpO1xuICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyAxODggLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgcG10SWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZGF0YVtvZmZzZXRdICsgMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwYXJzZWRQSURzID0gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZyA9PT0gdHJ1ZSB8fCB0aGlzLnR5cGVTdXBwb3J0ZWQubXAzID09PSB0cnVlLCBpc1NhbXBsZUFlcyk7IC8vIG9ubHkgdXBkYXRlIHRyYWNrIGlkIGlmIHRyYWNrIFBJRCBmb3VuZCB3aGlsZSBwYXJzaW5nIFBNVFxuICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgICAgLy8gdHJhY2sgUElEIHRyYW5zaWVudGx5IGRpc2FwcGVhcnMgZnJvbSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGluIGNhc2Ugb2YgdHJhbnNpZW50IG1pc3NpbmcgYXVkaW8gc2FtcGxlcyBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgdXNpbmcgdGhpcyBmb3IgTVA0IHRyYWNrIElEcy5cblxuICAgICAgICAgICAgICBhdmNJZCA9IHBhcnNlZFBJRHMuYXZjO1xuXG4gICAgICAgICAgICAgIGlmIChhdmNJZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdmNUcmFjay5waWQgPSBhdmNJZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF1ZGlvSWQgPSBwYXJzZWRQSURzLmF1ZGlvO1xuXG4gICAgICAgICAgICAgIGlmIChhdWRpb0lkID4gMCkge1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2sucGlkID0gYXVkaW9JZDtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLmlzQUFDID0gcGFyc2VkUElEcy5pc0FBQztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlkM0lkID0gcGFyc2VkUElEcy5pZDM7XG5cbiAgICAgICAgICAgICAgaWYgKGlkM0lkID4gMCkge1xuICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM0lkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSURzICYmICFwbXRQYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKCdyZXBhcnNlIGZyb20gYmVnaW5uaW5nJyk7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRHMgPSBmYWxzZTsgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzeW5jT2Zmc2V0IC0gMTg4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJFcnJvckRldGFpbHNcIl0uRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246ICdUUyBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIDB4NDcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBhdmNEYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgIGF2Y1RyYWNrOiBhdmNUcmFjayxcbiAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2tcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciByZW1haW5kZXJEYXRhID0gdGhpcy5yZW1haW5kZXJEYXRhO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmRlbXV4KHJlbWFpbmRlckRhdGEsIC0xLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgYXZjVHJhY2s6IHRoaXMuX2F2Y1RyYWNrLFxuICAgICAgICB0ZXh0VHJhY2s6IHRoaXMuX3R4dFRyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2tcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzID0gZnVuY3Rpb24gZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpIHtcbiAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgIGF2Y1RyYWNrID0gZGVtdXhSZXN1bHQuYXZjVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2s7XG4gICAgdmFyIGF2Y0RhdGEgPSBhdmNUcmFjay5wZXNEYXRhO1xuICAgIHZhciBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhOyAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuXG4gICAgdmFyIHBlcztcblxuICAgIGlmIChhdmNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdmNEYXRhKSkpIHtcbiAgICAgIHRoaXMuX3BhcnNlQVZDUEVTKHBlcywgdHJ1ZSk7XG5cbiAgICAgIGF2Y1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBhdmNUcmFjay5wZXNEYXRhID0gYXZjRGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyhhdWRpb0RhdGEpKSkge1xuICAgICAgaWYgKGF1ZGlvVHJhY2suaXNBQUMpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VBQUNQRVMocGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTVBFR1BFUyhwZXMpO1xuICAgICAgfVxuXG4gICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXVkaW9EYXRhICE9PSBudWxsICYmIGF1ZGlvRGF0YSAhPT0gdm9pZCAwICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ2xhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHMnKTtcbiAgICAgIH0gLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG5cblxuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHRoaXMuX3BhcnNlSUQzUEVTKHBlcyk7XG5cbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCB0cnVlKTtcbiAgICB2YXIgc2FtcGxlQWVzID0gdGhpcy5zYW1wbGVBZXMgPSBuZXcgX3NhbXBsZV9hZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0odGhpcy5vYnNlcnZlciwgdGhpcy5jb25maWcsIGRlY3J5cHREYXRhLCB0aGlzLmRpc2NhcmRFUEIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssIGRlbXV4UmVzdWx0LmF2Y1RyYWNrLCBzYW1wbGVBZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5kZWNyeXB0ID0gZnVuY3Rpb24gZGVjcnlwdChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBzYW1wbGVBZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5pc0FBQykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEFhY1NhbXBsZXMoYXVkaW9UcmFjay5zYW1wbGVzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBudWxsO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgfTtcblxuICBfcHJvdG8ucHVzaEFjY2Vzc1VuaXQgPSBmdW5jdGlvbiBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIGF2Y1RyYWNrKSB7XG4gICAgaWYgKGF2Y1NhbXBsZS51bml0cy5sZW5ndGggJiYgYXZjU2FtcGxlLmZyYW1lKSB7XG4gICAgICAvLyBpZiBzYW1wbGUgZG9lcyBub3QgaGF2ZSBQVFMvRFRTLCBwYXRjaCB3aXRoIGxhc3Qgc2FtcGxlIFBUUy9EVFNcbiAgICAgIGlmIChpc05hTihhdmNTYW1wbGUucHRzKSkge1xuICAgICAgICB2YXIgc2FtcGxlcyA9IGF2Y1RyYWNrLnNhbXBsZXM7XG4gICAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBzYW1wbGVzW25iU2FtcGxlcyAtIDFdO1xuICAgICAgICAgIGF2Y1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgICBhdmNTYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBpbmcgc2FtcGxlcywgbm8gdGltZXN0YW1wIGZvdW5kXG4gICAgICAgICAgYXZjVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhdmNUcmFjay5zYW1wbGVzLnB1c2goYXZjU2FtcGxlKTtcbiAgICB9XG5cbiAgICBpZiAoYXZjU2FtcGxlLmRlYnVnLmxlbmd0aCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhhdmNTYW1wbGUucHRzICsgJy8nICsgYXZjU2FtcGxlLmR0cyArICc6JyArIGF2Y1NhbXBsZS5kZWJ1Zyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGFyc2VBVkNQRVMgPSBmdW5jdGlvbiBfcGFyc2VBVkNQRVMocGVzLCBsYXN0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBsb2dnZXIubG9nKCdwYXJzZSBuZXcgUEVTJyk7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXZjVHJhY2s7XG5cbiAgICB2YXIgdW5pdHMgPSB0aGlzLl9wYXJzZUFWQ05BTHUocGVzLmRhdGEpO1xuXG4gICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgdmFyIGV4cEdvbG9tYkRlY29kZXI7XG4gICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIHZhciBwdXNoO1xuICAgIHZhciBzcHNmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBwdXNoQWNjZXNzVW5pdCA9IHRoaXMucHVzaEFjY2Vzc1VuaXQuYmluZCh0aGlzKTsgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG5cbiAgICBwZXMuZGF0YSA9IG51bGw7IC8vIGlmIG5ldyBOQUwgdW5pdHMgZm91bmQgYW5kIGxhc3Qgc2FtcGxlIHN0aWxsIHRoZXJlLCBsZXQncyBwdXNoIC4uLlxuICAgIC8vIHRoaXMgaGVscHMgcGFyc2luZyBzdHJlYW1zIHdpdGggbWlzc2luZyBBVUQgKG9ubHkgZG8gdGhpcyBpZiBBVUQgbmV2ZXIgZm91bmQpXG5cbiAgICBpZiAoYXZjU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgYXZjU2FtcGxlID0gdGhpcy5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICB9XG5cbiAgICB1bml0cy5mb3JFYWNoKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpczIuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAnTkRSICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF2Y1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuaXQuZGF0YTsgLy8gb25seSBjaGVjayBzbGljZSB0eXBlIHRvIGRldGVjdCBLRiBpbiBjYXNlIFNQUyBmb3VuZCBpbiBzYW1lIHBhY2tldCAoYW55IGtleWZyYW1lIGlzIHByZWNlZGVkIGJ5IFNQUyAuLi4pXG5cbiAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgdmFyIHNsaWNlVHlwZSA9IG5ldyBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXShkYXRhKS5yZWFkU2xpY2VUeXBlKCk7IC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG5cbiAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGF2Y1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrOyAvLyBJRFJcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlOyAvLyBoYW5kbGUgUEVTIG5vdCBzdGFydGluZyB3aXRoIEFVRFxuXG4gICAgICAgICAgaWYgKCFhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZSA9IF90aGlzMi5hdmNTYW1wbGUgPSBjcmVhdGVBVkNTYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdmNTYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBhdmNTYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUlcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTRUkgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXShfdGhpczIuZGlzY2FyZEVQQih1bml0LmRhdGEpKTsgLy8gc2tpcCBmcmFtZVR5cGVcblxuICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIGVuZE9mQ2FwdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKCFlbmRPZkNhcHRpb25zICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgPiAxKSB7XG4gICAgICAgICAgICAgIHBheWxvYWRUeXBlID0gMDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7IC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cblxuXG4gICAgICAgICAgICAgIHBheWxvYWRTaXplID0gMDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYiA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7IC8vIFRPRE86IHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIHBheWxvYWQgaW4gYW4gU0VJIHBhY2tldC4uLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIHJlYWQgdHlwZSBhbmQgc2l6ZSBpbiBhIHdoaWxlIGxvb3AgdG8gZ2V0IHRoZW0gYWxsXG5cblxuICAgICAgICAgICAgICBpZiAocGF5bG9hZFR5cGUgPT09IDQgJiYgZXhwR29sb21iRGVjb2Rlci5ieXRlc0F2YWlsYWJsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVuZE9mQ2FwdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudHJ5Q29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgPT09IDE4MSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyQ29kZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVTaG9ydCgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXJDb2RlID09PSA0OSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVJbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlclN0cnVjdHVyZSA9PT0gMHg0NzQxMzkzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyRGF0YVR5cGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpOyAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbENDcyA9IDMxICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVBcnJheSA9IFtmaXJzdEJ5dGUsIHNlY29uZEJ5dGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDQ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGJ5dGVzIHBlciBDQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlQXJyYXkucHVzaChleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZUFycmF5LnB1c2goZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuX2luc2VydFNhbXBsZUluT3JkZXIoX3RoaXMyLl90eHRUcmFjay5zYW1wbGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHB0czogcGVzLnB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM6IGJ5dGVBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1ICYmIGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBlbmRPZkNhcHRpb25zID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkU2l6ZSA+IDE2KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdXVpZFN0ckFycmF5ID0gW107XG5cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKGV4cEdvbG9tYkRlY29kZXIucmVhZFVCeXRlKCkudG9TdHJpbmcoMTYpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHBheWxvYWRTaXplIC0gMTY7XG4gICAgICAgICAgICAgICAgICB2YXIgdXNlckRhdGFQYXlsb2FkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFQYXlsb2FkQnl0ZXNbaV0gPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVQnl0ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczIuX2luc2VydFNhbXBsZUluT3JkZXIoX3RoaXMyLl90eHRUcmFjay5zYW1wbGVzLCB7XG4gICAgICAgICAgICAgICAgICAgIHB0czogcGVzLnB0cyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICB1dWlkOiB1dWlkU3RyQXJyYXkuam9pbignJyksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhOiBPYmplY3QoX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1widXRmOEFycmF5VG9TdHJcIl0pKHVzZXJEYXRhUGF5bG9hZEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckRhdGFCeXRlczogdXNlckRhdGFQYXlsb2FkQnl0ZXNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkU2l6ZSA8IGV4cEdvbG9tYkRlY29kZXIuYnl0ZXNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF5bG9hZFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVUJ5dGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7IC8vIFNQU1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGRlYnVnICYmIGF2Y1NhbXBsZSkge1xuICAgICAgICAgICAgYXZjU2FtcGxlLmRlYnVnICs9ICdTUFMgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRyYWNrLnNwcykge1xuICAgICAgICAgICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBfZXhwX2dvbG9tYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSh1bml0LmRhdGEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFNQUygpO1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IF90aGlzMi5fZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgY29kZWNhcnJheSA9IHVuaXQuZGF0YS5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIHZhciBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBjb2RlY2FycmF5W2ldLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFjay5jb2RlYyA9IGNvZGVjc3RyaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQUFNcblxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoZGVidWcgJiYgYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBhdmNTYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdHJhY2sucHBzKSB7XG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQVVEXG5cbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICB0cmFjay5hdWRGb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoYXZjU2FtcGxlKSB7XG4gICAgICAgICAgICBwdXNoQWNjZXNzVW5pdChhdmNTYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdmNTYW1wbGUgPSBfdGhpczIuYXZjU2FtcGxlID0gY3JlYXRlQVZDU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCBkZWJ1ZyA/ICdBVUQgJyA6ICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmlsbGVyIERhdGFcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChhdmNTYW1wbGUpIHtcbiAgICAgICAgICAgIGF2Y1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGF2Y1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgIHZhciBfdW5pdHMgPSBhdmNTYW1wbGUudW5pdHM7XG5cbiAgICAgICAgX3VuaXRzLnB1c2godW5pdCk7XG4gICAgICB9XG4gICAgfSk7IC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG5cbiAgICBpZiAobGFzdCAmJiBhdmNTYW1wbGUpIHtcbiAgICAgIHB1c2hBY2Nlc3NVbml0KGF2Y1NhbXBsZSwgdHJhY2spO1xuICAgICAgdGhpcy5hdmNTYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2luc2VydFNhbXBsZUluT3JkZXIgPSBmdW5jdGlvbiBfaW5zZXJ0U2FtcGxlSW5PcmRlcihhcnIsIGRhdGEpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBpZiAoZGF0YS5wdHMgPj0gYXJyW2xlbiAtIDFdLnB0cykge1xuICAgICAgICBhcnIucHVzaChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IGxlbiAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChkYXRhLnB0cyA8IGFycltwb3NdLnB0cykge1xuICAgICAgICAgICAgYXJyLnNwbGljZShwb3MsIDAsIGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyci5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2dldExhc3ROYWxVbml0ID0gZnVuY3Rpb24gX2dldExhc3ROYWxVbml0KCkge1xuICAgIHZhciBfYXZjU2FtcGxlO1xuXG4gICAgdmFyIGF2Y1NhbXBsZSA9IHRoaXMuYXZjU2FtcGxlO1xuICAgIHZhciBsYXN0VW5pdDsgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuXG4gICAgaWYgKCFhdmNTYW1wbGUgfHwgYXZjU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIHNhbXBsZXMgPSB0aGlzLl9hdmNUcmFjay5zYW1wbGVzO1xuICAgICAgYXZjU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGlmICgoX2F2Y1NhbXBsZSA9IGF2Y1NhbXBsZSkgIT09IG51bGwgJiYgX2F2Y1NhbXBsZSAhPT0gdm9pZCAwICYmIF9hdmNTYW1wbGUudW5pdHMpIHtcbiAgICAgIHZhciB1bml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3RVbml0O1xuICB9O1xuXG4gIF9wcm90by5fcGFyc2VBVkNOQUx1ID0gZnVuY3Rpb24gX3BhcnNlQVZDTkFMdShhcnJheSkge1xuICAgIHZhciBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgIHZhciB0cmFjayA9IHRoaXMuX2F2Y1RyYWNrO1xuICAgIHZhciBzdGF0ZSA9IHRyYWNrLm5hbHVTdGF0ZSB8fCAwO1xuICAgIHZhciBsYXN0U3RhdGUgPSBzdGF0ZTtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdmVyZmxvdztcbiAgICB2YXIgdW5pdDtcbiAgICB2YXIgdW5pdFR5cGU7XG4gICAgdmFyIGxhc3RVbml0U3RhcnQgPSAtMTtcbiAgICB2YXIgbGFzdFVuaXRUeXBlOyAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDsgLy8gTkFMdSB0eXBlIGlzIHZhbHVlIHJlYWQgZnJvbSBvZmZzZXQgMFxuXG4gICAgICBsYXN0VW5pdFR5cGUgPSBhcnJheVswXSAmIDB4MWY7XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdOyAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuXG5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgdW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGkgLSBzdGF0ZSAtIDEpLFxuICAgICAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlXG4gICAgICAgICAgfTsgLy8gbG9nZ2VyLmxvZygncHVzaGluZyBOQUxVLCB0eXBlL3NpemU6JyArIHVuaXQudHlwZSArICcvJyArIHVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcblxuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIHZhciBsYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG5cbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgaSA8PSA0IC0gbGFzdFN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElmIE5BTCB1bml0cyBhcmUgbm90IHN0YXJ0aW5nIHJpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYWNrZXQsIHB1c2ggcHJlY2VkaW5nIGRhdGEgaW50byBwcmV2aW91cyBOQUwgdW5pdC5cblxuXG4gICAgICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIHRtcC5zZXQobGFzdFVuaXQuZGF0YSwgMCk7XG4gICAgICAgICAgICAgIHRtcC5zZXQoYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcblxuXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7IC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuXG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xuICAgICAgdW5pdCA9IHtcbiAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICB1bml0cy5wdXNoKHVuaXQpOyAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgfSAvLyBubyBOQUx1IGZvdW5kXG5cblxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgdmFyIF9sYXN0VW5pdCA9IHRoaXMuX2dldExhc3ROYWxVbml0KCk7XG5cbiAgICAgIGlmIChfbGFzdFVuaXQpIHtcbiAgICAgICAgdmFyIF90bXAgPSBuZXcgVWludDhBcnJheShfbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoICsgYXJyYXkuYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgX3RtcC5zZXQoX2xhc3RVbml0LmRhdGEsIDApO1xuXG4gICAgICAgIF90bXAuc2V0KGFycmF5LCBfbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoKTtcblxuICAgICAgICBfbGFzdFVuaXQuZGF0YSA9IF90bXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG4gIC8qKlxuICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGlzY2FyZEVQQiA9IGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdmFyIEVQQlBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciBpID0gMTsgLy8gRmluZCBhbGwgYEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzYFxuXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcblxuXG4gICAgaWYgKEVQQlBvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcblxuXG4gICAgdmFyIG5ld0xlbmd0aCA9IGxlbmd0aCAtIEVQQlBvc2l0aW9ucy5sZW5ndGg7XG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xuICAgIHZhciBzb3VyY2VJbmRleCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7IC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG5cbiAgICAgICAgRVBCUG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlQUFDUEVTID0gZnVuY3Rpb24gX3BhcnNlQUFDUEVTKHBlcykge1xuICAgIHZhciBzdGFydE9mZnNldCA9IDA7XG4gICAgdmFyIHRyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICB2YXIgYWFjTGFzdFBUUyA9IHRoaXMuYWFjTGFzdFBUUztcbiAgICB2YXIgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIHZhciBkYXRhID0gcGVzLmRhdGE7XG4gICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgdmFyIGZyYW1lSW5kZXg7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgc3RhbXA7XG4gICAgdmFyIGxlbjtcblxuICAgIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGFhY092ZXJGbG93LmJ5dGVMZW5ndGggKyBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgdG1wLnNldChhYWNPdmVyRmxvdywgMCk7XG4gICAgICB0bXAuc2V0KGRhdGEsIGFhY092ZXJGbG93LmJ5dGVMZW5ndGgpOyAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke2FhY092ZXJGbG93LmJ5dGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG5cbiAgICAgIGRhdGEgPSB0bXA7XG4gICAgfSAvLyBsb29rIGZvciBBRFRTIGhlYWRlciAoMHhGRkZ4KVxuXG5cbiAgICBmb3IgKG9mZnNldCA9IHN0YXJ0T2Zmc2V0LCBsZW4gPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgIGlmIChfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNIZWFkZXJcIl0oZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG5cblxuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHZhciByZWFzb247XG4gICAgICB2YXIgZmF0YWw7XG5cbiAgICAgIGlmIChvZmZzZXQgPCBsZW4gLSAxKSB7XG4gICAgICAgIHJlYXNvbiA9IFwiQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OlwiICsgb2Zmc2V0O1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ25vIEFEVFMgaGVhZGVyIGZvdW5kIGluIEFBQyBQRVMnO1xuICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKFwicGFyc2luZyBlcnJvcjpcIiArIHJlYXNvbik7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXZlbnRzXCJdLkVSUk9SLCBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRXJyb3JUeXBlc1wiXS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImluaXRUcmFja0NvbmZpZ1wiXSh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0aGlzLmF1ZGlvQ29kZWMpO1xuICAgIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBmcmFtZUR1cmF0aW9uID0gX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldEZyYW1lRHVyYXRpb25cIl0odHJhY2suc2FtcGxlcmF0ZSk7IC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgLy8gZmlyc3Qgc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZnJhbWVEdXJhdGlvblxuXG4gICAgaWYgKGFhY092ZXJGbG93ICYmIGFhY0xhc3RQVFMpIHtcbiAgICAgIHZhciBuZXdQVFMgPSBhYWNMYXN0UFRTICsgZnJhbWVEdXJhdGlvbjtcblxuICAgICAgaWYgKE1hdGguYWJzKG5ld1BUUyAtIHB0cykgPiAxKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coXCJbdHNkZW11eGVyXTogQUFDOiBhbGlnbiBQVFMgZm9yIG92ZXJsYXBwaW5nIGZyYW1lcyBieSBcIiArIE1hdGgucm91bmQoKG5ld1BUUyAtIHB0cykgLyA5MCkpO1xuICAgICAgICBwdHMgPSBuZXdQVFM7XG4gICAgICB9XG4gICAgfSAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuXG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBpZiAoX2FkdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgaWYgKG9mZnNldCArIDUgPCBsZW4pIHtcbiAgICAgICAgICB2YXIgZnJhbWUgPSBfYWR0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYXBwZW5kRnJhbWVcIl0odHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcblxuICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YW1wID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSBhcmUgYXQgYW4gQURUUyBoZWFkZXIsIGJ1dCBkbyBub3QgaGF2ZSBlbm91Z2ggZGF0YSBmb3IgYSBmcmFtZVxuICAgICAgICAvLyBSZW1haW5pbmcgZGF0YSB3aWxsIGJlIGFkZGVkIHRvIGFhY092ZXJGbG93XG5cblxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBhYWNPdmVyRmxvdyA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBsZW4pOyAvLyBsb2dnZXIubG9nKGBBQUM6IG92ZXJmbG93IGRldGVjdGVkOiR7bGVuLW9mZnNldH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBhYWNPdmVyRmxvdztcbiAgICB0aGlzLmFhY0xhc3RQVFMgPSBzdGFtcDtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlTVBFR1BFUyA9IGZ1bmN0aW9uIF9wYXJzZU1QRUdQRVMocGVzKSB7XG4gICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGZyYW1lSW5kZXggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBwdHMgPSBwZXMucHRzO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKF9tcGVnYXVkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImlzSGVhZGVyXCJdKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gX21wZWdhdWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiYXBwZW5kRnJhbWVcIl0odGhpcy5fYXVkaW9UcmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuXG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZUlEM1BFUyA9IGZ1bmN0aW9uIF9wYXJzZUlEM1BFUyhwZXMpIHtcbiAgICB0aGlzLl9pZDNUcmFjay5zYW1wbGVzLnB1c2gocGVzKTtcbiAgfTtcblxuICByZXR1cm4gVFNEZW11eGVyO1xufSgpO1xuXG5UU0RlbXV4ZXIubWluUHJvYmVCeXRlTGVuZ3RoID0gMTg4O1xuXG5mdW5jdGlvbiBjcmVhdGVBVkNTYW1wbGUoa2V5LCBwdHMsIGR0cywgZGVidWcpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBmcmFtZTogZmFsc2UsXG4gICAgcHRzOiBwdHMsXG4gICAgZHRzOiBkdHMsXG4gICAgdW5pdHM6IFtdLFxuICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICBsZW5ndGg6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MWYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTsgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQTVQoZGF0YSwgb2Zmc2V0LCBtcGVnU3VwcG9ydGVkLCBpc1NhbXBsZUFlcykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIGF1ZGlvOiAtMSxcbiAgICBhdmM6IC0xLFxuICAgIGlkMzogLTEsXG4gICAgaXNBQUM6IHRydWVcbiAgfTtcbiAgdmFyIHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICB2YXIgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7IC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuXG4gIHZhciBwcm9ncmFtSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTsgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuXG4gIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuXG4gIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgIHZhciBwaWQgPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MWYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ0FEVFMgQUFDIHdpdGggQUVTLTEyOC1DQkMgZnJhbWUgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkMyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ0guMjY0IHdpdGggQUVTLTEyOC1DQkMgc2xpY2UgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW0nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF2YyA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXZjID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcblxuICAgICAgY2FzZSAweDAzOlxuICAgICAgY2FzZSAweDA0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdNUEVHIFBJRDonICArIHBpZCk7XG4gICAgICAgIGlmICghbXBlZ1N1cHBvcnRlZCkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ01QRUcgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuaXNBQUMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKCdVbnN1cHBvcnRlZCBIRVZDIHN0cmVhbSB0eXBlIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCd1bmtub3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG5cblxuICAgIG9mZnNldCArPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XSkgKyA1O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGZyYWc7XG4gIHZhciBwZXNGbGFncztcbiAgdmFyIHBlc0xlbjtcbiAgdmFyIHBlc0hkckxlbjtcbiAgdmFyIHBlc0RhdGE7XG4gIHZhciBwZXNQdHM7XG4gIHZhciBwZXNEdHM7XG4gIHZhciBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gIHZhciBkYXRhID0gc3RyZWFtLmRhdGE7IC8vIHNhZmV0eSBjaGVja1xuXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcblxuXG4gIHdoaWxlIChkYXRhWzBdLmxlbmd0aCA8IDE5ICYmIGRhdGEubGVuZ3RoID4gMSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVswXS5sZW5ndGggKyBkYXRhWzFdLmxlbmd0aCk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVswXSk7XG4gICAgbmV3RGF0YS5zZXQoZGF0YVsxXSwgZGF0YVswXS5sZW5ndGgpO1xuICAgIGRhdGFbMF0gPSBuZXdEYXRhO1xuICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICB9IC8vIHJldHJpZXZlIFBUUy9EVFMgZnJvbSBmaXJzdCBmcmFnbWVudFxuXG5cbiAgZnJhZyA9IGRhdGFbMF07XG4gIHZhciBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG5cbiAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTsgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcblxuICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwZXNGbGFncyA9IGZyYWdbN107XG5cbiAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwZSkgKiA1MzY4NzA5MTIgKyAvLyAxIDw8IDI5XG4gICAgICAoZnJhZ1sxMF0gJiAweGZmKSAqIDQxOTQzMDQgKyAvLyAxIDw8IDIyXG4gICAgICAoZnJhZ1sxMV0gJiAweGZlKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgKGZyYWdbMTJdICYgMHhmZikgKiAxMjggKyAvLyAxIDw8IDdcbiAgICAgIChmcmFnWzEzXSAmIDB4ZmUpIC8gMjtcblxuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPSAoZnJhZ1sxNF0gJiAweDBlKSAqIDUzNjg3MDkxMiArIC8vIDEgPDwgMjlcbiAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgICAoZnJhZ1sxN10gJiAweGZmKSAqIDEyOCArIC8vIDEgPDwgN1xuICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG5cbiAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApICsgXCJzIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1cIik7XG4gICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGVzSGRyTGVuID0gZnJhZ1s4XTsgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG5cbiAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuXG4gICAgaWYgKHN0cmVhbS5zaXplIDw9IHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3RyZWFtLnNpemUgLT0gcGF5bG9hZFN0YXJ0T2Zmc2V0OyAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcblxuICAgIHBlc0RhdGEgPSBuZXcgVWludDhBcnJheShzdHJlYW0uc2l6ZSk7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIHZhciBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG5cbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgaSArPSBsZW47XG4gICAgfVxuXG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcGVzRGF0YSxcbiAgICAgIHB0czogcGVzUHRzLFxuICAgICAgZHRzOiBwZXNEdHMsXG4gICAgICBsZW46IHBlc0xlblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChUU0RlbXV4ZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9lcnJvcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Vycm9ycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkVycm9yVHlwZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvclR5cGVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFcnJvckRldGFpbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBFcnJvckRldGFpbHM7IH0pO1xudmFyIEVycm9yVHlwZXM7XG4vKipcbiAqIEBlbnVtIHtFcnJvckRldGFpbHN9XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBFcnJvckRldGFpbFxuICovXG5cbihmdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICBFcnJvclR5cGVzW1wiTkVUV09SS19FUlJPUlwiXSA9IFwibmV0d29ya0Vycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNRURJQV9FUlJPUlwiXSA9IFwibWVkaWFFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk1VWF9FUlJPUlwiXSA9IFwibXV4RXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIk9USEVSX0VSUk9SXCJdID0gXCJvdGhlckVycm9yXCI7XG59KShFcnJvclR5cGVzIHx8IChFcnJvclR5cGVzID0ge30pKTtcblxudmFyIEVycm9yRGV0YWlscztcblxuKGZ1bmN0aW9uIChFcnJvckRldGFpbHMpIHtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19BQ0NFU1NcIl0gPSBcImtleVN5c3RlbU5vQWNjZXNzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fU0VTU0lPTlwiXSA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtTGljZW5zZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19JTklUX0RBVEFcIl0gPSBcImtleVN5c3RlbU5vSW5pdERhdGFcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9FUlJPUlwiXSA9IFwibWFuaWZlc3RMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9USU1FT1VUXCJdID0gXCJtYW5pZmVzdExvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX0VSUk9SXCJdID0gXCJsZXZlbExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX1RJTUVPVVRcIl0gPSBcImxldmVsTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfU1dJVENIX0VSUk9SXCJdID0gXCJsZXZlbFN3aXRjaEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkFVRElPX1RSQUNLX0xPQURfRVJST1JcIl0gPSBcImF1ZGlvVHJhY2tMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfTE9BRF9FUlJPUlwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19MT0FEX1RJTUVPVVRcIl0gPSBcImZyYWdMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0RFQ1JZUFRfRVJST1JcIl0gPSBcImZyYWdEZWNyeXB0RXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIlJFTVVYX0FMTE9DX0VSUk9SXCJdID0gXCJyZW11eEFsbG9jRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRJTkdfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TVEFMTEVEX0VSUk9SXCJdID0gXCJidWZmZXJTdGFsbGVkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU0VFS19PVkVSX0hPTEVcIl0gPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfTlVER0VfT05fU1RBTExcIl0gPSBcImJ1ZmZlck51ZGdlT25TdGFsbFwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gIEVycm9yRGV0YWlsc1tcIklOVEVSTkFMX0FCT1JURURcIl0gPSBcImFib3J0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xufSkoRXJyb3JEZXRhaWxzIHx8IChFcnJvckRldGFpbHMgPSB7fSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9ldmVudHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2V2ZW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogRXZlbnRzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkV2ZW50c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEV2ZW50czsgfSk7XG4vKipcbiAqIEByZWFkb25seVxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEV2ZW50cztcblxuKGZ1bmN0aW9uIChFdmVudHMpIHtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFBdHRhY2hlZFwiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hJTkdcIl0gPSBcImhsc01lZGlhRGV0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9SRVNFVFwiXSA9IFwiaGxzQnVmZmVyUmVzZXRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NPREVDU1wiXSA9IFwiaGxzQnVmZmVyQ29kZWNzXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRJTkdcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ERURcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9FT1NcIl0gPSBcImhsc0J1ZmZlckVvc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSEVEXCJdID0gXCJobHNCdWZmZXJGbHVzaGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hFRFwiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FESU5HXCJdID0gXCJobHNMZXZlbExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9VUERBVEVEXCJdID0gXCJobHNMZXZlbFVwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfUFRTX1VQREFURURcIl0gPSBcImhsc0xldmVsUHRzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19DTEVBUkVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfU1dJVENIXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrU3dpdGNoXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gIEV2ZW50c1tcIkNVRVNfUEFSU0VEXCJdID0gXCJobHNDdWVzUGFyc2VkXCI7XG4gIEV2ZW50c1tcIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRcIl0gPSBcImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiO1xuICBFdmVudHNbXCJJTklUX1BUU19GT1VORFwiXSA9IFwiaGxzSW5pdFB0c0ZvdW5kXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRElOR1wiXSA9IFwiaGxzRnJhZ0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEXCJdID0gXCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FERURcIl0gPSBcImhsc0ZyYWdMb2FkZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfVVNFUkRBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nVXNlcmRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0VEXCJdID0gXCJobHNGcmFnUGFyc2VkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQlVGRkVSRURcIl0gPSBcImhsc0ZyYWdCdWZmZXJlZFwiO1xuICBFdmVudHNbXCJGUkFHX0NIQU5HRURcIl0gPSBcImhsc0ZyYWdDaGFuZ2VkXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QXCJdID0gXCJobHNGcHNEcm9wXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QX0xFVkVMX0NBUFBJTkdcIl0gPSBcImhsc0Zwc0Ryb3BMZXZlbENhcHBpbmdcIjtcbiAgRXZlbnRzW1wiRVJST1JcIl0gPSBcImhsc0Vycm9yXCI7XG4gIEV2ZW50c1tcIkRFU1RST1lJTkdcIl0gPSBcImhsc0Rlc3Ryb3lpbmdcIjtcbiAgRXZlbnRzW1wiS0VZX0xPQURJTkdcIl0gPSBcImhsc0tleUxvYWRpbmdcIjtcbiAgRXZlbnRzW1wiS0VZX0xPQURFRFwiXSA9IFwiaGxzS2V5TG9hZGVkXCI7XG4gIEV2ZW50c1tcIkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCI7XG59KShFdmVudHMgfHwgKEV2ZW50cyA9IHt9KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2hscy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaGxzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfcGxheWxpc3RfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWRlci9wbGF5bGlzdC1sb2FkZXIgKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfa2V5X2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2FkZXIva2V5LWxvYWRlciAqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2ZyYWdtZW50X3RyYWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyICovIFwiLi9zcmMvY29udHJvbGxlci9mcmFnbWVudC10cmFja2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX3N0cmVhbV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRyb2xsZXIvc3RyZWFtLWNvbnRyb2xsZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xldmVsX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyICovIFwiLi9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc19zdXBwb3J0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3VwcG9ydGVkICovIFwiLi9zcmMvaXMtc3VwcG9ydGVkLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uZmlnICovIFwiLi9zcmMvY29uZmlnLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXZlbnRlbWl0dGVyMyAqLyBcIi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihldmVudGVtaXR0ZXIzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udHJvbGxlcl9pZDNfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udHJvbGxlci9pZDMtdHJhY2stY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRyb2xsZXJfbGF0ZW5jeV9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250cm9sbGVyL2xhdGVuY3ktY29udHJvbGxlciAqLyBcIi4vc3JjL2NvbnRyb2xsZXIvbGF0ZW5jeS1jb250cm9sbGVyLnRzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEBtb2R1bGUgSGxzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgSGxzLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdChfaXNfc3VwcG9ydGVkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJpc1N1cHBvcnRlZFwiXSkoKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoSGxzLCBudWxsLCBbe1xuICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFdmVudHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiRXZlbnRzXCJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJFcnJvclR5cGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRXJyb3JEZXRhaWxzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEZWZhdWx0Q29uZmlnXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJobHNEZWZhdWx0Q29uZmlnXCJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIbHNDb25maWd9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRlZmF1bHRDb25maWcpIHtcbiAgICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBITFMgY2xpZW50IHRoYXQgY2FuIGF0dGFjaCB0byBleGFjdGx5IG9uZSBgSFRNTE1lZGlhRWxlbWVudGAuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0cyBIbHNcbiAgICAgKiBAcGFyYW0ge0hsc0NvbmZpZ30gY29uZmlnXG4gICAgICovXG5cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEhscyh1c2VyQ29uZmlnKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh1c2VyQ29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgIHVzZXJDb25maWcgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZXJDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJFdmVudEVtaXR0ZXJcIl0oKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbWVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnID0gT2JqZWN0KF9jb25maWdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcIm1lcmdlQ29uZmlnXCJdKShIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG4gICAgdGhpcy51c2VyQ29uZmlnID0gdXNlckNvbmZpZztcbiAgICBPYmplY3QoX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZW5hYmxlTG9nc1wiXSkoY29uZmlnLmRlYnVnKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG5cbiAgICBpZiAoY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICBPYmplY3QoX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZW5hYmxlU3RyZWFtaW5nTW9kZVwiXSkoY29uZmlnKTtcbiAgICB9IC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuXG5cbiAgICB2YXIgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYWJyQ29udHJvbGxlcih0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICB2YXIgYnVmZmVyQ29udHJvbGxlciA9IG5ldyBjb25maWcuYnVmZmVyQ29udHJvbGxlcih0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICB2YXIgY2FwTGV2ZWxDb250cm9sbGVyID0gdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgY29uZmlnLmNhcExldmVsQ29udHJvbGxlcih0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICB2YXIgZnBzQ29udHJvbGxlciA9IG5ldyBjb25maWcuZnBzQ29udHJvbGxlcih0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cbiAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgX2xvYWRlcl9wbGF5bGlzdF9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odGhpcyk7XG4gICAgdmFyIGtleUxvYWRlciA9IG5ldyBfbG9hZGVyX2tleV9sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0odGhpcyk7XG4gICAgdmFyIGlkM1RyYWNrQ29udHJvbGxlciA9IG5ldyBfY29udHJvbGxlcl9pZDNfdHJhY2tfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImRlZmF1bHRcIl0odGhpcyk7IC8vIG5ldHdvcmsgY29udHJvbGxlcnNcblxuICAgIHZhciBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBfY29udHJvbGxlcl9sZXZlbF9jb250cm9sbGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdKHRoaXMpOyAvLyBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuXG4gICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBfY29udHJvbGxlcl9mcmFnbWVudF90cmFja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJGcmFnbWVudFRyYWNrZXJcIl0odGhpcyk7XG4gICAgdmFyIHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgX2NvbnRyb2xsZXJfc3RyZWFtX2NvbnRyb2xsZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odGhpcywgZnJhZ21lbnRUcmFja2VyKTsgLy8gTGV2ZWwgQ29udHJvbGxlciBpbml0aWF0ZXMgbG9hZGluZyBhZnRlciBhbGwgY29udHJvbGxlcnMgaGF2ZSByZWNlaXZlZCBNQU5JRkVTVF9QQVJTRURcblxuICAgIGxldmVsQ29udHJvbGxlci5vblBhcnNlZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNvbmZpZy5hdXRvU3RhcnRMb2FkIHx8IHN0cmVhbUNvbnRyb2xsZXIuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgICAgX3RoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9OyAvLyBDYXAgbGV2ZWwgY29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gZmx1c2ggdGhlIGJ1ZmZlclxuXG5cbiAgICBjYXBMZXZlbENvbnRyb2xsZXIuc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKTsgLy8gZnBzQ29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gc3dpdGNoIHdoZW4gZnJhbWVzIGFyZSBiZWluZyBkcm9wcGVkXG5cbiAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgdmFyIG5ldHdvcmtDb250cm9sbGVycyA9IFtsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFtwbGF5TGlzdExvYWRlciwga2V5TG9hZGVyLCBhYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5hdWRpb1RyYWNrQ29udHJvbGxlciwgbnVsbCwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyLCBuZXR3b3JrQ29udHJvbGxlcnMpOyAvLyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlICBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcblxuICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBudWxsLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmVtZUNvbnRyb2xsZXIsIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKF9jb250cm9sbGVyX2xhdGVuY3lfY29udHJvbGxlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0sIG51bGwsIGNvcmVDb21wb25lbnRzKTtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSGxzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY3JlYXRlQ29udHJvbGxlciA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xsZXIoQ29udHJvbGxlckNsYXNzLCBmcmFnbWVudFRyYWNrZXIsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gZnJhZ21lbnRUcmFja2VyID8gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIpIDogbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcblxuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gRGVsZWdhdGUgdGhlIEV2ZW50RW1pdHRlciB0aHJvdWdoIHRoZSBwdWJsaWMgQVBJIG9mIEhscy5qc1xuICA7XG5cbiAgX3Byb3RvLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGhsc2pzID0gdGhpcztcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGxzanMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5lcnJvcignQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50ICsgJy4gRXJyb3IgbWVzc2FnZTogXCInICsgZS5tZXNzYWdlICsgJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLCBlKTtcbiAgICAgICAgICBobHNqcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIF9wcm90by5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgaGxzanMgPSB0aGlzO1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGxzanMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5lcnJvcignQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArIGV2ZW50ICsgJy4gRXJyb3IgbWVzc2FnZTogXCInICsgZS5tZXNzYWdlICsgJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLCBlKTtcbiAgICAgICAgICBobHNqcy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJFdmVudHNcIl0uRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpO1xuICB9O1xuXG4gIF9wcm90by5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH07XG5cbiAgX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50LCBldmVudE9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gIH07XG5cbiAgX3Byb3RvLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGluc3RhbmNlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcIkV2ZW50c1wiXS5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MTWVkaWFFbGVtZW50fSBtZWRpYVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hdHRhY2hNZWRpYSA9IGZ1bmN0aW9uIGF0dGFjaE1lZGlhKG1lZGlhKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibG9nZ2VyXCJdLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiRXZlbnRzXCJdLk1FRElBX0FUVEFDSElORywge1xuICAgICAgbWVkaWE6IG1lZGlhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCBIbHMuanMgZnJvbSB0aGUgbWVkaWFcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoTWVkaWEgPSBmdW5jdGlvbiBkZXRhY2hNZWRpYSgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiRXZlbnRzXCJdLk1FRElBX0RFVEFDSElORywgdW5kZWZpbmVkKTtcbiAgICB0aGlzLl9tZWRpYSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmxvYWRTb3VyY2UgPSBmdW5jdGlvbiBsb2FkU291cmNlKHVybCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuXG4gICAgaWYgKG1lZGlhICYmIHRoaXMudXJsKSB7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG5cbiAgICB1cmwgPSB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYnVpbGRBYnNvbHV0ZVVSTFwiXShzZWxmLmxvY2F0aW9uLmhyZWYsIHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgfSk7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibG9nZ2VyXCJdLmxvZyhcImxvYWRTb3VyY2U6XCIgKyB1cmwpO1xuICAgIHRoaXMudXJsID0gdXJsOyAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG5cbiAgICB0aGlzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB7XG4gICAgICB1cmw6IHVybFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zaXRpb24gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbVxuICAgKiBAZGVmYXVsdCAtMSBOb25lIChmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmIChzdGFydFBvc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKFwic3RhcnRMb2FkKFwiICsgc3RhcnRQb3NpdGlvbiArIFwiKVwiKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKCdzdG9wTG9hZCcpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3dhcCB0aHJvdWdoIHBvc3NpYmxlIGF1ZGlvIGNvZGVjcyBpbiB0aGUgc3RyZWFtIChmb3IgZXhhbXBsZSB0byBzd2l0Y2ggZnJvbSBzdGVyZW8gdG8gNS4xKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zd2FwQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coJ3N3YXBBdWRpb0NvZGVjJyk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLnN3YXBBdWRpb0NvZGVjKCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXG4gICAqXG4gICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVjb3Zlck1lZGlhRXJyb3IgPSBmdW5jdGlvbiByZWNvdmVyTWVkaWFFcnJvcigpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgIHZhciBtZWRpYSA9IHRoaXMuX21lZGlhO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW1vdmVMZXZlbCA9IGZ1bmN0aW9uIHJlbW92ZUxldmVsKGxldmVsSW5kZXgsIHVybElkKSB7XG4gICAgaWYgKHVybElkID09PSB2b2lkIDApIHtcbiAgICAgIHVybElkID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4LCB1cmxJZCk7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtMZXZlbFtdfVxuICAgKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhIbHMsIFt7XG4gICAga2V5OiBcImxldmVsc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscyA/IHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsIGN1cnJlbnRseSBwbGF5ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkgLlxuICAgICAqIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLlxuICAgICAqIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibG9nZ2VyXCJdLmxvZyhcInNldCBjdXJyZW50TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxvYWRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXh0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSB2aWRlbyBxdWFsaXR5IGFzYXAsIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrLlxuICAgICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAgICogQHR5cGUge251bWJlcn0gLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgbmV4dExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBxdWFsaXR5IGxldmVsIG9mIHRoZSBjdXJyZW50bHkgb3IgbGFzdCAob2Ygbm9uZSBpcyBsb2FkZWQgY3VycmVudGx5KSBzZWdtZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWwgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgbG9hZExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dExvYWRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICAgKiBTYW1lIGFzIGBsb2FkTGV2ZWxgIGJ1dCB3aWxsIHdhaXQgZm9yIG5leHQgc3dpdGNoICh1bnRpbCBjdXJyZW50IGxvYWRpbmcgaXMgZG9uZSkuXG4gICAgICogQHR5cGUge251bWJlcn0gbGV2ZWxcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJsb2dnZXJcIl0ubG9nKFwic2V0IGZpcnN0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICAgKiBpZiBub3Qgb3ZlcnJpZGVkIGJ5IHVzZXIsIGZpcnN0IGxldmVsIGFwcGVhcmluZyBpbiBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgYXMgc3RhcnQgbGV2ZWxcbiAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAgICogQHR5cGUge251bWJlcn0gbmV3TGV2ZWxcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImxvZ2dlclwiXS5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTsgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcblxuICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWF4KG5ld0xldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNldHRpbmcgZm9yIGNhcExldmVsVG9QbGF5ZXJTaXplXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhcExldmVsVG9QbGF5ZXJTaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCAgZHluYW1pY2FsbHkgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplIGFnYWluc3QgKGBDYXBMZXZlbENvbnRyb2xsZXJgKVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNob3VsZFN0YXJ0Q2FwcGluZykge1xuICAgICAgdmFyIG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG5cbiAgICAgIGlmIChuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSAhPT0gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTsgLy8gTm93IHdlJ3JlIHVuY2FwcGVkLCBnZXQgdGhlIG5leHQgbGV2ZWwgYXNhcC5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXV0b0xldmVsQ2FwcGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCBiYW5kd2lkdGggZXN0aW1hdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcblxuICAgIC8qKlxuICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICBpZiAodGhpcy5fYXV0b0xldmVsQ2FwcGluZyAhPT0gbmV3TGV2ZWwpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibG9nZ2VyXCJdLmxvZyhcInNldCBhdXRvTGV2ZWxDYXBwaW5nOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJhbmR3aWR0aEVzdGltYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1dG9MZXZlbEVuYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldmVsIHNldCBtYW51YWxseSAoaWYgYW55KVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtaW5BdXRvTGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBtaW5BdXRvQml0cmF0ZSA9IHRoaXMuY29uZmlnLm1pbkF1dG9CaXRyYXRlO1xuICAgICAgaWYgKCFsZXZlbHMpIHJldHVybiAwO1xuICAgICAgdmFyIGxlbiA9IGxldmVscy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID4gbWluQXV0b0JpdHJhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1heEF1dG9MZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgIGF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB2YXIgbWF4QXV0b0xldmVsO1xuXG4gICAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzICYmIGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXh0QXV0b0xldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyBlbnN1cmUgbmV4dCBhdXRvIGxldmVsIGlzIGJldHdlZW4gIG1pbiBhbmQgbWF4IGF1dG8gbGV2ZWxcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpLCB0aGlzLm1heEF1dG9MZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsLlxuICAgICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICAgKiBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCA9IE1hdGgubWF4KHRoaXMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXVkaW9UcmFja1tdfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9UcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrcyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb1RyYWNrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA6IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdWRpb1RyYWNrSWQpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG5cbiAgICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xuICAgICAgICBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrID0gYXVkaW9UcmFja0lkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICAgKiBAdHlwZSB7TWVkaWFQbGF5bGlzdFtdfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VidGl0bGVUcmFja3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA6IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3VidGl0bGVUcmFja0lkKSB7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuXG4gICAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtZWRpYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0aXRsZURpc3BsYXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgc3VidGl0bGUgZGlzcGxheSByZW5kZXJpbmdcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG5cbiAgICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IG1vZGUgZm9yIExvdy1MYXRlbmN5IEhMUyBsb2FkaW5nXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb3dMYXRlbmN5TW9kZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobW9kZSkge1xuICAgICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBzeW5jIHBvaW50IChpZSBlZGdlIG9mIGxpdmUgcG9zaXRpb24gbWludXMgc2FmZXR5IGRlbGF5IGRlZmluZWQgYnkgYGBgaGxzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uYGBgKVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXZlU3luY1Bvc2l0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlc3RpbWF0ZWQgcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgZWRnZSAoaWUgZWRnZSBvZiBsaXZlIHBsYXlsaXN0IHBsdXMgdGltZSBzeW5jIHBsYXlsaXN0IGFkdmFuY2VkKVxuICAgICAqIHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxhdGVuY3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBiZWZvcmUgdGhlIHBsYXllciBzZWVrcyBmb3J3YXJkIHRvIGBgYGhscy5saXZlU3luY1Bvc2l0aW9uYGBgXG4gICAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgICAqIHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1heExhdGVuY3lcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRhcmdldCBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGFzIGNhbGN1bGF0ZWQgYnkgdGhlIGxhdGVuY3kgY29udHJvbGxlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0YXJnZXRMYXRlbmN5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIbHM7XG59KCk7XG5cbkhscy5kZWZhdWx0Q29uZmlnID0gdm9pZCAwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2lzLXN1cHBvcnRlZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaXMtc3VwcG9ydGVkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc1N1cHBvcnRlZCwgY2hhbmdlVHlwZVN1cHBvcnRlZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc1N1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU3VwcG9ydGVkOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjaGFuZ2VUeXBlU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhbmdlVHlwZVN1cHBvcnRlZDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIgKi8gXCIuL3NyYy91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXIudHNcIik7XG5cblxuZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyKCkge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICB2YXIgbWVkaWFTb3VyY2UgPSBPYmplY3QoX3V0aWxzX21lZGlhc291cmNlX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZ2V0TWVkaWFTb3VyY2VcIl0pKCk7XG5cbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgdmFyIGlzVHlwZVN1cHBvcnRlZCA9IG1lZGlhU291cmNlICYmIHR5cGVvZiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgPT09ICdmdW5jdGlvbicgJiYgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCd2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJFMDFFLG1wNGEuNDAuMlwiJyk7IC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gIC8vIHNhZmFyaSBhbmQgb2xkIHZlcnNpb24gb2YgQ2hyb21lIGRvZSBub3QgZXhwb3NlIFNvdXJjZUJ1ZmZlciBnbG9iYWxseSBzbyBjaGVja2luZyBTb3VyY2VCdWZmZXIucHJvdG90eXBlIGlzIGltcG9zc2libGVcblxuICB2YXIgc291cmNlQnVmZmVyVmFsaWRBUEkgPSAhc291cmNlQnVmZmVyIHx8IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuICEhaXNUeXBlU3VwcG9ydGVkICYmICEhc291cmNlQnVmZmVyVmFsaWRBUEk7XG59XG5mdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCkge1xuICB2YXIgX3NvdXJjZUJ1ZmZlciRwcm90b3R5O1xuXG4gIHZhciBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuIHR5cGVvZiAoc291cmNlQnVmZmVyID09PSBudWxsIHx8IHNvdXJjZUJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09PSBudWxsIHx8IF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZUJ1ZmZlciRwcm90b3R5LmNoYW5nZVR5cGUpID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIExvYWRFcnJvciAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnJhZ21lbnRMb2FkZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxvYWRFcnJvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExvYWRFcnJvcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG5cblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cbnZhciBNSU5fQ0hVTktfU0laRSA9IE1hdGgucG93KDIsIDE3KTsgLy8gMTI4a2JcblxudmFyIEZyYWdtZW50TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnRMb2FkZXIoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMucGFydExvYWRUaW1lb3V0ID0gLTE7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhZ21lbnRMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgLy8gQWJvcnQgdGhlIGxvYWRlciBmb3IgY3VycmVudCBmcmFnbWVudC4gT25seSBvbmUgbWF5IGxvYWQgYXQgYW55IGdpdmVuIHRpbWVcbiAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChmcmFnLCBfb25Qcm9ncmVzcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdXJsID0gZnJhZy51cmw7XG5cbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICAgIH0sIFwiRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhIFwiICsgKHVybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCcpKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICB2YXIgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgdmFyIERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGxvYWRlciA9IF90aGlzLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTsgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuXG4gICAgICBmcmFnLnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKF9vblByb2dyZXNzKSB7XG4gICAgICAgICAgICBfb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZFBhcnQgPSBmdW5jdGlvbiBsb2FkUGFydChmcmFnLCBwYXJ0LCBvblByb2dyZXNzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLmFib3J0KCk7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIHZhciBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICB2YXIgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3RoaXMyLmxvYWRlciA9IGZyYWcubG9hZGVyID0gRnJhZ21lbnRJTG9hZGVyID8gbmV3IEZyYWdtZW50SUxvYWRlcihjb25maWcpIDogbmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZyk7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICB0aW1lb3V0OiBjb25maWcuZnJhZ0xvYWRpbmdUaW1lT3V0LFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogY29uZmlnLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTsgLy8gQXNzaWduIHBhcnQgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuXG4gICAgICBwYXJ0LnN0YXRzID0gbG9hZGVyLnN0YXRzO1xuICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIF90aGlzMi51cGRhdGVTdGF0c0Zyb21QYXJ0KGZyYWcsIHBhcnQpO1xuXG4gICAgICAgICAgdmFyIHBhcnRMb2FkZWREYXRhID0ge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvblByb2dyZXNzKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG5cbiAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcblxuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVycm9yRGV0YWlsc1wiXS5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuXG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTdGF0c0Zyb21QYXJ0ID0gZnVuY3Rpb24gdXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgdmFyIHBhcnRTdGF0cyA9IHBhcnQuc3RhdHM7XG4gICAgdmFyIHBhcnRUb3RhbCA9IHBhcnRTdGF0cy50b3RhbDtcbiAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG5cbiAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICB2YXIgZXN0VG90YWxQYXJ0cyA9IE1hdGgucm91bmQoZnJhZy5kdXJhdGlvbiAvIHBhcnQuZHVyYXRpb24pO1xuICAgICAgdmFyIGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSwgZXN0VG90YWxQYXJ0cyk7XG4gICAgICB2YXIgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICB2YXIgZXN0UmVtYWluaW5nQnl0ZXMgPSBlc3RSZW1haW5pbmdQYXJ0cyAqIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIGVzdExvYWRlZFBhcnRzKTtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IGZyYWdTdGF0cy5sb2FkZWQgKyBlc3RSZW1haW5pbmdCeXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gTWF0aC5tYXgoZnJhZ1N0YXRzLmxvYWRlZCwgZnJhZ1N0YXRzLnRvdGFsKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ0xvYWRpbmcgPSBmcmFnU3RhdHMubG9hZGluZztcbiAgICB2YXIgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcblxuICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgLy8gYWRkIHRvIGZyYWdtZW50IGxvYWRlciBsYXRlbmN5XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCArPSBwYXJ0TG9hZGluZy5maXJzdCAtIHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnTG9hZGluZy5zdGFydCA9IHBhcnRMb2FkaW5nLnN0YXJ0O1xuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgPSBwYXJ0TG9hZGluZy5maXJzdDtcbiAgICB9XG5cbiAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TG9hZGVyID0gZnVuY3Rpb24gcmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZyYWdtZW50TG9hZGVyO1xufSgpO1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0KSB7XG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICB2YXIgbG9hZGVyQ29udGV4dCA9IHtcbiAgICBmcmFnOiBmcmFnLFxuICAgIHBhcnQ6IHBhcnQsXG4gICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgcmFuZ2VTdGFydDogMCxcbiAgICByYW5nZUVuZDogMFxuICB9O1xuICB2YXIgc3RhcnQgPSBzZWdtZW50LmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICB2YXIgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG5cbiAgaWYgKE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzdGFydCkgJiYgT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGVuZCkpIHtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gZW5kO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5cbnZhciBMb2FkRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShMb2FkRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gTG9hZEVycm9yKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwYXJhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9FcnJvci5jYWxsLmFwcGx5KF9FcnJvciwgW3RoaXNdLmNvbmNhdChwYXJhbXMpKSB8fCB0aGlzO1xuICAgIF90aGlzMy5kYXRhID0gdm9pZCAwO1xuICAgIF90aGlzMy5kYXRhID0gZGF0YTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgcmV0dXJuIExvYWRFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsIEJhc2VTZWdtZW50LCBkZWZhdWx0LCBQYXJ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEVsZW1lbnRhcnlTdHJlYW1UeXBlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQmFzZVNlZ21lbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBCYXNlU2VnbWVudDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZyYWdtZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQYXJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGFydDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXJsLXRvb2xraXQgKi8gXCIuL25vZGVfbW9kdWxlcy91cmwtdG9vbGtpdC9zcmMvdXJsLXRvb2xraXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1rZXkgKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvYWQtc3RhdHMgKi8gXCIuL3NyYy9sb2FkZXIvbG9hZC1zdGF0cy50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxudmFyIEVsZW1lbnRhcnlTdHJlYW1UeXBlcztcblxuKGZ1bmN0aW9uIChFbGVtZW50YXJ5U3RyZWFtVHlwZXMpIHtcbiAgRWxlbWVudGFyeVN0cmVhbVR5cGVzW1wiQVVESU9cIl0gPSBcImF1ZGlvXCI7XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlc1tcIlZJREVPXCJdID0gXCJ2aWRlb1wiO1xuICBFbGVtZW50YXJ5U3RyZWFtVHlwZXNbXCJBVURJT1ZJREVPXCJdID0gXCJhdWRpb3ZpZGVvXCI7XG59KShFbGVtZW50YXJ5U3RyZWFtVHlwZXMgfHwgKEVsZW1lbnRhcnlTdHJlYW1UeXBlcyA9IHt9KSk7XG5cbnZhciBCYXNlU2VnbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGJhc2V1cmwgaXMgdGhlIFVSTCB0byB0aGUgcGxheWxpc3RcbiAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXG4gIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgZnVuY3Rpb24gQmFzZVNlZ21lbnQoYmFzZXVybCkge1xuICAgIHZhciBfdGhpcyRlbGVtZW50YXJ5U3RyZWE7XG5cbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSAoX3RoaXMkZWxlbWVudGFyeVN0cmVhID0ge30sIF90aGlzJGVsZW1lbnRhcnlTdHJlYVtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsLCBfdGhpcyRlbGVtZW50YXJ5U3RyZWFbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhKTtcbiAgICB0aGlzLmJhc2V1cmwgPSBiYXNldXJsO1xuICB9IC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG5cblxuICB2YXIgX3Byb3RvID0gQmFzZVNlZ21lbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXRCeXRlUmFuZ2UgPSBmdW5jdGlvbiBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgdmFyIHBhcmFtcyA9IHZhbHVlLnNwbGl0KCdAJywgMik7XG4gICAgdmFyIGJ5dGVSYW5nZSA9IFtdO1xuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGJ5dGVSYW5nZVswXSA9IHByZXZpb3VzID8gcHJldmlvdXMuYnl0ZVJhbmdlRW5kT2Zmc2V0IDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZVJhbmdlWzBdID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG5cbiAgICBieXRlUmFuZ2VbMV0gPSBwYXJzZUludChwYXJhbXNbMF0pICsgYnl0ZVJhbmdlWzBdO1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IGJ5dGVSYW5nZTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQmFzZVNlZ21lbnQsIFt7XG4gICAga2V5OiBcImJ5dGVSYW5nZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VTdGFydE9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJieXRlUmFuZ2VFbmRPZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gT2JqZWN0KHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJidWlsZEFic29sdXRlVVJMXCJdKSh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdXJsIHx8ICcnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlU2VnbWVudDtcbn0oKTtcblxudmFyIEZyYWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVNlZ21lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRnJhZ21lbnQsIF9CYXNlU2VnbWVudCk7XG5cbiAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zOCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG4gIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gIC8vIGxldmVsa2V5IGlzIHRoZSBFWFQtWC1LRVkgdGhhdCBhcHBsaWVzIHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBUaGUgbGF0ZXN0IFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIGFwcGVuZGVkIHRvIHRoZSBidWZmZXIuXG4gIC8vIFRoZSBzdGFydGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIGVuZGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGZyYWdtZW50LCBhcyBsaXN0ZWQgaW4gdGhlIG1hbmlmZXN0LiBVcGRhdGVkIGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICAvLyBUaGUgbWF4aW11bSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgLy8gVGhlIG1pbmltdW0gZW5kaW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAvLyBMb2FkL3BhcnNlIHRpbWluZyBpbmZvcm1hdGlvblxuICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICBmdW5jdGlvbiBGcmFnbWVudCh0eXBlLCBiYXNldXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVNlZ21lbnQuY2FsbCh0aGlzLCBiYXNldXJsKSB8fCB0aGlzO1xuICAgIF90aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGw7XG4gICAgX3RoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBfdGhpcy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIF90aGlzLnRhZ0xpc3QgPSBbXTtcbiAgICBfdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgX3RoaXMuc24gPSAwO1xuICAgIF90aGlzLmxldmVsa2V5ID0gdm9pZCAwO1xuICAgIF90aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgX3RoaXMubG9hZGVyID0gbnVsbDtcbiAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgIF90aGlzLmNjID0gMDtcbiAgICBfdGhpcy5zdGFydFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuYXBwZW5kZWRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuc3RhcnREVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5kRFRTID0gdm9pZCAwO1xuICAgIF90aGlzLnN0YXJ0ID0gMDtcbiAgICBfdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5tYXhTdGFydFBUUyA9IHZvaWQgMDtcbiAgICBfdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgX3RoaXMuc3RhdHMgPSBuZXcgX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0oKTtcbiAgICBfdGhpcy51cmxJZCA9IDA7XG4gICAgX3RoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICBfdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIF90aGlzLnRpdGxlID0gbnVsbDtcbiAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEZyYWdtZW50LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNlTGV2ZWxQbGF5bGlzdCB0byBjcmVhdGUgYW4gaW5pdGlhbGl6YXRpb24gdmVjdG9yIGZvciBhIGdpdmVuIHNlZ21lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnROdW1iZXIgLSBzZWdtZW50IG51bWJlciB0byBnZW5lcmF0ZSBJViB3aXRoXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgX3Byb3RvMi5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgICAgdWludDhWaWV3W2ldID0gc2VnbWVudE51bWJlciA+PiA4ICogKDE1IC0gaSkgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiB1aW50OFZpZXc7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBwYXJzZUxldmVsUGxheWxpc3QgdG8gZ2V0IGEgZnJhZ21lbnQncyBkZWNyeXB0aW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudGx5IHBhcnNlZCBlbmNyeXB0aW9uIGtleSBkYXRhXG4gICAqIEBwYXJhbSBsZXZlbGtleSAtIGEgcGxheWxpc3QncyBlbmNyeXB0aW9uIGluZm9cbiAgICogQHBhcmFtIHNlZ21lbnROdW1iZXIgLSB0aGUgZnJhZ21lbnQncyBzZWdtZW50IG51bWJlclxuICAgKiBAcmV0dXJucyB7TGV2ZWxLZXl9IC0gYW4gb2JqZWN0IHRvIGJlIGFwcGxpZWQgYXMgYSBmcmFnbWVudCdzIGRlY3J5cHRkYXRhXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi5zZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSA9IGZ1bmN0aW9uIHNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5KGxldmVsa2V5LCBzZWdtZW50TnVtYmVyKSB7XG4gICAgdmFyIGRlY3J5cHRkYXRhID0gbGV2ZWxrZXk7XG5cbiAgICBpZiAoKGxldmVsa2V5ID09PSBudWxsIHx8IGxldmVsa2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZXZlbGtleS5tZXRob2QpID09PSAnQUVTLTEyOCcgJiYgbGV2ZWxrZXkudXJpICYmICFsZXZlbGtleS5pdikge1xuICAgICAgZGVjcnlwdGRhdGEgPSBfbGV2ZWxfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLmZyb21VUkkobGV2ZWxrZXkudXJpKTtcbiAgICAgIGRlY3J5cHRkYXRhLm1ldGhvZCA9IGxldmVsa2V5Lm1ldGhvZDtcbiAgICAgIGRlY3J5cHRkYXRhLml2ID0gdGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihzZWdtZW50TnVtYmVyKTtcbiAgICAgIGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9ICdpZGVudGl0eSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8gPSBmdW5jdGlvbiBzZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh0eXBlLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHBhcnRpYWwgPT09IHZvaWQgMCkge1xuICAgICAgcGFydGlhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgdmFyIGluZm8gPSBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbdHlwZV0gPSB7XG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICAgIHBhcnRpYWw6IHBhcnRpYWxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8gPSBmdW5jdGlvbiBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcImRlY3J5cHRkYXRhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMubGV2ZWxrZXkgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhICYmIHRoaXMubGV2ZWxrZXkpIHtcbiAgICAgICAgdmFyIHNuID0gdGhpcy5zbjtcblxuICAgICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAgIC8vIElmIHRoZSBzZWdtZW50IHdhcyBlbmNyeXB0ZWQgd2l0aCBBRVMtMTI4XG4gICAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgICBpZiAodGhpcy5sZXZlbGtleSAmJiB0aGlzLmxldmVsa2V5Lm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmICF0aGlzLmxldmVsa2V5Lml2KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybihcIm1pc3NpbmcgSVYgZm9yIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgd2l0aCBtZXRob2Q9XFxcIlwiICsgdGhpcy5sZXZlbGtleS5tZXRob2QgKyBcIlxcXCIgLSBjb21wbGlhbmNlIGlzc3VlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKlxuICAgICAgICAgIEJlIGNvbnZlcnRlZCB0byBhIE51bWJlci5cbiAgICAgICAgICAnaW5pdFNlZ21lbnQnIHdpbGwgYmVjb21lIE5hTi5cbiAgICAgICAgICBOYU4sIHdoaWNoIHdoZW4gY29udmVydGVkIHRocm91Z2ggVG9JbnQzMigpIC0+ICswLlxuICAgICAgICAgIC0tLVxuICAgICAgICAgIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICAgICovXG5cblxuICAgICAgICAgIHNuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5zZXREZWNyeXB0RGF0YUZyb21MZXZlbEtleSh0aGlzLmxldmVsa2V5LCBzbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFByb2dyYW1EYXRlVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9ICFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5kdXJhdGlvbikgPyAwIDogdGhpcy5kdXJhdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5jcnlwdGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkZGVjcnlwdGRhdGE7XG5cbiAgICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgICAvLyBDdXJyZW50bHksIGtleUZvcm1hdCB3aWxsIG9ubHkgYmUgc2V0IGZvciBpZGVudGl0eSBrZXlzXG4gICAgICBpZiAoKF90aGlzJGRlY3J5cHRkYXRhID0gdGhpcy5kZWNyeXB0ZGF0YSkgIT09IG51bGwgJiYgX3RoaXMkZGVjcnlwdGRhdGEgIT09IHZvaWQgMCAmJiBfdGhpcyRkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgJiYgdGhpcy5kZWNyeXB0ZGF0YS51cmkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhZ21lbnQ7XG59KEJhc2VTZWdtZW50KTtcblxuXG52YXIgUGFydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTZWdtZW50Mikge1xuICBfaW5oZXJpdHNMb29zZShQYXJ0LCBfQmFzZVNlZ21lbnQyKTtcblxuICBmdW5jdGlvbiBQYXJ0KHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF90aGlzMiA9IF9CYXNlU2VnbWVudDIuY2FsbCh0aGlzLCBiYXNldXJsKSB8fCB0aGlzO1xuICAgIF90aGlzMi5mcmFnT2Zmc2V0ID0gMDtcbiAgICBfdGhpczIuZHVyYXRpb24gPSAwO1xuICAgIF90aGlzMi5nYXAgPSBmYWxzZTtcbiAgICBfdGhpczIuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICBfdGhpczIucmVsdXJsID0gdm9pZCAwO1xuICAgIF90aGlzMi5mcmFnbWVudCA9IHZvaWQgMDtcbiAgICBfdGhpczIuaW5kZXggPSB2b2lkIDA7XG4gICAgX3RoaXMyLnN0YXRzID0gbmV3IF9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKCk7XG4gICAgX3RoaXMyLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIF90aGlzMi5nYXAgPSBwYXJ0QXR0cnMuYm9vbCgnR0FQJyk7XG4gICAgX3RoaXMyLmluZGVwZW5kZW50ID0gcGFydEF0dHJzLklOREVQRU5ERU5UID8gcGFydEF0dHJzLmJvb2woJ0lOREVQRU5ERU5UJykgOiB0cnVlO1xuICAgIF90aGlzMi5yZWx1cmwgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnVVJJJyk7XG4gICAgX3RoaXMyLmZyYWdtZW50ID0gZnJhZztcbiAgICBfdGhpczIuaW5kZXggPSBpbmRleDtcbiAgICB2YXIgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuXG4gICAgaWYgKGJ5dGVSYW5nZSkge1xuICAgICAgX3RoaXMyLnNldEJ5dGVSYW5nZShieXRlUmFuZ2UsIHByZXZpb3VzKTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIF90aGlzMi5mcmFnT2Zmc2V0ID0gcHJldmlvdXMuZnJhZ09mZnNldCArIHByZXZpb3VzLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFydCwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZWxlbWVudGFyeVN0cmVhbXMgPSB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgcmV0dXJuICEhKGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvIHx8IGVsZW1lbnRhcnlTdHJlYW1zLmF1ZGlvdmlkZW8pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJ0O1xufShCYXNlU2VnbWVudCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEtleUxvYWRlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXZlbnRzICovIFwiLi9zcmMvZXZlbnRzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9ycyAqLyBcIi4vc3JjL2Vycm9ycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLypcbiAqIERlY3J5cHQga2V5IExvYWRlclxuICovXG5cblxuXG5cbnZhciBLZXlMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlMb2FkZXIoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXJzID0ge307XG4gICAgdGhpcy5kZWNyeXB0a2V5ID0gbnVsbDtcbiAgICB0aGlzLmRlY3J5cHR1cmwgPSBudWxsO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBLZXlMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLktFWV9MT0FESU5HLCB0aGlzLm9uS2V5TG9hZGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5LRVlfTE9BRElORywgdGhpcy5vbktleUxvYWRpbmcpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG5cbiAgICBmb3IgKHZhciBsb2FkZXJOYW1lIGluIHRoaXMubG9hZGVycykge1xuICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1tsb2FkZXJOYW1lXTtcblxuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9hZGVycyA9IHt9O1xuICB9O1xuXG4gIF9wcm90by5vbktleUxvYWRpbmcgPSBmdW5jdGlvbiBvbktleUxvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICB2YXIgdHlwZSA9IGZyYWcudHlwZTtcbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdO1xuXG4gICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybignTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBMb2FkIHRoZSBrZXkgaWYgdGhlIHVyaSBpcyBkaWZmZXJlbnQgZnJvbSBwcmV2aW91cyBvbmUsIG9yIGlmIHRoZSBkZWNyeXB0IGtleSBoYXMgbm90IHlldCBiZWVuIHJldHJpZXZlZFxuXG5cbiAgICB2YXIgdXJpID0gZnJhZy5kZWNyeXB0ZGF0YS51cmk7XG5cbiAgICBpZiAodXJpICE9PSB0aGlzLmRlY3J5cHR1cmwgfHwgdGhpcy5kZWNyeXB0a2V5ID09PSBudWxsKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKFwiYWJvcnQgcHJldmlvdXMga2V5IGxvYWRlciBmb3IgdHlwZTpcIiArIHR5cGUpO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF1cmkpIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ2tleSB1cmkgaXMgZmFsc3knKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIGNvbnNvbGUubG9nKGNvbmZpZyk7XG4gICAgICB2YXIgZnJhZ0xvYWRlciA9IGZyYWcubG9hZGVyID0gdGhpcy5sb2FkZXJzW3R5cGVdID0gbmV3IExvYWRlciggLy8gY29uZmlnXG4gICAgICBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyksIGNvbmZpZy5rZXlSZXF1ZXN0KSk7XG4gICAgICB0aGlzLmRlY3J5cHR1cmwgPSB1cmk7XG4gICAgICB0aGlzLmRlY3J5cHRrZXkgPSBudWxsO1xuICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIHVybDogdXJpLFxuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcidcbiAgICAgIH07IC8vIG1heFJldHJ5IGlzIDAgc28gdGhhdCBpbnN0ZWFkIG9mIHJldHJ5aW5nIHRoZSBzYW1lIGtleSBvbiB0aGUgc2FtZSB2YXJpYW50IG11bHRpcGxlIHRpbWVzLFxuICAgICAgLy8ga2V5LWxvYWRlciB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgYW5kIHJlbHkgb24gc3RyZWFtLWNvbnRyb2xsZXIgdG8gaGFuZGxlIHJldHJ5IGxvZ2ljLlxuICAgICAgLy8gdGhpcyB3aWxsIGFsc28gYWxpZ24gcmV0cnkgbG9naWMgd2l0aCBmcmFnbWVudC1sb2FkZXJcblxuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgdGltZW91dDogY29uZmlnLmZyYWdMb2FkaW5nVGltZU91dCxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ1JldHJ5RGVsYXksXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IGNvbmZpZy5mcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogMFxuICAgICAgfTtcbiAgICAgIHZhciBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogdGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICBvblRpbWVvdXQ6IHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIGNvbnNvbGUubG9nKCdkYXRhJywgbG9hZGVyQ29uZmlnLCBsb2FkZXJDb250ZXh0KTtcbiAgICAgIGZyYWdMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRlY3J5cHRrZXkpIHtcbiAgICAgIC8vIFJldHVybiB0aGUga2V5IGlmIGl0J3MgYWxyZWFkeSBiZWVuIGxvYWRlZFxuICAgICAgZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSB0aGlzLmRlY3J5cHRrZXk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5LRVlfTE9BREVELCB7XG4gICAgICAgIGZyYWc6IGZyYWdcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZHN1Y2Nlc3MgPSBmdW5jdGlvbiBsb2Fkc3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQpIHtcbiAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZztcblxuICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLmVycm9yKCdhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRlY3J5cHRrZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpOyAvLyBkZXRhY2ggZnJhZ21lbnQgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuXG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5LRVlfTE9BREVELCB7XG4gICAgICBmcmFnOiBmcmFnXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRlcnJvciA9IGZ1bmN0aW9uIGxvYWRlcnJvcihyZXNwb25zZSwgY29udGV4dCkge1xuICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnO1xuICAgIHZhciBsb2FkZXIgPSBmcmFnLmxvYWRlcjtcblxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbZnJhZy50eXBlXTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXJyb3JEZXRhaWxzXCJdLktFWV9MT0FEX0VSUk9SLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZzogZnJhZyxcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KHN0YXRzLCBjb250ZXh0KSB7XG4gICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWc7XG4gICAgdmFyIGxvYWRlciA9IGZyYWcubG9hZGVyO1xuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMubG9hZGVyc1tmcmFnLnR5cGVdO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFcnJvckRldGFpbHNcIl0uS0VZX0xPQURfVElNRU9VVCxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGZyYWc6IGZyYWdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gS2V5TG9hZGVyO1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWRldGFpbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xldmVsLWRldGFpbHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxEZXRhaWxzOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OID0gMTA7XG5cbnZhciBMZXZlbERldGFpbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG4gIGZ1bmN0aW9uIExldmVsRGV0YWlscyhiYXNlVXJsKSB7XG4gICAgdGhpcy5QVFNLbm93biA9IGZhbHNlO1xuICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZENDID0gMDtcbiAgICB0aGlzLmVuZFNOID0gMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50SGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxpdmUgPSB0cnVlO1xuICAgIHRoaXMuYWdlSGVhZGVyID0gMDtcbiAgICB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMubWlzc2VzID0gMDtcbiAgICB0aGlzLm5lZWRTaWR4UmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydENDID0gMDtcbiAgICB0aGlzLnN0YXJ0U04gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRvdGFsZHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5tM3U4ID0gJyc7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLmNhbkJsb2NrUmVsb2FkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5Ta2lwVW50aWwgPSAwO1xuICAgIHRoaXMuY2FuU2tpcERhdGVSYW5nZXMgPSBmYWxzZTtcbiAgICB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDA7XG4gICAgdGhpcy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMucGFydEhvbGRCYWNrID0gMDtcbiAgICB0aGlzLmhvbGRCYWNrID0gMDtcbiAgICB0aGlzLnBhcnRUYXJnZXQgPSAwO1xuICAgIHRoaXMucHJlbG9hZEhpbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwO1xuICAgIHRoaXMudHVuZUluR29hbCA9IDA7XG4gICAgdGhpcy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMZXZlbERldGFpbHMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZWxvYWRlZCA9IGZ1bmN0aW9uIHJlbG9hZGVkKHByZXZpb3VzKSB7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJ0U25EaWZmID0gdGhpcy5sYXN0UGFydFNuIC0gcHJldmlvdXMubGFzdFBhcnRTbjtcbiAgICB2YXIgcGFydEluZGV4RGlmZiA9IHRoaXMubGFzdFBhcnRJbmRleCAtIHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZjtcbiAgICB0aGlzLmFkdmFuY2VkID0gdGhpcy5lbmRTTiA+IHByZXZpb3VzLmVuZFNOIHx8IHBhcnRTbkRpZmYgPiAwIHx8IHBhcnRTbkRpZmYgPT09IDAgJiYgcGFydEluZGV4RGlmZiA+IDA7XG5cbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuXG4gICAgdGhpcy5hdmFpbGFiaWxpdHlEZWxheSA9IHByZXZpb3VzLmF2YWlsYWJpbGl0eURlbGF5O1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMZXZlbERldGFpbHMsIFt7XG4gICAga2V5OiBcImhhc1Byb2dyYW1EYXRlVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxUYXJnZXREdXJhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRFbmQgfHwgdGhpcy5mcmFnbWVudEVuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFydEVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHBhcnRMaXN0O1xuXG4gICAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT09IG51bGwgJiYgX3RoaXMkcGFydExpc3QgIT09IHZvaWQgMCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50RW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcmFnbWVudEVuZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJGZyYWdtZW50cztcblxuICAgICAgaWYgKChfdGhpcyRmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cykgIT09IG51bGwgJiYgX3RoaXMkZnJhZ21lbnRzICE9PSB2b2lkIDAgJiYgX3RoaXMkZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5hZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChEYXRlLm5vdygpIC0gdGhpcy5hZHZhbmNlZERhdGVUaW1lLCAwKSAvIDEwMDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0UGFydEluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3QyO1xuXG4gICAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9PSBudWxsICYmIF90aGlzJHBhcnRMaXN0MiAhPT0gdm9pZCAwICYmIF90aGlzJHBhcnRMaXN0Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0UGFydFNuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuXG4gICAgICBpZiAoKF90aGlzJHBhcnRMaXN0MyA9IHRoaXMucGFydExpc3QpICE9PSBudWxsICYmIF90aGlzJHBhcnRMaXN0MyAhPT0gdm9pZCAwICYmIF90aGlzJHBhcnRMaXN0My5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5mcmFnbWVudC5zbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW5kU047XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsRGV0YWlscztcbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9sZXZlbC1rZXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTGV2ZWxLZXk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxudmFyIExldmVsS2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgTGV2ZWxLZXkuZnJvbVVSTCA9IGZ1bmN0aW9uIGZyb21VUkwoYmFzZVVybCwgcmVsYXRpdmVVcmwpIHtcbiAgICByZXR1cm4gbmV3IExldmVsS2V5KGJhc2VVcmwsIHJlbGF0aXZlVXJsKTtcbiAgfTtcblxuICBMZXZlbEtleS5mcm9tVVJJID0gZnVuY3Rpb24gZnJvbVVSSSh1cmkpIHtcbiAgICByZXR1cm4gbmV3IExldmVsS2V5KHVyaSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTGV2ZWxLZXkoYWJzb2x1dGVPckJhc2VVUkksIHJlbGF0aXZlVVJMKSB7XG4gICAgdGhpcy5fdXJpID0gbnVsbDtcbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSBudWxsO1xuICAgIHRoaXMua2V5SUQgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLml2ID0gbnVsbDtcblxuICAgIGlmIChyZWxhdGl2ZVVSTCkge1xuICAgICAgdGhpcy5fdXJpID0gT2JqZWN0KHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJidWlsZEFic29sdXRlVVJMXCJdKShhYnNvbHV0ZU9yQmFzZVVSSSwgcmVsYXRpdmVVUkwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXJpID0gYWJzb2x1dGVPckJhc2VVUkk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsS2V5LCBbe1xuICAgIGtleTogXCJ1cmlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExldmVsS2V5O1xufSgpO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTG9hZFN0YXRzOyB9KTtcbnZhciBMb2FkU3RhdHMgPSBmdW5jdGlvbiBMb2FkU3RhdHMoKSB7XG4gIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLmxvYWRlZCA9IDA7XG4gIHRoaXMucmV0cnkgPSAwO1xuICB0aGlzLnRvdGFsID0gMDtcbiAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgdGhpcy5id0VzdGltYXRlID0gMDtcbiAgdGhpcy5sb2FkaW5nID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGZpcnN0OiAwLFxuICAgIGVuZDogMFxuICB9O1xuICB0aGlzLnBhcnNpbmcgPSB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG4gIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGZpcnN0OiAwLFxuICAgIGVuZDogMFxuICB9O1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2xvYWRlci9tM3U4LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNM1U4UGFyc2VyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1cmwtdG9vbGtpdCAqLyBcIi4vbm9kZV9tb2R1bGVzL3VybC10b29sa2l0L3NyYy91cmwtdG9vbGtpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB1cmxfdG9vbGtpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHVybF90b29sa2l0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcmFnbWVudCAqLyBcIi4vc3JjL2xvYWRlci9mcmFnbWVudC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGV2ZWxfZGV0YWlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1kZXRhaWxzICovIFwiLi9zcmMvbG9hZGVyL2xldmVsLWRldGFpbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xldmVsX2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sZXZlbC1rZXkgKi8gXCIuL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2F0dHItbGlzdCAqLyBcIi4vc3JjL3V0aWxzL2F0dHItbGlzdC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvZGVjc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY29kZWNzICovIFwiLi9zcmMvdXRpbHMvY29kZWNzLnRzXCIpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tIGlzIHlvdXIgZnJpZW5kXG52YXIgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcblxccl0qKVtcXHJcXG5dKyhbXlxcclxcbl0rKXwjRVhULVgtU0VTU0lPTi1EQVRBOihbXlxcblxccl0qKVtcXHJcXG5dKy9nO1xudmFyIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xudmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSwgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuLyg/ISMpICooXFxTW1xcUyBdKikvLnNvdXJjZSwgLy8gc2VnbWVudCBVUkksIGdyb3VwIDMgPT4gdGhlIFVSSSAobm90ZSBuZXdsaW5lIGlzIG5vdCBlYXRlbilcbi8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4vI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuLyMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJ3wnKSwgJ2cnKTtcbnZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyMoRVhUTTNVKS8uc291cmNlLCAvI0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispLy5zb3VyY2UsIC8jRVhULVgtKE1FRElBLVNFUVVFTkNFKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShTS0lQKTooLispLy5zb3VyY2UsIC8jRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShLRVkpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oU1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oRU5ETElTVCkvLnNvdXJjZSwgLyNFWFQtWC0oRElTQ09OVElOVUlUWS1TRVEpVUVOQ0U6ICooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oRElTKUNPTlRJTlVJVFkvLnNvdXJjZSwgLyNFWFQtWC0oVkVSU0lPTik6KFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKE1BUCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShTRVJWRVItQ09OVFJPTCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShQQVJULUlORik6KC4rKS8uc291cmNlLCAvI0VYVC1YLShHQVApLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEUpOlxccyooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oUEFSVCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShQUkVMT0FELUhJTlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oUkVORElUSU9OLVJFUE9SVCk6KC4rKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbignfCcpKTtcbnZhciBNUDRfUkVHRVhfU1VGRklYID0gL1xcLihtcDR8bTRzfG00dnxtNGEpJC9pO1xuXG52YXIgTTNVOFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE0zVThQYXJzZXIoKSB7fVxuXG4gIE0zVThQYXJzZXIuZmluZEdyb3VwID0gZnVuY3Rpb24gZmluZEdyb3VwKGdyb3VwcywgbWVkaWFHcm91cElkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcblxuICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkgPSBmdW5jdGlvbiBjb252ZXJ0QVZDMVRvQVZDT1RJKGNvZGVjKSB7XG4gICAgdmFyIGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnN1YnN0cigtNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvZGVjO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgTTNVOFBhcnNlci5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gdXJsX3Rvb2xraXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImJ1aWxkQWJzb2x1dGVVUkxcIl0oYmFzZVVybCwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBwYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgYmFzZXVybCkge1xuICAgIHZhciBsZXZlbHMgPSBbXTtcbiAgICB2YXIgc2Vzc2lvbkRhdGEgPSB7fTtcbiAgICB2YXIgaGFzU2Vzc2lvbkRhdGEgPSBmYWxzZTtcbiAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIC8vICcjRVhULVgtU1RSRUFNLUlORicgaXMgZm91bmQsIHBhcnNlIGxldmVsIHRhZyAgaW4gZ3JvdXAgMVxuICAgICAgICB2YXIgYXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXShyZXN1bHRbMV0pO1xuICAgICAgICB2YXIgbGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdCQU5EV0lEVEgnKSxcbiAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FLFxuICAgICAgICAgIHVybDogTTNVOFBhcnNlci5yZXNvbHZlKHJlc3VsdFsyXSwgYmFzZXVybClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuXG4gICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICAgIGxldmVsLmhlaWdodCA9IHJlc29sdXRpb24uaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0Q29kZWNzKChhdHRycy5DT0RFQ1MgfHwgJycpLnNwbGl0KC9bICxdKy8pLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KSwgbGV2ZWwpO1xuXG4gICAgICAgIGlmIChsZXZlbC52aWRlb0NvZGVjICYmIGxldmVsLnZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpICE9PSAtMSkge1xuICAgICAgICAgIGxldmVsLnZpZGVvQ29kZWMgPSBNM1U4UGFyc2VyLmNvbnZlcnRBVkMxVG9BVkNPVEkobGV2ZWwudmlkZW9Db2RlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAvLyAnI0VYVC1YLVNFU1NJT04tREFUQScgaXMgZm91bmQsIHBhcnNlIHNlc3Npb24gZGF0YSBpbiBncm91cCAzXG4gICAgICAgIHZhciBzZXNzaW9uQXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXShyZXN1bHRbM10pO1xuXG4gICAgICAgIGlmIChzZXNzaW9uQXR0cnNbJ0RBVEEtSUQnXSkge1xuICAgICAgICAgIGhhc1Nlc3Npb25EYXRhID0gdHJ1ZTtcbiAgICAgICAgICBzZXNzaW9uRGF0YVtzZXNzaW9uQXR0cnNbJ0RBVEEtSUQnXV0gPSBzZXNzaW9uQXR0cnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICBzZXNzaW9uRGF0YTogaGFzU2Vzc2lvbkRhdGEgPyBzZXNzaW9uRGF0YSA6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhID0gZnVuY3Rpb24gcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgYmFzZXVybCwgdHlwZSwgZ3JvdXBzKSB7XG4gICAgaWYgKGdyb3VwcyA9PT0gdm9pZCAwKSB7XG4gICAgICBncm91cHMgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBtZWRpYXMgPSBbXTtcbiAgICB2YXIgaWQgPSAwO1xuICAgIE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ocmVzdWx0WzFdKTtcblxuICAgICAgaWYgKGF0dHJzLlRZUEUgPT09IHR5cGUpIHtcbiAgICAgICAgdmFyIG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzOiBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGF0dHJzWydHUk9VUC1JRCddLFxuICAgICAgICAgIGluc3RyZWFtSWQ6IGF0dHJzWydJTlNUUkVBTS1JRCddLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUgfHwgYXR0cnMuTEFOR1VBR0UgfHwgJycsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBkZWZhdWx0OiBhdHRycy5ib29sKCdERUZBVUxUJyksXG4gICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgIGZvcmNlZDogYXR0cnMuYm9vbCgnRk9SQ0VEJyksXG4gICAgICAgICAgbGFuZzogYXR0cnMuTEFOR1VBR0UsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICB2YXIgZ3JvdXBDb2RlYyA9IE0zVThQYXJzZXIuZmluZEdyb3VwKGdyb3VwcywgbWVkaWEuZ3JvdXBJZCkgfHwgZ3JvdXBzWzBdO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAnYXVkaW9Db2RlYycpO1xuICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lZGlhcztcbiAgfTtcblxuICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkKSB7XG4gICAgdmFyIGxldmVsID0gbmV3IF9sZXZlbF9kZXRhaWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKGJhc2V1cmwpO1xuICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbC5mcmFnbWVudHM7XG4gICAgdmFyIGN1cnJlbnRTTiA9IDA7XG4gICAgdmFyIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgdmFyIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICB2YXIgcHJldkZyYWcgPSBudWxsO1xuICAgIHZhciBmcmFnID0gbmV3IF9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSh0eXBlLCBiYXNldXJsKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBpO1xuICAgIHZhciBsZXZlbGtleTtcbiAgICB2YXIgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcblxuICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgIC8vIElORlxuICAgICAgICBmcmFnLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbik7IC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcblxuICAgICAgICB2YXIgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgZnJhZy50aXRsZSA9IHRpdGxlIHx8IG51bGw7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHRpdGxlID8gWydJTkYnLCBkdXJhdGlvbiwgdGl0bGVdIDogWydJTkYnLCBkdXJhdGlvbl0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgLy8gdXJsXG4gICAgICAgIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcblxuICAgICAgICAgIGlmIChsZXZlbGtleSkge1xuICAgICAgICAgICAgZnJhZy5sZXZlbGtleSA9IGxldmVsa2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICBmcmFnLnVybElkID0gbGV2ZWxVcmxJZDtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnKTsgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuXG4gICAgICAgICAgZnJhZy5yZWx1cmwgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgICAgIHByZXZGcmFnID0gZnJhZztcbiAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY3VycmVudFNOKys7XG4gICAgICAgICAgY3VycmVudFBhcnQgPSAwO1xuICAgICAgICAgIGZyYWcgPSBuZXcgX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHR5cGUsIGJhc2V1cmwpOyAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG5cbiAgICAgICAgICBmcmFnLnN0YXJ0ID0gdG90YWxkdXJhdGlvbjtcbiAgICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgIC8vIFgtQllURVJBTkdFXG4gICAgICAgIHZhciBkYXRhID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG5cbiAgICAgICAgaWYgKHByZXZGcmFnKSB7XG4gICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs1XSkge1xuICAgICAgICAvLyBQUk9HUkFNLURBVEUtVElNRVxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gKCcgJyArIHJlc3VsdFs1XSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnUFJPR1JBTS1EQVRFLVRJTUUnLCBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZV0pO1xuXG4gICAgICAgIGlmIChmaXJzdFBkdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJsb2dnZXJcIl0ud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG5cblxuICAgICAgICB2YXIgdGFnID0gKCcgJyArIHJlc3VsdFtpXSkuc2xpY2UoMSk7XG4gICAgICAgIHZhciB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgIHZhciB2YWx1ZTIgPSByZXN1bHRbaSArIDJdID8gKCcgJyArIHJlc3VsdFtpICsgMl0pLnNsaWNlKDEpIDogJyc7XG5cbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1NLSVAnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgc2tpcEF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgdmFyIHNraXBwZWRTZWdtZW50cyA9IHNraXBBdHRycy5kZWNpbWFsSW50ZWdlcignU0tJUFBFRC1TRUdNRU5UUycpO1xuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnNraXBwZWRTZWdtZW50cyA9IHNraXBwZWRTZWdtZW50czsgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnRTTiArPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcblxuICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgbGV2ZWwudGFyZ2V0ZHVyYXRpb24gPSBwYXJzZUZsb2F0KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgbGV2ZWwudmVyc2lvbiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VYVE0zVSc6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgbGV2ZWwubGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRElTJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICBjYXNlICdHQVAnOlxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZ10pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfa2V5QXR0cnMkZW51bWVyYXRlZFM7XG5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gICAgICAgICAgICAgIHZhciBrZXlBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0bWV0aG9kID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnTUVUSE9EJyk7XG4gICAgICAgICAgICAgIHZhciBkZWNyeXB0dXJpID0ga2V5QXR0cnMuVVJJO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdGl2ID0ga2V5QXR0cnMuaGV4YWRlY2ltYWxJbnRlZ2VyKCdJVicpO1xuICAgICAgICAgICAgICB2YXIgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuZW51bWVyYXRlZFN0cmluZygnS0VZRk9STUFUVkVSU0lPTlMnKTtcbiAgICAgICAgICAgICAgdmFyIGRlY3J5cHRrZXlpZCA9IGtleUF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0tFWUlEJyk7IC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cblxuICAgICAgICAgICAgICB2YXIgZGVjcnlwdGtleWZvcm1hdCA9IChfa2V5QXR0cnMkZW51bWVyYXRlZFMgPSBrZXlBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdLRVlGT1JNQVQnKSkgIT0gbnVsbCA/IF9rZXlBdHRycyRlbnVtZXJhdGVkUyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICAgIHZhciB1bnN1cHBvcnRlZEtub3duS2V5Zm9ybWF0c0luTWFuaWZlc3QgPSBbJ2NvbS5hcHBsZS5zdHJlYW1pbmdrZXlkZWxpdmVyeScsICdjb20ubWljcm9zb2Z0LnBsYXlyZWFkeScsICd1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWQnLCAvLyB3aWRldmluZSAodjIpXG4gICAgICAgICAgICAgICdjb20ud2lkZXZpbmUnIC8vIGVhcmxpZXIgd2lkZXZpbmUgKHYxKVxuICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgIGlmICh1bnN1cHBvcnRlZEtub3duS2V5Zm9ybWF0c0luTWFuaWZlc3QuaW5kZXhPZihkZWNyeXB0a2V5Zm9ybWF0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oXCJLZXlmb3JtYXQgXCIgKyBkZWNyeXB0a2V5Zm9ybWF0ICsgXCIgaXMgbm90IHN1cHBvcnRlZCBmcm9tIHRoZSBtYW5pZmVzdFwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNyeXB0a2V5Zm9ybWF0ICE9PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN1cHBvc2VkIHRvIHNraXAga2V5cyB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIC8vIEFzIHdlIGN1cnJlbnRseSBvbmx5IG9mZmljaWFsbHkgc3VwcG9ydCBpZGVudGl0eSBrZXlzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgbWFuaWZlc3Qgd2Ugc2hvdWxkbid0IHNhdmUgYW55IG90aGVyIGtleS5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSAvLyBUT0RPOiBtdWx0aXBsZSBrZXlzIGNhbiBiZSBkZWZpbmVkIG9uIGEgZnJhZ21lbnQsIGFuZCB3ZSBuZWVkIHRvIHN1cHBvcnQgdGhpc1xuICAgICAgICAgICAgICAvLyBmb3IgY2xpZW50cyB0aGF0IHN1cHBvcnQgYm90aCBwbGF5cmVhZHkgYW5kIHdpZGV2aW5lXG5cblxuICAgICAgICAgICAgICBpZiAoZGVjcnlwdG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsZXZlbCBrZXkgaXMgYWN0dWFsbHkgYSByZWxhdGl2ZSBVUkxcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpc24ndCwgdGhlbiB3ZSBzaG91bGQgaW5zdGVhZCBjb25zdHJ1Y3QgdGhlIExldmVsS2V5IHVzaW5nIGZyb21VUkkuXG4gICAgICAgICAgICAgICAgbGV2ZWxrZXkgPSBfbGV2ZWxfa2V5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLmZyb21VUkwoYmFzZXVybCwgZGVjcnlwdHVyaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdHVyaSAmJiBbJ0FFUy0xMjgnLCAnU0FNUExFLUFFUycsICdTQU1QTEUtQUVTLUNFTkMnXS5pbmRleE9mKGRlY3J5cHRtZXRob2QpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lm1ldGhvZCA9IGRlY3J5cHRtZXRob2Q7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleS5rZXlGb3JtYXQgPSBkZWNyeXB0a2V5Zm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdGtleWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleUlEID0gZGVjcnlwdGtleWlkO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsa2V5LmtleUZvcm1hdFZlcnNpb25zID0gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zO1xuICAgICAgICAgICAgICAgICAgfSAvLyBJbml0aWFsaXphdGlvbiBWZWN0b3IgKElWKVxuXG5cbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5Lml2ID0gZGVjcnlwdGl2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKHZhbHVlMSk7XG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpOyAvLyBUSU1FLU9GRlNFVCBjYW4gYmUgMFxuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGxldmVsLnN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnTUFQJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIG1hcEF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hcEF0dHJzLkJZVEVSQU5HRSkge1xuICAgICAgICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKG1hcEF0dHJzLkJZVEVSQU5HRSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgICAgIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuXG4gICAgICAgICAgICAgIGlmIChsZXZlbGtleSkge1xuICAgICAgICAgICAgICAgIGZyYWcubGV2ZWxrZXkgPSBsZXZlbGtleTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldmVsLmluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgZnJhZyA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0odHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbGV2ZWwuaW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ1NFUlZFUi1DT05UUk9MJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHNlcnZlckNvbnRyb2xBdHRycyA9IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKHZhbHVlMSk7XG4gICAgICAgICAgICAgIGxldmVsLmNhbkJsb2NrUmVsb2FkID0gc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1CTE9DSy1SRUxPQUQnKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0NBTi1TS0lQLVVOVElMJywgMCk7XG4gICAgICAgICAgICAgIGxldmVsLmNhblNraXBEYXRlUmFuZ2VzID0gbGV2ZWwuY2FuU2tpcFVudGlsID4gMCAmJiBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLVNLSVAtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICBsZXZlbC5wYXJ0SG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnUEFSVC1IT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnUEFSVC1JTkYnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFydEluZkF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3Q7XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c0ZyYWdtZW50UGFydCA9IGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IG5ldyBfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIlBhcnRcIl0obmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odmFsdWUxKSwgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzRnJhZ21lbnRQYXJ0KTtcbiAgICAgICAgICAgICAgcGFydExpc3QucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiArPSBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcmVsb2FkSGludEF0dHJzID0gbmV3IF91dGlsc19hdHRyX2xpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0odmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucHJlbG9hZEhpbnQgPSBwcmVsb2FkSGludEF0dHJzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ1JFTkRJVElPTi1SRVBPUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVuZGl0aW9uUmVwb3J0QXR0cnMgPSBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSh2YWx1ZTEpO1xuICAgICAgICAgICAgICBsZXZlbC5yZW5kaXRpb25SZXBvcnRzID0gbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyB8fCBbXTtcbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wibG9nZ2VyXCJdLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZGcmFnICYmICFwcmV2RnJhZy5yZWx1cmwpIHtcbiAgICAgIGZyYWdtZW50cy5wb3AoKTtcbiAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG4gICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIHZhciBmaXJzdEZyYWdtZW50ID0gZnJhZ21lbnRzWzBdO1xuICAgIHZhciBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgaWYgKHRvdGFsZHVyYXRpb24gPiAwICYmIGZyYWdtZW50TGVuZ3RoICYmIGxhc3RGcmFnbWVudCkge1xuICAgICAgbGV2ZWwuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbiAvIGZyYWdtZW50TGVuZ3RoO1xuICAgICAgdmFyIGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcblxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG5cbiAgICAgICAgaWYgKCFsZXZlbC5pbml0U2VnbWVudCkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBiaXQgbHVya3kgYnV0IEhMUyByZWFsbHkgaGFzIG5vIG90aGVyIHdheSB0byB0ZWxsIHVzXG4gICAgICAgICAgLy8gaWYgdGhlIGZyYWdtZW50cyBhcmUgVFMgb3IgTVA0LCBleGNlcHQgaWYgd2UgZG93bmxvYWQgdGhlbSA6L1xuICAgICAgICAgIC8vIGJ1dCB0aGlzIGlzIHRvIGJlIGFibGUgdG8gaGFuZGxlIFNJRFguXG4gICAgICAgICAgaWYgKGxldmVsLmZyYWdtZW50cy5ldmVyeShmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgICAgcmV0dXJuIE1QNF9SRUdFWF9TVUZGSVgudGVzdChmcmFnLnJlbHVybCk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImxvZ2dlclwiXS53YXJuKCdNUDQgZnJhZ21lbnRzIGZvdW5kIGJ1dCBubyBpbml0IHNlZ21lbnQgKHByb2JhYmx5IG5vIE1BUCwgaW5jb21wbGV0ZSBNM1U4KSwgdHJ5aW5nIHRvIGZldGNoIFNJRFgnKTtcbiAgICAgICAgICAgIGZyYWcgPSBuZXcgX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSBsYXN0RnJhZ21lbnQucmVsdXJsO1xuICAgICAgICAgICAgZnJhZy5sZXZlbCA9IGlkO1xuICAgICAgICAgICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gICAgICAgICAgICBsZXZlbC5pbml0U2VnbWVudCA9IGZyYWc7XG4gICAgICAgICAgICBsZXZlbC5uZWVkU2lkeFJhbmdlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cblxuICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5mcmFnbWVudEhpbnQuZHVyYXRpb247XG4gICAgfVxuXG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAvKipcbiAgICAgKiBCYWNrZmlsbCBhbnkgbWlzc2luZyBQRFQgdmFsdWVzXG4gICAgICogXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAqIG9uZSBvciBtb3JlIE1lZGlhIFNlZ21lbnQgVVJJcywgdGhlIGNsaWVudCBTSE9VTEQgZXh0cmFwb2xhdGVcbiAgICAgKiBiYWNrd2FyZCBmcm9tIHRoYXQgdGFnICh1c2luZyBFWFRJTkYgZHVyYXRpb25zIGFuZC9vciBtZWRpYVxuICAgICAqIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICogV2UgaGF2ZSBhbHJlYWR5IGV4dHJhcG9sYXRlZCBmb3J3YXJkLCBidXQgYWxsIGZyYWdtZW50cyB1cCB0byB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgUERUIGRvIG5vdCBoYXZlIHRoZWlyIFBEVHNcbiAgICAgKiBjb21wdXRlZC5cbiAgICAgKi9cblxuICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9O1xuXG4gIHJldHVybiBNM1U4UGFyc2VyO1xufSgpO1xuXG5cblxuZnVuY3Rpb24gc2V0Q29kZWNzKGNvZGVjcywgbGV2ZWwpIHtcbiAgWyd2aWRlbycsICdhdWRpbycsICd0ZXh0J10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KF91dGlsc19jb2RlY3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImlzQ29kZWNUeXBlXCJdKShjb2RlYywgdHlwZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcHJlZmVycmVkID0gZmlsdGVyZWQuZmlsdGVyKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4gY29kZWMubGFzdEluZGV4T2YoJ2F2YzEnLCAwKSA9PT0gMCB8fCBjb2RlYy5sYXN0SW5kZXhPZignbXA0YScsIDApID09PSAwO1xuICAgICAgfSk7XG4gICAgICBsZXZlbFt0eXBlICsgXCJDb2RlY1wiXSA9IHByZWZlcnJlZC5sZW5ndGggPiAwID8gcHJlZmVycmVkWzBdIDogZmlsdGVyZWRbMF07IC8vIHJlbW92ZSBmcm9tIGxpc3RcblxuICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgdmFyIGNvZGVjVmFsdWUgPSBncm91cEl0ZW1bY29kZWNQcm9wZXJ0eV07XG5cbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCkge1xuICB2YXIgZnJhZ1ByZXYgPSBmcmFnbWVudHNbZmlyc3RQZHRJbmRleF07XG5cbiAgZm9yICh2YXIgaSA9IGZpcnN0UGR0SW5kZXg7IGktLTspIHtcbiAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tpXTsgLy8gRXhpdCBvbiBkZWx0YS1wbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG5cbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSAtIGZyYWcuZHVyYXRpb24gKiAxMDAwO1xuICAgIGZyYWdQcmV2ID0gZnJhZztcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgfSBlbHNlIGlmIChwcmV2RnJhZyAhPT0gbnVsbCAmJiBwcmV2RnJhZyAhPT0gdm9pZCAwICYmIHByZXZGcmFnLnByb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICB9XG5cbiAgaWYgKCFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbG9hZGVyL3BsYXlsaXN0LWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ldmVudHMgKi8gXCIuL3NyYy9ldmVudHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3JzICovIFwiLi9zcmMvZXJyb3JzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2xvZ2dlciAqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tcDQtdG9vbHMgKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL20zdTgtcGFyc2VyICovIFwiLi9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3R5cGVzL2xvYWRlciAqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9hdHRyLWxpc3QgKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIik7XG5cblxuXG4vKipcbiAqIFBsYXlsaXN0TG9hZGVyIC0gZGVsZWdhdGUgZm9yIG1lZGlhIG1hbmlmZXN0L3BsYXlsaXN0IGxvYWRpbmcgdGFza3MuIFRha2VzIGNhcmUgb2YgcGFyc2luZyBtZWRpYSB0byBpbnRlcm5hbCBkYXRhLW1vZGVscy5cbiAqXG4gKiBPbmNlIGxvYWRlZCwgZGlzcGF0Y2hlcyBldmVudHMgd2l0aCBwYXJzZWQgZGF0YS1tb2RlbHMgb2YgbWFuaWZlc3QvbGV2ZWxzL2F1ZGlvL3N1YnRpdGxlIHRyYWNrcy5cbiAqXG4gKiBVc2VzIGxvYWRlcihzKSBzZXQgaW4gY29uZmlnIHRvIGRvIGFjdHVhbCBpbnRlcm5hbCBsb2FkaW5nIG9mIHJlc291cmNlIHRhc2tzLlxuICpcbiAqIEBtb2R1bGVcbiAqXG4gKi9cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBtYXBDb250ZXh0VG9MZXZlbFR5cGUoY29udGV4dCkge1xuICB2YXIgdHlwZSA9IGNvbnRleHQudHlwZTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0s6XG4gICAgICByZXR1cm4gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uQVVESU87XG5cbiAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RMZXZlbFR5cGVcIl0uU1VCVElUTEU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0TGV2ZWxUeXBlXCJdLk1BSU47XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpIHtcbiAgdmFyIHVybCA9IHJlc3BvbnNlLnVybDsgLy8gcmVzcG9uc2VVUkwgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzIChpdCBpcyB1c2VkIHRvIGRldGVjdCBVUkwgcmVkaXJlY3Rpb24pXG4gIC8vIGRhdGEtdXJpIG1vZGUgYWxzbyBub3Qgc3VwcG9ydGVkIChidXQgbm8gbmVlZCB0byBkZXRlY3QgcmVkaXJlY3Rpb24pXG5cbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbnZhciBQbGF5bGlzdExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYXlsaXN0TG9hZGVyKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jaGVja0FnZUhlYWRlciA9IHRydWU7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpIHtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHZhciBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgdmFyIExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgdmFyIEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgdmFyIGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpO1xuICAgIGNvbnRleHQubG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH07XG5cbiAgX3Byb3RvLmdldEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24gZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXN0cm95SW50ZXJuYWxMb2FkZXJzID0gZnVuY3Rpb24gZGVzdHJveUludGVybmFsTG9hZGVycygpIHtcbiAgICBmb3IgKHZhciBjb250ZXh0VHlwZSBpbiB0aGlzLmxvYWRlcnMpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuXG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfTtcblxuICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHZhciB1cmwgPSBkYXRhLnVybDtcbiAgICB0aGlzLmNoZWNrQWdlSGVhZGVyID0gdHJ1ZTtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBncm91cElkOiBudWxsLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgbGV2ZWwgPSBkYXRhLmxldmVsLFxuICAgICAgICB1cmwgPSBkYXRhLnVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGdyb3VwSWQ6IG51bGwsXG4gICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTEVWRUwsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQXVkaW9UcmFja0xvYWRpbmcgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0ssXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uU3VidGl0bGVUcmFja0xvYWRpbmcgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogaWQsXG4gICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0ssXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQpIHtcbiAgICB2YXIgX2NvbnRleHQkZGVsaXZlcnlEaXJlO1xuXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZzsgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogTG9hZGluZyBwbGF5bGlzdCBvZiB0eXBlICR7Y29udGV4dC50eXBlfSwgbGV2ZWw6ICR7Y29udGV4dC5sZXZlbH0sIGlkOiAke2NvbnRleHQuaWR9YCk7XG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuXG4gICAgdmFyIGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuXG4gICAgICBpZiAobG9hZGVyQ29udGV4dCAmJiBsb2FkZXJDb250ZXh0LnVybCA9PT0gY29udGV4dC51cmwpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0udHJhY2UoJ1twbGF5bGlzdC1sb2FkZXJdOiBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogXCIgKyBjb250ZXh0LnR5cGUpO1xuICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgdmFyIG1heFJldHJ5O1xuICAgIHZhciB0aW1lb3V0O1xuICAgIHZhciByZXRyeURlbGF5O1xuICAgIHZhciBtYXhSZXRyeURlbGF5OyAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG5cbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLk1BTklGRVNUOlxuICAgICAgICBtYXhSZXRyeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeTtcbiAgICAgICAgdGltZW91dCA9IGNvbmZpZy5tYW5pZmVzdExvYWRpbmdUaW1lT3V0O1xuICAgICAgICByZXRyeURlbGF5ID0gY29uZmlnLm1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk7XG4gICAgICAgIG1heFJldHJ5RGVsYXkgPSBjb25maWcubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkxFVkVMOlxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkFVRElPX1RSQUNLOlxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICAvLyBNYW5hZ2UgcmV0cmllcyBpbiBMZXZlbC9UcmFjayBDb250cm9sbGVyXG4gICAgICAgIG1heFJldHJ5ID0gMDtcbiAgICAgICAgdGltZW91dCA9IGNvbmZpZy5sZXZlbExvYWRpbmdUaW1lT3V0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWF4UmV0cnkgPSBjb25maWcubGV2ZWxMb2FkaW5nTWF4UmV0cnk7XG4gICAgICAgIHRpbWVvdXQgPSBjb25maWcubGV2ZWxMb2FkaW5nVGltZU91dDtcbiAgICAgICAgcmV0cnlEZWxheSA9IGNvbmZpZy5sZXZlbExvYWRpbmdSZXRyeURlbGF5O1xuICAgICAgICBtYXhSZXRyeURlbGF5ID0gY29uZmlnLmxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTsgLy8gT3ZlcnJpZGUgbGV2ZWwvdHJhY2sgdGltZW91dCBmb3IgTEwtSExTIHJlcXVlc3RzXG4gICAgLy8gKHRoZSBkZWZhdWx0IG9mIDEwMDAwbXMgaXMgY291bnRlciBwcm9kdWN0aXZlIHRvIGJsb2NraW5nIHBsYXlsaXN0IHJlbG9hZCByZXF1ZXN0cylcblxuICAgIGlmICgoX2NvbnRleHQkZGVsaXZlcnlEaXJlID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpICE9PSBudWxsICYmIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZSAhPT0gdm9pZCAwICYmIF9jb250ZXh0JGRlbGl2ZXJ5RGlyZS5wYXJ0KSB7XG4gICAgICB2YXIgbGV2ZWxEZXRhaWxzO1xuXG4gICAgICBpZiAoY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLkxFVkVMICYmIGNvbnRleHQubGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMubGV2ZWxzW2NvbnRleHQubGV2ZWxdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5BVURJT19UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5TVUJUSVRMRV9UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW2NvbnRleHQuaWRdLmRldGFpbHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgdmFyIHBhcnRUYXJnZXQgPSBsZXZlbERldGFpbHMucGFydFRhcmdldDtcbiAgICAgICAgdmFyIHRhcmdldER1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuXG4gICAgICAgIGlmIChwYXJ0VGFyZ2V0ICYmIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgdGltZW91dCA9IE1hdGgubWluKE1hdGgubWF4KHBhcnRUYXJnZXQgKiAzLCB0YXJnZXREdXJhdGlvbiAqIDAuOCkgKiAxMDAwLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgbWF4UmV0cnk6IG1heFJldHJ5LFxuICAgICAgcmV0cnlEZWxheTogcmV0cnlEZWxheSxcbiAgICAgIG1heFJldHJ5RGVsYXk6IG1heFJldHJ5RGVsYXksXG4gICAgICBoaWdoV2F0ZXJNYXJrOiAwXG4gICAgfTtcbiAgICB2YXIgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgb25TdWNjZXNzOiB0aGlzLmxvYWRzdWNjZXNzLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLmxvYWRlcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25UaW1lb3V0OiB0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcylcbiAgICB9OyAvLyBsb2dnZXIuZGVidWcoYFtwbGF5bGlzdC1sb2FkZXJdOiBDYWxsaW5nIGludGVybmFsIGxvYWRlciBkZWxlZ2F0ZSBmb3IgVVJMOiAke2NvbnRleHQudXJsfWApO1xuXG4gICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICB9O1xuXG4gIF9wcm90by5sb2Fkc3VjY2VzcyA9IGZ1bmN0aW9uIGxvYWRzdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgbmV0d29ya0RldGFpbHMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmlzU2lkeFJlcXVlc3QpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2lkeFJlcXVlc3QocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dC50eXBlKTtcbiAgICB2YXIgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTsgLy8gVmFsaWRhdGUgaWYgaXQgaXMgYW4gTTNVOCBhdCBhbGxcblxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnbm8gRVhUTTNVIGRlbGltaXRlcicsIG5ldHdvcmtEZXRhaWxzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIENoZWNrIGlmIGNodW5rLWxpc3Qgb3IgbWFzdGVyLiBoYW5kbGUgZW1wdHkgY2h1bmsgbGlzdCBjYXNlIChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcblxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVElORjonKSA+IDAgfHwgc3RyaW5nLmluZGV4T2YoJyNFWFQtWC1UQVJHRVREVVJBVElPTjonKSA+IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkZXJyb3IgPSBmdW5jdGlvbiBsb2FkZXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgaWYgKG5ldHdvcmtEZXRhaWxzID09PSB2b2lkIDApIHtcbiAgICAgIG5ldHdvcmtEZXRhaWxzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlKTtcbiAgfTtcblxuICBfcHJvdG8ubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiBsb2FkdGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICBpZiAobmV0d29ya0RldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgbmV0d29ya0RldGFpbHMgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlTWFzdGVyUGxheWxpc3QgPSBmdW5jdGlvbiBoYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgIHZhciBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuICAgIHZhciB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG5cbiAgICB2YXIgX00zVThQYXJzZXIkcGFyc2VNYXN0ID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCB1cmwpLFxuICAgICAgICBsZXZlbHMgPSBfTTNVOFBhcnNlciRwYXJzZU1hc3QubGV2ZWxzLFxuICAgICAgICBzZXNzaW9uRGF0YSA9IF9NM1U4UGFyc2VyJHBhcnNlTWFzdC5zZXNzaW9uRGF0YTtcblxuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgJ25vIGxldmVsIGZvdW5kIGluIG1hbmlmZXN0JywgbmV0d29ya0RldGFpbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbXVsdGkgbGV2ZWwgcGxheWxpc3QsIHBhcnNlIGxldmVsIGluZm9cblxuXG4gICAgdmFyIGF1ZGlvR3JvdXBzID0gbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlY1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgc3VidGl0bGVHcm91cHMgPSBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgdGV4dENvZGVjOiBsZXZlbC50ZXh0Q29kZWNcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gX20zdThfcGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgJ0FVRElPJywgYXVkaW9Hcm91cHMpO1xuICAgIHZhciBzdWJ0aXRsZXMgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCAnU1VCVElUTEVTJywgc3VidGl0bGVHcm91cHMpO1xuICAgIHZhciBjYXB0aW9ucyA9IF9tM3U4X3BhcnNlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsICdDTE9TRUQtQ0FQVElPTlMnKTtcblxuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgcmV0dXJuICFhdWRpb1RyYWNrLnVybDtcbiAgICAgIH0pOyAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2lnbmFsIHRoaXMgbWFpbiBhdWRpbyB0cmFjayB0aGlzIGNvdWxkIGhhcHBlbiB3aXRoIHBsYXlsaXN0cyB3aXRoXG4gICAgICAvLyBhbHQgYXVkaW8gcmVuZGl0aW9uIGluIHdoaWNoIHF1YWxpdHkgbGV2ZWxzIChtYWluKVxuICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG5cbiAgICAgIGlmICghZW1iZWRkZWRBdWRpb0ZvdW5kICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wibG9nZ2VyXCJdLmxvZygnW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScpO1xuICAgICAgICBhdWRpb1RyYWNrcy51bnNoaWZ0KHtcbiAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgbmFtZTogJ21haW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlZDogZmFsc2UsXG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGF0dHJzOiBuZXcgX3V0aWxzX2F0dHJfbGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICB1cmw6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVsczogbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzOiBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9uczogY2FwdGlvbnMsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgIHNlc3Npb25EYXRhOiBzZXNzaW9uRGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgdmFyIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuICAgIHZhciB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgdmFyIGxldmVsVXJsSWQgPSBPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoaWQpID8gaWQgOiAwO1xuICAgIHZhciBsZXZlbElkID0gT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGxldmVsKSA/IGxldmVsIDogbGV2ZWxVcmxJZDtcbiAgICB2YXIgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIHZhciBsZXZlbERldGFpbHMgPSBfbTN1OF9wYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0ucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkKTtcblxuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgICB0eXBlOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvclR5cGVzXCJdLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5MRVZFTF9FTVBUWV9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgcmVhc29uOiAnbm8gZnJhZ21lbnRzIGZvdW5kIGluIGxldmVsJyxcbiAgICAgICAgbGV2ZWw6IHR5cGVvZiBjb250ZXh0LmxldmVsID09PSAnbnVtYmVyJyA/IGNvbnRleHQubGV2ZWwgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxuICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAvLyBXZSBmaXJlIHRoZSBtYW5pZmVzdC1sb2FkZWQgZXZlbnQgYW55d2F5IHdpdGggdGhlIHBhcnNlZCBsZXZlbC1kZXRhaWxzXG4gICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cblxuXG4gICAgaWYgKHR5cGUgPT09IF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uTUFOSUZFU1QpIHtcbiAgICAgIHZhciBzaW5nbGVMZXZlbCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBfdXRpbHNfYXR0cl9saXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdKHt9KSxcbiAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHNlc3Npb25EYXRhOiBudWxsXG4gICAgICB9KTtcbiAgICB9IC8vIHNhdmUgcGFyc2luZyB0aW1lXG5cblxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIGluIGNhc2Ugd2UgbmVlZCBTSURYIHJhbmdlc1xuICAgIC8vIHJldHVybiBlYXJseSBhZnRlciBjYWxsaW5nIGxvYWQgZm9yXG4gICAgLy8gdGhlIFNJRFggYm94LlxuXG4gICAgaWYgKGxldmVsRGV0YWlscy5uZWVkU2lkeFJhbmdlcykge1xuICAgICAgdmFyIHNpZHhVcmwgPSBsZXZlbERldGFpbHMuaW5pdFNlZ21lbnQudXJsO1xuICAgICAgdGhpcy5sb2FkKHtcbiAgICAgICAgdXJsOiBzaWR4VXJsLFxuICAgICAgICBpc1NpZHhSZXF1ZXN0OiB0cnVlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIGxldmVsRGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IG51bGwsXG4gICAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICAgIHJhbmdlRW5kOiAyMDQ4LFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuXG5cbiAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVTaWR4UmVxdWVzdCA9IGZ1bmN0aW9uIGhhbmRsZVNpZHhSZXF1ZXN0KHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIHNpZHhJbmZvID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInBhcnNlU2VnbWVudEluZGV4XCJdKShuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKSk7IC8vIGlmIHByb3ZpZGVkIGZyYWdtZW50IGRvZXMgbm90IGNvbnRhaW4gc2lkeCwgZWFybHkgcmV0dXJuXG5cbiAgICBpZiAoIXNpZHhJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpZHhSZWZlcmVuY2VzID0gc2lkeEluZm8ucmVmZXJlbmNlcztcbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gY29udGV4dC5sZXZlbERldGFpbHM7XG4gICAgc2lkeFJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudFJlZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzZWdSZWZJbmZvID0gc2VnbWVudFJlZi5pbmZvO1xuICAgICAgdmFyIGZyYWcgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKGZyYWcuYnl0ZVJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShTdHJpbmcoMSArIHNlZ1JlZkluZm8uZW5kIC0gc2VnUmVmSW5mby5zdGFydCkgKyAnQCcgKyBTdHJpbmcoc2VnUmVmSW5mby5zdGFydCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldmVsRGV0YWlscy5pbml0U2VnbWVudC5zZXRCeXRlUmFuZ2UoU3RyaW5nKHNpZHhJbmZvLm1vb3ZFbmRPZmZzZXQpICsgJ0AwJyk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIHJlYXNvbiwgbmV0d29ya0RldGFpbHMpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkV2ZW50c1wiXS5FUlJPUiwge1xuICAgICAgdHlwZTogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JUeXBlc1wiXS5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogY29udGV4dC50eXBlID09PSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLk1BTklGRVNULFxuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICByZWFzb246IHJlYXNvbixcbiAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlTmV0d29ya0Vycm9yID0gZnVuY3Rpb24gaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0aW1lb3V0LCByZXNwb25zZSkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVvdXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJsb2dnZXJcIl0ud2FybihcIltwbGF5bGlzdC1sb2FkZXJdOiBBIG5ldHdvcmsgXCIgKyAodGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcicpICsgXCIgb2NjdXJyZWQgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudHlwZSArIFwiIGxldmVsOiBcIiArIGNvbnRleHQubGV2ZWwgKyBcIiBpZDogXCIgKyBjb250ZXh0LmlkICsgXCIgZ3JvdXAtaWQ6IFxcXCJcIiArIGNvbnRleHQuZ3JvdXBJZCArIFwiXFxcIlwiKTtcbiAgICB2YXIgZGV0YWlscyA9IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5VTktOT1dOO1xuICAgIHZhciBmYXRhbCA9IGZhbHNlO1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uTEVWRUxfTE9BRF9USU1FT1VUIDogX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkxFVkVMX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gX2Vycm9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiRXJyb3JEZXRhaWxzXCJdLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5BVURJT19UUkFDS19MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdHlwZXNfbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJQbGF5bGlzdENvbnRleHRUeXBlXCJdLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yRGV0YWlsc1wiXS5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJFcnJvckRldGFpbHNcIl0uU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcIkVycm9yVHlwZXNcIl0uTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICBmYXRhbDogZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgfTtcblxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uRVJST1IsIGVycm9yRGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVBsYXlsaXN0TG9hZGVkID0gZnVuY3Rpb24gaGFuZGxlUGxheWxpc3RMb2FkZWQocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgIHZhciB0eXBlID0gY29udGV4dC50eXBlLFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWwsXG4gICAgICAgIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGNvbnRleHQuZ3JvdXBJZCxcbiAgICAgICAgbG9hZGVyID0gY29udGV4dC5sb2FkZXIsXG4gICAgICAgIGxldmVsRGV0YWlscyA9IGNvbnRleHQubGV2ZWxEZXRhaWxzLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcztcblxuICAgIGlmICghKGxldmVsRGV0YWlscyAhPT0gbnVsbCAmJiBsZXZlbERldGFpbHMgIT09IHZvaWQgMCAmJiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCAnaW52YWxpZCB0YXJnZXQgZHVyYXRpb24nLCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEF2b2lkIHJlcGVhdGVkIGJyb3dzZXIgZXJyb3IgbG9nIGBSZWZ1c2VkIHRvIGdldCB1bnNhZmUgaGVhZGVyIFwiYWdlXCJgIHdoZW4gdW5uZWNlc3Nhcnkgb3IgcGFzdCBhdHRlbXB0cyBmYWlsZWRcblxuXG4gICAgdmFyIGNoZWNrQWdlSGVhZGVyID0gdGhpcy5jaGVja0FnZUhlYWRlciAmJiBsZXZlbERldGFpbHMubGl2ZTtcbiAgICB2YXIgYWdlSGVhZGVyID0gY2hlY2tBZ2VIZWFkZXIgPyBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpIDogbnVsbDtcbiAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogMDtcbiAgICB0aGlzLmNoZWNrQWdlSGVhZGVyID0gISFhZ2VIZWFkZXI7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgX3R5cGVzX2xvYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiUGxheWxpc3RDb250ZXh0VHlwZVwiXS5MRVZFTDpcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihfZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFdmVudHNcIl0uTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uQVVESU9fVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF90eXBlc19sb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIlBsYXlsaXN0Q29udGV4dFR5cGVcIl0uU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiRXZlbnRzXCJdLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoUGxheWxpc3RMb2FkZXIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcG9seWZpbGxzL251bWJlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGlzRmluaXRlTnVtYmVyLCBNQVhfU0FGRV9JTlRFR0VSICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzRmluaXRlTnVtYmVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGaW5pdGVOdW1iZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIk1BWF9TQUZFX0lOVEVHRVJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBNQVhfU0FGRV9JTlRFR0VSOyB9KTtcbnZhciBpc0Zpbml0ZU51bWJlciA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpO1xufTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVtdXgvYWFjLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L2FhYy1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG52YXIgQUFDID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQUFDKCkge31cblxuICBBQUMuZ2V0U2lsZW50RnJhbWUgPSBmdW5jdGlvbiBnZXRTaWxlbnRGcmFtZShjb2RlYywgY2hhbm5lbENvdW50KSB7XG4gICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgY2FzZSAnbXA0YS40MC4yJzpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgwMCwgMHhiMiwgMHgwMCwgMHgyMCwgMHgwOCwgMHhlMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGUgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIEFBQztcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBQUMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIEdlbmVyYXRlIE1QNCBCb3hcbiAqL1xudmFyIFVJTlQzMl9NQVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG52YXIgTVA0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTVA0KCkge31cblxuICBNUDQuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sXG4gICAgICAvLyBjb2RpbmduYW1lXG4gICAgICBhdmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICAnLm1wMyc6IFtdLFxuICAgICAgbXZleDogW10sXG4gICAgICBtdmhkOiBbXSxcbiAgICAgIHBhc3A6IFtdLFxuICAgICAgc2R0cDogW10sXG4gICAgICBzdGJsOiBbXSxcbiAgICAgIHN0Y286IFtdLFxuICAgICAgc3RzYzogW10sXG4gICAgICBzdHNkOiBbXSxcbiAgICAgIHN0c3o6IFtdLFxuICAgICAgc3R0czogW10sXG4gICAgICB0ZmR0OiBbXSxcbiAgICAgIHRmaGQ6IFtdLFxuICAgICAgdHJhZjogW10sXG4gICAgICB0cmFrOiBbXSxcbiAgICAgIHRydW46IFtdLFxuICAgICAgdHJleDogW10sXG4gICAgICB0a2hkOiBbXSxcbiAgICAgIHZtaGQ6IFtdLFxuICAgICAgc21oZDogW11cbiAgICB9O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbaS5jaGFyQ29kZUF0KDApLCBpLmNoYXJDb2RlQXQoMSksIGkuY2hhckNvZGVBdCgyKSwgaS5jaGFyQ29kZUF0KDMpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LCAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4NTYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1ZpZGVvSGFuZGxlcidcbiAgICBdKTtcbiAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDczLCAweDZmLCAweDc1LCAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICBhdWRpbzogYXVkaW9IZGxyXG4gICAgfTtcbiAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYywgLy8gZW50cnlfc2l6ZVxuICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsIC8vICd1cmwnIHR5cGVcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSk7XG4gICAgdmFyIHN0Y28gPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5TVFRTID0gTVA0LlNUU0MgPSBNUDQuU1RDTyA9IHN0Y287XG4gICAgTVA0LlNUU1ogPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gb3Bjb2xvclxuICAgIF0pO1xuICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIC8vIGJhbGFuY2VcbiAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgXSk7XG4gICAgTVA0LlNUU0QgPSBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7IC8vIGVudHJ5X2NvdW50XG5cbiAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuXG4gICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuXG4gICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KE1QNC50eXBlcy5mdHlwLCBtYWpvckJyYW5kLCBtaW5vclZlcnNpb24sIG1ham9yQnJhbmQsIGF2YzFCcmFuZCk7XG4gICAgTVA0LkRJTkYgPSBNUDQuYm94KE1QNC50eXBlcy5kaW5mLCBNUDQuYm94KE1QNC50eXBlcy5kcmVmLCBkcmVmKSk7XG4gIH07XG5cbiAgTVA0LmJveCA9IGZ1bmN0aW9uIGJveCh0eXBlKSB7XG4gICAgdmFyIHNpemUgPSA4O1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGF5bG9hZFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICB2YXIgbGVuID0gaTsgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSBzaXplID4+IDE2ICYgMHhmZjtcbiAgICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgIHJlc3VsdC5zZXQodHlwZSwgNCk7IC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG5cbiAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBjb3B5IHBheWxvYWRbaV0gYXJyYXkgQCBvZmZzZXQgc2l6ZVxuICAgICAgcmVzdWx0LnNldChwYXlsb2FkW2ldLCBzaXplKTtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgTVA0LmhkbHIgPSBmdW5jdGlvbiBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9O1xuXG4gIE1QNC5tZGF0ID0gZnVuY3Rpb24gbWRhdChkYXRhKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kYXQsIGRhdGEpO1xuICB9O1xuXG4gIE1QNC5tZGhkID0gZnVuY3Rpb24gbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFsweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4ZmYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4ZmYsIHRpbWVzY2FsZSA+PiA4ICYgMHhmZiwgdGltZXNjYWxlICYgMHhmZiwgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHg1NSwgMHhjNCwgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAweDAwLCAweDAwXSkpO1xuICB9O1xuXG4gIE1QNC5tZGlhID0gZnVuY3Rpb24gbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH07XG5cbiAgTVA0Lm1maGQgPSBmdW5jdGlvbiBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIHNlcXVlbmNlTnVtYmVyID4+IDI0LCBzZXF1ZW5jZU51bWJlciA+PiAxNiAmIDB4ZmYsIHNlcXVlbmNlTnVtYmVyID4+IDggJiAweGZmLCBzZXF1ZW5jZU51bWJlciAmIDB4ZmYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC5taW5mID0gZnVuY3Rpb24gbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9O1xuXG4gIE1QNC5tb29mID0gZnVuY3Rpb24gbW9vZihzbiwgYmFzZU1lZGlhRGVjb2RlVGltZSwgdHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubW9vZiwgTVA0Lm1maGQoc24pLCBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdHJhY2tzLi4uIChvcHRpb25hbCkge2FycmF5fSB0aGUgdHJhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1vdmllXG4gICAqL1xuICA7XG5cbiAgTVA0Lm1vb3YgPSBmdW5jdGlvbiBtb292KHRyYWNrcykge1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICB2YXIgYm94ZXMgPSBbXTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGJveGVzW2ldID0gTVA0LnRyYWsodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfTtcblxuICBNUDQubXZleCA9IGZ1bmN0aW9uIG12ZXgodHJhY2tzKSB7XG4gICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIHZhciBib3hlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleF0uY29uY2F0KGJveGVzKSk7XG4gIH07XG5cbiAgTVA0Lm12aGQgPSBmdW5jdGlvbiBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgdmFyIHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHZhciBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsIC8vIHRpbWVzY2FsZVxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIC8vIDEuMCByYXRlXG4gICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYgLy8gbmV4dF90cmFja19JRFxuICAgIF0pO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gIH07XG5cbiAgTVA0LnNkdHAgPSBmdW5jdGlvbiBzZHRwKHRyYWNrKSB7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGZsYWdzOyAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICBieXRlc1tpICsgNF0gPSBmbGFncy5kZXBlbmRzT24gPDwgNCB8IGZsYWdzLmlzRGVwZW5kZWRPbiA8PCAyIHwgZmxhZ3MuaGFzUmVkdW5kYW5jeTtcbiAgICB9XG5cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc2R0cCwgYnl0ZXMpO1xuICB9O1xuXG4gIE1QNC5zdGJsID0gZnVuY3Rpb24gc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdGJsLCBNUDQuc3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLnN0dHMsIE1QNC5TVFRTKSwgTVA0LmJveChNUDQudHlwZXMuc3RzYywgTVA0LlNUU0MpLCBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksIE1QNC5ib3goTVA0LnR5cGVzLnN0Y28sIE1QNC5TVENPKSk7XG4gIH07XG5cbiAgTVA0LmF2YzEgPSBmdW5jdGlvbiBhdmMxKHRyYWNrKSB7XG4gICAgdmFyIHNwcyA9IFtdO1xuICAgIHZhciBwcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgbGVuOyAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSA9IHRyYWNrLnNwc1tpXTtcbiAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHNwcy5wdXNoKGxlbiA+Pj4gOCAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7IC8vIFNQU1xuXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9IC8vIGFzc2VtYmxlIHRoZSBQUFNzXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvblxuICAgIHNwc1szXSwgLy8gcHJvZmlsZVxuICAgIHNwc1s0XSwgLy8gcHJvZmlsZSBjb21wYXRcbiAgICBzcHNbNV0sIC8vIGxldmVsXG4gICAgMHhmYyB8IDMsIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgXS5jb25jYXQoc3BzKS5jb25jYXQoW3RyYWNrLnBwcy5sZW5ndGggLy8gbnVtT2ZQaWN0dXJlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChwcHMpKSk7IC8vIFwiUFBTXCJcblxuICAgIHZhciB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgdmFyIGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXTtcbiAgICB2YXIgdlNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIC8vIGhlaWdodFxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIGhvcml6cmVzb2x1dGlvblxuICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBmcmFtZV9jb3VudFxuICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgMHgwMCwgMHgxOCwgLy8gZGVwdGggPSAyNFxuICAgIDB4MTEsIDB4MTFdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLCAvLyBidWZmZXJTaXplREJcbiAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSwgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcbiAgICBoU3BhY2luZyA+PiAxNiAmIDB4ZmYsIGhTcGFjaW5nID4+IDggJiAweGZmLCBoU3BhY2luZyAmIDB4ZmYsIHZTcGFjaW5nID4+IDI0LCAvLyB2U3BhY2luZ1xuICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gIH07XG5cbiAgTVA0LmVzZHMgPSBmdW5jdGlvbiBlc2RzKHRyYWNrKSB7XG4gICAgdmFyIGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDMsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIDB4MTcgKyBjb25maWdsZW4sIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDEsIC8vIGVzX2lkXG4gICAgMHgwMCwgLy8gc3RyZWFtX3ByaW9yaXR5XG4gICAgMHgwNCwgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgMHgwZiArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsIC8vIHN0cmVhbV90eXBlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYnVmZmVyX3NpemVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gYXZnQml0cmF0ZVxuICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgXS5jb25jYXQoW2NvbmZpZ2xlbl0pLmNvbmNhdCh0cmFjay5jb25maWcpLmNvbmNhdChbMHgwNiwgMHgwMSwgMHgwMl0pKTsgLy8gR0FTcGVjaWZpY0NvbmZpZykpOyAvLyBsZW5ndGggKyBhdWRpbyBjb25maWcgZGVzY3JpcHRvclxuICB9O1xuXG4gIE1QNC5tcDRhID0gZnVuY3Rpb24gbXA0YSh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgIDB4MDAsIDB4MDBdKSwgTVA0LmJveChNUDQudHlwZXMuZXNkcywgTVA0LmVzZHModHJhY2spKSk7XG4gIH07XG5cbiAgTVA0Lm1wMyA9IGZ1bmN0aW9uIG1wMyh0cmFjaykge1xuICAgIHZhciBzYW1wbGVyYXRlID0gdHJhY2suc2FtcGxlcmF0ZTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJy5tcDMnXSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAweDAwLCAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLCAvL1xuICAgIDB4MDAsIDB4MDBdKSk7XG4gIH07XG5cbiAgTVA0LnN0c2QgPSBmdW5jdGlvbiBzdHNkKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIGlmICghdHJhY2suaXNBQUMgJiYgdHJhY2suY29kZWMgPT09ICdtcDMnKSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wMyh0cmFjaykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDRhKHRyYWNrKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICB9XG4gIH07XG5cbiAgTVA0LnRraGQgPSBmdW5jdGlvbiB0a2hkKHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIGR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gKiB0cmFjay50aW1lc2NhbGU7XG4gICAgdmFyIHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgdmFyIGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgLy8gbGF5ZXJcbiAgICAweDAwLCAweDAwLCAvLyBhbHRlcm5hdGVfZ3JvdXBcbiAgICAweDAwLCAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgMHgwMCwgMHgwMCwgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC50cmFmID0gZnVuY3Rpb24gdHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSkge1xuICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgdmFyIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICB2YXIgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFmLCBNUDQuYm94KE1QNC50eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICBpZCA+PiAyNCwgaWQgPj4gMTYgJiAweGZmLCBpZCA+PiA4ICYgMHhmZiwgaWQgJiAweGZmIC8vIHRyYWNrX0lEXG4gICAgXSkpLCBNUDQuYm94KE1QNC50eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArIC8vIHRmaGRcbiAgICAyMCArIC8vIHRmZHRcbiAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAxNiArIC8vIG1maGRcbiAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICA4KSwgLy8gbWRhdCBoZWFkZXJcbiAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICogQHBhcmFtIHRyYWNrIHtvYmplY3R9IGEgdHJhY2sgZGVmaW5pdGlvblxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gICAqL1xuICA7XG5cbiAgTVA0LnRyYWsgPSBmdW5jdGlvbiB0cmFrKHRyYWNrKSB7XG4gICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cmFrLCBNUDQudGtoZCh0cmFjayksIE1QNC5tZGlhKHRyYWNrKSk7XG4gIH07XG5cbiAgTVA0LnRyZXggPSBmdW5jdGlvbiB0cmV4KHRyYWNrKSB7XG4gICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyZXgsIG5ldyBVaW50OEFycmF5KFsweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gICAgXSkpO1xuICB9O1xuXG4gIE1QNC50cnVuID0gZnVuY3Rpb24gdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIHZhciBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICB2YXIgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2FtcGxlO1xuICAgIHZhciBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZTtcbiAgICB2YXIgZmxhZ3M7XG4gICAgdmFyIGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwZiwgMHgwMSwgLy8gZmxhZ3NcbiAgICBsZW4gPj4+IDI0ICYgMHhmZiwgbGVuID4+PiAxNiAmIDB4ZmYsIGxlbiA+Pj4gOCAmIDB4ZmYsIGxlbiAmIDB4ZmYsIC8vIHNhbXBsZV9jb3VudFxuICAgIG9mZnNldCA+Pj4gMjQgJiAweGZmLCBvZmZzZXQgPj4+IDE2ICYgMHhmZiwgb2Zmc2V0ID4+PiA4ICYgMHhmZiwgb2Zmc2V0ICYgMHhmZiAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgIHNpemUgPj4+IDI0ICYgMHhmZiwgc2l6ZSA+Pj4gMTYgJiAweGZmLCBzaXplID4+PiA4ICYgMHhmZiwgc2l6ZSAmIDB4ZmYsIC8vIHNhbXBsZV9zaXplXG4gICAgICBmbGFncy5pc0xlYWRpbmcgPDwgMiB8IGZsYWdzLmRlcGVuZHNPbiwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDYgfCBmbGFncy5oYXNSZWR1bmRhbmN5IDw8IDQgfCBmbGFncy5wYWRkaW5nVmFsdWUgPDwgMSB8IGZsYWdzLmlzTm9uU3luYywgZmxhZ3MuZGVncmFkUHJpbyAmIDB4ZjAgPDwgOCwgZmxhZ3MuZGVncmFkUHJpbyAmIDB4MGYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH07XG5cbiAgTVA0LmluaXRTZWdtZW50ID0gZnVuY3Rpb24gaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuXG4gICAgdmFyIG1vdmllID0gTVA0Lm1vb3YodHJhY2tzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTVA0LkZUWVAuYnl0ZUxlbmd0aCArIG1vdmllLmJ5dGVMZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQoTVA0LkZUWVApO1xuICAgIHJlc3VsdC5zZXQobW92aWUsIE1QNC5GVFlQLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIE1QNDtcbn0oKTtcblxuTVA0LnR5cGVzID0gdm9pZCAwO1xuTVA0LkhETFJfVFlQRVMgPSB2b2lkIDA7XG5NUDQuU1RUUyA9IHZvaWQgMDtcbk1QNC5TVFNDID0gdm9pZCAwO1xuTVA0LlNUQ08gPSB2b2lkIDA7XG5NUDQuU1RTWiA9IHZvaWQgMDtcbk1QNC5WTUhEID0gdm9pZCAwO1xuTVA0LlNNSEQgPSB2b2lkIDA7XG5NUDQuU1RTRCA9IHZvaWQgMDtcbk1QNC5GVFlQID0gdm9pZCAwO1xuTVA0LkRJTkYgPSB2b2lkIDA7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE1QNCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlbXV4L21wNC1yZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQsIFBUU05vcm1hbGl6ZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTVA0UmVtdXhlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUFRTTm9ybWFsaXplXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUFRTTm9ybWFsaXplOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hYWNfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FhYy1oZWxwZXIgKi8gXCIuL3NyYy9yZW11eC9hYWMtaGVscGVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC1nZW5lcmF0b3IgKi8gXCIuL3NyYy9yZW11eC9tcDQtZ2VuZXJhdG9yLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2V2ZW50cyAqLyBcIi4vc3JjL2V2ZW50cy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvcnMgKi8gXCIuL3NyYy9lcnJvcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24gKi8gXCIuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50c1wiKTtcblxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5cblxuXG5cblxuXG52YXIgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xuXG52YXIgQUFDX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTAyNDtcbnZhciBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUgPSAxMTUyO1xudmFyIGNocm9tZVZlcnNpb24gPSBudWxsO1xudmFyIHNhZmFyaVdlYmtpdFZlcnNpb24gPSBudWxsO1xudmFyIHJlcXVpcmVzUG9zaXRpdmVEdHMgPSBmYWxzZTtcblxudmFyIE1QNFJlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNUDRSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcikge1xuICAgIGlmICh2ZW5kb3IgPT09IHZvaWQgMCkge1xuICAgICAgdmVuZG9yID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRQVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5faW5pdERUUyA9IHZvaWQgMDtcbiAgICB0aGlzLm5leHRBdmNEdHMgPSBudWxsO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbnVsbDtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaHJvbWVWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIHZhciByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG5cbiAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdmFyIF9yZXN1bHQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKykvaSk7XG5cbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSBfcmVzdWx0ID8gcGFyc2VJbnQoX3Jlc3VsdFsxXSkgOiAwO1xuICAgIH1cblxuICAgIHJlcXVpcmVzUG9zaXRpdmVEdHMgPSAhIWNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8IDc1IHx8ICEhc2FmYXJpV2Via2l0VmVyc2lvbiAmJiBzYWZhcmlXZWJraXRWZXJzaW9uIDwgNjAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1QNFJlbXV4ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuXG4gIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKCdbbXA0LXJlbXV4ZXJdOiBpbml0UFRTICYgaW5pdERUUyByZXNldCcpO1xuICAgIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZGVmYXVsdFRpbWVTdGFtcDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXROZXh0VGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coJ1ttcDQtcmVtdXhlcl06IHJlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZygnW21wNC1yZW11eGVyXTogSVNHZW5lcmF0ZWQgZmxhZyByZXNldCcpO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmlkZW9TdGFydFB0cyA9IGZ1bmN0aW9uIGdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKSB7XG4gICAgdmFyIHJvbGxvdmVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKGZ1bmN0aW9uIChtaW5QVFMsIHNhbXBsZSkge1xuICAgICAgdmFyIGRlbHRhID0gc2FtcGxlLnB0cyAtIG1pblBUUztcblxuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUFRTTm9ybWFsaXplKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG5cbiAgICBpZiAocm9sbG92ZXJEZXRlY3RlZCkge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmRlYnVnKCdQVFMgcm9sbG92ZXIgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhcnRQVFM7XG4gIH07XG5cbiAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmbHVzaCkge1xuICAgIHZhciB2aWRlbztcbiAgICB2YXIgYXVkaW87XG4gICAgdmFyIGluaXRTZWdtZW50O1xuICAgIHZhciB0ZXh0O1xuICAgIHZhciBpZDM7XG4gICAgdmFyIGluZGVwZW5kZW50O1xuICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHZhciB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0OyAvLyBJZiB3ZSdyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gcHJvZ3Jlc3NpdmVseSwgd2FpdCB1bnRpbCB3ZSd2ZSByZWNlaXZlZCBlbm91Z2ggc2FtcGxlcyBmb3IgZWFjaCB0cmFjayBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gc3luY2hyb25pemUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zLiBXZSBrbm93IGlmIHRoZSBjdXJyZW50IHNlZ21lbnQgd2lsbCBoYXZlIHNhbXBsZXMgaWYgdGhlIFwicGlkXCJcbiAgICAvLyBwYXJhbWV0ZXIgaXMgZ3JlYXRlciB0aGFuIC0xLiBUaGUgcGlkIGlzIHNldCB3aGVuIHRoZSBQTVQgaXMgcGFyc2VkLCB3aGljaCBjb250YWlucyB0aGUgdHJhY2tzIGxpc3QuXG4gICAgLy8gSG93ZXZlciwgaWYgdGhlIGluaXRTZWdtZW50IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLCBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgYSBzZWdtZW50IChmbHVzaCksXG4gICAgLy8gdGhlbiB3ZSBjYW4gcmVtdXggb25lIHRyYWNrIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIG90aGVyLlxuXG4gICAgdmFyIGhhc0F1ZGlvID0gYXVkaW9UcmFjay5waWQgPiAtMTtcbiAgICB2YXIgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIHZhciBlbm91Z2hBdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXMubGVuZ3RoID4gMDtcbiAgICB2YXIgZW5vdWdoVmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuXG4gICAgaWYgKGNhblJlbXV4QXZjKSB7XG4gICAgICBpZiAoIXRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1ZpZGVvQ29udGlndW91cyA9IHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM7XG5cbiAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMgJiYgIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgICAgIHZhciBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA+IDApIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlttcDQtcmVtdXhlcl06IERyb3BwZWQgXCIgKyBmaXJzdEtleUZyYW1lSW5kZXggKyBcIiBvdXQgb2YgXCIgKyBsZW5ndGggKyBcIiB2aWRlbyBzYW1wbGVzIGR1ZSB0byBhIG1pc3Npbmcga2V5ZnJhbWVcIik7XG4gICAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkICs9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gKHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMgLSBzdGFydFBUUykgLyAodmlkZW9UcmFjay50aW1lc2NhbGUgfHwgOTAwMDApO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiBcIiArIGxlbmd0aCArIFwiIHZpZGVvIHNhbXBsZXNcIik7XG4gICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIC8vIHRpbWVPZmZzZXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIG9mZnNldCBvZiB0aGUgZmlyc3QgdGltZXN0YW1wIG9mIHRoaXMgZnJhZ21lbnQgKGZpcnN0IERUUylcbiAgICAgICAgICAvLyBpZiBmaXJzdCBhdWRpbyBEVFMgaXMgbm90IGFsaWduZWQgd2l0aCBmaXJzdCB2aWRlbyBEVFMgdGhlbiB3ZSBuZWVkIHRvIHRha2UgdGhhdCBpbnRvIGFjY291bnRcbiAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgLy8gZHJpZnQgYmV0d2VlbiBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtc1xuICAgICAgICAgIHZhciBfc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcblxuICAgICAgICAgIHZhciB0c0RlbHRhID0gUFRTTm9ybWFsaXplKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIF9zdGFydFBUUykgLSBfc3RhcnRQVFM7XG5cbiAgICAgICAgICB2YXIgYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhID0gdHNEZWx0YSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIC1hdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICB9IC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuXG5cbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgIC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCBhdWRpbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG4gICAgICAgICAgaWYgKCFhdWRpb1RyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbml0U2VnbWVudC52aWRlbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhdWRpbyA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgZW5vdWdoVmlkZW9TYW1wbGVzID8gdmlkZW9UaW1lT2Zmc2V0IDogdW5kZWZpbmVkKTtcblxuICAgICAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrTGVuZ3RoID0gYXVkaW8gPyBhdWRpby5lbmRQVFMgLSBhdWRpby5zdGFydFBUUyA6IDA7IC8vIGlmIGluaXRTZWdtZW50IHdhcyBnZW5lcmF0ZWQgd2l0aG91dCB2aWRlbyBzYW1wbGVzLCByZWdlbmVyYXRlIGl0IGFnYWluXG5cbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZpZGVvICYmIGluZGVwZW5kZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGluZGVwZW5kZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuXG5cbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCkge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IHRoaXMucmVtdXhJRDMoaWQzVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSB0aGlzLnJlbXV4VGV4dCh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbzogYXVkaW8sXG4gICAgICB2aWRlbzogdmlkZW8sXG4gICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudDogaW5kZXBlbmRlbnQsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgaWQzOiBpZDNcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZW5lcmF0ZUlTID0gZnVuY3Rpb24gZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcztcbiAgICB2YXIgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIHZhciB0eXBlU3VwcG9ydGVkID0gdGhpcy50eXBlU3VwcG9ydGVkO1xuICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICB2YXIgY29tcHV0ZVBUU0RUUyA9ICFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkodGhpcy5faW5pdFBUUyk7XG4gICAgdmFyIGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIHZhciBpbml0UFRTO1xuICAgIHZhciBpbml0RFRTO1xuICAgIHZhciB0aW1lc2NhbGU7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcbiAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKFwiW21wNC1yZW11eGVyXTogYXVkaW8gc2FtcGxpbmcgcmF0ZSA6IFwiICsgYXVkaW9UcmFjay5zYW1wbGVyYXRlKTtcblxuICAgICAgaWYgKCFhdWRpb1RyYWNrLmlzQUFDKSB7XG4gICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaVxuICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6ICFhdWRpb1RyYWNrLmlzQUFDICYmIHR5cGVTdXBwb3J0ZWQubXBlZyA/IG5ldyBVaW50OEFycmF5KDApIDogX21wNF9nZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0uaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7IC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiB0aGlzIGRlbXV4aW5nIGNvbnRleHQuIGZvciBhdWRpbywgUFRTID0gRFRTXG5cbiAgICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBhdWRpb1NhbXBsZXNbMF0ucHRzIC0gTWF0aC5yb3VuZCh0aW1lc2NhbGUgKiB0aW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihpbml0RFRTLCBQVFNOb3JtYWxpemUodmlkZW9TYW1wbGVzWzBdLmR0cywgc3RhcnRQVFMpIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IGluaXRQVFM7XG4gICAgICAgIHRoaXMuX2luaXREVFMgPSBpbml0RFRTO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFja3M6IHRyYWNrcyxcbiAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW11eFZpZGVvID0gZnVuY3Rpb24gcmVtdXhWaWRlbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCkge1xuICAgIHZhciB0aW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB2YXIgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIHZhciBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICB2YXIgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICB2YXIgb2Zmc2V0ID0gODtcbiAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdmFyIGZpcnN0RFRTO1xuICAgIHZhciBsYXN0RFRTO1xuICAgIHZhciBtaW5QVFMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heFBUUyA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgcHRzRHRzU2hpZnQgPSAwO1xuICAgIHZhciBzb3J0U2FtcGxlcyA9IGZhbHNlOyAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG5cbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgbmV4dEF2Y0R0cyA9PT0gbnVsbCkge1xuICAgICAgdmFyIHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICB2YXIgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIFBUU05vcm1hbGl6ZShpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTsgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuXG4gICAgICBuZXh0QXZjRHRzID0gcHRzIC0gY3RzO1xuICAgIH0gLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIHNhbXBsZS5wdHMgPSBQVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IFBUU05vcm1hbGl6ZShzYW1wbGUuZHRzIC0gaW5pdFBUUywgbmV4dEF2Y0R0cyk7XG5cbiAgICAgIGlmIChzYW1wbGUuZHRzID4gc2FtcGxlLnB0cykge1xuICAgICAgICB2YXIgUFRTX0RUU19TSElGVF9UT0xFUkFOQ0VfOTBLSFogPSA5MDAwMCAqIDAuMjtcbiAgICAgICAgcHRzRHRzU2hpZnQgPSBNYXRoLm1heChNYXRoLm1pbihwdHNEdHNTaGlmdCwgc2FtcGxlLnB0cyAtIHNhbXBsZS5kdHMpLCAtMSAqIFBUU19EVFNfU0hJRlRfVE9MRVJBTkNFXzkwS0haKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcblxuXG4gICAgaWYgKHNvcnRTYW1wbGVzKSB7XG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZGVsdGFkdHMgPSBhLmR0cyAtIGIuZHRzO1xuICAgICAgICB2YXIgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgICByZXR1cm4gZGVsdGFkdHMgfHwgZGVsdGFwdHM7XG4gICAgICB9KTtcbiAgICB9IC8vIEdldCBmaXJzdC9sYXN0IERUU1xuXG5cbiAgICBmaXJzdERUUyA9IGlucHV0U2FtcGxlc1swXS5kdHM7XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV0uZHRzOyAvLyBvbiBTYWZhcmkgbGV0J3Mgc2lnbmFsIHRoZSBzYW1lIHNhbXBsZSBkdXJhdGlvbiBmb3IgYWxsIHNhbXBsZXNcbiAgICAvLyBzYW1wbGUgZHVyYXRpb24gKGFzIGV4cGVjdGVkIGJ5IHRydW4gTVA0IGJveGVzKSwgc2hvdWxkIGJlIHRoZSBkZWx0YSBiZXR3ZWVuIHNhbXBsZSBEVFNcbiAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuXG4gICAgdmFyIGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA9IE1hdGgucm91bmQoKGxhc3REVFMgLSBmaXJzdERUUykgLyAobmJTYW1wbGVzIC0gMSkpOyAvLyBoYW5kbGUgYnJva2VuIHN0cmVhbXMgd2l0aCBQVFMgPCBEVFMsIHRvbGVyYW5jZSB1cCAwLjIgc2Vjb25kc1xuXG4gICAgaWYgKHB0c0R0c1NoaWZ0IDwgMCkge1xuICAgICAgaWYgKHB0c0R0c1NoaWZ0IDwgYXZlcmFnZVNhbXBsZUR1cmF0aW9uICogLTIpIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoaW5jbHVkaW5nIFNhZmFyaSBicm93c2VyKVxuICAgICAgICAvLyBXaXRoIGxhcmdlIFBUUyA8IERUUyBlcnJvcnMgc3VjaCBhcyB0aGlzLCB3ZSB3YW50IHRvIGNvcnJlY3QgQ1RTIHdoaWxlIG1haW50YWluaW5nIGluY3JlYXNpbmcgRFRTIHZhbHVlc1xuICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlBUUyA8IERUUyBkZXRlY3RlZCBpbiB2aWRlbyBzYW1wbGVzLCBvZmZzZXR0aW5nIERUUyBmcm9tIFBUUyBieSBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKC1hdmVyYWdlU2FtcGxlRHVyYXRpb24sIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgIHZhciBsYXN0RHRzID0gcHRzRHRzU2hpZnQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5iU2FtcGxlczsgX2krKykge1xuICAgICAgICAgIGlucHV0U2FtcGxlc1tfaV0uZHRzID0gbGFzdER0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzIC0gYXZlcmFnZVNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLnB0cyA9IE1hdGgubWF4KGxhc3REdHMsIGlucHV0U2FtcGxlc1tfaV0ucHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkN1c3RvbSBJViB3aXRoIGJhZCBQVFMgRFRTXCIgaW4gdGVzdC1zdHJlYW1zXG4gICAgICAgIC8vIFdpdGggc21hbGxlciBQVFMgPCBEVFMgZXJyb3JzIHdlIGNhbiBzaW1wbHkgbW92ZSBhbGwgRFRTIGJhY2suIFRoaXMgaW5jcmVhc2VzIENUUyB3aXRob3V0IGNhdXNpbmcgYnVmZmVyIGdhcHMgb3IgZGVjb2RlIGVycm9ycyBpbiBTYWZhcmlcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgc2hpZnRpbmcgRFRTIGJ5IFwiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkocHRzRHRzU2hpZnQsIHRydWUpICsgXCIgbXMgdG8gb3ZlcmNvbWUgdGhpcyBpc3N1ZVwiKTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuYlNhbXBsZXM7IF9pMisrKSB7XG4gICAgICAgICAgaW5wdXRTYW1wbGVzW19pMl0uZHRzID0gaW5wdXRTYW1wbGVzW19pMl0uZHRzICsgcHRzRHRzU2hpZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG4gICAgfSAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcblxuXG4gICAgaWYgKGNvbnRpZ3VvdXMpIHtcbiAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgdmFyIGRlbHRhID0gZmlyc3REVFMgLSBuZXh0QXZjRHRzO1xuICAgICAgdmFyIGZvdW5kSG9sZSA9IGRlbHRhID4gYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgdmFyIGZvdW5kT3ZlcmxhcCA9IGRlbHRhIDwgLTE7XG5cbiAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgIGlmIChmb3VuZEhvbGUpIHtcbiAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIkFWQzogXCIgKyBPYmplY3QoX3V0aWxzX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCJdKShkZWx0YSwgdHJ1ZSkgKyBcIiBtcyAoXCIgKyBkZWx0YSArIFwiZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkLCBmaWxsaW5nIGl0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS53YXJuKFwiQVZDOiBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKC1kZWx0YSwgdHJ1ZSkgKyBcIiBtcyAoXCIgKyBkZWx0YSArIFwiZHRzKSBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgdmFyIGZpcnN0UFRTID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGRlbHRhO1xuICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhcIlZpZGVvOiBGaXJzdCBQVFMvRFRTIGFkanVzdGVkOiBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKGZpcnN0UFRTLCB0cnVlKSArIFwiL1wiICsgT2JqZWN0KF91dGlsc190aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1widG9Nc0Zyb21NcGVnVHNDbG9ja1wiXSkoZmlyc3REVFMsIHRydWUpICsgXCIsIGRlbHRhOiBcIiArIE9iamVjdChfdXRpbHNfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInRvTXNGcm9tTXBlZ1RzQ2xvY2tcIl0pKGRlbHRhLCB0cnVlKSArIFwiIG1zXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1aXJlc1Bvc2l0aXZlRHRzKSB7XG4gICAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICB9XG5cbiAgICB2YXIgbmJOYWx1ID0gMDtcbiAgICB2YXIgbmFsdUxlbiA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuYlNhbXBsZXM7IF9pMysrKSB7XG4gICAgICAvLyBjb21wdXRlIHRvdGFsL2F2YyBzYW1wbGUgbGVuZ3RoIGFuZCBuYiBvZiBOQUwgdW5pdHNcbiAgICAgIHZhciBfc2FtcGxlID0gaW5wdXRTYW1wbGVzW19pM107XG4gICAgICB2YXIgdW5pdHMgPSBfc2FtcGxlLnVuaXRzO1xuICAgICAgdmFyIG5iVW5pdHMgPSB1bml0cy5sZW5ndGg7XG4gICAgICB2YXIgc2FtcGxlTGVuID0gMDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgc2FtcGxlTGVuICs9IHVuaXRzW2pdLmRhdGEubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBuYWx1TGVuICs9IHNhbXBsZUxlbjtcbiAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgX3NhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47IC8vIG5vcm1hbGl6ZSBQVFMvRFRTXG4gICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcblxuICAgICAgX3NhbXBsZS5kdHMgPSBNYXRoLm1heChfc2FtcGxlLmR0cywgZmlyc3REVFMpOyAvLyBlbnN1cmUgdGhhdCBjb21wdXRlZCB2YWx1ZSBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gc2FtcGxlIERUU1xuXG4gICAgICBfc2FtcGxlLnB0cyA9IE1hdGgubWF4KF9zYW1wbGUucHRzLCBfc2FtcGxlLmR0cywgMCk7XG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihfc2FtcGxlLnB0cywgbWluUFRTKTtcbiAgICAgIG1heFBUUyA9IE1hdGgubWF4KF9zYW1wbGUucHRzLCBtYXhQVFMpO1xuICAgIH1cblxuICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMV0uZHRzO1xuICAgIC8qIGNvbmNhdGVuYXRlIHRoZSB2aWRlbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cblxuICAgIHZhciBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICB2YXIgbWRhdDtcblxuICAgIHRyeSB7XG4gICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yVHlwZXNcIl0uTVVYX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICByZWFzb246IFwiZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgXCIgKyBtZGF0U2l6ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS50eXBlcy5tZGF0LCA0KTtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5iU2FtcGxlczsgX2k0KyspIHtcbiAgICAgIHZhciBhdmNTYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2k0XTtcbiAgICAgIHZhciBhdmNTYW1wbGVVbml0cyA9IGF2Y1NhbXBsZS51bml0cztcbiAgICAgIHZhciBtcDRTYW1wbGVMZW5ndGggPSAwOyAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG5cbiAgICAgIGZvciAodmFyIF9qID0gMCwgX25iVW5pdHMgPSBhdmNTYW1wbGVVbml0cy5sZW5ndGg7IF9qIDwgX25iVW5pdHM7IF9qKyspIHtcbiAgICAgICAgdmFyIHVuaXQgPSBhdmNTYW1wbGVVbml0c1tfal07XG4gICAgICAgIHZhciB1bml0RGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgdmFyIHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH0gLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG5cblxuICAgICAgaWYgKF9pNCA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbX2k0ICsgMV0uZHRzIC0gYXZjU2FtcGxlLmR0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIGxhc3RGcmFtZUR1cmF0aW9uID0gYXZjU2FtcGxlLmR0cyAtIGlucHV0U2FtcGxlc1tfaTQgPiAwID8gX2k0IC0gMSA6IF9pNF0uZHRzO1xuXG4gICAgICAgIGlmIChjb25maWcuc3RyZXRjaFNob3J0VmlkZW9UcmFjayAmJiB0aGlzLm5leHRBdWRpb1B0cyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGFscmVhZHkgcmVtdXhlZCBhdWRpbywgYW5kIHdlIGtub3cgaG93IGxvbmcgdGhlIGF1ZGlvIHRyYWNrIGlzLCB3ZSBsb29rIHRvXG4gICAgICAgICAgLy8gc2VlIGlmIHRoZSBkZWx0YSB0byB0aGUgbmV4dCBzZWdtZW50IGlzIGxvbmdlciB0aGFuIG1heEJ1ZmZlckhvbGUuXG4gICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAvLyB0aGUgZHVyYXRpb24gb2YgdGhlIGxhc3QgZnJhbWUgdG8gbWluaW1pemUgYW55IHBvdGVudGlhbCBnYXAgYmV0d2VlbiBzZWdtZW50cy5cbiAgICAgICAgICB2YXIgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgdmFyIGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIGF2Y1NhbXBsZS5wdHM7XG5cbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhcIlttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgXCIgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArIFwiIG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uIFwiICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArIFwiIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IE1hdGgucm91bmQoYXZjU2FtcGxlLnB0cyAtIGF2Y1NhbXBsZS5kdHMpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUoYXZjU2FtcGxlLmtleSwgbXA0U2FtcGxlRHVyYXRpb24sIG1wNFNhbXBsZUxlbmd0aCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0KSk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoICYmIGNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgIH1cblxuICAgIGNvbnNvbGUuYXNzZXJ0KG1wNFNhbXBsZUR1cmF0aW9uICE9PSB1bmRlZmluZWQsICdtcDRTYW1wbGVEdXJhdGlvbiBtdXN0IGJlIGNvbXB1dGVkJyk7IC8vIG5leHQgQVZDIHNhbXBsZSBEVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIERUUyArIGxhc3Qgc2FtcGxlIGR1cmF0aW9uIChpbiBQRVMgdGltZXNjYWxlKVxuXG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICB2YXIgbW9vZiA9IF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcbiAgICB2YXIgdHlwZSA9ICd2aWRlbyc7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IG1pblBUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZFBUUzogKG1heFBUUyArIG1wNFNhbXBsZUR1cmF0aW9uKSAvIHRpbWVTY2FsZSxcbiAgICAgIHN0YXJ0RFRTOiBmaXJzdERUUyAvIHRpbWVTY2FsZSxcbiAgICAgIGVuZERUUzogbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBoYXNBdWRpbzogZmFsc2UsXG4gICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgIG5iOiBvdXRwdXRTYW1wbGVzLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IHRyYWNrLmRyb3BwZWRcbiAgICB9O1xuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB0cmFjay5kcm9wcGVkID0gMDtcbiAgICBjb25zb2xlLmFzc2VydChtZGF0Lmxlbmd0aCwgJ01EQVQgbGVuZ3RoIG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBfcHJvdG8ucmVtdXhBdWRpbyA9IGZ1bmN0aW9uIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdmlkZW9UaW1lT2Zmc2V0KSB7XG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgdmFyIG1wNFNhbXBsZUR1cmF0aW9uID0gdHJhY2suaXNBQUMgPyBBQUNfU0FNUExFU19QRVJfRlJBTUUgOiBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUU7XG4gICAgdmFyIGlucHV0U2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbiAqIHNjYWxlRmFjdG9yO1xuICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICB2YXIgcmF3TVBFRyA9ICF0cmFjay5pc0FBQyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcbiAgICB2YXIgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgIHZhciBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIHZhciBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgdmFyIGZpbGxGcmFtZTtcbiAgICB2YXIgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHMgfHwgLTE7IC8vIHdpbmRvdy5hdWRpb1NhbXBsZXMgPyB3aW5kb3cuYXVkaW9TYW1wbGVzLnB1c2goaW5wdXRTYW1wbGVzLm1hcChzID0+IHMucHRzKSkgOiAod2luZG93LmF1ZGlvU2FtcGxlcyA9IFtpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpXSk7XG4gICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAvLyBmb3Igc2FrZSBvZiBjbGFyaXR5OlxuICAgIC8vIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcmUgZnJhZ3Mgd2l0aFxuICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgLy8gIC0gbGVzcyB0aGFuIDIwIGF1ZGlvIGZyYW1lcyBkaXN0YW5jZVxuICAgIC8vIGNvbnRpZ3VvdXMgZnJhZ21lbnRzIGFyZSBjb25zZWN1dGl2ZSBmcmFnbWVudHMgZnJvbSBzYW1lIHF1YWxpdHkgbGV2ZWwgKHNhbWUgbGV2ZWwsIG5ldyBTTiA9IG9sZCBTTiArIDEpXG4gICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgLy8gYW5kIHRoaXMgYWxzbyBhdm9pZHMgYXVkaW8gZ2xpdGNoZXMvY3V0IHdoZW4gc3dpdGNoaW5nIHF1YWxpdHksIG9yIHJlcG9ydGluZyB3cm9uZyBkdXJhdGlvbiBvbiBmaXJzdCBhdWRpbyBmcmFtZVxuXG4gICAgdmFyIHRpbWVPZmZzZXRNcGVnVFMgPSB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGU7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPSBjb250aWd1b3VzIHx8IGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzID4gMCAmJiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXRNcGVnVFMgLSBuZXh0QXVkaW9QdHMpIDwgOTAwMCB8fCBNYXRoLmFicyhQVFNOb3JtYWxpemUoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXRNcGVnVFMpIC0gbmV4dEF1ZGlvUHRzKSA8IDIwICogaW5wdXRTYW1wbGVEdXJhdGlvbik7IC8vIGNvbXB1dGUgbm9ybWFsaXplZCBQVFNcblxuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBzYW1wbGUuZHRzID0gUFRTTm9ybWFsaXplKHNhbXBsZS5wdHMgLSBpbml0UFRTLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICB9KTtcblxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXVkaW9QdHMgPCAwKSB7XG4gICAgICAvLyBmaWx0ZXIgb3V0IHNhbXBsZSB3aXRoIG5lZ2F0aXZlIFBUUyB0aGF0IGFyZSBub3QgcGxheWFibGUgYW55d2F5XG4gICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAvLyBsZWFkaW5nIHRvIGF1ZGlvIG92ZXJsYXAgYmV0d2VlbiBjdXJyZW50IC8gbmV4dCBmcmFnbWVudFxuICAgICAgaW5wdXRTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmZpbHRlcihmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgICB9KTsgLy8gaW4gY2FzZSBhbGwgc2FtcGxlcyBoYXZlIG5lZ2F0aXZlIFBUUywgYW5kIGhhdmUgYmVlbiBmaWx0ZXJlZCBvdXQsIHJldHVybiBub3dcblxuICAgICAgaWYgKCFpbnB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IHRvIDAgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIC8vIFdoZW4gbm90IHNlZWtpbmcsIG5vdCBsaXZlLCBhbmQgTGV2ZWxEZXRhaWxzLlBUU0tub3duLCB1c2UgZnJhZ21lbnQgc3RhcnQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cblxuICAgIGlmICh0cmFjay5pc0FBQykge1xuICAgICAgdmFyIG1heEF1ZGlvRnJhbWVzRHJpZnQgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7KSB7XG4gICAgICAgIC8vIEZpcnN0LCBsZXQncyBzZWUgaG93IGZhciBvZmYgdGhpcyBmcmFtZSBpcyBmcm9tIHdoZXJlIHdlIGV4cGVjdCBpdCB0byBiZVxuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICB2YXIgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgdmFyIGRlbHRhID0gcHRzIC0gbmV4dFB0cztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpOyAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuXG4gICAgICAgIGlmIChkZWx0YSA8PSAtbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29udGlndW91cyB8fCBpID4gMCkge1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBEcm9wcGluZyAxIGF1ZGlvIGZyYW1lIEAgXCIgKyAobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpICsgXCJzIGR1ZSB0byBcIiArIE1hdGgucm91bmQoZHVyYXRpb24pICsgXCIgbXMgb3ZlcmxhcC5cIik7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDEpOyAvLyBEb24ndCB0b3VjaCBuZXh0UHRzTm9ybSBvciBpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY2hhbmdpbmcgcXVhbGl0aWVzIHdlIGNhbid0IHRydXN0IHRoYXQgYXVkaW8gaGFzIGJlZW4gYXBwZW5kZWQgdXAgdG8gbmV4dEF1ZGlvUHRzXG4gICAgICAgICAgICAvLyBXYXJuIGFib3V0IHRoZSBvdmVybGFwIGJ1dCBkbyBub3QgZHJvcCBzYW1wbGVzIGFzIHRoYXQgY2FuIGludHJvZHVjZSBidWZmZXIgZ2Fwc1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLndhcm4oXCJBdWRpbyBmcmFtZSBAIFwiICsgKHB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpICsgXCJzIG92ZXJsYXBzIG5leHRBdWRpb1B0cyBieSBcIiArIE1hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpICsgXCIgbXMuXCIpO1xuICAgICAgICAgICAgbmV4dFB0cyA9IHB0cyArIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcbiAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAvLyAxOiBXZSdyZSBtb3JlIHRoYW4gbWF4QXVkaW9GcmFtZXNEcmlmdCBmcmFtZSBhd2F5XG4gICAgICAgIC8vIDI6IE5vdCBtb3JlIHRoYW4gTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiBhd2F5XG4gICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgIC8vIDQ6IHJlbXV4aW5nIHdpdGggdmlkZW8gKHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA+PSBtYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJiBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiYgdmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5mbG9vcihkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pOyAvLyBBZGp1c3QgbmV4dFB0cyBzbyB0aGF0IHNpbGVudCBzYW1wbGVzIGFyZSBhbGlnbmVkIHdpdGggbWVkaWEgcHRzLiBUaGlzIHdpbGwgcHJldmVudCBtZWRpYSBzYW1wbGVzIGZyb21cbiAgICAgICAgICAgIC8vIGxhdGVyIGJlaW5nIHNoaWZ0ZWQgaWYgbmV4dFB0cyBpcyBiYXNlZCBvbiB0aW1lT2Zmc2V0IGFuZCBkZWx0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiBpbnB1dFNhbXBsZUR1cmF0aW9uLlxuXG4gICAgICAgICAgICBuZXh0UHRzID0gcHRzIC0gbWlzc2luZyAqIGlucHV0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybihcIlttcDQtcmVtdXhlcl06IEluamVjdGluZyBcIiArIG1pc3NpbmcgKyBcIiBhdWRpbyBmcmFtZSBAIFwiICsgKG5leHRQdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBkdWUgdG8gXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKSArIFwiIG1zIGdhcC5cIik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBfYWFjX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuXG4gICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZygnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICAgIHVuaXQ6IGZpbGxGcmFtZSxcbiAgICAgICAgICAgICAgICBwdHM6IG5ld1N0YW1wLFxuICAgICAgICAgICAgICAgIGR0czogbmV3U3RhbXBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSAvLyBBZGp1c3Qgc2FtcGxlIHRvIG5leHQgZXhwZWN0ZWQgcHRzXG5cblxuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgYWRqdXN0IHB0c1xuICAgICAgICAgICAgc2FtcGxlLnB0cyA9IHNhbXBsZS5kdHMgPSBuZXh0UHRzO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmlyc3RQVFMgPSBudWxsO1xuICAgIHZhciBsYXN0UFRTID0gbnVsbDtcbiAgICB2YXIgbWRhdDtcbiAgICB2YXIgbWRhdFNpemUgPSAwO1xuICAgIHZhciBzYW1wbGVMZW5ndGggPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKHNhbXBsZUxlbmd0aC0tKSB7XG4gICAgICBtZGF0U2l6ZSArPSBpbnB1dFNhbXBsZXNbc2FtcGxlTGVuZ3RoXS51bml0LmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2oyID0gMCwgX25iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IF9qMiA8IF9uYlNhbXBsZXM7IF9qMisrKSB7XG4gICAgICB2YXIgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2oyXTtcbiAgICAgIHZhciB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIHZhciBfcHRzID0gYXVkaW9TYW1wbGUucHRzO1xuXG4gICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzYW1wbGUgdG8gdGhlIFwicmVhbFwiIGR1cmF0aW9uOyB0aGUgUFRTIGRpZmYgd2l0aFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIHZhciBwcmV2U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tfajIgLSAxXTtcbiAgICAgICAgcHJldlNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKF9wdHMgLSBsYXN0UFRTKSAvIHNjYWxlRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZGVsdGEgPSBNYXRoLnJvdW5kKDEwMDAgKiAoX3B0cyAtIG5leHRBdWRpb1B0cykgLyBpbnB1dFRpbWVTY2FsZSk7XG5cbiAgICAgICAgdmFyIG51bU1pc3NpbmdGcmFtZXMgPSAwOyAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgICAgLy8gY29udGlndW91cyBmcmFnbWVudHMgYXJlIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBmcm9tIHNhbWUgcXVhbGl0eSBsZXZlbCAoc2FtZSBsZXZlbCwgbmV3IFNOID0gb2xkIFNOICsgMSlcblxuICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5pc0FBQykge1xuICAgICAgICAgIGlmIChfZGVsdGEgPiAwICYmIF9kZWx0YSA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04pIHtcbiAgICAgICAgICAgIG51bU1pc3NpbmdGcmFtZXMgPSBNYXRoLnJvdW5kKChfcHRzIC0gbmV4dEF1ZGlvUHRzKSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibG9nZ2VyXCJdLmxvZyhcIlttcDQtcmVtdXhlcl06IFwiICsgX2RlbHRhICsgXCIgbXMgaG9sZSBiZXR3ZWVuIEFBQyBzYW1wbGVzIGRldGVjdGVkLGZpbGxpbmcgaXRcIik7XG5cbiAgICAgICAgICAgIGlmIChudW1NaXNzaW5nRnJhbWVzID4gMCkge1xuICAgICAgICAgICAgICBmaWxsRnJhbWUgPSBfYWFjX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuXG4gICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gdW5pdC5zdWJhcnJheSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbWRhdFNpemUgKz0gbnVtTWlzc2luZ0ZyYW1lcyAqIGZpbGxGcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICB9IC8vIGlmIHdlIGhhdmUgZnJhbWUgb3ZlcmxhcCwgb3ZlcmxhcHBpbmcgZm9yIG1vcmUgdGhhbiBoYWxmIGEgZnJhbWUgZHVyYWlvblxuXG4gICAgICAgICAgfSBlbHNlIGlmIChfZGVsdGEgPCAtMTIpIHtcbiAgICAgICAgICAgIC8vIGRyb3Agb3ZlcmxhcHBpbmcgYXVkaW8gZnJhbWVzLi4uIGJyb3dzZXIgd2lsbCBkZWFsIHdpdGggaXRcbiAgICAgICAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS5sb2coXCJbbXA0LXJlbXV4ZXJdOiBkcm9wIG92ZXJsYXBwaW5nIEFBQyBzYW1wbGUsIGV4cGVjdGVkL3BhcnNlZC9kZWx0YTpcIiArIChuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicy9cIiArIChfcHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMykgKyBcInMvXCIgKyAtX2RlbHRhICsgXCJtc1wiKTtcbiAgICAgICAgICAgIG1kYXRTaXplIC09IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuXG5cbiAgICAgICAgICBfcHRzID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICB9IC8vIHJlbWVtYmVyIGZpcnN0IFBUUyBvZiBvdXIgYXVkaW9TYW1wbGVzXG5cblxuICAgICAgICBmaXJzdFBUUyA9IF9wdHM7XG5cbiAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZGF0ID0gbmV3IFVpbnQ4QXJyYXkobWRhdFNpemUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KF9ldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIkV2ZW50c1wiXS5FUlJPUiwgX2V2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiRXZlbnRzXCJdLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IF9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIkVycm9yVHlwZXNcIl0uTVVYX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBfZXJyb3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJFcnJvckRldGFpbHNcIl0uUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgICAgICByZWFzb246IFwiZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgXCIgKyBtZGF0U2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICAgICAgICBtZGF0LnNldChfbXA0X2dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bU1pc3NpbmdGcmFtZXM7IF9pNSsrKSB7XG4gICAgICAgICAgZmlsbEZyYW1lID0gX2FhY19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcblxuICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ubG9nKCdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gZ2V0IHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWM7IGR1cGxpY2F0aW5nIHRoZSBjdXJyZW50IGZyYW1lIGluc3RlYWQnKTtcbiAgICAgICAgICAgIGZpbGxGcmFtZSA9IHVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZGF0LnNldChmaWxsRnJhbWUsIG9mZnNldCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZpbGxGcmFtZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIG91dHB1dFNhbXBsZXMucHVzaChuZXcgTXA0U2FtcGxlKHRydWUsIEFBQ19TQU1QTEVTX1BFUl9GUkFNRSwgZmlsbEZyYW1lLmJ5dGVMZW5ndGgsIDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgdmFyIHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjsgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuXG4gICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgbGFzdFBUUyA9IF9wdHM7XG4gICAgfSAvLyBXZSBjb3VsZCBlbmQgdXAgd2l0aCBubyBhdWRpbyBzYW1wbGVzIGlmIGFsbCBpbnB1dCBzYW1wbGVzIHdlcmUgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJldmlvdXNseSByZW11eGVkIG9uZXNcblxuXG4gICAgdmFyIG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZSBuZXh0IGF1ZGlvIHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGR1cmF0aW9uXG5cblxuICAgIHZhciBsYXN0U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tvdXRwdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbGFzdFBUUyArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZS5kdXJhdGlvbjsgLy8gU2V0IHRoZSB0cmFjayBzYW1wbGVzIGZyb20gaW5wdXRTYW1wbGVzIHRvIG91dHB1dFNhbXBsZXMgYmVmb3JlIHJlbXV4aW5nXG5cbiAgICB2YXIgbW9vZiA9IHJhd01QRUcgPyBuZXcgVWludDhBcnJheSgwKSA6IF9tcDRfZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3RQVFMgLyBzY2FsZUZhY3RvciwgX2V4dGVuZHMoe30sIHRyYWNrLCB7XG4gICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzXG4gICAgfSkpOyAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcblxuICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICB2YXIgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgIHZhciBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgdHlwZSA9ICdhdWRpbyc7XG4gICAgdmFyIGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlc1xuICAgIH07XG4gICAgY29uc29sZS5hc3NlcnQobWRhdC5sZW5ndGgsICdNREFUIGxlbmd0aCBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfTtcblxuICBfcHJvdG8ucmVtdXhFbXB0eUF1ZGlvID0gZnVuY3Rpb24gcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICB2YXIgbmV4dEF1ZGlvUHRzID0gdGhpcy5uZXh0QXVkaW9QdHM7IC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuXG4gICAgdmFyIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gbnVsbCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIHRoaXMuX2luaXREVFM7XG4gICAgdmFyIGVuZERUUyA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIHRoaXMuX2luaXREVFM7IC8vIG9uZSBzYW1wbGUncyBkdXJhdGlvbiB2YWx1ZVxuXG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBzY2FsZUZhY3RvciAqIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTsgLy8gc2FtcGxlcyBjb3VudCBvZiB0aGlzIHNlZ21lbnQncyBkdXJhdGlvblxuXG4gICAgdmFyIG5iU2FtcGxlcyA9IE1hdGguY2VpbCgoZW5kRFRTIC0gc3RhcnREVFMpIC8gZnJhbWVEdXJhdGlvbik7IC8vIHNpbGVudCBmcmFtZVxuXG4gICAgdmFyIHNpbGVudEZyYW1lID0gX2FhY19oZWxwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uZ2V0U2lsZW50RnJhbWUodHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYywgdHJhY2suY2hhbm5lbENvdW50KTtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJsb2dnZXJcIl0ud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTsgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cblxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImxvZ2dlclwiXS50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNhbXBsZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJTYW1wbGVzOyBpKyspIHtcbiAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICB1bml0OiBzaWxlbnRGcmFtZSxcbiAgICAgICAgcHRzOiBzdGFtcCxcbiAgICAgICAgZHRzOiBzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgcmV0dXJuIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5yZW11eElEMyA9IGZ1bmN0aW9uIHJlbXV4SUQzKHRyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgdmFyIGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdOyAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG5cbiAgICAgIHNhbXBsZS5wdHMgPSBQVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHNhbXBsZS5kdHMgPSBQVFNOb3JtYWxpemUoc2FtcGxlLmR0cyAtIGluaXREVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGVzOiBzYW1wbGVzXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVtdXhUZXh0ID0gZnVuY3Rpb24gcmVtdXhUZXh0KHRyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07IC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG5cbiAgICAgIHNhbXBsZS5wdHMgPSBQVFNOb3JtYWxpemUoc2FtcGxlLnB0cyAtIGluaXRQVFMsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICB9XG5cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICAgIH0pO1xuICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBNUDRSZW11eGVyO1xufSgpO1xuXG5cbmZ1bmN0aW9uIFBUU05vcm1hbGl6ZSh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gIHZhciBvZmZzZXQ7XG5cbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgIC8vIC0gMl4zM1xuICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xuICB9IGVsc2Uge1xuICAgIC8vICsgMl4zM1xuICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gIH1cbiAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuXG5cbiAgd2hpbGUgKE1hdGguYWJzKHZhbHVlIC0gcmVmZXJlbmNlKSA+IDQyOTQ5NjcyOTYpIHtcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXlmcmFtZUluZGV4KHNhbXBsZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbnZhciBNcDRTYW1wbGUgPSBmdW5jdGlvbiBNcDRTYW1wbGUoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gIHRoaXMuY3RzID0gdm9pZCAwO1xuICB0aGlzLmZsYWdzID0gdm9pZCAwO1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIHRoaXMuc2l6ZSA9IHNpemU7XG4gIHRoaXMuY3RzID0gY3RzO1xuICB0aGlzLmZsYWdzID0gbmV3IE1wNFNhbXBsZUZsYWdzKGlzS2V5ZnJhbWUpO1xufTtcblxudmFyIE1wNFNhbXBsZUZsYWdzID0gZnVuY3Rpb24gTXA0U2FtcGxlRmxhZ3MoaXNLZXlmcmFtZSkge1xuICB0aGlzLmlzTGVhZGluZyA9IDA7XG4gIHRoaXMuaXNEZXBlbmRlZE9uID0gMDtcbiAgdGhpcy5oYXNSZWR1bmRhbmN5ID0gMDtcbiAgdGhpcy5kZWdyYWRQcmlvID0gMDtcbiAgdGhpcy5kZXBlbmRzT24gPSAxO1xuICB0aGlzLmlzTm9uU3luYyA9IDE7XG4gIHRoaXMuZGVwZW5kc09uID0gaXNLZXlmcmFtZSA/IDIgOiAxO1xuICB0aGlzLmlzTm9uU3luYyA9IGlzS2V5ZnJhbWUgPyAwIDogMTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3JlbXV4L3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cblxuXG5cblxudmFyIFBhc3NUaHJvdWdoUmVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhc3NUaHJvdWdoUmVtdXhlcigpIHtcbiAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRQVFMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEVuZERUUyA9IG51bGw7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFzc1Rocm91Z2hSZW11eGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUykge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIHRoaXMubGFzdEVuZERUUyA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmREVFMgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYykge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZ2VuZXJhdGVJbml0U2VnbWVudCA9IGZ1bmN0aW9uIGdlbmVyYXRlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpIHtcbiAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRoaXMudmlkZW9Db2RlYztcblxuICAgIGlmICghaW5pdFNlZ21lbnQgfHwgIWluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5pdFRyYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuaW5pdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YSA9IE9iamVjdChfdXRpbHNfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZUluaXRTZWdtZW50XCJdKShpbml0U2VnbWVudCk7IC8vIGRlZmF1bHQgYXVkaW8gY29kZWMgaWYgbm90aGluZyBzcGVjaWZpZWRcbiAgICAvLyBUT0RPIDogZXh0cmFjdCB0aGF0IGZyb20gaW5pdFNlZ21lbnRcblxuICAgIGlmICghYXVkaW9Db2RlYykge1xuICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgIH1cblxuICAgIGlmICghdmlkZW9Db2RlYykge1xuICAgICAgdmlkZW9Db2RlYyA9ICdhdmMxLjQyZTAxZSc7XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrcyA9IHt9O1xuXG4gICAgaWYgKGluaXREYXRhLmF1ZGlvICYmIGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgdHJhY2tzLmF1ZGlvID0ge1xuICAgICAgICBjb250YWluZXI6ICdhdWRpby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ2F1ZGlvJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImxvZ2dlclwiXS53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFRyYWNrcyA9IHRyYWNrcztcbiAgfTtcblxuICBfcHJvdG8ucmVtdXggPSBmdW5jdGlvbiByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICAgIGxhc3RFbmREVFMgPSB0aGlzLmxhc3RFbmREVFM7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICB2aWRlbzogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGV4dFRyYWNrLFxuICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgIGluaXRTZWdtZW50OiB1bmRlZmluZWRcbiAgICB9OyAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cblxuICAgIGlmICghT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKGxhc3RFbmREVFMpKSB7XG4gICAgICBsYXN0RW5kRFRTID0gdGhpcy5sYXN0RW5kRFRTID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH0gLy8gVGhlIGJpbmFyeSBzZWdtZW50IGRhdGEgaXMgYWRkZWQgdG8gdGhlIHZpZGVvVHJhY2sgaW4gdGhlIG1wNGRlbXV4ZXIuIFdlIGRvbid0IGNoZWNrIHRvIHNlZSBpZiB0aGUgZGF0YSBpcyBvbmx5XG4gICAgLy8gYXVkaW8gb3IgdmlkZW8gKG9yIGJvdGgpOyBhZGRpbmcgaXQgdG8gdmlkZW8gd2FzIGFuIGFyYml0cmFyeSBjaG9pY2UuXG5cblxuICAgIHZhciBkYXRhID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdFNlZ21lbnQgPSB7XG4gICAgICBpbml0UFRTOiB1bmRlZmluZWQsXG4gICAgICB0aW1lc2NhbGU6IDFcbiAgICB9O1xuICAgIHZhciBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG5cbiAgICBpZiAoIWluaXREYXRhIHx8ICFpbml0RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG5cbiAgICBpZiAoIWluaXREYXRhIHx8ICFpbml0RGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIFdlIGNhbid0IHJlbXV4IGlmIHRoZSBpbml0U2VnbWVudCBjb3VsZCBub3QgYmUgZ2VuZXJhdGVkXG4gICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJsb2dnZXJcIl0ud2FybignW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBGYWlsZWQgdG8gZ2VuZXJhdGUgaW5pdFNlZ21lbnQuJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgaW5pdFNlZ21lbnQudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzO1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShpbml0UFRTKSkge1xuICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGluaXRQVFMgPSBjb21wdXRlSW5pdFBUUyhpbml0RGF0YSwgZGF0YSwgbGFzdEVuZERUUyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uID0gT2JqZWN0KF91dGlsc19tcDRfdG9vbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldER1cmF0aW9uXCJdKShkYXRhLCBpbml0RGF0YSk7XG4gICAgdmFyIHN0YXJ0RFRTID0gbGFzdEVuZERUUztcbiAgICB2YXIgZW5kRFRTID0gZHVyYXRpb24gKyBzdGFydERUUztcbiAgICBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wib2Zmc2V0U3RhcnREVFNcIl0pKGluaXREYXRhLCBkYXRhLCBpbml0UFRTKTtcblxuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZERUUyA9IGVuZERUUztcbiAgICB9IGVsc2Uge1xuICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wibG9nZ2VyXCJdLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuXG4gICAgdmFyIGhhc0F1ZGlvID0gISFpbml0RGF0YS5hdWRpbztcbiAgICB2YXIgaGFzVmlkZW8gPSAhIWluaXREYXRhLnZpZGVvO1xuICAgIHZhciB0eXBlID0gJyc7XG5cbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICB2YXIgdHJhY2sgPSB7XG4gICAgICBkYXRhMTogZGF0YSxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydERUUyxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgIGVuZFBUUzogZW5kRFRTLFxuICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaGFzQXVkaW86IGhhc0F1ZGlvLFxuICAgICAgaGFzVmlkZW86IGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gdHJhY2sudHlwZSAhPT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC50ZXh0ID0gdGV4dFRyYWNrO1xuICAgIHJlc3VsdC5pZDMgPSBpZDNUcmFjaztcbiAgICByZXN1bHQuaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBQYXNzVGhyb3VnaFJlbXV4ZXI7XG59KCk7XG5cbnZhciBjb21wdXRlSW5pdFBUUyA9IGZ1bmN0aW9uIGNvbXB1dGVJbml0UFRTKGluaXREYXRhLCBkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gIHJldHVybiBPYmplY3QoX3V0aWxzX21wNF90b29sc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZ2V0U3RhcnREVFNcIl0pKGluaXREYXRhLCBkYXRhKSAtIHRpbWVPZmZzZXQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFBhc3NUaHJvdWdoUmVtdXhlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3Rhc2stbG9vcC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdGFzay1sb29wLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYXNrTG9vcDsgfSk7XG4vKipcbiAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBUYXNrTG9vcCBhbGxvd3MgdG8gc2NoZWR1bGUgYSB0YXNrIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAob3B0aW9ubmFseSByZXBlYXRlZGx5KSBvbiB0aGUgbWFpbiBsb29wLFxuICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXG4gKlxuICogVGhlIHRhc2sgaXRzZWxmIGlzIGltcGxlbWVudGVkIGluIGBkb1RpY2tgLiBJdCBjYW4gYmUgcmVxdWVzdGVkIGFuZCBjYWxsZWQgZm9yIHNpbmdsZSBleGVjdXRpb25cbiAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxuICpcbiAqIEl0IHdpbGwgYmUgYXNzdXJlZCB0aGF0IHRoZSB0YXNrIGV4ZWN1dGlvbiBtZXRob2QgKGB0aWNrYCkgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBtYWluIGxvb3AgXCJ0aWNrXCIsXG4gKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxuICpcbiAqIElmIGZ1cnRoZXIgZXhlY3V0aW9uIHJlcXVlc3RzIGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCB0aWNrLCBpdCBjYW4gYmUgY2hlY2tlZCB3aXRoIGBoYXNOZXh0VGlja2AsXG4gKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxuICpcbiAqIFRoZSB0YXNrIGNhbiBiZSBzY2hlZHVsZWQgYXMgYW4gaW50ZXJ2YWwgcmVwZWF0ZWRseSB3aXRoIGEgcGVyaW9kIGFzIHBhcmFtZXRlciAoc2VlIGBzZXRJbnRlcnZhbGAsIGBjbGVhckludGVydmFsYCkuXG4gKlxuICogU3ViLWNsYXNzZXMgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGBkb1RpY2tgIG1ldGhvZCB3aGljaCB3aWxsIGVmZmVjdGl2ZWx5IGhhdmUgdGhlIHRhc2sgZXhlY3V0aW9uIHJvdXRpbmUuXG4gKlxuICogRnVydGhlciBleHBsYW5hdGlvbnM6XG4gKlxuICogVGhlIGJhc2VjbGFzcyBoYXMgYSBgdGlja2AgbWV0aG9kIHRoYXQgd2lsbCBzY2hlZHVsZSB0aGUgZG9UaWNrIGNhbGwuIEl0IG1heSBiZSBjYWxsZWQgc3luY2hyb25lb3VzbHlcbiAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cbiAqXG4gKiBXaGVuIHRoZSB0YXNrIGV4ZWN1dGlvbiAoYHRpY2tgIG1ldGhvZCkgaXMgY2FsbGVkIGluIHJlLWVudHJhbnQgd2F5IHRoaXMgaXMgZGV0ZWN0ZWQgYW5kXG4gKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXG4gKiB0YXNrIHByb2Nlc3Npbmcgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiAoYWxzbyBrbm93biBhcyBcIm5leHQgdGlja1wiIGluIHRoZSBOb2RlL0pTIHJ1bnRpbWUgbGluZ28pLlxuICovXG52YXIgVGFza0xvb3AgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYXNrTG9vcCgpIHtcbiAgICB0aGlzLl9ib3VuZFRpY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhc2tMb29wLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgLy8gY2xlYXIgYWxsIHRpbWVycyBiZWZvcmUgdW5yZWdpc3RlcmluZyBmcm9tIGV2ZW50IGJ1c1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICB9O1xuXG4gIF9wcm90by5vbkhhbmRsZXJEZXN0cm95ZWQgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmhhc0ludGVydmFsID0gZnVuY3Rpb24gaGFzSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja0ludGVydmFsO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaGFzTmV4dFRpY2sgPSBmdW5jdGlvbiBoYXNOZXh0VGljaygpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXMgSW50ZXJ2YWwgdGltZSAobXMpXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwobWlsbGlzKSB7XG4gICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKTtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2xlYXJOZXh0VGljayA9IGZ1bmN0aW9uIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tUaW1lcikge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKTtcbiAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50Kys7XG5cbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTsgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG5cbiAgICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID4gMSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgb25seSBvbmUgdGltZXIgZXhpc3RzIGF0IGFueSB0aW1lIGF0IG1heFxuICAgICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7fTtcblxuICByZXR1cm4gVGFza0xvb3A7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90eXBlcy9sZXZlbC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90eXBlcy9sZXZlbC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBIbHNTa2lwLCBnZXRTa2lwVmFsdWUsIEhsc1VybFBhcmFtZXRlcnMsIExldmVsICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1NraXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNTa2lwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTa2lwVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTa2lwVmFsdWU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkhsc1VybFBhcmFtZXRlcnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBIbHNVcmxQYXJhbWV0ZXJzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMZXZlbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExldmVsOyB9KTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhsc1NraXA7XG5cbihmdW5jdGlvbiAoSGxzU2tpcCkge1xuICBIbHNTa2lwW1wiTm9cIl0gPSBcIlwiO1xuICBIbHNTa2lwW1wiWWVzXCJdID0gXCJZRVNcIjtcbiAgSGxzU2tpcFtcInYyXCJdID0gXCJ2MlwiO1xufSkoSGxzU2tpcCB8fCAoSGxzU2tpcCA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pIHtcbiAgdmFyIGNhblNraXBVbnRpbCA9IGRldGFpbHMuY2FuU2tpcFVudGlsLFxuICAgICAgY2FuU2tpcERhdGVSYW5nZXMgPSBkZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzLFxuICAgICAgZW5kU04gPSBkZXRhaWxzLmVuZFNOO1xuICB2YXIgc25DaGFuZ2VHb2FsID0gbXNuIC0gZW5kU047XG5cbiAgaWYgKGNhblNraXBVbnRpbCAmJiBzbkNoYW5nZUdvYWwgPCBjYW5Ta2lwVW50aWwpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cblxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuXG4gIHJldHVybiBIbHNTa2lwLk5vO1xufVxudmFyIEhsc1VybFBhcmFtZXRlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCkge1xuICAgIHRoaXMubXNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEhsc1VybFBhcmFtZXRlcnMucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGREaXJlY3RpdmVzID0gZnVuY3Rpb24gYWRkRGlyZWN0aXZlcyh1cmkpIHtcbiAgICB2YXIgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gICAgdmFyIHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcblxuICAgIGlmICh0aGlzLnBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfc2tpcCcsIHRoaXMuc2tpcCk7XG4gICAgfVxuXG4gICAgc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgICB1cmwuc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBIbHNVcmxQYXJhbWV0ZXJzO1xufSgpO1xudmFyIExldmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGV2ZWwoZGF0YSkge1xuICAgIHRoaXMuYXR0cnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGVjU2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvR3JvdXBJZHMgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICB0aGlzLmxvYWRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlYWxCaXRyYXRlID0gMDtcbiAgICB0aGlzLnRleHRHcm91cElkcyA9IHZvaWQgMDtcbiAgICB0aGlzLnVybCA9IHZvaWQgMDtcbiAgICB0aGlzLl91cmxJZCA9IDA7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcblxuICAgIGlmIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBkYXRhLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gZGF0YS52aWRlb0NvZGVjO1xuICAgIHRoaXMudW5rbm93bkNvZGVjcyA9IGRhdGEudW5rbm93bkNvZGVjcztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pLmpvaW4oJywnKS5yZXBsYWNlKC9cXC5bXi4sXSsvZywgJycpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldmVsLCBbe1xuICAgIGtleTogXCJtYXhCaXRyYXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJpXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cmxbdGhpcy5fdXJsSWRdIHx8ICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cmxJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybElkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlICUgdGhpcy51cmwubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5fdXJsSWQgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXJsSWQgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV2ZWw7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3R5cGVzL2xvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHlwZXMvbG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBQbGF5bGlzdENvbnRleHRUeXBlLCBQbGF5bGlzdExldmVsVHlwZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQbGF5bGlzdENvbnRleHRUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUGxheWxpc3RDb250ZXh0VHlwZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUGxheWxpc3RMZXZlbFR5cGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQbGF5bGlzdExldmVsVHlwZTsgfSk7XG52YXIgUGxheWxpc3RDb250ZXh0VHlwZTtcblxuKGZ1bmN0aW9uIChQbGF5bGlzdENvbnRleHRUeXBlKSB7XG4gIFBsYXlsaXN0Q29udGV4dFR5cGVbXCJNQU5JRkVTVFwiXSA9IFwibWFuaWZlc3RcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIkxFVkVMXCJdID0gXCJsZXZlbFwiO1xuICBQbGF5bGlzdENvbnRleHRUeXBlW1wiQVVESU9fVFJBQ0tcIl0gPSBcImF1ZGlvVHJhY2tcIjtcbiAgUGxheWxpc3RDb250ZXh0VHlwZVtcIlNVQlRJVExFX1RSQUNLXCJdID0gXCJzdWJ0aXRsZVRyYWNrXCI7XG59KShQbGF5bGlzdENvbnRleHRUeXBlIHx8IChQbGF5bGlzdENvbnRleHRUeXBlID0ge30pKTtcblxudmFyIFBsYXlsaXN0TGV2ZWxUeXBlO1xuXG4oZnVuY3Rpb24gKFBsYXlsaXN0TGV2ZWxUeXBlKSB7XG4gIFBsYXlsaXN0TGV2ZWxUeXBlW1wiTUFJTlwiXSA9IFwibWFpblwiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIkFVRElPXCJdID0gXCJhdWRpb1wiO1xuICBQbGF5bGlzdExldmVsVHlwZVtcIlNVQlRJVExFXCJdID0gXCJzdWJ0aXRsZVwiO1xufSkoUGxheWxpc3RMZXZlbFR5cGUgfHwgKFBsYXlsaXN0TGV2ZWxUeXBlID0ge30pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHlwZXMvdHJhbnNtdXhlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3R5cGVzL3RyYW5zbXV4ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBDaHVua01ldGFkYXRhICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNodW5rTWV0YWRhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDaHVua01ldGFkYXRhOyB9KTtcbnZhciBDaHVua01ldGFkYXRhID0gZnVuY3Rpb24gQ2h1bmtNZXRhZGF0YShsZXZlbCwgc24sIGlkLCBzaXplLCBwYXJ0LCBwYXJ0aWFsKSB7XG4gIGlmIChzaXplID09PSB2b2lkIDApIHtcbiAgICBzaXplID0gMDtcbiAgfVxuXG4gIGlmIChwYXJ0ID09PSB2b2lkIDApIHtcbiAgICBwYXJ0ID0gLTE7XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbCA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IHZvaWQgMDtcbiAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgdGhpcy5wYXJ0ID0gdm9pZCAwO1xuICB0aGlzLmlkID0gdm9pZCAwO1xuICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gIHRoaXMucGFydGlhbCA9IHZvaWQgMDtcbiAgdGhpcy50cmFuc211eGluZyA9IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgfTtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB0aGlzLnNuID0gc247XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5zaXplID0gc2l6ZTtcbiAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbn07XG5cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9hdHRyLWxpc3QudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2F0dHItbGlzdC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbnZhciBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG52YXIgQVRUUl9MSVNUX1JFR0VYID0gL1xccyooLis/KVxccyo9KCg/OlxcXCIuKj9cXFwiKXwuKj8pKD86LHwkKS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5cbnZhciBBdHRyTGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJMaXN0KGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHRoaXNbYXR0cl0gPSBhdHRyc1thdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXR0ckxpc3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWNpbWFsSW50ZWdlciA9IGZ1bmN0aW9uIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcblxuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICBpZiAodGhpc1thdHRyTmFtZV0pIHtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9ICh0aGlzW2F0dHJOYW1lXSB8fCAnMHgnKS5zbGljZSgyKTtcbiAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgIHZhciB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXJBc051bWJlciA9IGZ1bmN0aW9uIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGF0dHJOYW1lKSB7XG4gICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDE2KTtcblxuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5kZWNpbWFsRmxvYXRpbmdQb2ludCA9IGZ1bmN0aW9uIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9O1xuXG4gIF9wcm90by5vcHRpb25hbEZsb2F0ID0gZnVuY3Rpb24gb3B0aW9uYWxGbG9hdChhdHRyTmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmVudW1lcmF0ZWRTdHJpbmcgPSBmdW5jdGlvbiBlbnVtZXJhdGVkU3RyaW5nKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9O1xuXG4gIF9wcm90by5ib29sID0gZnVuY3Rpb24gYm9vbChhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXSA9PT0gJ1lFUyc7XG4gIH07XG5cbiAgX3Byb3RvLmRlY2ltYWxSZXNvbHV0aW9uID0gZnVuY3Rpb24gZGVjaW1hbFJlc29sdXRpb24oYXR0ck5hbWUpIHtcbiAgICB2YXIgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuXG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH07XG5cbiAgQXR0ckxpc3QucGFyc2VBdHRyTGlzdCA9IGZ1bmN0aW9uIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgdmFyIHF1b3RlID0gJ1wiJztcbiAgICBBVFRSX0xJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcblxuICAgIHdoaWxlICgobWF0Y2ggPSBBVFRSX0xJU1RfUkVHRVguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBtYXRjaFsyXTtcblxuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cblxuICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJzO1xuICB9O1xuXG4gIHJldHVybiBBdHRyTGlzdDtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChBdHRyTGlzdCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2JpbmFyeS1zZWFyY2gudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbnZhciBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gbGlzdCBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge0JpbmFyeVNlYXJjaENvbXBhcmlzb248VD59IGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUIHwgbnVsbH0gVGhlIG9iamVjdCBpZiBpdCBpcyBmb3VuZCBvciBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKGxpc3QsIGNvbXBhcmlzb25Gbikge1xuICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgdmFyIG1heEluZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBudWxsO1xuICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG5cbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmluYXJ5U2VhcmNoKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvYnVmZmVyLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2J1ZmZlci1oZWxwZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBCdWZmZXJIZWxwZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQnVmZmVySGVscGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVySGVscGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG4vKipcbiAqIEBtb2R1bGUgQnVmZmVySGVscGVyXG4gKlxuICogUHJvdmlkaW5nIG1ldGhvZHMgZGVhbGluZyB3aXRoIGJ1ZmZlciBsZW5ndGggcmV0cmlldmFsIGZvciBleGFtcGxlLlxuICpcbiAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gKlxuICogQWxzbyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2J1ZmZlcmVkXG4gKi9cblxudmFyIG5vb3BCdWZmZXJlZCA9IHtcbiAgbGVuZ3RoOiAwLFxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIEJ1ZmZlckhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckhlbHBlcigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICogQHBhcmFtIHtCdWZmZXJhYmxlfSBtZWRpYVxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzQnVmZmVyZWQobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVmZmVyZWQuc3RhcnQoaSkgJiYgcG9zaXRpb24gPD0gYnVmZmVyZWQuZW5kKGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikgey8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvID0gZnVuY3Rpb24gYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHZhciB2YnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICB2YXIgYnVmZmVyZWQgPSBbXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSxcbiAgICAgICAgICAgIGVuZDogdmJ1ZmZlcmVkLmVuZChpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZW46IDAsXG4gICAgICBzdGFydDogcG9zLFxuICAgICAgZW5kOiBwb3MsXG4gICAgICBuZXh0U3RhcnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG5cbiAgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mbyA9IGZ1bmN0aW9uIGJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGRpZmYgPSBhLnN0YXJ0IC0gYi5zdGFydDtcblxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgYnVmZmVyZWQyID0gW107XG5cbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuXG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgdmFyIGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDsgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcblxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlckxlbiA9IDA7IC8vIGJ1ZmZlclN0YXJ0TmV4dCBjYW4gcG9zc2libHkgYmUgdW5kZWZpbmVkIGJhc2VkIG9uIHRoZSBjb25kaXRpb25hbCBsb2dpYyBiZWxvd1xuXG4gICAgdmFyIGJ1ZmZlclN0YXJ0TmV4dDsgLy8gYnVmZmVyU3RhcnQgYW5kIGJ1ZmZlckVuZCBhcmUgYnVmZmVyIGJvdW5kYXJpZXMgYXJvdW5kIGN1cnJlbnQgdmlkZW8gcG9zaXRpb25cblxuICAgIHZhciBidWZmZXJTdGFydCA9IHBvcztcbiAgICB2YXIgYnVmZmVyRW5kID0gcG9zO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJ1ZmZlcmVkMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkMltfaV0uc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gYnVmZmVyZWQyW19pXS5lbmQ7IC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcblxuICAgICAgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA+PSBzdGFydCAmJiBwb3MgPCBlbmQpIHtcbiAgICAgICAgLy8gcGxheSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhpcyBidWZmZXIgVGltZVJhbmdlLCByZXRyaWV2ZSBlbmQgb2YgYnVmZmVyIHBvc2l0aW9uIGFuZCBidWZmZXIgbGVuZ3RoXG4gICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGJ1ZmZlckVuZCA9IGVuZDtcbiAgICAgICAgYnVmZmVyTGVuID0gYnVmZmVyRW5kIC0gcG9zO1xuICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydE5leHQgPSBzdGFydDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogYnVmZmVyTGVuLFxuICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICBlbmQ6IGJ1ZmZlckVuZCB8fCAwLFxuICAgICAgbmV4dFN0YXJ0OiBidWZmZXJTdGFydE5leHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICA7XG5cbiAgQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWQobWVkaWEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCdWZmZXJIZWxwZXI7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2NlYS02MDgtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFJvdywgQ2FwdGlvblNjcmVlbiwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSb3dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBSb3c7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNhcHRpb25TY3JlZW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDYXB0aW9uU2NyZWVuOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9sb2dnZXIgKi8gXCIuL3NyYy91dGlscy9sb2dnZXIudHNcIik7XG5cbi8qKlxuICpcbiAqIFRoaXMgY29kZSB3YXMgcG9ydGVkIGZyb20gdGhlIGRhc2guanMgcHJvamVjdCBhdDpcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvY29tbWl0LzgyNjliMjZhNzYxZTA4NTNiYjIxZDc4NzgwZWQ5NDUxNDRlY2RkNGQjZGlmZi03MWJjMjk1YTJkNmI2YjcwOTNhMWQzMjkwZDUzYTRiMlxuICpcbiAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAqXG4gKiBUaGUgY29weXJpZ2h0IGluIHRoaXMgc29mdHdhcmUgaXMgYmVpbmcgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLFxuICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gKiByaWdodHMsIGluY2x1ZGluZyBwYXRlbnQgcmlnaHRzLCBhbmQgbm8gc3VjaCByaWdodHMgYXJlIGdyYW50ZWQgdW5kZXIgdGhpcyBsaWNlbnNlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAyLiBOZWl0aGVyIHRoZSBuYW1lIG9mIERhc2ggSW5kdXN0cnkgRm9ydW0gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgQVMgSVMgQU5EIEFOWVxuICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAqICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuXG4gKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gKiAgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqICBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogIEV4Y2VwdGlvbnMgZnJvbSByZWd1bGFyIEFTQ0lJLiBDb2RlUG9pbnRzIGFyZSBtYXBwZWQgdG8gVVRGLTE2IGNvZGVzXG4gKi9cblxudmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAweDJhOiAweGUxLFxuICAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDB4NWM6IDB4ZTksXG4gIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZTogMHhlZCxcbiAgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAweDVmOiAweGYzLFxuICAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDB4NjA6IDB4ZmEsXG4gIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMHg3YjogMHhlNyxcbiAgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gIDB4N2M6IDB4ZjcsXG4gIC8vIGRpdmlzaW9uIHN5bWJvbFxuICAweDdkOiAweGQxLFxuICAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAweDdlOiAweGYxLFxuICAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAweDdmOiAweDI1ODgsXG4gIC8vIEZ1bGwgYmxvY2tcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDExIEFORCBMT1cgQkVUV0VFTiAweDMwIEFORCAweDNGXG4gIC8vIFRISVMgTUVBTlMgVEhBVCBcXHg1MCBNVVNUIEJFIEFEREVEIFRPIFRIRSBWQUxVRVNcbiAgMHg4MDogMHhhZSxcbiAgLy8gUmVnaXN0ZXJlZCBzeW1ib2wgKFIpXG4gIDB4ODE6IDB4YjAsXG4gIC8vIGRlZ3JlZSBzaWduXG4gIDB4ODI6IDB4YmQsXG4gIC8vIDEvMiBzeW1ib2xcbiAgMHg4MzogMHhiZixcbiAgLy8gSW52ZXJ0ZWQgKG9wZW4pIHF1ZXN0aW9uIG1hcmtcbiAgMHg4NDogMHgyMTIyLFxuICAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgMHg4NTogMHhhMixcbiAgLy8gQ2VudHMgc3ltYm9sXG4gIDB4ODY6IDB4YTMsXG4gIC8vIFBvdW5kcyBzdGVybGluZ1xuICAweDg3OiAweDI2NmEsXG4gIC8vIE11c2ljIDgndGggbm90ZVxuICAweDg4OiAweGUwLFxuICAvLyBsb3dlcmNhc2UgYSwgZ3JhdmUgYWNjZW50XG4gIDB4ODk6IDB4MjAsXG4gIC8vIHRyYW5zcGFyZW50IHNwYWNlIChyZWd1bGFyKVxuICAweDhhOiAweGU4LFxuICAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDB4OGI6IDB4ZTIsXG4gIC8vIGxvd2VyY2FzZSBhLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhjOiAweGVhLFxuICAvLyBsb3dlcmNhc2UgZSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZDogMHhlZSxcbiAgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGU6IDB4ZjQsXG4gIC8vIGxvd2VyY2FzZSBvLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhmOiAweGZiLFxuICAvLyBsb3dlcmNhc2UgdSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4OTA6IDB4YzEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAweDkxOiAweGM5LFxuICAvLyBjYXBpdGFsIGxldHRlciBFIHdpdGggYWN1dGVcbiAgMHg5MjogMHhkMyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gIDB4OTM6IDB4ZGEsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAweDk0OiAweGRjLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggZGlhcmVzaXNcbiAgMHg5NTogMHhmYyxcbiAgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gIDB4OTY6IDB4MjAxOCxcbiAgLy8gb3BlbmluZyBzaW5nbGUgcXVvdGVcbiAgMHg5NzogMHhhMSxcbiAgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAweDk4OiAweDJhLFxuICAvLyBhc3Rlcmlza1xuICAweDk5OiAweDIwMTksXG4gIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDB4OWE6IDB4MjUwMSxcbiAgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMHg5YjogMHhhOSxcbiAgLy8gY29weXJpZ2h0IHNpZ25cbiAgMHg5YzogMHgyMTIwLFxuICAvLyBTZXJ2aWNlIG1hcmtcbiAgMHg5ZDogMHgyMDIyLFxuICAvLyAocm91bmQpIGJ1bGxldFxuICAweDllOiAweDIwMWMsXG4gIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4OWY6IDB4MjAxZCxcbiAgLy8gUmlnaHQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gIDB4YTA6IDB4YzAsXG4gIC8vIHVwcGVyY2FzZSBBLCBncmF2ZSBhY2NlbnRcbiAgMHhhMTogMHhjMixcbiAgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMHhhMjogMHhjNyxcbiAgLy8gdXBwZXJjYXNlIEMgd2l0aCBjZWRpbGxhXG4gIDB4YTM6IDB4YzgsXG4gIC8vIHVwcGVyY2FzZSBFLCBncmF2ZSBhY2NlbnRcbiAgMHhhNDogMHhjYSxcbiAgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMHhhNTogMHhjYixcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGRpYXJlc2lzXG4gIDB4YTY6IDB4ZWIsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgZSB3aXRoIGRpYXJlc2lzXG4gIDB4YTc6IDB4Y2UsXG4gIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDB4YTg6IDB4Y2YsXG4gIC8vIHVwcGVyY2FzZSBJLCB3aXRoIGRpYXJlc2lzXG4gIDB4YTk6IDB4ZWYsXG4gIC8vIGxvd2VyY2FzZSBpLCB3aXRoIGRpYXJlc2lzXG4gIDB4YWE6IDB4ZDQsXG4gIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDB4YWI6IDB4ZDksXG4gIC8vIHVwcGVyY2FzZSBVLCBncmF2ZSBhY2NlbnRcbiAgMHhhYzogMHhmOSxcbiAgLy8gbG93ZXJjYXNlIHUsIGdyYXZlIGFjY2VudFxuICAweGFkOiAweGRiLFxuICAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAweGFlOiAweGFiLFxuICAvLyBsZWZ0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAweGFmOiAweGJiLFxuICAvLyByaWdodC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMzIgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gIDB4YjA6IDB4YzMsXG4gIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAweGIxOiAweGUzLFxuICAvLyBMb3dlcmNhc2UgYSwgdGlsZGVcbiAgMHhiMjogMHhjZCxcbiAgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAweGIzOiAweGNjLFxuICAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDB4YjQ6IDB4ZWMsXG4gIC8vIExvd2VyY2FzZSBpLCBncmF2ZSBhY2NlbnRcbiAgMHhiNTogMHhkMixcbiAgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAweGI2OiAweGYyLFxuICAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDB4Yjc6IDB4ZDUsXG4gIC8vIFVwcGVyY2FzZSBPLCB0aWxkZVxuICAweGI4OiAweGY1LFxuICAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgMHhiOTogMHg3YixcbiAgLy8gT3BlbiBjdXJseSBicmFjZVxuICAweGJhOiAweDdkLFxuICAvLyBDbG9zaW5nIGN1cmx5IGJyYWNlXG4gIDB4YmI6IDB4NWMsXG4gIC8vIEJhY2tzbGFzaFxuICAweGJjOiAweDVlLFxuICAvLyBDYXJldFxuICAweGJkOiAweDVmLFxuICAvLyBVbmRlcnNjb3JlXG4gIDB4YmU6IDB4N2MsXG4gIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gIDB4YmY6IDB4MjIzYyxcbiAgLy8gVGlsZGUgb3BlcmF0b3JcbiAgMHhjMDogMHhjNCxcbiAgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAweGMxOiAweGU0LFxuICAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gIDB4YzI6IDB4ZDYsXG4gIC8vIFVwcGVyY2FzZSBPLCB1bWxhdXRcbiAgMHhjMzogMHhmNixcbiAgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAweGM0OiAweGRmLFxuICAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAweGM1OiAweGE1LFxuICAvLyBZZW4gc3ltYm9sXG4gIDB4YzY6IDB4YTQsXG4gIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAweGM3OiAweDI1MDMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAweGM4OiAweGM1LFxuICAvLyBVcHBlcmNhc2UgQSwgcmluZ1xuICAweGM5OiAweGU1LFxuICAvLyBMb3dlcmNhc2UgQSwgcmluZ1xuICAweGNhOiAweGQ4LFxuICAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDB4Y2I6IDB4ZjgsXG4gIC8vIExvd2VyY2FzZSBvLCBzdHJva1xuICAweGNjOiAweDI1MGYsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCByaWdodFxuICAweGNkOiAweDI1MTMsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gIDB4Y2U6IDB4MjUxNyxcbiAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCByaWdodFxuICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG5cbn07XG4vKipcbiAqIFV0aWxzXG4gKi9cblxudmFyIGdldENoYXJGb3JCeXRlID0gZnVuY3Rpb24gZ2V0Q2hhckZvckJ5dGUoX2J5dGUpIHtcbiAgdmFyIGNoYXJDb2RlID0gX2J5dGU7XG5cbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KF9ieXRlKSkge1xuICAgIGNoYXJDb2RlID0gc3BlY2lhbENlYTYwOENoYXJzQ29kZXNbX2J5dGVdO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xufTtcblxudmFyIE5SX1JPV1MgPSAxNTtcbnZhciBOUl9DT0xTID0gMTAwOyAvLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxuXG52YXIgcm93c0xvd0NoMSA9IHtcbiAgMHgxMTogMSxcbiAgMHgxMjogMyxcbiAgMHgxNTogNSxcbiAgMHgxNjogNyxcbiAgMHgxNzogOSxcbiAgMHgxMDogMTEsXG4gIDB4MTM6IDEyLFxuICAweDE0OiAxNFxufTtcbnZhciByb3dzSGlnaENoMSA9IHtcbiAgMHgxMTogMixcbiAgMHgxMjogNCxcbiAgMHgxNTogNixcbiAgMHgxNjogOCxcbiAgMHgxNzogMTAsXG4gIDB4MTM6IDEzLFxuICAweDE0OiAxNVxufTtcbnZhciByb3dzTG93Q2gyID0ge1xuICAweDE5OiAxLFxuICAweDFhOiAzLFxuICAweDFkOiA1LFxuICAweDFlOiA3LFxuICAweDFmOiA5LFxuICAweDE4OiAxMSxcbiAgMHgxYjogMTIsXG4gIDB4MWM6IDE0XG59O1xudmFyIHJvd3NIaWdoQ2gyID0ge1xuICAweDE5OiAyLFxuICAweDFhOiA0LFxuICAweDFkOiA2LFxuICAweDFlOiA4LFxuICAweDFmOiAxMCxcbiAgMHgxYjogMTMsXG4gIDB4MWM6IDE1XG59O1xudmFyIGJhY2tncm91bmRDb2xvcnMgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnYmxhY2snLCAndHJhbnNwYXJlbnQnXTtcbnZhciBWZXJib3NlTGV2ZWw7XG5cbihmdW5jdGlvbiAoVmVyYm9zZUxldmVsKSB7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJFUlJPUlwiXSA9IDBdID0gXCJFUlJPUlwiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiVEVYVFwiXSA9IDFdID0gXCJURVhUXCI7XG4gIFZlcmJvc2VMZXZlbFtWZXJib3NlTGV2ZWxbXCJXQVJOSU5HXCJdID0gMl0gPSBcIldBUk5JTkdcIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIklORk9cIl0gPSAyXSA9IFwiSU5GT1wiO1xuICBWZXJib3NlTGV2ZWxbVmVyYm9zZUxldmVsW1wiREVCVUdcIl0gPSAzXSA9IFwiREVCVUdcIjtcbiAgVmVyYm9zZUxldmVsW1ZlcmJvc2VMZXZlbFtcIkRBVEFcIl0gPSAzXSA9IFwiREFUQVwiO1xufSkoVmVyYm9zZUxldmVsIHx8IChWZXJib3NlTGV2ZWwgPSB7fSkpO1xuXG52YXIgQ2FwdGlvbnNMb2dnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXB0aW9uc0xvZ2dlcigpIHtcbiAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgIHRoaXMudmVyYm9zZUxldmVsID0gVmVyYm9zZUxldmVsLkVSUk9SO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhcHRpb25zTG9nZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubG9nID0gZnVuY3Rpb24gbG9nKHNldmVyaXR5LCBtc2cpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gc2V2ZXJpdHkpIHtcbiAgICAgIF91dGlsc19sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImxvZ2dlclwiXS5sb2codGhpcy50aW1lICsgXCIgW1wiICsgc2V2ZXJpdHkgKyBcIl0gXCIgKyBtc2cpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvbnNMb2dnZXI7XG59KCk7XG5cbnZhciBudW1BcnJheVRvSGV4QXJyYXkgPSBmdW5jdGlvbiBudW1BcnJheVRvSGV4QXJyYXkobnVtQXJyYXkpIHtcbiAgdmFyIGhleEFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcnJheS5sZW5ndGg7IGorKykge1xuICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgfVxuXG4gIHJldHVybiBoZXhBcnJheTtcbn07XG5cbnZhciBQZW5TdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBlblN0YXRlKGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSB2b2lkIDA7XG4gICAgdGhpcy51bmRlcmxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5pdGFsaWNzID0gdm9pZCAwO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZsYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQgfHwgJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IHVuZGVybGluZSB8fCBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBpdGFsaWNzIHx8IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgJ2JsYWNrJztcbiAgICB0aGlzLmZsYXNoID0gZmxhc2ggfHwgZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFBlblN0YXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzIuc2V0U3R5bGVzID0gZnVuY3Rpb24gc2V0U3R5bGVzKHN0eWxlcykge1xuICAgIHZhciBhdHRyaWJzID0gWydmb3JlZ3JvdW5kJywgJ3VuZGVybGluZScsICdpdGFsaWNzJywgJ2JhY2tncm91bmQnLCAnZmxhc2gnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcblxuICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgdGhpc1tzdHlsZV0gPSBzdHlsZXNbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmlzRGVmYXVsdCA9IGZ1bmN0aW9uIGlzRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaDtcbiAgfTtcblxuICBfcHJvdG8yLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IG90aGVyLmZvcmVncm91bmQgJiYgdGhpcy51bmRlcmxpbmUgPT09IG90aGVyLnVuZGVybGluZSAmJiB0aGlzLml0YWxpY3MgPT09IG90aGVyLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBvdGhlci5iYWNrZ3JvdW5kICYmIHRoaXMuZmxhc2ggPT09IG90aGVyLmZsYXNoO1xuICB9O1xuXG4gIF9wcm90bzIuY29weSA9IGZ1bmN0aW9uIGNvcHkobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIHRoaXMudW5kZXJsaW5lID0gbmV3UGVuU3RhdGUudW5kZXJsaW5lO1xuICAgIHRoaXMuaXRhbGljcyA9IG5ld1BlblN0YXRlLml0YWxpY3M7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICB0aGlzLmZsYXNoID0gbmV3UGVuU3RhdGUuZmxhc2g7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgKyAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaDtcbiAgfTtcblxuICByZXR1cm4gUGVuU3RhdGU7XG59KCk7XG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIFN0eWxlZFVuaWNvZGVDaGFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVkVW5pY29kZUNoYXIodWNoYXIsIGZvcmVncm91bmQsIHVuZGVybGluZSwgaXRhbGljcywgYmFja2dyb3VuZCwgZmxhc2gpIHtcbiAgICB0aGlzLnVjaGFyID0gdm9pZCAwO1xuICAgIHRoaXMucGVuU3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyIHx8ICcgJzsgLy8gdW5pY29kZSBjaGFyYWN0ZXJcblxuICAgIHRoaXMucGVuU3RhdGUgPSBuZXcgUGVuU3RhdGUoZm9yZWdyb3VuZCwgdW5kZXJsaW5lLCBpdGFsaWNzLCBiYWNrZ3JvdW5kLCBmbGFzaCk7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy51Y2hhciA9ICcgJztcbiAgICB0aGlzLnBlblN0YXRlLnJlc2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvMy5zZXRDaGFyID0gZnVuY3Rpb24gc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnVjaGFyID0gdWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld1BlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8zLnNldFBlblN0YXRlID0gZnVuY3Rpb24gc2V0UGVuU3RhdGUobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9O1xuXG4gIF9wcm90bzMuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8zLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld0NoYXIpIHtcbiAgICB0aGlzLnVjaGFyID0gbmV3Q2hhci51Y2hhcjtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvMy5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gJyAnICYmIHRoaXMucGVuU3RhdGUuaXNEZWZhdWx0KCk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlZFVuaWNvZGVDaGFyO1xufSgpO1xuLyoqXG4gKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgUm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm93KGxvZ2dlcikge1xuICAgIHRoaXMuY2hhcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wb3MgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyUGVuU3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFJvdy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICB2YXIgZXF1YWwgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5jaGFyc1tpXS5lcXVhbHMob3RoZXIuY2hhcnNbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcXVhbDtcbiAgfTtcblxuICBfcHJvdG80LmNvcHkgPSBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzQuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuICAvKipcbiAgICogIFNldCB0aGUgY3Vyc29yIHRvIGEgdmFsaWQgY29sdW1uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzQuc2V0Q3Vyc29yID0gZnVuY3Rpb24gc2V0Q3Vyc29yKGFic1Bvcykge1xuICAgIGlmICh0aGlzLnBvcyAhPT0gYWJzUG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wb3MgPCAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IE5SX0NPTFM7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG80Lm1vdmVDdXJzb3IgPSBmdW5jdGlvbiBtb3ZlQ3Vyc29yKHJlbFBvcykge1xuICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcblxuICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MgKyAxOyBpIDwgbmV3UG9zICsgMTsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbaV0uc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gIH1cbiAgLyoqXG4gICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNC5iYWNrU3BhY2UgPSBmdW5jdGlvbiBiYWNrU3BhY2UoKSB7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKTtcbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9O1xuXG4gIF9wcm90bzQuaW5zZXJ0Q2hhciA9IGZ1bmN0aW9uIGluc2VydENoYXIoX2J5dGUyKSB7XG4gICAgaWYgKF9ieXRlMiA+PSAweDkwKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyXG4gICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIH1cblxuICAgIHZhciBfY2hhciA9IGdldENoYXJGb3JCeXRlKF9ieXRlMik7XG5cbiAgICBpZiAodGhpcy5wb3MgPj0gTlJfQ09MUykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5FUlJPUiwgJ0Nhbm5vdCBpbnNlcnQgJyArIF9ieXRlMi50b1N0cmluZygxNikgKyAnICgnICsgX2NoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKF9jaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICB9O1xuXG4gIF9wcm90bzQuY2xlYXJGcm9tUG9zID0gZnVuY3Rpb24gY2xlYXJGcm9tUG9zKHN0YXJ0UG9zKSB7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgdGhpcy5jaGFyc1tpXS5yZXNldCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3MoMCk7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvNC5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgdGhpcy5jbGVhckZyb21Qb3ModGhpcy5wb3MpO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0VGV4dFN0cmluZyA9IGZ1bmN0aW9uIGdldFRleHRTdHJpbmcoKSB7XG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB2YXIgX2NoYXIyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcblxuICAgICAgaWYgKF9jaGFyMiAhPT0gJyAnKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNoYXJzLnB1c2goX2NoYXIyKTtcbiAgICB9XG5cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG80LnNldFBlblN0eWxlcyA9IGZ1bmN0aW9uIHNldFBlblN0eWxlcyhzdHlsZXMpIHtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICB2YXIgY3VyckNoYXIgPSB0aGlzLmNoYXJzW3RoaXMucG9zXTtcbiAgICBjdXJyQ2hhci5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFJvdztcbn0oKTtcbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgQ2FwdGlvblNjcmVlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhcHRpb25TY3JlZW4obG9nZ2VyKSB7XG4gICAgdGhpcy5yb3dzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLm5yUm9sbFVwUm93cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yb3dzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzLnB1c2gobmV3IFJvdyhsb2dnZXIpKTtcbiAgICB9IC8vIE5vdGUgdGhhdCB3ZSB1c2UgemVyby1iYXNlZCBudW1iZXJpbmcgKDAtMTQpXG5cblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBudWxsO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG81ID0gQ2FwdGlvblNjcmVlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgfTtcblxuICBfcHJvdG81LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHZhciBlcXVhbCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcXVhbDtcbiAgfTtcblxuICBfcHJvdG81LmNvcHkgPSBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIHRoaXMucm93c1tpXS5jb3B5KG90aGVyLnJvd3NbaV0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG81LmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbXB0eTtcbiAgfTtcblxuICBfcHJvdG81LmJhY2tTcGFjZSA9IGZ1bmN0aW9uIGJhY2tTcGFjZSgpIHtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmJhY2tTcGFjZSgpO1xuICB9O1xuXG4gIF9wcm90bzUuY2xlYXJUb0VuZE9mUm93ID0gZnVuY3Rpb24gY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvNS5pbnNlcnRDaGFyID0gZnVuY3Rpb24gaW5zZXJ0Q2hhcihfY2hhcjMpIHtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lmluc2VydENoYXIoX2NoYXIzKTtcbiAgfTtcblxuICBfcHJvdG81LnNldFBlbiA9IGZ1bmN0aW9uIHNldFBlbihzdHlsZXMpIHtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICB9O1xuXG4gIF9wcm90bzUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5tb3ZlQ3Vyc29yKHJlbFBvcyk7XG4gIH07XG5cbiAgX3Byb3RvNS5zZXRDdXJzb3IgPSBmdW5jdGlvbiBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnc2V0Q3Vyc29yOiAnICsgYWJzUG9zKTtcbiAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldEN1cnNvcihhYnNQb3MpO1xuICB9O1xuXG4gIF9wcm90bzUuc2V0UEFDID0gZnVuY3Rpb24gc2V0UEFDKHBhY0RhdGEpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdwYWNEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KHBhY0RhdGEpKTtcbiAgICB2YXIgbmV3Um93ID0gcGFjRGF0YS5yb3cgLSAxO1xuXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIG5ld1JvdyA8IHRoaXMubnJSb2xsVXBSb3dzIC0gMSkge1xuICAgICAgbmV3Um93ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcblxuXG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzICYmIHRoaXMuY3VyclJvdyAhPT0gbmV3Um93KSB7XG4gICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICB9IC8vIENvcHkgdGhpcy5uclJvbGxVcFJvd3Mgcm93cyBmcm9tIGxhc3RPdXRwdXRTY3JlZW4gYW5kIHBsYWNlIGl0IGluIHRoZSBuZXdSb3cgbG9jYXRpb25cbiAgICAgIC8vIHRvcFJvd0luZGV4IC0gdGhlIHN0YXJ0IG9mIHJvd3MgdG8gY29weSAoaW5jbHVzaXZlIGluZGV4KVxuXG5cbiAgICAgIHZhciB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93czsgLy8gV2Ugb25seSBjb3B5IGlmIHRoZSBsYXN0IHBvc2l0aW9uIHdhcyBhbHJlYWR5IHNob3duLlxuICAgICAgLy8gV2UgdXNlIHRoZSBjdWVTdGFydFRpbWUgdmFsdWUgdG8gY2hlY2sgdGhpcy5cblxuICAgICAgdmFyIGxhc3RPdXRwdXRTY3JlZW4gPSB0aGlzLmxhc3RPdXRwdXRTY3JlZW47XG5cbiAgICAgIGlmIChsYXN0T3V0cHV0U2NyZWVuKSB7XG4gICAgICAgIHZhciBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLmxvZ2dlci50aW1lO1xuXG4gICAgICAgIGlmIChwcmV2TGluZVRpbWUgJiYgdGltZSAhPT0gbnVsbCAmJiBwcmV2TGluZVRpbWUgPCB0aW1lKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubnJSb2xsVXBSb3dzOyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBfaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgX2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuXG4gICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XG4gICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGluZGVudCAtIDEsIDApO1xuICAgICAgcm93LnNldEN1cnNvcihwYWNEYXRhLmluZGVudCk7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgIGZvcmVncm91bmQ6IHBhY0RhdGEuY29sb3IsXG4gICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgaXRhbGljczogcGFjRGF0YS5pdGFsaWNzLFxuICAgICAgYmFja2dyb3VuZDogJ2JsYWNrJyxcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5zZXRQZW4oc3R5bGVzKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzUuc2V0QmtnRGF0YSA9IGZ1bmN0aW9uIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ2JrZ0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkoYmtnRGF0YSkpO1xuICAgIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgdGhpcy5zZXRQZW4oYmtnRGF0YSk7XG4gICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICB9O1xuXG4gIF9wcm90bzUuc2V0Um9sbFVwUm93cyA9IGZ1bmN0aW9uIHNldFJvbGxVcFJvd3MobnJSb3dzKSB7XG4gICAgdGhpcy5uclJvbGxVcFJvd3MgPSBuclJvd3M7XG4gIH07XG5cbiAgX3Byb3RvNS5yb2xsVXAgPSBmdW5jdGlvbiByb2xsVXAoKSB7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLkRFQlVHLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgdmFyIHRvcFJvdyA9IHRoaXMucm93cy5zcGxpY2UodG9wUm93SW5kZXgsIDEpWzBdO1xuICAgIHRvcFJvdy5jbGVhcigpO1xuICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1JvbGxpbmcgdXAnKTsgLy8gdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5URVhULCB0aGlzLmdldF9kaXNwbGF5X3RleHQoKSlcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBub24tZW1wdHkgcm93cyB3aXRoIGFzIHVuaWNvZGUgdGV4dC5cbiAgICovXG4gIDtcblxuICBfcHJvdG81LmdldERpc3BsYXlUZXh0ID0gZnVuY3Rpb24gZ2V0RGlzcGxheVRleHQoYXNPbmVSb3cpIHtcbiAgICBhc09uZVJvdyA9IGFzT25lUm93IHx8IGZhbHNlO1xuICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xuICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgdmFyIHJvd05yID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdmFyIHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuXG4gICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICByb3dOciA9IGkgKyAxO1xuXG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyBcIjogJ1wiICsgcm93VGV4dCArIFwiJ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNwbGF5VGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoYXNPbmVSb3cpIHtcbiAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IGRpc3BsYXlUZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIF9wcm90bzUuZ2V0VGV4dEFuZEZvcm1hdCA9IGZ1bmN0aW9uIGdldFRleHRBbmRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cztcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvblNjcmVlbjtcbn0oKTsgLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcblxudmFyIENlYTYwOENoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZWE2MDhDaGFubmVsKGNoYW5uZWxOdW1iZXIsIG91dHB1dEZpbHRlciwgbG9nZ2VyKSB7XG4gICAgdGhpcy5jaE5yID0gdm9pZCAwO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZlcmJvc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIHRoaXMuY2hOciA9IGNoYW5uZWxOdW1iZXI7XG4gICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBvdXRwdXRGaWx0ZXI7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLnZlcmJvc2UgPSAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gbmV3IENhcHRpb25TY3JlZW4obG9nZ2VyKTtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW05SX1JPV1MgLSAxXTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXJlIGEgY3VlIHN0YXJ0ZWQuXG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuXG4gIHZhciBfcHJvdG82ID0gQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90bzYuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uIGdldEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9O1xuXG4gIF9wcm90bzYuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgfTtcblxuICBfcHJvdG82LnNldFBBQyA9IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvNi5zZXRCa2dEYXRhID0gZnVuY3Rpb24gc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5zZXRCa2dEYXRhKGJrZ0RhdGEpO1xuICB9O1xuXG4gIF9wcm90bzYuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUobmV3TW9kZSkge1xuICAgIGlmIChuZXdNb2RlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ01PREU9JyArIG5ld01vZGUpO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUE9QLU9OJykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH07XG5cbiAgX3Byb3RvNi5pbnNlcnRDaGFycyA9IGZ1bmN0aW9uIGluc2VydENoYXJzKGNoYXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgc2NyZWVuICsgJzogJyArIHRoaXMud3JpdGVTY3JlZW4uZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuVEVYVCwgJ0RJU1BMQVlFRDogJyArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KHRydWUpKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG82LmNjUkNMID0gZnVuY3Rpb24gY2NSQ0woKSB7XG4gICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0JTID0gZnVuY3Rpb24gY2NCUygpIHtcbiAgICAvLyBCYWNrU3BhY2VcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdCUyAtIEJhY2tTcGFjZScpO1xuXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuXG4gICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNi5jY0FPRiA9IGZ1bmN0aW9uIGNjQU9GKCkgey8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPZmYpXG4gIH07XG5cbiAgX3Byb3RvNi5jY0FPTiA9IGZ1bmN0aW9uIGNjQU9OKCkgey8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgfTtcblxuICBfcHJvdG82LmNjREVSID0gZnVuY3Rpb24gY2NERVIoKSB7XG4gICAgLy8gRGVsZXRlIHRvIEVuZCBvZiBSb3dcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdERVItIERlbGV0ZSB0byBFbmQgb2YgUm93Jyk7XG4gICAgdGhpcy53cml0ZVNjcmVlbi5jbGVhclRvRW5kT2ZSb3coKTtcbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgfTtcblxuICBfcHJvdG82LmNjUlUgPSBmdW5jdGlvbiBjY1JVKG5yUm93cykge1xuICAgIC8vIFJvbGwtVXAgQ2FwdGlvbnMtMiwzLG9yIDQgUm93c1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1JVKCcgKyBuclJvd3MgKyAnKSAtIFJvbGwgVXAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgfTtcblxuICBfcHJvdG82LmNjRk9OID0gZnVuY3Rpb24gY2NGT04oKSB7XG4gICAgLy8gRmxhc2ggT25cbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdGT04gLSBGbGFzaCBPbicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgIGZsYXNoOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY1JEQyA9IGZ1bmN0aW9uIGNjUkRDKCkge1xuICAgIC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUEFJTlQtT04nKTtcbiAgfTtcblxuICBfcHJvdG82LmNjVFIgPSBmdW5jdGlvbiBjY1RSKCkge1xuICAgIC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnVFInKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NSVEQgPSBmdW5jdGlvbiBjY1JURCgpIHtcbiAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdSVEQnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NFRE0gPSBmdW5jdGlvbiBjY0VETSgpIHtcbiAgICAvLyBFcmFzZSBEaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NDUiA9IGZ1bmN0aW9uIGNjQ1IoKSB7XG4gICAgLy8gQ2FycmlhZ2UgUmV0dXJuXG4gICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5JTkZPLCAnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpO1xuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfTtcblxuICBfcHJvdG82LmNjRU5NID0gZnVuY3Rpb24gY2NFTk0oKSB7XG4gICAgLy8gRXJhc2UgTm9uLURpc3BsYXllZCBNZW1vcnlcbiAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvNi5jY0VPQyA9IGZ1bmN0aW9uIGNjRU9DKCkge1xuICAgIC8vIEVuZCBvZiBDYXB0aW9uIChGbGlwIE1lbW9yaWVzKVxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG5cbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICB2YXIgdG1wID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9O1xuXG4gIF9wcm90bzYuY2NUTyA9IGZ1bmN0aW9uIGNjVE8obnJDb2xzKSB7XG4gICAgLy8gVGFiIE9mZnNldCAxLDIsIG9yIDMgY29sdW1uc1xuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfTtcblxuICBfcHJvdG82LmNjTUlEUk9XID0gZnVuY3Rpb24gY2NNSURST1coc2Vjb25kQnl0ZSkge1xuICAgIC8vIFBhcnNlIE1JRFJPVyBjb21tYW5kXG4gICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgIGZsYXNoOiBmYWxzZVxuICAgIH07XG4gICAgc3R5bGVzLnVuZGVybGluZSA9IHNlY29uZEJ5dGUgJSAyID09PSAxO1xuICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuXG4gICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgdmFyIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKHNlY29uZEJ5dGUgLyAyKSAtIDB4MTA7XG4gICAgICB2YXIgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuSU5GTywgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gIH07XG5cbiAgX3Byb3RvNi5vdXRwdXREYXRhVXBkYXRlID0gZnVuY3Rpb24gb3V0cHV0RGF0YVVwZGF0ZShkaXNwYXRjaCkge1xuICAgIGlmIChkaXNwYXRjaCA9PT0gdm9pZCAwKSB7XG4gICAgICBkaXNwYXRjaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcblxuICAgIGlmICh0aW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdGltZSwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcblxuICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiB0aGlzLm91dHB1dEZpbHRlci5kaXNwYXRjaEN1ZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IG51bGwgOiB0aW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvNi5jdWVTcGxpdEF0VGltZSA9IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgIGlmICghdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUpIHtcbiAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENlYTYwOENoYW5uZWw7XG59KCk7XG5cbnZhciBDZWE2MDhQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDZWE2MDhQYXJzZXIoZmllbGQsIG91dDEsIG91dDIpIHtcbiAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSAwO1xuICAgIHRoaXMuY21kSGlzdG9yeSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB2YXIgbG9nZ2VyID0gbmV3IENhcHRpb25zTG9nZ2VyKCk7XG4gICAgdGhpcy5jaGFubmVscyA9IFtudWxsLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCwgb3V0MSwgbG9nZ2VyKSwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQgKyAxLCBvdXQyLCBsb2dnZXIpXTtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gIH1cblxuICB2YXIgX3Byb3RvNyA9IENlYTYwOFBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNy5nZXRIYW5kbGVyID0gZnVuY3Rpb24gZ2V0SGFuZGxlcihjaGFubmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uZ2V0SGFuZGxlcigpO1xuICB9O1xuXG4gIF9wcm90bzcuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIoY2hhbm5lbCwgbmV3SGFuZGxlcikge1xuICAgIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uc2V0SGFuZGxlcihuZXdIYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcuYWRkRGF0YSA9IGZ1bmN0aW9uIGFkZERhdGEodGltZSwgYnl0ZUxpc3QpIHtcbiAgICB2YXIgY21kRm91bmQ7XG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgdmFyIGNoYXJzRm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlci50aW1lID0gdGltZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XG4gICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREFUQSwgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQ21kKGEsIGIpO1xuXG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICB9XG5cbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY2hhcnNGb3VuZCA9IHRoaXMucGFyc2VDaGFycyhhLCBiKTtcblxuICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgIHZhciBjdXJyQ2hOciA9IHRoaXMuY3VycmVudENoYW5uZWw7XG5cbiAgICAgICAgICBpZiAoY3VyckNoTnIgJiYgY3VyckNoTnIgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY3VyckNoTnJdO1xuICAgICAgICAgICAgY2hhbm5lbC5pbnNlcnRDaGFycyhjaGFyc0ZvdW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5XQVJOSU5HLCAnTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjbWRGb3VuZCAmJiAhY2hhcnNGb3VuZCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLldBUk5JTkcsIFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBDb21tYW5kLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYSBjb21tYW5kIHdhcyBmb3VuZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VDbWQgPSBmdW5jdGlvbiBwYXJzZUNtZChhLCBiKSB7XG4gICAgdmFyIGNtZEhpc3RvcnkgPSB0aGlzLmNtZEhpc3Rvcnk7XG4gICAgdmFyIGNvbmQxID0gKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWQpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgdmFyIGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDIxICYmIGIgPD0gMHgyMztcblxuICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSkge1xuICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCBjbWRIaXN0b3J5KTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdSZXBlYXRlZCBjb21tYW5kICgnICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnKSBpcyBkcm9wcGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hOciA9IGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDE3ID8gMSA6IDI7XG4gICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuXG4gICAgaWYgKGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MWQpIHtcbiAgICAgIGlmIChiID09PSAweDIwKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMSkge1xuICAgICAgICBjaGFubmVsLmNjQlMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICBjaGFubmVsLmNjQU9GKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI0KSB7XG4gICAgICAgIGNoYW5uZWwuY2NERVIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICBjaGFubmVsLmNjUlUoMik7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjYpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI3KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSg0KTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICBjaGFubmVsLmNjRk9OKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjkpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJhKSB7XG4gICAgICAgIGNoYW5uZWwuY2NUUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJiKSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVEQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYykge1xuICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgICAgY2hhbm5lbC5jY0NSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmUpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VOTSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgY2hhbm5lbC5jY1RPKGIgLSAweDIwKTtcbiAgICB9XG5cbiAgICBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VNaWRyb3cgPSBmdW5jdGlvbiBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgdmFyIGNoTnIgPSAwO1xuXG4gICAgaWYgKChhID09PSAweDExIHx8IGEgPT09IDB4MTkpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmYpIHtcbiAgICAgIGlmIChhID09PSAweDExKSB7XG4gICAgICAgIGNoTnIgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hOciA9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJlbnRDaGFubmVsKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuRVJST1IsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuXG4gICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKFZlcmJvc2VMZXZlbC5ERUJVRywgJ01JRFJPVyAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VQQUMgPSBmdW5jdGlvbiBwYXJzZVBBQyhhLCBiKSB7XG4gICAgdmFyIHJvdztcbiAgICB2YXIgY21kSGlzdG9yeSA9IHRoaXMuY21kSGlzdG9yeTtcbiAgICB2YXIgY2FzZTEgPSAoYSA+PSAweDExICYmIGEgPD0gMHgxNyB8fCBhID49IDB4MTkgJiYgYSA8PSAweDFmKSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDdmO1xuICAgIHZhciBjYXNlMiA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4NWY7XG5cbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkpIHtcbiAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gUmVwZWF0ZWQgY29tbWFuZHMgYXJlIGRyb3BwZWQgKG9uY2UpXG4gICAgfVxuXG4gICAgdmFyIGNoTnIgPSBhIDw9IDB4MTcgPyAxIDogMjtcblxuICAgIGlmIChiID49IDB4NDAgJiYgYiA8PSAweDVmKSB7XG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDB4NjAgPD0gYiA8PSAweDdGXG4gICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG5cbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjaGFubmVsLnNldFBBQyh0aGlzLmludGVycHJldFBBQyhyb3csIGIpKTtcbiAgICBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpO1xuICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVycy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LmludGVycHJldFBBQyA9IGZ1bmN0aW9uIGludGVycHJldFBBQyhyb3csIF9ieXRlMykge1xuICAgIHZhciBwYWNJbmRleCA9IF9ieXRlMztcbiAgICB2YXIgcGFjRGF0YSA9IHtcbiAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgaXRhbGljczogZmFsc2UsXG4gICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICB1bmRlcmxpbmU6IGZhbHNlLFxuICAgICAgcm93OiByb3dcbiAgICB9O1xuXG4gICAgaWYgKF9ieXRlMyA+IDB4NWYpIHtcbiAgICAgIHBhY0luZGV4ID0gX2J5dGUzIC0gMHg2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFjSW5kZXggPSBfYnl0ZTMgLSAweDQwO1xuICAgIH1cblxuICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG5cbiAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICBwYWNEYXRhLmNvbG9yID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ3doaXRlJ11bTWF0aC5mbG9vcihwYWNJbmRleCAvIDIpXTtcbiAgICB9IGVsc2UgaWYgKHBhY0luZGV4IDw9IDB4Zikge1xuICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSAnd2hpdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNEYXRhLmluZGVudCA9IE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSAqIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnBhcnNlQ2hhcnMgPSBmdW5jdGlvbiBwYXJzZUNoYXJzKGEsIGIpIHtcbiAgICB2YXIgY2hhbm5lbE5yO1xuICAgIHZhciBjaGFyQ29kZXMgPSBudWxsO1xuICAgIHZhciBjaGFyQ29kZTEgPSBudWxsO1xuXG4gICAgaWYgKGEgPj0gMHgxOSkge1xuICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgIGNoYXJDb2RlMSA9IGEgLSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgY2hhckNvZGUxID0gYTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICB2YXIgb25lQ29kZSA9IGI7XG5cbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLklORk8sIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGVzKSB7XG4gICAgICB2YXIgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZyhWZXJib3NlTGV2ZWwuREVCVUcsICdDaGFyIGNvZGVzID0gICcgKyBoZXhDb2Rlcy5qb2luKCcsJykpO1xuICAgICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyQ29kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGV4dGVuZGVkIGJhY2tncm91bmQgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIG5ldyBmb3JlZ3JvdW5kIGNvbG9yIGJsYWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGVsbHMgaWYgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFyZSBmb3VuZFxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgIHZhciBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgdmFyIGNhc2UyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDJkICYmIGIgPD0gMHgyZjtcblxuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgYmtnRGF0YSA9IHt9O1xuXG4gICAgaWYgKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcnNbaW5kZXhdO1xuXG4gICAgICBpZiAoYiAlIDIgPT09IDEpIHtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmtnRGF0YS5iYWNrZ3JvdW5kICsgJ19zZW1pJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmQpIHtcbiAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0RhdGEuZm9yZWdyb3VuZCA9ICdibGFjayc7XG5cbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCB0aGlzLmNtZEhpc3RvcnkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICovXG4gIDtcblxuICBfcHJvdG83LnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuXG4gICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBnZW5lcmF0aW9uIG9mIGEgY3VlLCBhbmQgdGhlIHN0YXJ0IG9mIGEgbmV3IG9uZSBpZiBkaXNwbGF5U2NyZWVucyBhcmUgbm90IGVtcHR5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzcuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG5cbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDZWE2MDhQYXJzZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICBjbWRIaXN0b3J5LmEgPSBhO1xuICBjbWRIaXN0b3J5LmIgPSBiO1xufVxuXG5mdW5jdGlvbiBoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSB7XG4gIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENlYTYwOFBhcnNlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2NvZGVjcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvY29kZWNzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBpc0NvZGVjVHlwZSwgaXNDb2RlY1N1cHBvcnRlZEluTXA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNUeXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDb2RlY1R5cGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlzQ29kZWNTdXBwb3J0ZWRJbk1wNFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ29kZWNTdXBwb3J0ZWRJbk1wNDsgfSk7XG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbnZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IHRydWUsXG4gICAgJ2FjLTMnOiB0cnVlLFxuICAgICdhYy00JzogdHJ1ZSxcbiAgICBhbGFjOiB0cnVlLFxuICAgIGFsYXc6IHRydWUsXG4gICAgZHJhMTogdHJ1ZSxcbiAgICAnZHRzKyc6IHRydWUsXG4gICAgJ2R0cy0nOiB0cnVlLFxuICAgIGR0c2M6IHRydWUsXG4gICAgZHRzZTogdHJ1ZSxcbiAgICBkdHNoOiB0cnVlLFxuICAgICdlYy0zJzogdHJ1ZSxcbiAgICBlbmNhOiB0cnVlLFxuICAgIGc3MTk6IHRydWUsXG4gICAgZzcyNjogdHJ1ZSxcbiAgICBtNGFlOiB0cnVlLFxuICAgIG1oYTE6IHRydWUsXG4gICAgbWhhMjogdHJ1ZSxcbiAgICBtaG0xOiB0cnVlLFxuICAgIG1obTI6IHRydWUsXG4gICAgbWxwYTogdHJ1ZSxcbiAgICBtcDRhOiB0cnVlLFxuICAgICdyYXcgJzogdHJ1ZSxcbiAgICBPcHVzOiB0cnVlLFxuICAgIHNhbXI6IHRydWUsXG4gICAgc2F3YjogdHJ1ZSxcbiAgICBzYXdwOiB0cnVlLFxuICAgIHNldmM6IHRydWUsXG4gICAgc3FjcDogdHJ1ZSxcbiAgICBzc212OiB0cnVlLFxuICAgIHR3b3M6IHRydWUsXG4gICAgdWxhdzogdHJ1ZVxuICB9LFxuICB2aWRlbzoge1xuICAgIGF2YzE6IHRydWUsXG4gICAgYXZjMjogdHJ1ZSxcbiAgICBhdmMzOiB0cnVlLFxuICAgIGF2YzQ6IHRydWUsXG4gICAgYXZjcDogdHJ1ZSxcbiAgICBkcmFjOiB0cnVlLFxuICAgIGR2YXY6IHRydWUsXG4gICAgZHZoZTogdHJ1ZSxcbiAgICBlbmN2OiB0cnVlLFxuICAgIGhldjE6IHRydWUsXG4gICAgaHZjMTogdHJ1ZSxcbiAgICBtanAyOiB0cnVlLFxuICAgIG1wNHY6IHRydWUsXG4gICAgbXZjMTogdHJ1ZSxcbiAgICBtdmMyOiB0cnVlLFxuICAgIG12YzM6IHRydWUsXG4gICAgbXZjNDogdHJ1ZSxcbiAgICByZXN2OiB0cnVlLFxuICAgIHJ2NjA6IHRydWUsXG4gICAgczI2MzogdHJ1ZSxcbiAgICBzdmMxOiB0cnVlLFxuICAgIHN2YzI6IHRydWUsXG4gICAgJ3ZjLTEnOiB0cnVlLFxuICAgIHZwMDg6IHRydWUsXG4gICAgdnAwOTogdHJ1ZVxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogdHJ1ZSxcbiAgICB3dnR0OiB0cnVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSB7XG4gIHZhciB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNDb2RlY1N1cHBvcnRlZEluTXA0KGNvZGVjLCB0eXBlKSB7XG4gIHJldHVybiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoKHR5cGUgfHwgJ3ZpZGVvJykgKyBcIi9tcDQ7Y29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIpO1xufVxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvY3Vlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2N1ZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBuZXdDdWUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmV3Q3VlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3Q3VlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qc1wiKTtcblxudmFyIFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xuZnVuY3Rpb24gbmV3Q3VlKHRyYWNrLCBzdGFydFRpbWUsIGVuZFRpbWUsIGNhcHRpb25TY3JlZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgcm93OyAvLyB0aGUgdHlwZSBkYXRhIHN0YXRlcyB0aGlzIGlzIFZUVEN1ZSwgYnV0IGl0IGNhbiBwb3RlbnRpYWxseSBiZSBhIFRleHRUcmFja0N1ZSBvbiBvbGQgYnJvd3NlcnNcblxuICB2YXIgY3VlO1xuICB2YXIgaW5kZW50aW5nO1xuICB2YXIgaW5kZW50O1xuICB2YXIgdGV4dDtcbiAgdmFyIEN1ZSA9IHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xuXG4gIGZvciAodmFyIHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgcm93ID0gY2FwdGlvblNjcmVlbi5yb3dzW3JdO1xuICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgaW5kZW50ID0gMDtcbiAgICB0ZXh0ID0gJyc7XG5cbiAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgcm93LmNoYXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRvIGJlIHVzZWQgZm9yIGNsZWFuaW5nLXVwIG9ycGhhbmVkIHJvbGwtdXAgY2FwdGlvbnNcblxuXG4gICAgICByb3cuY3VlU3RhcnRUaW1lID0gc3RhcnRUaW1lOyAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuXG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBlbmRUaW1lKSB7XG4gICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgfVxuXG4gICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgT2JqZWN0KF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImZpeExpbmVCcmVha3NcIl0pKHRleHQudHJpbSgpKSk7XG5cbiAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgaW5kZW50LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH1cblxuICAgICAgY3VlLmxpbmUgPSByICsgMTtcbiAgICAgIGN1ZS5hbGlnbiA9ICdsZWZ0JzsgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMTAgYW5kIDgwIHBlcmNlbnQgKENFQS02MDggUEFDIGluZGVudCBjb2RlKVxuICAgICAgLy8gaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy90ZXh0LXRyYWNrcy9yYXctZmlsZS9kZWZhdWx0LzYwOHRvVlRULzYwOHRvVlRULmh0bWwjcG9zaXRpb25pbmctaW4tY2VhLTYwOFxuICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG5cbiAgICAgIGN1ZS5wb3NpdGlvbiA9IDEwICsgTWF0aC5taW4oODAsIE1hdGguZmxvb3IoaW5kZW50ICogOCAvIDMyKSAqIDEwKTtcbiAgICAgIHJlc3VsdC5wdXNoKGN1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRyYWNrICYmIHJlc3VsdC5sZW5ndGgpIHtcbiAgICAvLyBTb3J0IGJvdHRvbSBjdWVzIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCB0aGV5IHJlbmRlciBpbiBsaW5lIG9yZGVyIHdoZW4gb3ZlcmxhcHBpbmcgaW4gQ2hyb21lXG4gICAgdmFyIHNvcnRlZEN1ZXMgPSByZXN1bHQuc29ydChmdW5jdGlvbiAoY3VlQSwgY3VlQikge1xuICAgICAgaWYgKGN1ZUEubGluZSA9PT0gJ2F1dG8nIHx8IGN1ZUIubGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VlQS5saW5lID4gOCAmJiBjdWVCLmxpbmUgPiA4KSB7XG4gICAgICAgIHJldHVybiBjdWVCLmxpbmUgLSBjdWVBLmxpbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdWVBLmxpbmUgLSBjdWVCLmxpbmU7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZEN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyYWNrLmFkZEN1ZShzb3J0ZWRDdWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9kaXNjb250aW51aXRpZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZmluZEZpcnN0RnJhZ1dpdGhDQywgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcywgZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnLCBhZGp1c3RTbGlkaW5nU3RhcnQsIGFsaWduU3RyZWFtLCBhbGlnblBEVCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaW5kRmlyc3RGcmFnV2l0aENDXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmluZEZpcnN0RnJhZ1dpdGhDQzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRqdXN0U2xpZGluZ1N0YXJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWRqdXN0U2xpZGluZ1N0YXJ0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhbGlnblN0cmVhbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFsaWduU3RyZWFtOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhbGlnblBEVFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFsaWduUERUOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250cm9sbGVyX2xldmVsX2hlbHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29udHJvbGxlci9sZXZlbC1oZWxwZXIgKi8gXCIuL3NyYy9jb250cm9sbGVyL2xldmVsLWhlbHBlci50c1wiKTtcblxuXG5cbmZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICB2YXIgZmlyc3RGcmFnID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRGcmFnID0gZnJhZ21lbnRzW2ldO1xuXG4gICAgaWYgKGN1cnJlbnRGcmFnICYmIGN1cnJlbnRGcmFnLmNjID09PSBjYykge1xuICAgICAgZmlyc3RGcmFnID0gY3VycmVudEZyYWc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlyc3RGcmFnO1xufVxuZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgbGFzdExldmVsLCBkZXRhaWxzKSB7XG4gIGlmIChsYXN0TGV2ZWwuZGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcblxuZnVuY3Rpb24gZmluZERpc2NvbnRpbnVvdXNSZWZlcmVuY2VGcmFnKHByZXZEZXRhaWxzLCBjdXJEZXRhaWxzKSB7XG4gIHZhciBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIHZhciBjdXJGcmFncyA9IGN1ckRldGFpbHMuZnJhZ21lbnRzO1xuXG4gIGlmICghY3VyRnJhZ3MubGVuZ3RoIHx8ICFwcmV2RnJhZ3MubGVuZ3RoKSB7XG4gICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZygnTm8gZnJhZ21lbnRzIHRvIGFsaWduJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByZXZTdGFydEZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKHByZXZGcmFncywgY3VyRnJhZ3NbMF0uY2MpO1xuXG4gIGlmICghcHJldlN0YXJ0RnJhZyB8fCBwcmV2U3RhcnRGcmFnICYmICFwcmV2U3RhcnRGcmFnLnN0YXJ0UFRTKSB7XG4gICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWcsIHNsaWRpbmcpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nLCBkZXRhaWxzKSB7XG4gIC8vIFVwZGF0ZSBzZWdtZW50c1xuICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZnJhZ21lbnRzW2ldLCBzbGlkaW5nKTtcbiAgfSAvLyBVcGRhdGUgTEwtSExTIHBhcnRzIGF0IHRoZSBlbmQgb2YgdGhlIHBsYXlsaXN0XG5cblxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGRldGFpbHMuZnJhZ21lbnRIaW50LCBzbGlkaW5nKTtcbiAgfVxuXG4gIGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xufVxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cblxuZnVuY3Rpb24gYWxpZ25TdHJlYW0obGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykge1xuICBpZiAoIWxhc3RMZXZlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpO1xuXG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBsYXN0TGV2ZWwuZGV0YWlscykge1xuICAgIC8vIElmIHRoZSBQVFMgd2Fzbid0IGZpZ3VyZWQgb3V0IHZpYSBkaXNjb250aW51aXR5IHNlcXVlbmNlIHRoYXQgbWVhbnMgdGhlcmUgd2FzIG5vIENDIGluY3JlYXNlIHdpdGhpbiB0aGUgbGV2ZWwuXG4gICAgLy8gQWxpZ25pbmcgdmlhIFByb2dyYW0gRGF0ZSBUaW1lIHNob3VsZCB0aGVyZWZvcmUgYmUgcmVsaWFibGUsIHNpbmNlIFBEVCBzaG91bGQgYmUgdGhlIHNhbWUgd2l0aGluIHRoZSBzYW1lXG4gICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICBhbGlnblBEVChkZXRhaWxzLCBsYXN0TGV2ZWwuZGV0YWlscyk7XG4gIH1cblxuICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgbGFzdExldmVsLmRldGFpbHMgJiYgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgLy8gVHJ5IHRvIGFsaWduIG9uIHNuIHNvIHRoYXQgd2UgcGljayBhIGJldHRlciBzdGFydCBmcmFnbWVudC5cbiAgICAvLyBEbyBub3QgcGVyZm9ybSB0aGlzIG9uIHBsYXlsaXN0cyB3aXRoIGRlbHRhIHVwZGF0ZXMgYXMgdGhpcyBpcyBvbmx5IHRvIGFsaWduIGxldmVscyBvbiBzd2l0Y2hcbiAgICAvLyBhbmQgYWRqdXN0U2xpZGluZyBvbmx5IGFkanVzdHMgZnJhZ21lbnRzIGFmdGVyIHNraXBwZWRTZWdtZW50cy5cbiAgICBPYmplY3QoX2NvbnRyb2xsZXJfbGV2ZWxfaGVscGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJhZGp1c3RTbGlkaW5nXCJdKShsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG4gIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RGcmFnIC0gVGhlIGxhc3QgRnJhZ21lbnQgd2hpY2ggc2hhcmVzIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2VcbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5cbmZ1bmN0aW9uIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBsYXN0TGV2ZWwpIHtcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGxhc3RMZXZlbCwgZGV0YWlscykpIHtcbiAgICB2YXIgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhsYXN0TGV2ZWwuZGV0YWlscywgZGV0YWlscyk7XG5cbiAgICBpZiAocmVmZXJlbmNlRnJhZyAhPT0gbnVsbCAmJiByZWZlcmVuY2VGcmFnICE9PSB2b2lkIDAgJiYgcmVmZXJlbmNlRnJhZy5zdGFydCkge1xuICAgICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgbGFzdCBsZXZlbCBkdWUgdG8gQ0MgaW5jcmVhc2Ugd2l0aGluIGN1cnJlbnQgbGV2ZWwgXCIgKyBkZXRhaWxzLnVybCk7XG4gICAgICBhZGp1c3RTbGlkaW5nU3RhcnQocmVmZXJlbmNlRnJhZy5zdGFydCwgZGV0YWlscyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgb2YgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIGRpZmZlcmVuY2UgaW4gUHJvZ3JhbSBEYXRlIFRpbWUgZnJvbSB0aGUgbGFzdCBsZXZlbC5cbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICogQHBhcmFtIGxhc3REZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKi9cblxuXG5mdW5jdGlvbiBhbGlnblBEVChkZXRhaWxzLCBsYXN0RGV0YWlscykge1xuICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIHRoZSB1bnNhZmUgXCIhXCIgdXNhZ2UgYmVsb3cgZm9yIG51bGwgcHJvZ3JhbSBkYXRlIHRpbWUgYWNjZXNzLlxuICBpZiAoIWxhc3REZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFsYXN0RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgbGFzdCBsZXZlbCBzbGlkaW5nIGlzIDEwMDAgYW5kIGl0cyBmaXJzdCBmcmFnIFBST0dSQU0tREFURS1USU1FIGlzIDIwMTctMDgtMjAgMToxMDowMCBBTVxuICAvLyBhbmQgaWYgbmV3IGRldGFpbHMgZmlyc3QgZnJhZyBQUk9HUkFNIERBVEUtVElNRSBpcyAyMDE3LTA4LTIwIDE6MTA6MDggQU1cbiAgLy8gdGhlbiB3ZSBjYW4gZGVkdWNlIHRoYXQgcGxheWxpc3QgQiBzbGlkaW5nIGlzIDEwMDArOCA9IDEwMDhzXG5cblxuICB2YXIgbGFzdFBEVCA9IGxhc3REZXRhaWxzLmZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7IC8vIGhhc1Byb2dyYW1EYXRlVGltZSBjaGVjayBhYm92ZSBtYWtlcyB0aGlzIHNhZmUuXG5cbiAgdmFyIG5ld1BEVCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnByb2dyYW1EYXRlVGltZTsgLy8gZGF0ZSBkaWZmIGlzIGluIG1zLiBmcmFnLnN0YXJ0IGlzIGluIHNlY29uZHNcblxuICB2YXIgc2xpZGluZyA9IChuZXdQRFQgLSBsYXN0UERUKSAvIDEwMDAgKyBsYXN0RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG5cbiAgaWYgKHNsaWRpbmcgJiYgT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKHNsaWRpbmcpKSB7XG4gICAgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wibG9nZ2VyXCJdLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhIFwiICsgKG5ld1BEVCAtIGxhc3RQRFQpICsgXCJtcywgc2xpZGluZzpcIiArIHNsaWRpbmcudG9GaXhlZCgzKSArIFwiIFwiICsgZGV0YWlscy51cmwgKyBcIiBcIik7XG4gICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHNsaWRpbmcsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvZXdtYS1iYW5kd2lkdGgtZXN0aW1hdG9yLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19ld21hX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9ld21hICovIFwiLi9zcmMvdXRpbHMvZXdtYS50c1wiKTtcbi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuXG52YXIgRXdtYUJhbmRXaWR0aEVzdGltYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV3bWFCYW5kV2lkdGhFc3RpbWF0b3Ioc2xvdywgZmFzdCwgZGVmYXVsdEVzdGltYXRlKSB7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gdm9pZCAwO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLm1pbkRlbGF5TXNfID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvd18gPSB2b2lkIDA7XG4gICAgdGhpcy5mYXN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgX3V0aWxzX2V3bWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0oc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShmYXN0KTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFd21hQmFuZFdpZHRoRXN0aW1hdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNsb3csIGZhc3QpIHtcbiAgICB2YXIgc2xvd18gPSB0aGlzLnNsb3dfLFxuICAgICAgICBmYXN0XyA9IHRoaXMuZmFzdF87XG5cbiAgICBpZiAodGhpcy5zbG93Xy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgdGhpcy5zbG93XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShzbG93LCBzbG93Xy5nZXRFc3RpbWF0ZSgpLCBzbG93Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBfdXRpbHNfZXdtYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXShmYXN0LCBmYXN0Xy5nZXRFc3RpbWF0ZSgpLCBmYXN0Xy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhbXBsZSA9IGZ1bmN0aW9uIHNhbXBsZShkdXJhdGlvbk1zLCBudW1CeXRlcykge1xuICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICB2YXIgbnVtQml0cyA9IDggKiBudW1CeXRlczsgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcblxuICAgIHZhciBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDsgLy8gdmFsdWUgaXMgYmFuZHdpZHRoIGluIGJpdHMvc1xuXG4gICAgdmFyIGJhbmR3aWR0aEluQnBzID0gbnVtQml0cyAvIGR1cmF0aW9uUztcbiAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgICB0aGlzLnNsb3dfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgfTtcblxuICBfcHJvdG8uY2FuRXN0aW1hdGUgPSBmdW5jdGlvbiBjYW5Fc3RpbWF0ZSgpIHtcbiAgICB2YXIgZmFzdCA9IHRoaXMuZmFzdF87XG4gICAgcmV0dXJuIGZhc3QgJiYgZmFzdC5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5jYW5Fc3RpbWF0ZSgpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Zhc3QgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLmZhc3RfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIFRha2UgdGhlIG1pbmltdW0gb2YgdGhlc2UgdHdvIGVzdGltYXRlcy4gIFRoaXMgc2hvdWxkIGhhdmUgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLCB0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcblxuICByZXR1cm4gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChFd21hQmFuZFdpZHRoRXN0aW1hdG9yKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvZXdtYS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2V3bWEudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xudmFyIEVXTUEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICBmdW5jdGlvbiBFV01BKGhhbGZMaWZlLCBlc3RpbWF0ZSwgd2VpZ2h0KSB7XG4gICAgaWYgKGVzdGltYXRlID09PSB2b2lkIDApIHtcbiAgICAgIGVzdGltYXRlID0gMDtcbiAgICB9XG5cbiAgICBpZiAod2VpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIHdlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFscGhhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhbGZMaWZlID0gaGFsZkxpZmU7IC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cblxuICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICB0aGlzLmVzdGltYXRlXyA9IGVzdGltYXRlO1xuICAgIHRoaXMudG90YWxXZWlnaHRfID0gd2VpZ2h0O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVXTUEucHJvdG90eXBlO1xuXG4gIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgIHZhciBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3RhbFdlaWdodCA9IGZ1bmN0aW9uIGdldFRvdGFsV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsV2VpZ2h0XztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbHBoYV8pIHtcbiAgICAgIHZhciB6ZXJvRmFjdG9yID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG5cbiAgICAgIGlmICh6ZXJvRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9O1xuXG4gIHJldHVybiBFV01BO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEVXTUEpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9mZXRjaC1sb2FkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZmV0Y2hTdXBwb3J0ZWQsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmV0Y2hTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmZXRjaFN1cHBvcnRlZDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyICovIFwiLi9zcmMvcG9seWZpbGxzL251bWJlci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvYWRlci9sb2FkLXN0YXRzICovIFwiLi9zcmMvbG9hZGVyL2xvYWQtc3RhdHMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9jaHVuay1jYWNoZSAqLyBcIi4vc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzXCIpO1xuXG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbmZ1bmN0aW9uIGZldGNoU3VwcG9ydGVkKCkge1xuICBpZiAoc2VsZi5mZXRjaCAmJiBzZWxmLkFib3J0Q29udHJvbGxlciAmJiBzZWxmLlJlYWRhYmxlU3RyZWFtICYmIHNlbGYuUmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBGZXRjaExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZldGNoTG9hZGVyKGNvbmZpZ1xuICAvKiBIbHNDb25maWcgKi9cbiAgKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdm9pZCAwO1xuICAgIHRoaXMucmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBfbG9hZGVyX2xvYWRfc3RhdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0oKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGZXRjaExvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICB9O1xuXG4gIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICB9O1xuXG4gIF9wcm90by5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG5cbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcblxuICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9PSBudWxsICYmIF90aGlzJGNhbGxiYWNrcyAhPT0gdm9pZCAwICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuXG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG5cbiAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgaW5pdFBhcmFtcyA9IGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHRoaXMuY29udHJvbGxlci5zaWduYWwpO1xuICAgIHZhciBvblByb2dyZXNzID0gY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJztcbiAgICB2YXIgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuYWJvcnRJbnRlcm5hbCgpO1xuXG4gICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBfdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgX3RoaXMucmVzcG9uc2UgPSBfdGhpcy5sb2FkZXIgPSByZXNwb25zZTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG4gICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICBzdGF0cy50b3RhbCA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpIHx8ICcwJyk7XG5cbiAgICAgIGlmIChvblByb2dyZXNzICYmIE9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgX3RoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgdmFyIHJlc3BvbnNlID0gX3RoaXMucmVzcG9uc2U7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgc3RhdHMubG9hZGVkID0gc3RhdHMudG90YWwgPSByZXNwb25zZURhdGFbTEVOR1RIXTtcbiAgICAgIHZhciBsb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YVxuICAgICAgfTtcblxuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgcmVzcG9uc2VEYXRhLCByZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dChfdGhpcy5yZXF1ZXN0VGltZW91dCk7XG5cbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09SUyBlcnJvcnMgcmVzdWx0IGluIGFuIHVuZGVmaW5lZCBjb2RlLiBTZXQgaXQgdG8gMCBoZXJlIHRvIGFsaWduIHdpdGggWEhSJ3MgYmVoYXZpb3JcblxuXG4gICAgICB2YXIgY29kZSA9IGVycm9yLmNvZGUgfHwgMDtcbiAgICAgIGNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgdGV4dDogZXJyb3IubWVzc2FnZVxuICAgICAgfSwgY29udGV4dCwgZXJyb3IuZGV0YWlscyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8qIENvdWxkIG5vdCBnZXQgaGVhZGVyICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRQcm9ncmVzc2l2ZWx5ID0gZnVuY3Rpb24gbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHZvaWQgMCkge1xuICAgICAgaGlnaFdhdGVyTWFyayA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rQ2FjaGUgPSBuZXcgX2RlbXV4X2NodW5rX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKCk7XG4gICAgdmFyIHJlYWRlciA9IHJlc3BvbnNlLmNsb25lKCkuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIHZhciBwdW1wID0gZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rID0gZGF0YS52YWx1ZTtcbiAgICAgICAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcblxuICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgY3VycmVudCBjaHVuayBpcyB0b28gc21hbGwgdG8gdG8gYmUgZW1pdHRlZCBvciB0aGUgY2FjaGUgYWxyZWFkeSBoYXMgZGF0YVxuICAgICAgICAgIC8vIFB1c2ggaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgLy8gZmx1c2ggaW4gb3JkZXIgdG8gam9pbiB0aGUgdHlwZWQgYXJyYXlzXG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVua0NhY2hlLmZsdXNoKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBub3RoaW5nIGNhY2hlZCBhbHJlYWR5LCBhbmQgdGhlIGNoYWNoZSBpcyBsYXJnZSBlbm91Z2hcbiAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmssIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHB1bXAoKTtcbiAgfTtcblxuICByZXR1cm4gRmV0Y2hMb2FkZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICB2YXIgaW5pdFBhcmFtcyA9IHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIG1vZGU6ICdjb3JzJyxcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBzaWduYWw6IHNpZ25hbFxuICB9O1xuXG4gIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgaW5pdFBhcmFtcy5oZWFkZXJzID0gbmV3IHNlbGYuSGVhZGVycyh7XG4gICAgICBSYW5nZTogJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cblxudmFyIEZldGNoRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHNMb29zZShGZXRjaEVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIF90aGlzMi5jb2RlID0gdm9pZCAwO1xuICAgIF90aGlzMi5kZXRhaWxzID0gdm9pZCAwO1xuICAgIF90aGlzMi5jb2RlID0gY29kZTtcbiAgICBfdGhpczIuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBGZXRjaEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChGZXRjaExvYWRlcik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL2ltc2MxLXR0bWwtcGFyc2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IElNU0MxX0NPREVDLCBwYXJzZUlNU0MxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIklNU0MxX0NPREVDXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSU1TQzFfQ09ERUM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlSU1TQzFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUlNU0MxOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21wNC10b29scyAqLyBcIi4vc3JjL3V0aWxzL21wNC10b29scy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dHBhcnNlciAqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdnR0Y3VlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Z0dGN1ZSAqLyBcIi4vc3JjL3V0aWxzL3Z0dGN1ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVtdXhfaWQzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kZW11eC9pZDMgKi8gXCIuL3NyYy9kZW11eC9pZDMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RpbWVzY2FsZV9jb252ZXJzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVzY2FsZS1jb252ZXJzaW9uICovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIik7XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5cblxuXG5cblxudmFyIElNU0MxX0NPREVDID0gJ3N0cHAudHRtbC5pbTF0JzsgLy8gVGltZSBmb3JtYXQ6IGg6bTpzOmZyYW1lcyguc3ViZnJhbWVzKVxuXG52YXIgSE1TRl9SRUdFWCA9IC9eKFxcZHsyLH0pOihcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pXFwuPyhcXGQrKT8kLzsgLy8gVGltZSBmb3JtYXQ6IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIGZyYW1lcywgdGlja3NcblxudmFyIFRJTUVfVU5JVF9SRUdFWCA9IC9eKFxcZCooPzpcXC5cXGQqKT8pKGh8bXxzfG1zfGZ8dCkkLztcbmZ1bmN0aW9uIHBhcnNlSU1TQzEocGF5bG9hZCwgaW5pdFBUUywgdGltZXNjYWxlLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICB2YXIgcmVzdWx0cyA9IE9iamVjdChfbXA0X3Rvb2xzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJmaW5kQm94XCJdKShuZXcgVWludDhBcnJheShwYXlsb2FkKSwgWydtZGF0J10pO1xuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWRhdCA9IHJlc3VsdHNbMF07XG4gIHZhciB0dG1sID0gT2JqZWN0KF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInV0ZjhBcnJheVRvU3RyXCJdKShuZXcgVWludDhBcnJheShwYXlsb2FkLCBtZGF0LnN0YXJ0LCBtZGF0LmVuZCAtIG1kYXQuc3RhcnQpKTtcbiAgdmFyIHN5bmNUaW1lID0gT2JqZWN0KF90aW1lc2NhbGVfY29udmVyc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1widG9UaW1lc2NhbGVGcm9tU2NhbGVcIl0pKGluaXRQVFMsIDEsIHRpbWVzY2FsZSk7XG5cbiAgdHJ5IHtcbiAgICBjYWxsQmFjayhwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvckNhbGxCYWNrKGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRUTUwodHRtbCwgc3luY1RpbWUpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgdmFyIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodHRtbCwgJ3RleHQveG1sJyk7XG4gIHZhciB0dCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndHQnKVswXTtcblxuICBpZiAoIXR0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR0bWwnKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0UmF0ZUluZm8gPSB7XG4gICAgZnJhbWVSYXRlOiAzMCxcbiAgICBzdWJGcmFtZVJhdGU6IDEsXG4gICAgZnJhbWVSYXRlTXVsdGlwbGllcjogMCxcbiAgICB0aWNrUmF0ZTogMFxuICB9O1xuICB2YXIgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHR0LmdldEF0dHJpYnV0ZShcInR0cDpcIiArIGtleSkgfHwgZGVmYXVsdFJhdGVJbmZvW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xuICB2YXIgdHJpbSA9IHR0LmdldEF0dHJpYnV0ZSgneG1sOnNwYWNlJykgIT09ICdwcmVzZXJ2ZSc7XG4gIHZhciBzdHlsZUVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ3N0eWxpbmcnLCAnc3R5bGUnKSk7XG4gIHZhciByZWdpb25FbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdsYXlvdXQnLCAncmVnaW9uJykpO1xuICB2YXIgY3VlRWxlbWVudHMgPSBnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2JvZHknLCAnW2JlZ2luXScpO1xuICByZXR1cm4gW10ubWFwLmNhbGwoY3VlRWxlbWVudHMsIGZ1bmN0aW9uIChjdWVFbGVtZW50KSB7XG4gICAgdmFyIGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcblxuICAgIGlmICghY3VlVGV4dCB8fCAhY3VlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2JlZ2luJykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdGFydFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdiZWdpbicpLCByYXRlSW5mbyk7XG4gICAgdmFyIGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICB2YXIgZW5kVGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2VuZCcpLCByYXRlSW5mbyk7XG5cbiAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgY3VlID0gbmV3IF92dHRjdWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0oc3RhcnRUaW1lIC0gc3luY1RpbWUsIGVuZFRpbWUgLSBzeW5jVGltZSwgY3VlVGV4dCk7XG4gICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbkVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWdpb24nKV07XG4gICAgdmFyIHN0eWxlID0gc3R5bGVFbGVtZW50c1tjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKV07IC8vIFRPRE86IEFkZCByZWdpb25zIHRvIHRyYWNrIGFuZCBjdWUgKG9yaWdpbiBhbmQgZXh0ZW5kKVxuICAgIC8vIFRoZXNlIHZhbHVlcyBhcmUgaGFyZC1jb2RlZCAoZm9yIG5vdykgdG8gc2ltdWxhdGUgcmVnaW9uIHNldHRpbmdzIGluIHRoZSBkZW1vXG5cbiAgICBjdWUucG9zaXRpb24gPSAxMDtcbiAgICBjdWUuc2l6ZSA9IDgwOyAvLyBBcHBseSBzdHlsZXMgdG8gY3VlXG5cbiAgICB2YXIgc3R5bGVzID0gZ2V0VHRtbFN0eWxlcyhyZWdpb24sIHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGVzLnRleHRBbGlnbjtcblxuICAgIGlmICh0ZXh0QWxpZ24pIHtcbiAgICAgIC8vIGN1ZS5wb3NpdGlvbkFsaWduIG5vdCBzZXR0YWJsZSBpbiBGRn4yMDE2XG4gICAgICBjdWUubGluZUFsaWduID0ge1xuICAgICAgICBsZWZ0OiAnc3RhcnQnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICByaWdodDogJ2VuZCcsXG4gICAgICAgIHN0YXJ0OiAnc3RhcnQnLFxuICAgICAgICBlbmQ6ICdlbmQnXG4gICAgICB9W3RleHRBbGlnbl07XG4gICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgX2V4dGVuZHMoY3VlLCBzdHlsZXMpO1xuXG4gICAgcmV0dXJuIGN1ZTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjdWUpIHtcbiAgICByZXR1cm4gY3VlICE9PSBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudENvbGxlY3Rpb24oZnJvbUVsZW1lbnQsIHBhcmVudE5hbWUsIGNoaWxkTmFtZSkge1xuICB2YXIgcGFyZW50ID0gZnJvbUVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocGFyZW50TmFtZSlbMF07XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKGNoaWxkTmFtZSkpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uVG9EaWN0aW9uYXJ5KGVsZW1lbnRzV2l0aElkKSB7XG4gIHJldHVybiBlbGVtZW50c1dpdGhJZC5yZWR1Y2UoZnVuY3Rpb24gKGRpY3QsIGVsZW1lbnQpIHtcbiAgICB2YXIgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG5cbiAgICBpZiAoaWQpIHtcbiAgICAgIGRpY3RbaWRdID0gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcykucmVkdWNlKGZ1bmN0aW9uIChzdHIsIG5vZGUsIGkpIHtcbiAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcblxuICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnYnInICYmIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAnXFxuJztcbiAgICB9XG5cbiAgICBpZiAoKF9ub2RlJGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXMpICE9PSBudWxsICYmIF9ub2RlJGNoaWxkTm9kZXMgIT09IHZvaWQgMCAmJiBfbm9kZSRjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldFRleHRDb250ZW50KG5vZGUsIHRyaW0pO1xuICAgIH0gZWxzZSBpZiAodHJpbSkge1xuICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudDtcbiAgfSwgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUpIHtcbiAgdmFyIHR0c05zID0gJ2h0dHA6Ly93d3cudzMub3JnL25zL3R0bWwjc3R5bGluZyc7XG4gIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSBbJ2Rpc3BsYXlBbGlnbicsICd0ZXh0QWxpZ24nLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknIC8vICdmb250V2VpZ2h0JyxcbiAgLy8gJ2xpbmVIZWlnaHQnLFxuICAvLyAnd3JhcE9wdGlvbicsXG4gIC8vICdmb250U3R5bGUnLFxuICAvLyAnZGlyZWN0aW9uJyxcbiAgLy8gJ3dyaXRpbmdNb2RlJ1xuICBdO1xuICByZXR1cm4gc3R5bGVBdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGVzLCBuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBucywgbmFtZSkge1xuICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGVOUyhucywgbmFtZSkgPyBlbGVtZW50LmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRpbWVzdGFtcFBhcnNpbmdFcnJvcihub2RlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgdHRtbCB0aW1lc3RhbXAgXCIgKyBub2RlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUdG1sVGltZSh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGlmICghdGltZUF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2Vjb25kcyA9IE9iamVjdChfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVRpbWVTdGFtcFwiXSkodGltZUF0dHJpYnV0ZVZhbHVlKTtcblxuICBpZiAoc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIGlmIChITVNGX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgc2Vjb25kcyA9IHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9IGVsc2UgaWYgKFRJTUVfVU5JVF9SRUdFWC50ZXN0KHRpbWVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2Vjb25kcztcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgdmFyIG0gPSBITVNGX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgdmFyIGZyYW1lcyA9IChtWzRdIHwgMCkgKyAobVs1XSB8IDApIC8gcmF0ZUluZm8uc3ViRnJhbWVSYXRlO1xuICByZXR1cm4gKG1bMV0gfCAwKSAqIDM2MDAgKyAobVsyXSB8IDApICogNjAgKyAobVszXSB8IDApICsgZnJhbWVzIC8gcmF0ZUluZm8uZnJhbWVSYXRlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIHZhciBtID0gVElNRV9VTklUX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgdmFyIHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICB2YXIgdW5pdCA9IG1bMl07XG5cbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gdmFsdWUgKiAzNjAwO1xuXG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gdmFsdWUgKiA2MDtcblxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDEwMDA7XG5cbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcblxuICAgIGNhc2UgJ3QnOlxuICAgICAgcmV0dXJuIHZhbHVlIC8gcmF0ZUluZm8udGlja1JhdGU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL2xvZ2dlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbG9nZ2VyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBlbmFibGVMb2dzLCBsb2dnZXIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZW5hYmxlTG9nc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVuYWJsZUxvZ3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxvZ2dlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZ2dlcjsgfSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIGZha2VMb2dnZXIgPSB7XG4gIHRyYWNlOiBub29wLFxuICBkZWJ1Zzogbm9vcCxcbiAgbG9nOiBub29wLFxuICB3YXJuOiBub29wLFxuICBpbmZvOiBub29wLFxuICBlcnJvcjogbm9vcFxufTtcbnZhciBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7IC8vIGxldCBsYXN0Q2FsbFRpbWU7XG4vLyBmdW5jdGlvbiBmb3JtYXRNc2dXaXRoVGltZUluZm8odHlwZSwgbXNnKSB7XG4vLyAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4vLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbi8vICAgbGFzdENhbGxUaW1lID0gbm93O1xuLy8gICBtc2cgPSAobmV3IERhdGUobm93KSkudG9JU09TdHJpbmcoKSArICcgfCBbJyArICB0eXBlICsgJ10gPiAnICsgbXNnICsgJyAoICcgKyBkaWZmICsgJyBtcyApJztcbi8vICAgcmV0dXJuIG1zZztcbi8vIH1cblxuZnVuY3Rpb24gY29uc29sZVByaW50Rm4odHlwZSkge1xuICB2YXIgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcblxuICBpZiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jLmJpbmQoc2VsZi5jb25zb2xlLCBcIltcIiArIHR5cGUgKyBcIl0gPlwiKTtcbiAgfVxuXG4gIHJldHVybiBub29wO1xufVxuXG5mdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3Rpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgZXhwb3J0ZWRMb2dnZXJbdHlwZV0gPSBkZWJ1Z0NvbmZpZ1t0eXBlXSA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpIDogY29uc29sZVByaW50Rm4odHlwZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnKSB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgaWYgKHNlbGYuY29uc29sZSAmJiBkZWJ1Z0NvbmZpZyA9PT0gdHJ1ZSB8fCB0eXBlb2YgZGVidWdDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgIC8vICd0cmFjZScsXG4gICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTsgLy8gU29tZSBicm93c2VycyBkb24ndCBhbGxvdyB0byB1c2UgYmluZCBvbiBjb25zb2xlIG9iamVjdCBhbnl3YXlcbiAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICB9XG59XG52YXIgbG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL21lZGlha2V5cy1oZWxwZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy9tZWRpYWtleXMtaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogS2V5U3lzdGVtcywgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIktleVN5c3RlbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBLZXlTeXN0ZW1zOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3M7IH0pO1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gKi9cbnZhciBLZXlTeXN0ZW1zO1xuXG4oZnVuY3Rpb24gKEtleVN5c3RlbXMpIHtcbiAgS2V5U3lzdGVtc1tcIldJREVWSU5FXCJdID0gXCJjb20ud2lkZXZpbmUuYWxwaGFcIjtcbiAgS2V5U3lzdGVtc1tcIlBMQVlSRUFEWVwiXSA9IFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIjtcbn0pKEtleVN5c3RlbXMgfHwgKEtleVN5c3RlbXMgPSB7fSkpO1xuXG52YXIgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYubmF2aWdhdG9yICYmIHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgIHJldHVybiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZChzZWxmLm5hdmlnYXRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0oKTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBnZXRNZWRpYVNvdXJjZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRNZWRpYVNvdXJjZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldE1lZGlhU291cmNlOyB9KTtcbi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIGdldE1lZGlhU291cmNlKCkge1xuICByZXR1cm4gc2VsZi5NZWRpYVNvdXJjZSB8fCBzZWxmLldlYktpdE1lZGlhU291cmNlO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy9tcDQtdG9vbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL21wNC10b29scy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogYmluMnN0ciwgcmVhZFVpbnQxNiwgcmVhZFVpbnQzMiwgd3JpdGVVaW50MzIsIGZpbmRCb3gsIHBhcnNlU2VnbWVudEluZGV4LCBwYXJzZUluaXRTZWdtZW50LCBnZXRTdGFydERUUywgZ2V0RHVyYXRpb24sIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzLCBvZmZzZXRTdGFydERUUywgc2VnbWVudFZhbGlkUmFuZ2UsIGFwcGVuZFVpbnQ4QXJyYXkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYmluMnN0clwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJpbjJzdHI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlYWRVaW50MTZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZWFkVWludDE2OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZWFkVWludDMyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVhZFVpbnQzMjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwid3JpdGVVaW50MzJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZVVpbnQzMjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmluZEJveFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbmRCb3g7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlU2VnbWVudEluZGV4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VTZWdtZW50SW5kZXg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhcnNlSW5pdFNlZ21lbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZUluaXRTZWdtZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRTdGFydERUU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFN0YXJ0RFRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXREdXJhdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldER1cmF0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvZmZzZXRTdGFydERUU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9mZnNldFN0YXJ0RFRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZWdtZW50VmFsaWRSYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlZ21lbnRWYWxpZFJhbmdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhcHBlbmRVaW50OEFycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXBwZW5kVWludDhBcnJheTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVkLWFycmF5ICovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvYWRlcl9mcmFnbWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2ZyYWdtZW50ICovIFwiLi9zcmMvbG9hZGVyL2ZyYWdtZW50LnRzXCIpO1xuXG5cbnZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbnZhciBwdXNoID0gW10ucHVzaDtcbmZ1bmN0aW9uIGJpbjJzdHIoYnVmZmVyKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ1ZmZlcik7XG59XG5mdW5jdGlvbiByZWFkVWludDE2KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICgnZGF0YScgaW4gYnVmZmVyKSB7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgfVxuXG4gIHZhciB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4IHwgYnVmZmVyW29mZnNldCArIDFdO1xuICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICBpZiAoJ2RhdGEnIGluIGJ1ZmZlcikge1xuICAgIG9mZnNldCArPSBidWZmZXIuc3RhcnQ7XG4gICAgYnVmZmVyID0gYnVmZmVyLmRhdGE7XG4gIH1cblxuICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgMjQgfCBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgMTYgfCBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuZnVuY3Rpb24gd3JpdGVVaW50MzIoYnVmZmVyLCBvZmZzZXQsIHZhbHVlKSB7XG4gIGlmICgnZGF0YScgaW4gYnVmZmVyKSB7XG4gICAgb2Zmc2V0ICs9IGJ1ZmZlci5zdGFydDtcbiAgICBidWZmZXIgPSBidWZmZXIuZGF0YTtcbiAgfVxuXG4gIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDE2ICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDJdID0gdmFsdWUgPj4gOCAmIDB4ZmY7XG4gIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbn0gLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG5cbmZ1bmN0aW9uIGZpbmRCb3goaW5wdXQsIHBhdGgpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgdmFyIGRhdGE7XG4gIHZhciBzdGFydDtcbiAgdmFyIGVuZDtcblxuICBpZiAoJ2RhdGEnIGluIGlucHV0KSB7XG4gICAgZGF0YSA9IGlucHV0LmRhdGE7XG4gICAgc3RhcnQgPSBpbnB1dC5zdGFydDtcbiAgICBlbmQgPSBpbnB1dC5lbmQ7XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IGlucHV0O1xuICAgIHN0YXJ0ID0gMDtcbiAgICBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XG4gICAgdmFyIHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIHZhciB0eXBlID0gYmluMnN0cihkYXRhLnN1YmFycmF5KGkgKyA0LCBpICsgOCkpO1xuICAgIHZhciBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuXG4gICAgaWYgKHR5cGUgPT09IHBhdGhbMF0pIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlbmQgb2YgdGhlIHBhdGggYW5kIHdlJ3ZlIGZvdW5kIHRoZSBib3ggd2Ugd2VyZVxuICAgICAgICAvLyBsb29raW5nIGZvclxuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgc3RhcnQ6IGkgKyA4LFxuICAgICAgICAgIGVuZDogZW5kYm94XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgdmFyIHN1YnJlc3VsdHMgPSBmaW5kQm94KHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHN0YXJ0OiBpICsgOCxcbiAgICAgICAgICBlbmQ6IGVuZGJveFxuICAgICAgICB9LCBwYXRoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaSA9IGVuZGJveDtcbiAgfSAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcblxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gcGFyc2VTZWdtZW50SW5kZXgoaW5pdFNlZ21lbnQpIHtcbiAgdmFyIG1vb3ZCb3ggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnXSk7XG4gIHZhciBtb292ID0gbW9vdkJveCA/IG1vb3ZCb3hbMF0gOiBudWxsO1xuICB2YXIgbW9vdkVuZE9mZnNldCA9IG1vb3YgPyBtb292LmVuZCA6IG51bGw7IC8vIHdlIG5lZWQgdGhpcyBpbiBjYXNlIHdlIG5lZWQgdG8gY2hvcCBvZiBnYXJiYWdlIG9mIHRoZSBlbmQgb2YgY3VycmVudCBkYXRhXG5cbiAgdmFyIHNpZHhCb3ggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ3NpZHgnXSk7XG5cbiAgaWYgKCFzaWR4Qm94IHx8ICFzaWR4Qm94WzBdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICB2YXIgc2lkeCA9IHNpZHhCb3hbMF07XG4gIHZhciB2ZXJzaW9uID0gc2lkeC5kYXRhWzBdOyAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcblxuICB2YXIgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gOCA6IDE2O1xuICB2YXIgdGltZXNjYWxlID0gcmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDQ7IC8vIFRPRE86IHBhcnNlIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSBhbmQgZmlyc3RPZmZzZXRcbiAgLy8gdXN1YWxseSB6ZXJvIGluIG91ciBjYXNlXG5cbiAgdmFyIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIHZhciBmaXJzdE9mZnNldCA9IDA7XG5cbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICBpbmRleCArPSA4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ICs9IDE2O1xuICB9IC8vIHNraXAgcmVzZXJ2ZWRcblxuXG4gIGluZGV4ICs9IDI7XG4gIHZhciBzdGFydEJ5dGUgPSBzaWR4LmVuZCArIGZpcnN0T2Zmc2V0O1xuICB2YXIgcmVmZXJlbmNlc0NvdW50ID0gcmVhZFVpbnQxNihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgIHZhciByZWZlcmVuY2VJbmRleCA9IGluZGV4O1xuICAgIHZhciByZWZlcmVuY2VJbmZvID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICB2YXIgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIHZhciByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG5cbiAgICBpZiAocmVmZXJlbmNlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2VnbWVudER1cmF0aW9uID0gcmVhZFVpbnQzMihzaWR4LCByZWZlcmVuY2VJbmRleCk7XG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgcmVmZXJlbmNlU2l6ZTogcmVmZXJlbmNlU2l6ZSxcbiAgICAgIHN1YnNlZ21lbnREdXJhdGlvbjogc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgLy8gdW5zY2FsZWRcbiAgICAgIGluZm86IHtcbiAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHN0YXJ0Qnl0ZSArPSByZWZlcmVuY2VTaXplOyAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cblxuICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7IC8vIHNraXAgdG8gbmV4dCByZWZcblxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZTogZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgcmVmZXJlbmNlc0NvdW50OiByZWZlcmVuY2VzQ291bnQsXG4gICAgcmVmZXJlbmNlczogcmVmZXJlbmNlcyxcbiAgICBtb292RW5kT2Zmc2V0OiBtb292RW5kT2Zmc2V0XG4gIH07XG59XG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gKiB0aW1lc2NhbGUgdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICogYGBgXG4gKiBAcGFyYW0gaW5pdFNlZ21lbnQge1VpbnQ4QXJyYXl9IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJuIHtJbml0RGF0YX0gYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRyYWtzID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ3RyYWsnXSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0cmFrID0gdHJha3NbaV07XG4gICAgdmFyIHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcblxuICAgIGlmICh0a2hkKSB7XG4gICAgICB2YXIgdmVyc2lvbiA9IHRraGQuZGF0YVt0a2hkLnN0YXJ0XTtcblxuICAgICAgdmFyIF9pbmRleCA9IHZlcnNpb24gPT09IDAgPyAxMiA6IDIwO1xuXG4gICAgICB2YXIgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgX2luZGV4KTtcbiAgICAgIHZhciBtZGhkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWRoZCddKVswXTtcblxuICAgICAgaWYgKG1kaGQpIHtcbiAgICAgICAgdmVyc2lvbiA9IG1kaGQuZGF0YVttZGhkLnN0YXJ0XTtcbiAgICAgICAgX2luZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgICAgIHZhciB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIF9pbmRleCk7XG4gICAgICAgIHZhciBoZGxyID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnaGRsciddKVswXTtcblxuICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgIHZhciBoZGxyVHlwZSA9IGJpbjJzdHIoaGRsci5kYXRhLnN1YmFycmF5KGhkbHIuc3RhcnQgKyA4LCBoZGxyLnN0YXJ0ICsgMTIpKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHtcbiAgICAgICAgICAgIHNvdW46IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5BVURJTyxcbiAgICAgICAgICAgIHZpZGU6IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFT1xuICAgICAgICAgIH1baGRsclR5cGVdO1xuXG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFBhcnNlIGNvZGVjIGRldGFpbHMgdG8gYmUgYWJsZSB0byBidWlsZCBNSU1FIHR5cGUuXG4gICAgICAgICAgICB2YXIgY29kZXhCb3hlcyA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pO1xuICAgICAgICAgICAgdmFyIGNvZGVjID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoY29kZXhCb3hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVjQm94ID0gY29kZXhCb3hlc1swXTtcbiAgICAgICAgICAgICAgY29kZWMgPSBiaW4yc3RyKGNvZGVjQm94LmRhdGEuc3ViYXJyYXkoY29kZWNCb3guc3RhcnQgKyAxMiwgY29kZWNCb3guc3RhcnQgKyAxNikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0ge1xuICAgICAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICAgIGNvZGVjOiBjb2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gIHRyZXguZm9yRWFjaChmdW5jdGlvbiAodHJleCkge1xuICAgIHZhciB0cmFja0lkID0gcmVhZFVpbnQzMih0cmV4LCA0KTtcbiAgICB2YXIgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmRlZmF1bHQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiByZWFkVWludDMyKHRyZXgsIDEyKSxcbiAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gaW5pdERhdGEge0luaXREYXRhfSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gKiBAcGFyYW0gZm1wNCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICogZnJhZ21lbnQsIGluIHNlY29uZHNcbiAqL1xuXG5mdW5jdGlvbiBnZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCkge1xuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgcmV0dXJuIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHRyYWYpIHtcbiAgICB2YXIgdGZkdCA9IGZpbmRCb3godHJhZiwgWyd0ZmR0J10pWzBdO1xuICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgIHZhciBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0ZmhkKSB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG5cbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB2YXIgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgYmFzZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH0gLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcblxuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzOyAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG5cbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG5cbiAgICAgICAgaWYgKGlzRmluaXRlKHN0YXJ0VGltZSkgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCBzdGFydFRpbWUgPCByZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIG51bGwpO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIG51bGwpIHx8IDA7XG59XG4vKlxuICBGb3IgUmVmZXJlbmNlOlxuICBhbGlnbmVkKDgpIGNsYXNzIFRyYWNrRnJhZ21lbnRIZWFkZXJCb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRmaGTigJksIDAsIHRmX2ZsYWdzKXtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgIC8vIGFsbCB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgdW5zaWduZWQgaW50KDY0KSAgYmFzZV9kYXRhX29mZnNldDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbjtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfc2l6ZTtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgfVxuICovXG5cbmZ1bmN0aW9uIGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKSB7XG4gIHZhciByYXdEdXJhdGlvbiA9IDA7XG4gIHZhciB2aWRlb0R1cmF0aW9uID0gMDtcbiAgdmFyIGF1ZGlvRHVyYXRpb24gPSAwO1xuICB2YXIgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHJhZiA9IHRyYWZzW2ldOyAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cblxuICAgIHZhciB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07IC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuXG4gICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tEZWZhdWx0ID0gdHJhY2suZGVmYXVsdDtcbiAgICB2YXIgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8ICh0cmFja0RlZmF1bHQgPT09IG51bGwgfHwgdHJhY2tEZWZhdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZmxhZ3MpO1xuICAgIHZhciBzYW1wbGVEdXJhdGlvbiA9IHRyYWNrRGVmYXVsdCA9PT0gbnVsbCB8fCB0cmFja0RlZmF1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5kdXJhdGlvbjtcblxuICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikge1xuICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGR1cmF0aW9uIGlzIGF0IGJ5dGUgb2Zmc2V0IDhcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDgpO1xuICAgICAgfVxuICAgIH0gLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcblxuXG4gICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgIHZhciB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1bnNbal0sIDQpO1xuICAgICAgICByYXdEdXJhdGlvbiA9IHNhbXBsZUR1cmF0aW9uICogc2FtcGxlQ291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IF9sb2FkZXJfZnJhZ21lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVsZW1lbnRhcnlTdHJlYW1UeXBlc1wiXS5WSURFTykge1xuICAgICAgICB2aWRlb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBfbG9hZGVyX2ZyYWdtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFbGVtZW50YXJ5U3RyZWFtVHlwZXNcIl0uQVVESU8pIHtcbiAgICAgICAgYXVkaW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmlkZW9EdXJhdGlvbiA9PT0gMCAmJiBhdWRpb0R1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gSWYgZHVyYXRpb24gc2FtcGxlcyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgdHJhZiB1c2Ugc2lkeCBzdWJzZWdtZW50X2R1cmF0aW9uXG4gICAgdmFyIHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChkYXRhKTtcblxuICAgIGlmIChzaWR4ICE9PSBudWxsICYmIHNpZHggIT09IHZvaWQgMCAmJiBzaWR4LnJlZmVyZW5jZXMpIHtcbiAgICAgIHJldHVybiBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKGZ1bmN0aW9uIChkdXIsIHJlZikge1xuICAgICAgICByZXR1cm4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2aWRlb0R1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gYXVkaW9EdXJhdGlvbjtcbn1cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRydW7igJksIHZlcnNpb24sIHRyX2ZsYWdzKSB7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9jb3VudDtcbiAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHNpZ25lZCBpbnQoMzIpIGRhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBmaXJzdF9zYW1wbGVfZmxhZ3M7XG4gICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAge1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZHVyYXRpb247XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZmxhZ3NcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gMClcbiAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgeyBzaWduZWQgaW50KDMyKVxuICAgICB9WyBzYW1wbGVfY291bnQgXVxuICB9XG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXModHJ1bikge1xuICB2YXIgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApOyAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG5cbiAgdmFyIG9mZnNldCA9IDg7IC8vIGRhdGEtb2Zmc2V0LXByZXNlbnQgZmxhZ1xuXG4gIGlmIChmbGFncyAmIDB4MDAwMDAxKSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH0gLy8gZmlyc3Qtc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuXG5cbiAgaWYgKGZsYWdzICYgMHgwMDAwMDQpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIHZhciBkdXJhdGlvbiA9IDA7XG4gIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1biwgNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMTAwKSB7XG4gICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIG9mZnNldCk7XG4gICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gLy8gc2FtcGxlLXNpemUtcHJlc2VudCBmbGFnXG5cblxuICAgIGlmIChmbGFncyAmIDB4MDAwMjAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9IC8vIHNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcblxuXG4gICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH0gLy8gc2FtcGxlLWNvbXBvc2l0aW9uLXRpbWUtb2Zmc2V0cy1wcmVzZW50IGZsYWdcblxuXG4gICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcbn1cbmZ1bmN0aW9uIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBmbXA0LCB0aW1lT2Zmc2V0KSB7XG4gIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkuZm9yRWFjaChmdW5jdGlvbiAodHJhZikge1xuICAgIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLmZvckVhY2goZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIHZhciB0cmFjayA9IGluaXREYXRhW2lkXTtcblxuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG5cblxuICAgICAgdmFyIHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzOyAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuXG4gICAgICBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5mb3JFYWNoKGZ1bmN0aW9uICh0ZmR0KSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdC5kYXRhW3RmZHQuc3RhcnRdO1xuICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lIC0gdGltZU9mZnNldCAqIHRpbWVzY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgdmFyIHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgdmFyIGxvd2VyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDgsIGxvd2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSAvLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuXG5mdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhKSB7XG4gIHZhciBzZWdtZW50ZWRSYW5nZSA9IHtcbiAgICB2YWxpZDogbnVsbCxcbiAgICByZW1haW5kZXI6IG51bGxcbiAgfTtcbiAgdmFyIG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG5cbiAgaWYgKCFtb29mcykge1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfSBlbHNlIGlmIChtb29mcy5sZW5ndGggPCAyKSB7XG4gICAgc2VnbWVudGVkUmFuZ2UucmVtYWluZGVyID0gZGF0YTtcbiAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gIH1cblxuICB2YXIgbGFzdCA9IG1vb2ZzW21vb2ZzLmxlbmd0aCAtIDFdOyAvLyBPZmZzZXQgYnkgOCBieXRlczsgZmluZEJveCBvZmZzZXRzIHRoZSBzdGFydCBieSBhcyBtdWNoXG5cbiAgc2VnbWVudGVkUmFuZ2UudmFsaWQgPSBPYmplY3QoX3R5cGVkX2FycmF5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzbGljZVVpbnQ4XCJdKShkYXRhLCAwLCBsYXN0LnN0YXJ0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IE9iamVjdChfdHlwZWRfYXJyYXlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNsaWNlVWludDhcIl0pKGRhdGEsIGxhc3Quc3RhcnQgLSA4KTtcbiAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xufVxuZnVuY3Rpb24gYXBwZW5kVWludDhBcnJheShkYXRhMSwgZGF0YTIpIHtcbiAgdmFyIHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvb3V0cHV0LWZpbHRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL291dHB1dC1maWx0ZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPdXRwdXRGaWx0ZXI7IH0pO1xudmFyIE91dHB1dEZpbHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE91dHB1dEZpbHRlcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdGltZWxpbmVDb250cm9sbGVyO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE91dHB1dEZpbHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRpc3BhdGNoQ3VlID0gZnVuY3Rpb24gZGlzcGF0Y2hDdWUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm5ld0N1ZSA9IGZ1bmN0aW9uIG5ld0N1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbikge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxuXG4gICAgdGhpcy5lbmRUaW1lID0gZW5kVGltZTtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5jcmVhdGVDYXB0aW9uc1RyYWNrKHRoaXMudHJhY2tOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICB9O1xuXG4gIHJldHVybiBPdXRwdXRGaWx0ZXI7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90ZXh0dHJhY2stdXRpbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc2VuZEFkZFRyYWNrRXZlbnQsIGNsZWFyQ3VycmVudEN1ZXMsIGdldEN1ZXNJblJhbmdlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlbmRBZGRUcmFja0V2ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VuZEFkZFRyYWNrRXZlbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNsZWFyQ3VycmVudEN1ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhckN1cnJlbnRDdWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRDdWVzSW5SYW5nZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEN1ZXNJblJhbmdlOyB9KTtcbmZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gIHZhciBldmVudDtcblxuICB0cnkge1xuICAgIGV2ZW50ID0gbmV3IEV2ZW50KCdhZGR0cmFjaycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBmb3IgSUUxMVxuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdhZGR0cmFjaycsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBldmVudC50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICBpZiAodHJhY2sgIT09IG51bGwgJiYgdHJhY2sgIT09IHZvaWQgMCAmJiB0cmFjay5jdWVzKSB7XG4gICAgLy8gV2hlbiB0cmFjay5tb2RlIGlzIGRpc2FibGVkLCB0cmFjay5jdWVzIHdpbGwgYmUgbnVsbC5cbiAgICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAgIC8vIGNoYW5nZSB0aGUgbW9kZSB0byBoaWRkZW5cbiAgICBpZiAodHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIHdoaWxlICh0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzWzBdKTtcbiAgICB9XG4gIH1cbn0gLy8gRmluZCBmaXJzdCBjdWUgc3RhcnRpbmcgYWZ0ZXIgZ2l2ZW4gdGltZS5cbi8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYmluYXJ5IHNlYXJjaCBPKGxvZyhuKSkuXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3VlcywgdGltZSkge1xuICAvLyBJZiBmaXJzdCBjdWUgc3RhcnRzIGFmdGVyIHRpbWUsIHN0YXJ0IHRoZXJlXG4gIGlmICh0aW1lIDwgY3Vlc1swXS5zdGFydFRpbWUpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJZiB0aGUgbGFzdCBjdWUgZW5kcyBiZWZvcmUgdGltZSB0aGVyZSBpcyBubyBvdmVybGFwXG5cblxuICBpZiAodGltZSA+IGN1ZXNbY3Vlcy5sZW5ndGggLSAxXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBjdWVzLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuXG4gICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICByaWdodCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIGlmICh0aW1lID4gY3Vlc1ttaWRdLnN0YXJ0VGltZSkge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9IC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cbiAgLy8gTm8gZGlyZWN0IG1hdGNoIHdhcyBmb3VuZCwgbGVmdCBvciByaWdodCBlbGVtZW50IG11c3QgYmUgdGhlIGNsb3Nlc3QuIENoZWNrIHdoaWNoIG9uZSBoYXMgdGhlIHNtYWxsZXN0IGRpZmYuXG5cblxuICByZXR1cm4gY3Vlc1tsZWZ0XS5zdGFydFRpbWUgLSB0aW1lIDwgdGltZSAtIGN1ZXNbcmlnaHRdLnN0YXJ0VGltZSA/IGxlZnQgOiByaWdodDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3Vlc0luUmFuZ2UoY3Vlcywgc3RhcnQsIGVuZCkge1xuICB2YXIgY3Vlc0ZvdW5kID0gW107XG4gIHZhciBmaXJzdEN1ZUluUmFuZ2UgPSBnZXRGaXJzdEN1ZUluZGV4QWZ0ZXJUaW1lKGN1ZXMsIHN0YXJ0KTtcblxuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKHZhciBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3Vlc0ZvdW5kO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy90aW1lLXJhbmdlcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy90aW1lLXJhbmdlcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cbnZhciBUaW1lUmFuZ2VzID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcocikge1xuICAgIHZhciBsb2cgPSAnJztcbiAgICB2YXIgbGVuID0gci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gJ1snICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgJywnICsgci5lbmQoaSkudG9GaXhlZCgzKSArICddJztcbiAgICB9XG5cbiAgICByZXR1cm4gbG9nO1xuICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChUaW1lUmFuZ2VzKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogdG9UaW1lc2NhbGVGcm9tQmFzZSwgdG9UaW1lc2NhbGVGcm9tU2NhbGUsIHRvTXNGcm9tTXBlZ1RzQ2xvY2ssIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvVGltZXNjYWxlRnJvbUJhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1RpbWVzY2FsZUZyb21TY2FsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvVGltZXNjYWxlRnJvbVNjYWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b01zRnJvbU1wZWdUc0Nsb2NrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9Nc0Zyb21NcGVnVHNDbG9jazsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZTsgfSk7XG52YXIgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKHZhbHVlLCBkZXN0U2NhbGUsIHNyY0Jhc2UsIHJvdW5kKSB7XG4gIGlmIChzcmNCYXNlID09PSB2b2lkIDApIHtcbiAgICBzcmNCYXNlID0gMTtcbiAgfVxuXG4gIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgcm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB2YWx1ZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXG5cbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUodmFsdWUsIGRlc3RTY2FsZSwgc3JjU2NhbGUsIHJvdW5kKSB7XG4gIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3JjU2NhbGUgPSAxO1xuICB9XG5cbiAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICByb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIGRlc3RTY2FsZSwgMSAvIHNyY1NjYWxlLCByb3VuZCk7XG59XG5mdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKHZhbHVlLCByb3VuZCkge1xuICBpZiAocm91bmQgPT09IHZvaWQgMCkge1xuICAgIHJvdW5kID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZSh2YWx1ZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUodmFsdWUsIHNyY1NjYWxlKSB7XG4gIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgc3JjU2NhbGUgPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRvVGltZXNjYWxlRnJvbUJhc2UodmFsdWUsIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgMSAvIHNyY1NjYWxlKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdHlwZWQtYXJyYXkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogc2xpY2VVaW50OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzbGljZVVpbnQ4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2xpY2VVaW50ODsgfSk7XG5mdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvdnR0Y3VlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlscy92dHRjdWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLlZUVEN1ZSkge1xuICAgIHJldHVybiBzZWxmLlZUVEN1ZTtcbiAgfVxuXG4gIHZhciBBbGxvd2VkRGlyZWN0aW9ucyA9IFsnJywgJ2xyJywgJ3JsJ107XG4gIHZhciBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG5cbiAgZnVuY3Rpb24gaXNBbGxvd2VkVmFsdWUoYWxsb3dlZCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gbmVjZXNzYXJ5IGZvciBhc3N1cmluZyB0aGUgZ2VuZXJpYyBjb25mb3JtcyB0byB0aGUgQXJyYXkgaW50ZXJmYWNlXG5cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGxvd2VkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gcmVzZXQgdGhlIHR5cGUgc28gdGhhdCB0aGUgbmV4dCBuYXJyb3dpbmcgd29ya3Mgd2VsbFxuXG5cbiAgICB2YXIgbGNWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7IC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuXG4gICAgaWYgKH5hbGxvd2VkLmluZGV4T2YobGNWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBsY1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWREaXJlY3Rpb25zLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWRBbGlnbm1lbnRzLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSAxO1xuXG4gICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgIHZhciBjdWUgPSB0aGlzO1xuICAgIHZhciBiYXNlT2JqID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cbiAgICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAgIC8vIHRvIHJlY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZS4gVGhpcyBsZXRzIHVzIGNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGVcbiAgICAvLyBsYXppbHkuXG5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgICAqL1xuXG4gICAgdmFyIF9pZCA9ICcnO1xuICAgIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHZhciBfdGV4dCA9IHRleHQ7XG4gICAgdmFyIF9yZWdpb24gPSBudWxsO1xuICAgIHZhciBfdmVydGljYWwgPSAnJztcbiAgICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcbiAgICB2YXIgX2xpbmUgPSAnYXV0byc7XG4gICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSAnbWlkZGxlJztcbiAgICB2YXIgX3NpemUgPSA1MDtcbiAgICB2YXIgX2FsaWduID0gJ21pZGRsZSc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2lkJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfaWQgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncGF1c2VPbkV4aXQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3RleHQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyB0b2RvOiBpbXBsZW1lbnQgVlRUUmVnaW9uIHBvbHlmaWxsP1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpOyAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cblxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHZhbHVlICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuXG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uQWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wb3NpdGlvbkFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnc2l6ZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcblxuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICovXG5cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICB2YXIgV2ViVlRUID0gc2VsZi5XZWJWVFQ7XG4gICAgcmV0dXJuIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHNlbGYsIHRoaXMudGV4dCk7XG4gIH07IC8vIHRoaXMgaXMgYSBwb2x5ZmlsbCBoYWNrXG5cblxuICByZXR1cm4gVlRUQ3VlO1xufSkoKSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxzL3Z0dHBhcnNlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMvdnR0cGFyc2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBwYXJzZVRpbWVTdGFtcCwgZml4TGluZUJyZWFrcywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVRpbWVTdGFtcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlVGltZVN0YW1wOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaXhMaW5lQnJlYWtzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZml4TGluZUJyZWFrczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92dHRjdWUgKi8gXCIuL3NyYy91dGlscy92dHRjdWUudHNcIik7XG4vKlxuICogU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvZGlzdC92dHQuanMjTDE3MTZcbiAqL1xuXG5cbnZhciBTdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFZUVFBhcnNlcigpIHtcbiAgdGhpcy53aW5kb3cgPSBzZWxmO1xuICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICB0aGlzLmJ1ZmZlciA9ICcnO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn0gLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cblxuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgfVxuXG4gIHZhciBtID0gaW5wdXQubWF0Y2goL14oPzooXFxkKyk6KT8oXFxkezJ9KTooXFxkezJ9KShcXC5cXGQrKT8vKTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzJdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMl0sIG1bM10sIDAsIG1bNF0pO1xuICB9IC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnMgKG9wdGlvbmFsKV06W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuXG5cbiAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10sIG1bNF0pO1xufSAvLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5cbmZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cblNldHRpbmdzLnByb3RvdHlwZSA9IHtcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0OiBmdW5jdGlvbiBzZXQoaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gJycpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQ6IGZ1bmN0aW9uIGdldChrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH0sXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzOiBmdW5jdGlvbiBoYXMoaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbiBhbHQoaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbiBpbnRlZ2VyKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7XG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbiBwZXJjZW50KGssIHYpIHtcbiAgICBpZiAoL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8udGVzdCh2KSkge1xuICAgICAgdmFyIHBlcmNlbnQgPSBwYXJzZUZsb2F0KHYpO1xuXG4gICAgICBpZiAocGVyY2VudCA+PSAwICYmIHBlcmNlbnQgPD0gMTAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHBlcmNlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07IC8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG5cbiAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcblxuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrID0ga3ZbMF07XG4gICAgdmFyIHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdHMgPSBuZXcgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgwLCAwLCAwKTsgLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxuXG52YXIgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0OyAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuXG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCB0aW1lc3RhbXA6ICcgKyBvSW5wdXQpO1xuICAgIH0gLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cblxuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCAnJyk7XG4gICAgcmV0dXJuIHRzO1xuICB9IC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcblxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgdmFyIHZhbHM7XG5cbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlICdyZWdpb24nOlxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbJ3JsJywgJ2xyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzWzBdKTtcblxuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG5cbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgnbGluZUFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuXG4gICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hbHQoJ3Bvc2l0aW9uQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJywgJ2xpbmUtbGVmdCcsICdsaW5lLXJpZ2h0JywgJ2F1dG8nXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhbGlnbic6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTsgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cblxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldCgndmVydGljYWwnLCAnJyk7XG4gICAgdmFyIGxpbmUgPSBzZXR0aW5ncy5nZXQoJ2xpbmUnLCAnYXV0bycpO1xuXG4gICAgaWYgKGxpbmUgPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5saW5lID09PSAtMSkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgbGluZSA9IC0xO1xuICAgIH1cblxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgZGVmYXVsdHMucG9zaXRpb24gPT09IDUwKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBwb3NpdGlvbiBmb3IgU2FmYXJpXG4gICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgIH1cblxuICAgIGN1ZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfSAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuXG5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcblxuICBza2lwV2hpdGVzcGFjZSgpO1xuXG4gIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09ICctLT4nKSB7XG4gICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoICctLT4nXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgKyBvSW5wdXQpO1xuICB9XG5cbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cblxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cblxuVlRUUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG5cblxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBfdGhpcy5idWZmZXIgKz0gX3RoaXMuZGVjb2Rlci5kZWNvZGUoZGF0YSwge1xuICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBfdGhpcy5idWZmZXI7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc3Vic3RyKDAsIHBvcyk7IC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0gLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgIGNhc2UgJ1JlZ2lvbic6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyc2UgcmVnaW9uJywgdik7XG4gICAgICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvOi8pO1xuICAgIH0gLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG5cblxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZTtcblxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTsgLy8gc3RyaXAgb2YgVVRGLTggQk9NIGlmIGFueVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcblxuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgJ0lEJzpcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdOT1RFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG5cblxuICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpcy5jdWUgPSBuZXcgX3Z0dGN1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgwLCAwLCAnJyk7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUUnOyAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCctLT4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICAgICAgICBjYXNlICdDVUUnOlxuICAgICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIF90aGlzLmN1ZSwgX3RoaXMucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICBjYXNlICdDVUVURVhUJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xOyAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cblxuICAgICAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgJ0JBRENVRSc6XG4gICAgICAgICAgICAvLyBCQURDVUVcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnQ1VFVEVYVCcgJiYgX3RoaXMuY3VlICYmIF90aGlzLm9uY3VlKSB7XG4gICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmN1ZSA9IG51bGw7IC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuXG4gICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgPyAnQkFEV0VCVlRUJyA6ICdCQURDVUUnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZSgpOyAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cblxuICAgICAgaWYgKF90aGlzLmN1ZSB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgX3RoaXMuYnVmZmVyICs9ICdcXG5cXG4nO1xuXG4gICAgICAgIF90aGlzLnBhcnNlKCk7XG4gICAgICB9IC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG5cblxuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcgfHwgX3RoaXMuc3RhdGUgPT09ICdCQURXRUJWVFQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKF90aGlzLm9ucGFyc2luZ2Vycm9yKSB7XG4gICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfdGhpcy5vbmZsdXNoKSB7XG4gICAgICBfdGhpcy5vbmZsdXNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoVlRUUGFyc2VyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMvd2VidnR0LXBhcnNlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxzL3dlYnZ0dC1wYXJzZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBwYXJzZVdlYlZUVCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVdlYlZUVFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlV2ViVlRUOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3JjL3BvbHlmaWxscy9udW1iZXIgKi8gXCIuL3NyYy9wb2x5ZmlsbHMvbnVtYmVyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92dHRwYXJzZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdnR0cGFyc2VyICovIFwiLi9zcmMvdXRpbHMvdnR0cGFyc2VyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZW11eF9pZDNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlbXV4L2lkMyAqLyBcIi4vc3JjL2RlbXV4L2lkMy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGltZXNjYWxlLWNvbnZlcnNpb24gKi8gXCIuL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVtdXhfbXA0X3JlbXV4ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3JlbXV4L21wNC1yZW11eGVyICovIFwiLi9zcmMvcmVtdXgvbXA0LXJlbXV4ZXIudHNcIik7XG5cblxuXG5cblxuXG5cblxudmFyIExJTkVCUkVBS1MgPSAvXFxyXFxufFxcblxccnxcXG58XFxyL2c7IC8vIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCBpcyBub3Qgc3VwcG9ydGVkIGluIElFMTFcblxudmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKGlucHV0U3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcG9zaXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0U3RyaW5nLnN1YnN0cihwb3NpdGlvbiwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbn07XG5cbnZhciBjdWVTdHJpbmcybWlsbGlzID0gZnVuY3Rpb24gY3VlU3RyaW5nMm1pbGxpcyh0aW1lU3RyaW5nKSB7XG4gIHZhciB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyKC0zKSk7XG4gIHZhciBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHIoLTYsIDIpKTtcbiAgdmFyIG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigtOSwgMikpO1xuICB2YXIgaG91cnMgPSB0aW1lU3RyaW5nLmxlbmd0aCA+IDkgPyBwYXJzZUludCh0aW1lU3RyaW5nLnN1YnN0cigwLCB0aW1lU3RyaW5nLmluZGV4T2YoJzonKSkpIDogMDtcblxuICBpZiAoIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKSh0cykgfHwgIU9iamVjdChfVXNlcnNfYXJ0ZW1teXpuaWtvdl9wcm9qZWN0c19obHNfanNfc3JjX3BvbHlmaWxsc19udW1iZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzRmluaXRlTnVtYmVyXCJdKShzZWNzKSB8fCAhT2JqZWN0KF9Vc2Vyc19hcnRlbW15em5pa292X3Byb2plY3RzX2hsc19qc19zcmNfcG9seWZpbGxzX251bWJlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNGaW5pdGVOdW1iZXJcIl0pKG1pbnMpIHx8ICFPYmplY3QoX1VzZXJzX2FydGVtbXl6bmlrb3ZfcHJvamVjdHNfaGxzX2pzX3NyY19wb2x5ZmlsbHNfbnVtYmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc0Zpbml0ZU51bWJlclwiXSkoaG91cnMpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDpcIiArIHRpbWVTdHJpbmcpO1xuICB9XG5cbiAgdHMgKz0gMTAwMCAqIHNlY3M7XG4gIHRzICs9IDYwICogMTAwMCAqIG1pbnM7XG4gIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gIHJldHVybiB0cztcbn07IC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcblxuXG52YXIgaGFzaCA9IGZ1bmN0aW9uIGhhc2godGV4dCkge1xuICB2YXIgaGFzaCA9IDUzODE7XG4gIHZhciBpID0gdGV4dC5sZW5ndGg7XG5cbiAgd2hpbGUgKGkpIHtcbiAgICBoYXNoID0gaGFzaCAqIDMzIF4gdGV4dC5jaGFyQ29kZUF0KC0taSk7XG4gIH1cblxuICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG59O1xuXG52YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgdmFyIGN1cnJDQyA9IHZ0dENDc1tjY107XG4gIHZhciBwcmV2Q0MgPSB2dHRDQ3NbY3VyckNDLnByZXZDQ107IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcblxuICBpZiAoIXByZXZDQyB8fCAhcHJldkNDLm5ldyAmJiBjdXJyQ0MubmV3KSB7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcblxuXG4gIHdoaWxlICgoX3ByZXZDQyA9IHByZXZDQykgIT09IG51bGwgJiYgX3ByZXZDQyAhPT0gdm9pZCAwICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG5cbiAgICB2dHRDQ3MuY2NPZmZzZXQgKz0gY3VyckNDLnN0YXJ0IC0gcHJldkNDLnN0YXJ0O1xuICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICBjdXJyQ0MgPSBwcmV2Q0M7XG4gICAgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuICB9XG5cbiAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHRpbWVzY2FsZSwgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBfdnR0cGFyc2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKCk7IC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxuICAvLyBVaW50OEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgaXMgbm90IGltcGxlbWVudGVkIGluIElFMTFcblxuICB2YXIgdnR0TGluZXMgPSBPYmplY3QoX2RlbXV4X2lkM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1widXRmOEFycmF5VG9TdHJcIl0pKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gIHZhciBjdWVzID0gW107XG4gIHZhciBpbml0UFRTOTBIeiA9IE9iamVjdChfdGltZXNjYWxlX2NvbnZlcnNpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlXCJdKShpbml0UFRTLCB0aW1lc2NhbGUpO1xuICB2YXIgY3VlVGltZSA9ICcwMDowMC4wMDAnO1xuICB2YXIgdGltZXN0YW1wTWFwTVBFR1RTID0gMDtcbiAgdmFyIHRpbWVzdGFtcE1hcExPQ0FMID0gMDtcbiAgdmFyIHBhcnNpbmdFcnJvcjtcbiAgdmFyIGluSGVhZGVyID0gdHJ1ZTtcbiAgdmFyIHRpbWVzdGFtcE1hcCA9IGZhbHNlO1xuXG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcbiAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICB2YXIgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0OyAvLyBDYWxjdWxhdGUgc3VidGl0bGUgUFRTIG9mZnNldFxuXG4gICAgdmFyIHdlYlZ0dE1wZWdUc01hcE9mZnNldCA9ICh0aW1lc3RhbXBNYXBNUEVHVFMgLSBpbml0UFRTOTBIeikgLyA5MDAwMDsgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcblxuICAgIGlmIChjdXJyQ0MgIT09IG51bGwgJiYgY3VyckNDICE9PSB2b2lkIDAgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgTVBFR1RTLCBvZmZzZXQgPSBwcmVzZW50YXRpb24gdGltZSArIGRpc2NvbnRpbnVpdHkgb2Zmc2V0XG4gICAgICBjdWVPZmZzZXQgPSB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgLSB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aW1lc3RhbXBNYXApIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IGN1ZS5lbmRUaW1lIC0gY3VlLnN0YXJ0VGltZTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBPYmplY3QoX3JlbXV4X21wNF9yZW11eGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJQVFNOb3JtYWxpemVcIl0pKChjdWUuc3RhcnRUaW1lICsgY3VlT2Zmc2V0IC0gdGltZXN0YW1wTWFwTE9DQUwpICogOTAwMDAsIHRpbWVPZmZzZXQgKiA5MDAwMCkgLyA5MDAwMDtcbiAgICAgIGN1ZS5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgIH0gLy8gSWYgdGhlIGN1ZSB3YXMgbm90IGFzc2lnbmVkIGFuIGlkIGZyb20gdGhlIFZUVCBmaWxlIChsaW5lIGFib3ZlIHRoZSBjb250ZW50KSxcbiAgICAvLyB0aGVuIGNyZWF0ZSBhIHVuaXF1ZSBoYXNoIGlkIGZvciBhIGN1ZSBiYXNlZCBvbiBzdGFydC9lbmQgdGltZXMuXG4gICAgLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG5cblxuICAgIGlmICghY3VlLmlkKSB7XG4gICAgICBjdWUuaWQgPSBoYXNoKGN1ZS5zdGFydFRpbWUudG9TdHJpbmcoKSkgKyBoYXNoKGN1ZS5lbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChjdWUudGV4dCk7XG4gICAgfSAvLyBGaXggZW5jb2Rpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzXG5cblxuICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChjdWUudGV4dCkpO1xuXG4gICAgaWYgKGN1ZS5lbmRUaW1lID4gMCkge1xuICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJzaW5nRXJyb3IgJiYgZXJyb3JDYWxsQmFjaykge1xuICAgICAgZXJyb3JDYWxsQmFjayhwYXJzaW5nRXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxCYWNrKGN1ZXMpO1xuICB9OyAvLyBHbyB0aHJvdWdoIGNvbnRlbnRzIGxpbmUgYnkgbGluZS5cblxuXG4gIHZ0dExpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAoaW5IZWFkZXIpIHtcbiAgICAgIC8vIExvb2sgZm9yIFgtVElNRVNUQU1QLU1BUCBpbiBoZWFkZXIuXG4gICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgIC8vIE9uY2UgZm91bmQsIG5vIG1vcmUgYXJlIGFsbG93ZWQgYW55d2F5LCBzbyBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgdGltZXN0YW1wTWFwID0gdHJ1ZTsgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuXG4gICAgICAgIGxpbmUuc3Vic3RyKDE2KS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ0xPQ0FMOicpKSB7XG4gICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnN1YnN0cig2KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTVBFR1RTOicpKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc3Vic3RyKDcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ29udmVydCBjdWUgdGltZSB0byBzZWNvbmRzXG4gICAgICAgICAgdGltZXN0YW1wTWFwTE9DQUwgPSBjdWVTdHJpbmcybWlsbGlzKGN1ZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aW1lc3RhbXBNYXAgPSBmYWxzZTtcbiAgICAgICAgICBwYXJzaW5nRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfSAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gUGFyc2UgbGluZSBieSBkZWZhdWx0LlxuXG5cbiAgICBwYXJzZXIucGFyc2UobGluZSArICdcXG4nKTtcbiAgfSk7XG4gIHBhcnNlci5mbHVzaCgpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlscy94aHItbG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMveGhyLWxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbG9nZ2VyICovIFwiLi9zcmMvdXRpbHMvbG9nZ2VyLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2FkZXJfbG9hZF9zdGF0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9hZGVyL2xvYWQtc3RhdHMgKi8gXCIuL3NyYy9sb2FkZXIvbG9hZC1zdGF0cy50c1wiKTtcblxuXG5cbnZhciBYaHJMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYaHJMb2FkZXIoY29uZmlnXG4gIC8qIEhsc0NvbmZpZyAqL1xuICApIHtcbiAgICB0aGlzLnhoclNldHVwID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMueGhyU2V0dXAgPSBjb25maWcgPyBjb25maWcueGhyU2V0dXAgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgX2xvYWRlcl9sb2FkX3N0YXRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKCk7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBYaHJMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uYWJvcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIGFib3J0SW50ZXJuYWwoKSB7XG4gICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyO1xuXG4gICAgaWYgKGxvYWRlciAmJiBsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgIH1cblxuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgfTtcblxuICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgX3RoaXMkY2FsbGJhY2tzO1xuXG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG5cbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPT0gbnVsbCAmJiBfdGhpcyRjYWxsYmFja3MgIT09IHZvaWQgMCAmJiBfdGhpcyRjYWxsYmFja3Mub25BYm9ydCkge1xuICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBjb25maWcucmV0cnlEZWxheTtcbiAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICB9O1xuXG4gIF9wcm90by5sb2FkSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2FkSW50ZXJuYWwoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICB2YXIgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZml4IHhoclNldHVwOiAoeGhyLCB1cmwpID0+IHt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtTGFuZ3VhZ2VcIiwgXCJ0ZXN0XCIpO31cbiAgICAgICAgICAvLyBub3Qgd29ya2luZywgYXMgeGhyLnNldFJlcXVlc3RIZWFkZXIgZXhwZWN0cyB4aHIucmVhZHlTdGF0ZSA9PT0gT1BFTlxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgeGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICB0ZXh0OiBlLm1lc3NhZ2VcbiAgICAgIH0sIGNvbnRleHQsIHhocik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSk7XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGU7IC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuXG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy50aW1lb3V0KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9O1xuXG4gIF9wcm90by5yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgeGhyID0gdGhpcy5sb2FkZXIsXG4gICAgICAgIHN0YXRzID0gdGhpcy5zdGF0cztcblxuICAgIGlmICghY29udGV4dCB8fCAheGhyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7IC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcblxuICAgIGlmIChzdGF0cy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyA+PSBIRUFERVJTX1JFQ0VJVkVEXG5cblxuICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIC8vIGNsZWFyIHhociB0aW1lb3V0IGFuZCByZWFybSBpdCBpZiByZWFkeVN0YXRlIGxlc3MgdGhhbiA0XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcblxuICAgICAgaWYgKHN0YXRzLmxvYWRpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1czsgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuXG4gICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgdmFyIGxlbjtcblxuICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICB2YXIgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG5cbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgeGhyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbWF4IG5iIG9mIHJldHJpZXMgcmVhY2hlZCBvciBpZiBodHRwIHN0YXR1cyBiZXR3ZWVuIDQwMCBhbmQgNDk5IChzdWNoIGVycm9yIGNhbm5vdCBiZSByZWNvdmVyZWQsIHJldHJ5aW5nIGlzIHVzZWxlc3MpLCByZXR1cm4gZXJyb3JcbiAgICAgICAgICBpZiAoc3RhdHMucmV0cnkgPj0gY29uZmlnLm1heFJldHJ5IHx8IHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNDk5KSB7XG4gICAgICAgICAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0uZXJyb3Ioc3RhdHVzICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICB9LCBjb250ZXh0LCB4aHIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZXRyeVxuICAgICAgICAgICAgX3V0aWxzX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wibG9nZ2VyXCJdLndhcm4oc3RhdHVzICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsICsgXCIsIHJldHJ5aW5nIGluIFwiICsgdGhpcy5yZXRyeURlbGF5ICsgXCIuLi5cIik7IC8vIGFib3J0IGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZVxuXG4gICAgICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDsgLy8gc2NoZWR1bGUgcmV0cnlcblxuICAgICAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSwgdGhpcy5yZXRyeURlbGF5KTsgLy8gc2V0IGV4cG9uZW50aWFsIGJhY2tvZmZcblxuICAgICAgICAgICAgdGhpcy5yZXRyeURlbGF5ID0gTWF0aC5taW4oMiAqIHRoaXMucmV0cnlEZWxheSwgY29uZmlnLm1heFJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgc3RhdHMucmV0cnkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9hZHRpbWVvdXQgPSBmdW5jdGlvbiBsb2FkdGltZW91dCgpIHtcbiAgICBfdXRpbHNfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJsb2dnZXJcIl0ud2FybihcInRpbWVvdXQgd2hpbGUgbG9hZGluZyBcIiArIHRoaXMuY29udGV4dC51cmwpO1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcztcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvYWRwcm9ncmVzcyA9IGZ1bmN0aW9uIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xuXG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8qIENvdWxkIG5vdCBnZXQgaGVhZGVycyAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBYaHJMb2FkZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoWGhyTG9hZGVyKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obHMuanMubWFwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2V2ZW50cydcblxuLyoqXG4gKiBAY2xhc3MgQmFzZU9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudHNcbiAqIEBtb2R1bGUgYmFzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlT2JqZWN0IGV4dGVuZHMgRXZlbnRzIHtcbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIG9iamVjdCBvcHRpb25zXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIE9iamVjdFxuICAgKi9cbiAgZ2V0IG9wdGlvbnMoKSB7IHJldHVybiB0aGlzLl9vcHRpb25zIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucz17fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnVuaXF1ZUlkID0gdW5pcXVlSWQoJ28nKVxuICB9XG4gIC8qKlxuICAqIGEgdW5pcXVlIGlkIHByZWZpeGVkIHdpdGggYCdvJ2AsIGBvMSwgbzIzMmBcbiAgKlxuICAqIEBwcm9wZXJ0eSB1bmlxdWVJZFxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xufVxuIiwiaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9iYXNlX29iamVjdCdcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgRXJyb3JNaXhpbiBmcm9tICcuL2Vycm9yX21peGluJ1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhIGNvbnRhaW5lciBwbHVnaW5cbiAqIEBjbGFzcyBDb250YWluZXJQbHVnaW5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFzZU9iamVjdFxuICogQG1vZHVsZSBiYXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhaW5lclBsdWdpbiBleHRlbmRzIEJhc2VPYmplY3Qge1xuICBnZXQgcGxheWVyRXJyb3IoKSB7IHJldHVybiB0aGlzLmNvbnRhaW5lci5wbGF5ZXJFcnJvciB9XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyLm9wdGlvbnMpXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpXG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7fVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKENvbnRhaW5lclBsdWdpbi5wcm90b3R5cGUsIEVycm9yTWl4aW4pXG5cbkNvbnRhaW5lclBsdWdpbi5leHRlbmQgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBleHRlbmQoQ29udGFpbmVyUGx1Z2luLCBwcm9wZXJ0aWVzKVxufVxuXG5Db250YWluZXJQbHVnaW4udHlwZSA9ICdjb250YWluZXInXG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9iYXNlX29iamVjdCdcbmltcG9ydCBFcnJvck1peGluIGZyb20gJy4vZXJyb3JfbWl4aW4nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVQbHVnaW4gZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgZ2V0IHBsYXllckVycm9yKCkgeyByZXR1cm4gdGhpcy5jb3JlLnBsYXllckVycm9yIH1cblxuICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG4gICAgc3VwZXIoY29yZS5vcHRpb25zKVxuICAgIHRoaXMuY29yZSA9IGNvcmVcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7fVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpXG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGdldEV4dGVybmFsSW50ZXJmYWNlKCkgeyByZXR1cm4ge30gfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKENvcmVQbHVnaW4ucHJvdG90eXBlLCBFcnJvck1peGluKVxuXG5Db3JlUGx1Z2luLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIGV4dGVuZChDb3JlUGx1Z2luLCBwcm9wZXJ0aWVzKVxufVxuXG5Db3JlUGx1Z2luLnR5cGUgPSAnY29yZSdcbiIsImltcG9ydCBMb2cgZnJvbSAnLi4vcGx1Z2lucy9sb2cnXG5pbXBvcnQgUGxheWVyRXJyb3IgZnJvbSAnLi4vY29tcG9uZW50cy9lcnJvcidcblxuY29uc3QgRXJyb3JNaXhpbiA9IHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gZXJyb3IuXG4gICAqIEBtZXRob2QgY3JlYXRlRXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBjb2RlLCBkZXNjcmlwdGlvbiwgbGV2ZWwgYW5kIHJhdyBlcnJvci5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBmb3JtYXR0ZWQgZXJyb3IgZGF0YSBpbmNsdWRpbmcgb3JpZ2luIGFuZCBzY29wZVxuICAgKi9cbiAgY3JlYXRlRXJyb3IoZXJyb3IsIG9wdGlvbnMgPSB7IHVzZUNvZGVQcmVmaXg6IHRydWUgfSkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLnR5cGUgfHwgJydcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLm5hbWUgfHwgc2NvcGVcbiAgICBjb25zdCBpMThuID0gdGhpcy5pMThuIHx8IHRoaXMuY29yZSAmJiB0aGlzLmNvcmUuaTE4biB8fCB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5pMThuXG5cbiAgICBjb25zdCBwcmVmaXhlZENvZGUgPSBgJHtvcmlnaW59OiR7ZXJyb3IgJiYgZXJyb3IuY29kZSB8fCAndW5rbm93bid9YFxuICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHtcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgIGxldmVsOiBQbGF5ZXJFcnJvci5MZXZlbHMuRkFUQUwsXG4gICAgICBvcmlnaW4sXG4gICAgICBzY29wZSxcbiAgICAgIHJhdzoge30sXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEVycm9yLCBlcnJvciwge1xuICAgICAgY29kZTogb3B0aW9ucy51c2VDb2RlUHJlZml4ID8gcHJlZml4ZWRDb2RlIDogZXJyb3IuY29kZVxuICAgIH0pXG5cbiAgICBpZiAoaTE4biAmJiBlcnJvckRhdGEubGV2ZWwgPT0gUGxheWVyRXJyb3IuTGV2ZWxzLkZBVEFMICYmICFlcnJvckRhdGEuVUkpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRVSSA9IHtcbiAgICAgICAgdGl0bGU6IGkxOG4udCgnZGVmYXVsdF9lcnJvcl90aXRsZScpLFxuICAgICAgICBtZXNzYWdlOiBpMThuLnQoJ2RlZmF1bHRfZXJyb3JfbWVzc2FnZScpXG4gICAgICB9XG4gICAgICBlcnJvckRhdGEuVUkgPSBkZWZhdWx0VUlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJFcnJvcilcbiAgICAgIHRoaXMucGxheWVyRXJyb3IuY3JlYXRlRXJyb3IoZXJyb3JEYXRhKVxuICAgIGVsc2VcbiAgICAgIExvZy53YXJuKG9yaWdpbiwgJ1BsYXllckVycm9yIGlzIG5vdCBkZWZpbmVkLiBFcnJvcjogJywgZXJyb3JEYXRhKVxuXG4gICAgcmV0dXJuIGVycm9yRGF0YVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVycm9yTWl4aW5cbiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vcGx1Z2lucy9sb2cnXG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4vdXRpbHMnXG5cbmNvbnN0IHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbmNvbnN0IGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy9cblxuY29uc3QgZXZlbnRzQXBpID0gZnVuY3Rpb24ob2JqLCBhY3Rpb24sIG5hbWUsIHJlc3QpIHtcbiAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZVxuXG4gIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSlcbiAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICBjb25zdCBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcilcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihldmVudHMsIGFyZ3MsIGtsYXNzLCBuYW1lKSB7XG4gIGxldCBldiwgaSA9IC0xXG4gIGNvbnN0IGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdXG4gIHJ1bigpXG5cbiAgZnVuY3Rpb24gcnVuKCkge1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjdXJseSAqL1xuICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgeyAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KSB9IHJldHVyblxuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgeyAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSkgfSByZXR1cm5cbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIHsgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyKSB9IHJldHVyblxuICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgeyAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKSB9IHJldHVyblxuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIHsgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpIH0gcmV0dXJuXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICBMb2cuZXJyb3IuYXBwbHkoTG9nLCBba2xhc3MsICdlcnJvciBvbiBldmVudCcsIG5hbWUsICd0cmlnZ2VyJywnLScsIGV4Y2VwdGlvbl0pXG4gICAgICBydW4oKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBFdmVudHNcbiAqIEBjb25zdHJ1Y3RvclxuICogQG1vZHVsZSBiYXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50cyB7XG4gIC8qKlxuICAgKiBsaXN0ZW4gdG8gYW4gZXZlbnQgaW5kZWZpbml0ZWx5LCBpZiB5b3Ugd2FudCB0byBzdG9wIHlvdSBuZWVkIHRvIGNhbGwgYG9mZmBcbiAgICogQG1ldGhvZCBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb24nLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzXG4gICAgdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSlcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgKHRoaXMuX2V2ZW50c1tuYW1lXSA9IFtdKVxuICAgIGV2ZW50cy5wdXNoKHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgdGhpcyB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogbGlzdGVuIHRvIGFuIGV2ZW50IG9ubHkgb25jZVxuICAgKiBAbWV0aG9kIG9uY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9uY2UobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBsZXQgb25jZVxuICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpc1xuICAgIGNvbnN0IG9mZiA9ICgpID0+IHRoaXMub2ZmKG5hbWUsIG9uY2UpXG4gICAgb25jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgb2ZmKG5hbWUsIG9uY2UpXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIG9uY2UsIGNvbnRleHQpXG4gIH1cblxuICAvKipcbiAgICogc3RvcCBsaXN0ZW5pbmcgdG8gYW4gZXZlbnRcbiAgICogQG1ldGhvZCBvZmZcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAgICovXG4gIG9mZihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGxldCByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrXG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBPYmplY3Qua2V5cyh0aGlzLl9ldmVudHMpXG4gICAgLy8ganNoaW50IG1heGRlcHRoOjVcbiAgICBmb3IgKGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV1cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXVxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXVxuICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBldmVudHMubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBldiA9IGV2ZW50c1tqXVxuICAgICAgICAgICAgaWYgKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrLl9jYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSlcbiAgICAgICAgICAgICAgcmV0YWluLnB1c2goZXYpXG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXRhaW4ubGVuZ3RoKSBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogdHJpZ2dlcnMgYW4gZXZlbnQgZ2l2ZW4gaXRzIGBuYW1lYFxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIHRyaWdnZXIobmFtZSkge1xuICAgIGNvbnN0IGtsYXNzID0gdGhpcy5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZVxuICAgIExvZy5kZWJ1Zy5hcHBseShMb2csIFtrbGFzc10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKVxuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpc1xuICAgIGNvbnN0IGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAndHJpZ2dlcicsIG5hbWUsIGFyZ3MpKSByZXR1cm4gdGhpc1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXVxuICAgIGNvbnN0IGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGxcbiAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncywga2xhc3MsIG5hbWUpXG4gICAgaWYgKGFsbEV2ZW50cykgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIGFyZ3VtZW50cywga2xhc3MsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBzdG9wIGxpc3RlbmluZyBhbiBldmVudCBmb3IgYSBnaXZlbiBvYmplY3RcbiAgICogQG1ldGhvZCBzdG9wTGlzdGVuaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHN0b3BMaXN0ZW5pbmcob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGxldCBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvXG4gICAgaWYgKCFsaXN0ZW5pbmdUbykgcmV0dXJuIHRoaXNcbiAgICBjb25zdCByZW1vdmUgPSAhbmFtZSAmJiAhY2FsbGJhY2tcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzXG4gICAgaWYgKG9iaikgKGxpc3RlbmluZ1RvID0ge30pW29iai5fbGlzdGVuSWRdID0gb2JqXG4gICAgZm9yIChjb25zdCBpZCBpbiBsaXN0ZW5pbmdUbykge1xuICAgICAgb2JqID0gbGlzdGVuaW5nVG9baWRdXG4gICAgICBvYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKVxuICAgICAgaWYgKHJlbW92ZSB8fCBPYmplY3Qua2V5cyhvYmouX2V2ZW50cykubGVuZ3RoID09PSAwKSBkZWxldGUgdGhpcy5fbGlzdGVuaW5nVG9baWRdXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXIoZXZlbnROYW1lKSB7XG4gICAgRXZlbnRzLkN1c3RvbSB8fCAoRXZlbnRzLkN1c3RvbSA9IHt9KVxuICAgIGxldCBwcm9wZXJ0eSA9IHR5cGVvZiBldmVudE5hbWUgPT09ICdzdHJpbmcnICYmIGV2ZW50TmFtZS50b1VwcGVyQ2FzZSgpLnRyaW0oKVxuXG4gICAgaWYgKHByb3BlcnR5ICYmICFFdmVudHMuQ3VzdG9tW3Byb3BlcnR5XSkge1xuICAgICAgRXZlbnRzLkN1c3RvbVtwcm9wZXJ0eV0gPSBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpLnNwbGl0KCdfJykubWFwKFxuICAgICAgICAodmFsdWUsIGluZGV4KSA9PiBpbmRleCA9PT0gMCA/IHZhbHVlIDogdmFsdWUgPSAodmFsdWVbMF0udG9VcHBlckNhc2UoKSArIHZhbHVlLnNsaWNlKDEpKVxuICAgICAgKS5qb2luKCcnKVxuICAgIH0gZWxzZVxuICAgICAgTG9nLmVycm9yKCdFdmVudHMnLCAnRXJyb3Igd2hlbiByZWdpc3RlciBldmVudDogJyArIGV2ZW50TmFtZSlcblxuICB9XG5cbiAgc3RhdGljIGxpc3RBdmFpbGFibGVDdXN0b21FdmVudHMoKSB7XG4gICAgRXZlbnRzLkN1c3RvbSB8fCAoRXZlbnRzLkN1c3RvbSA9IHt9KVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhFdmVudHMuQ3VzdG9tKS5maWx0ZXIoKHByb3BlcnR5KSA9PiB0eXBlb2YgRXZlbnRzLkN1c3RvbVtwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKVxuICB9XG59XG5cbi8qKlxuICogbGlzdGVuIHRvIGFuIGV2ZW50IGluZGVmaW5pdGVseSBmb3IgYSBnaXZlbiBgb2JqYFxuICogQG1ldGhvZCBsaXN0ZW5Ub1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLnBsYXliYWNrLCBFdmVudHMuUExBWUJBQ0tfUEFVU0UsIHRoaXMuY2FsbGJhY2spXG4gKiBgYGBcbiAqL1xuLyoqXG4gKiBsaXN0ZW4gdG8gYW4gZXZlbnQgb25jZSBmb3IgYSBnaXZlbiBgb2JqYFxuICogQG1ldGhvZCBsaXN0ZW5Ub09uY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmNvcmUucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19QQVVTRSwgdGhpcy5jYWxsYmFjaylcbiAqIGBgYFxuICovXG5jb25zdCBsaXN0ZW5NZXRob2RzID0geyBsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZScgfVxuXG5PYmplY3Qua2V5cyhsaXN0ZW5NZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBFdmVudHMucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSlcbiAgICBjb25zdCBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSB1bmlxdWVJZCgnbCcpKVxuICAgIGxpc3RlbmluZ1RvW2lkXSA9IG9ialxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXNcbiAgICBvYmpbbGlzdGVuTWV0aG9kc1ttZXRob2RdXShuYW1lLCBjYWxsYmFjaywgdGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuXG4vLyBQTEFZRVIgRVZFTlRTXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBpcyByZWFkeSBvbiBzdGFydHVwXG4gKlxuICogQGV2ZW50IFBMQVlFUl9SRUFEWVxuICovXG5FdmVudHMuUExBWUVSX1JFQURZID0gJ3JlYWR5J1xuLyoqXG4gKiBGaXJlZCB3aGVuIHBsYXllciByZXNpemVzXG4gKlxuICogQGV2ZW50IFBMQVlFUl9SRVNJWkVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50U2l6ZSBhbiBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBzaXplXG4gKi9cbkV2ZW50cy5QTEFZRVJfUkVTSVpFID0gJ3Jlc2l6ZSdcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5ZXIgY2hhbmdlcyBpdHMgZnVsbHNjcmVlbiBzdGF0ZVxuICpcbiAqIEBldmVudCBQTEFZRVJfRlVMTFNDUkVFTlxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIG9uIGZ1bGxzY3JlZW4gbW9kZVxuICovXG5FdmVudHMuUExBWUVSX0ZVTExTQ1JFRU4gPSAnZnVsbHNjcmVlbidcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5ZXIgc3RhcnRzIHRvIHBsYXlcbiAqXG4gKiBAZXZlbnQgUExBWUVSX1BMQVlcbiAqL1xuRXZlbnRzLlBMQVlFUl9QTEFZID0gJ3BsYXknXG4vKipcbiAqIEZpcmVkIHdoZW4gcGxheWVyIHBhdXNlc1xuICpcbiAqIEBldmVudCBQTEFZRVJfUEFVU0VcbiAqL1xuRXZlbnRzLlBMQVlFUl9QQVVTRSA9ICdwYXVzZSdcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5ZXIgc3RvcHNcbiAqXG4gKiBAZXZlbnQgUExBWUVSX1NUT1BcbiAqL1xuRXZlbnRzLlBMQVlFUl9TVE9QID0gJ3N0b3AnXG4vKipcbiAqIEZpcmVkIHdoZW4gcGxheWVyIGVuZHMgdGhlIHZpZGVvXG4gKlxuICogQGV2ZW50IFBMQVlFUl9FTkRFRFxuICovXG5FdmVudHMuUExBWUVSX0VOREVEID0gJ2VuZGVkJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHBsYXllciBzZWVrcyB0aGUgdmlkZW9cbiAqXG4gKiBAZXZlbnQgUExBWUVSX1NFRUtcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xuICovXG5FdmVudHMuUExBWUVSX1NFRUsgPSAnc2Vlaydcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5ZXIgcmVjZWl2ZXMgYW4gZXJyb3JcbiAqXG4gKiBAZXZlbnQgUExBWUVSX0VSUk9SXG4gKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgdGhlIGVycm9yXG4gKi9cbkV2ZW50cy5QTEFZRVJfRVJST1IgPSAncGxheWVyZXJyb3InXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3JcbiAqXG4gKiBAZXZlbnQgRVJST1JcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvclxuICogdGhlIGVycm9yIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtYXQgYHtjb2RlLCBkZXNjcmlwdGlvbiwgbGV2ZWwsIHJhdywgb3JpZ2luLCBzY29wZX1gXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29kZV1cbiAqIGVycm9yJ3MgY29kZTogY29kZSB0byBpZGVudGlmeSBlcnJvciBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogb3JpZ2luOmNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl1cbiAqIGVycm9yJ3MgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxldmVsXVxuICogZXJyb3IncyBsZXZlbDogRkFUQUwgb3IgV0FSTi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dXG4gKiBlcnJvcidzIG9yaWdpbi4gRXhhbXBsZTogaGxzLCBodG1sNSwgZXRjXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2NvcGVdXG4gKiBlcnJvcidzIHNjb3BlLiBFeGFtcGxlOiBwbGF5YmFjaywgY29udGFpbmVyLCBldGNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yYXddXG4gKiByYXcgZXJyb3I6IHRoZSBpbml0aWFsIGVycm9yIHJlY2VpdmVkXG4gKi9cbkV2ZW50cy5FUlJPUiA9ICdlcnJvcidcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIG9uIHBsYXllclxuICpcbiAqIEBldmVudCBQTEFZRVJfVElNRVVQREFURVxuICogQHBhcmFtIHtPYmplY3R9IHByb2dyZXNzIERhdGFcbiAqIHByb2dyZXNzIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy5jdXJyZW50XVxuICogY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy50b3RhbF1cbiAqIHRvdGFsIHRpbWUgKGluIHNlY29uZHMpXG4gKi9cbkV2ZW50cy5QTEFZRVJfVElNRVVQREFURSA9ICd0aW1ldXBkYXRlJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHBsYXllciB1cGRhdGVzIGl0cyB2b2x1bWVcbiAqXG4gKiBAZXZlbnQgUExBWUVSX1ZPTFVNRVVQREFURVxuICogQHBhcmFtIHtOdW1iZXJ9IHZvbHVtZSB0aGUgY3VycmVudCB2b2x1bWVcbiAqL1xuRXZlbnRzLlBMQVlFUl9WT0xVTUVVUERBVEUgPSAndm9sdW1ldXBkYXRlJ1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gc3VidGl0bGUgaXMgYXZhaWxhYmxlXG4gKlxuICogQGV2ZW50IFBMQVlFUl9TVUJUSVRMRV9BVkFJTEFCTEVcbiAqL1xuRXZlbnRzLlBMQVlFUl9TVUJUSVRMRV9BVkFJTEFCTEUgPSAnc3VidGl0bGVhdmFpbGFibGUnXG5cbi8vIFBsYXliYWNrIEV2ZW50c1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5YmFjayBpcyBkb3dubG9hZGluZyB0aGUgbWVkaWFcbiAqXG4gKiBAZXZlbnQgUExBWUJBQ0tfUFJPR1JFU1NcbiAqIEBwYXJhbSBwcm9ncmVzcyB7T2JqZWN0fVxuICogRGF0YSBwcm9ncmVzcyBvYmplY3RcbiAqIEBwYXJhbSBbcHJvZ3Jlc3Muc3RhcnRdIHtOdW1iZXJ9XG4gKiBzdGFydCBwb3NpdGlvbiBvZiBidWZmZXJlZCBjb250ZW50IGF0IGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSBbcHJvZ3Jlc3MuY3VycmVudF0ge051bWJlcn1cbiAqIGVuZCBwb3NpdGlvbiBvZiBidWZmZXJlZCBjb250ZW50IGF0IGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSBbcHJvZ3Jlc3MudG90YWxdIHtOdW1iZXJ9XG4gKiB0b3RhbCBjb250ZW50IHRvIGJlIGRvd25sb2FkZWRcbiAqIEBwYXJhbSBidWZmZXJlZCB7QXJyYXl9XG4gKiBhcnJheSBvZiBidWZmZXJlZCBzZWdtZW50cyAoe3N0YXJ0LCBlbmR9KS4gW09ubHkgZm9yIHN1cHBvcnRlZCBwbGF5YmFja3NdXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19QUk9HUkVTUyA9ICdwbGF5YmFjazpwcm9ncmVzcydcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIG9uIHBsYXliYWNrXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1RJTUVVUERBVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9ncmVzcyBEYXRhXG4gKiBwcm9ncmVzcyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvZ3Jlc3MuY3VycmVudF1cbiAqIGN1cnJlbnQgdGltZSAoaW4gc2Vjb25kcylcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvZ3Jlc3MudG90YWxdXG4gKiB0b3RhbCB0aW1lIChpbiBzZWNvbmRzKVxuICovXG5FdmVudHMuUExBWUJBQ0tfVElNRVVQREFURSA9ICdwbGF5YmFjazp0aW1ldXBkYXRlJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHBsYXliYWNrIGlzIHJlYWR5XG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1JFQURZXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19SRUFEWSA9ICdwbGF5YmFjazpyZWFkeSdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWJhY2sgc3RhcnRzIGhhdmluZyB0byBidWZmZXIgYmVjYXVzZVxuICogcGxheWJhY2sgY2FuIGN1cnJlbnRseSBub3QgYmUgc21vb3RoLlxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHBsYXliYWNrIGBidWZmZXJpbmdgIHByb3BlcnR5IGJlaW5nXG4gKiBgdHJ1ZWAuXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0JVRkZFUklOR1xuICovXG5FdmVudHMuUExBWUJBQ0tfQlVGRkVSSU5HID0gJ3BsYXliYWNrOmJ1ZmZlcmluZydcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWJhY2sgaGFzIGVub3VnaCBpbiB0aGUgYnVmZmVyIHRvIGJlXG4gKiBhYmxlIHRvIHBsYXkgc21vb3RobHksIGFmdGVyIHByZXZpb3VzbHkgYmVpbmcgdW5hYmxlIHRvXG4gKiBkbyB0aGlzLlxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHBsYXliYWNrIGBidWZmZXJpbmdgIHByb3BlcnR5IGJlaW5nXG4gKiBgZmFsc2VgLlxuICpcbiAqIEBldmVudCBQTEFZQkFDS19CVUZGRVJGVUxMXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19CVUZGRVJGVUxMID0gJ3BsYXliYWNrOmJ1ZmZlcmZ1bGwnXG4vKipcbiAqIEZpcmVkIHdoZW4gcGxheWJhY2sgY2hhbmdlcyBhbnkgc2V0dGluZ3MgKHZvbHVtZSwgc2VlayBhbmQgZXRjKVxuICpcbiAqIEBldmVudCBQTEFZQkFDS19TRVRUSU5HU1VQREFURVxuICovXG5FdmVudHMuUExBWUJBQ0tfU0VUVElOR1NVUERBVEUgPSAncGxheWJhY2s6c2V0dGluZ3N1cGRhdGUnXG4vKipcbiAqIEZpcmVkIHdoZW4gcGxheWJhY2sgbG9hZGVkIGl0cyBtZXRhZGF0YVxuICpcbiAqIEBldmVudCBQTEFZQkFDS19MT0FERURNRVRBREFUQVxuICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIERhdGFcbiAqIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IFttZXRhZGF0YS5kdXJhdGlvbl1cbiAqIHRoZSBwbGF5YmFjayBkdXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFttZXRhZGF0YS5kYXRhXVxuICogZXh0cmEgbWV0YSBkYXRhXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19MT0FERURNRVRBREFUQSA9ICdwbGF5YmFjazpsb2FkZWRtZXRhZGF0YSdcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5YmFjayB1cGRhdGVzIGl0cyB2aWRlbyBxdWFsaXR5XG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0hJR0hERUZJTklUSU9OVVBEQVRFXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzSERcbiAqIHRydWUgd2hlbiBpcyBvbiBIRCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19ISUdIREVGSU5JVElPTlVQREFURSA9ICdwbGF5YmFjazpoaWdoZGVmaW5pdGlvbnVwZGF0ZSdcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5YmFjayB1cGRhdGVzIGl0cyBiaXRyYXRlXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0JJVFJBVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBiaXRyYXRlIERhdGFcbiAqIGJpdHJhdGUgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHJhdGUuYmFuZHdpZHRoXVxuICogYml0cmF0ZSBiYW5kd2lkdGggd2hlbiBpdCdzIGF2YWlsYWJsZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRyYXRlLndpZHRoXVxuICogcGxheWJhY2sgd2lkdGggKGV4OiA3MjAsIDY0MCwgMTA4MClcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cmF0ZS5oZWlnaHRdXG4gKiBwbGF5YmFjayBoZWlnaHQgKGV4OiAyNDAsIDQ4MCwgNzIwKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRyYXRlLmxldmVsXVxuICogcGxheWJhY2sgbGV2ZWwgd2hlbiBpdCdzIGF2YWlsYWJsZSwgaXQgY291bGQgYmUganVzdCBhIG1hcCBmb3Igd2lkdGggKDAgPT4gMjQwLCAxID0+IDQ4MCwgMiA9PiA3MjApXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19CSVRSQVRFID0gJ3BsYXliYWNrOmJpdHJhdGUnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXliYWNrIGhhcyBpdHMgbGV2ZWxzXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0xFVkVMU19BVkFJTEFCTEVcbiAqIEBwYXJhbSB7QXJyYXl9IGxldmVsc1xuICogdGhlIG9yZGVyZWQgbGV2ZWxzLCBlYWNoIG9uZSB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybWF0IGB7aWQ6IDEsIGxhYmVsOiAnNTAwa2Jwcyd9YCBwczogaWQgc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbml0aWFsXG4gKiB0aGUgaW5pdGlhbCBsZXZlbCBvdGhlcndpc2UgLTEgKEFVVE8pXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19MRVZFTFNfQVZBSUxBQkxFID0gJ3BsYXliYWNrOmxldmVsczphdmFpbGFibGUnXG4vKipcbiAqIEZpcmVkIGZpcnN0IGxldmVsLCB3aGljaCBwbGF5IHJpZ2h0IG5vd1xuICpcbiAqIEBldmVudCBQTEFZQkFDS19GSVJTVF9MRVZFTFxuICpcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX0ZJUlNUX0xFVkVMID0gJ3BsYXliYWNrOmZpcnN0OmxldmVsJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5YmFjayBzdGFydHMgdG8gc3dpdGNoIGxldmVsXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0xFVkVMX1NXSVRDSF9TVEFSVFxuICpcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX0xFVkVMX1NXSVRDSF9TVEFSVCA9ICdwbGF5YmFjazpsZXZlbHM6c3dpdGNoOnN0YXJ0J1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5YmFjayBlbmRzIHRoZSBsZXZlbCBzd2l0Y2hcbiAqXG4gKiBAZXZlbnQgUExBWUJBQ0tfTEVWRUxfU1dJVENIX0VORFxuICpcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX0xFVkVMX1NXSVRDSF9FTkQgPSAncGxheWJhY2s6bGV2ZWxzOnN3aXRjaDplbmQnXG5cbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5YmFjayBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1BMQVlCQUNLU1RBVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBEYXRhXG4gKiBzdGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGUudHlwZV1cbiAqIHRoZSBwbGF5YmFjayB0eXBlXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19QTEFZQkFDS1NUQVRFID0gJ3BsYXliYWNrOnBsYXliYWNrc3RhdGUnXG4vKipcbiAqIEZpcmVkIHdoZW4gRFZSIGJlY29tZXMgZW5hYmxlZC9kaXNhYmxlZC5cbiAqXG4gKiBAZXZlbnQgUExBWUJBQ0tfRFZSXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIHRydWUgaWYgZHZyIGVuYWJsZWRcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX0RWUiA9ICdwbGF5YmFjazpkdnInXG4vLyBUT0RPIGRvY1xuRXZlbnRzLlBMQVlCQUNLX01FRElBQ09OVFJPTF9ESVNBQkxFID0gJ3BsYXliYWNrOm1lZGlhY29udHJvbDpkaXNhYmxlJ1xuLy8gVE9ETyBkb2NcbkV2ZW50cy5QTEFZQkFDS19NRURJQUNPTlRST0xfRU5BQkxFID0gJ3BsYXliYWNrOm1lZGlhY29udHJvbDplbmFibGUnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG1lZGlhIGZvciBhIHBsYXliYWNrIGVuZHMuXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX0VOREVEXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgcGxheWJhY2tcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX0VOREVEID0gJ3BsYXliYWNrOmVuZGVkJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHVzZXIgcmVxdWVzdHMgYHBsYXkoKWBcbiAqXG4gKiBAZXZlbnQgUExBWUJBQ0tfUExBWV9JTlRFTlRcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX1BMQVlfSU5URU5UID0gJ3BsYXliYWNrOnBsYXk6aW50ZW50J1xuLyoqXG4gKiBGaXJlZCB3aGVuIHVzZXIgcmVxdWVzdHMgYHBsYXkoKWAsIGJ1dCBmaXJzdGx5IHdlIGdvdHRhIHJlcXVlc3QgcHJlcm9sbC4gaXQncyBhZHZpc2FibGUgaWYgdXNlciB1c2UgaWZyYW1lQVBJXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1BSRVJPTExfUkVRVUVTVFxuICovXG5FdmVudHMuUExBWUJBQ0tfUFJFUk9MTF9SRVFVRVNUID0gJ3BsYXliYWNrOnByZXJvbGw6cmVxdWVzdCdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgZm9yIGEgcGxheWJhY2sgc3RhcnRzIHBsYXlpbmcuXG4gKiBUaGlzIGlzIG5vdCBuZWNlc3NhcmlseSB3aGVuIHRoZSB1c2VyIHJlcXVlc3RzIGBwbGF5KClgXG4gKiBUaGUgbWVkaWEgbWF5IGhhdmUgdG8gYnVmZmVyIGZpcnN0LlxuICogSS5lLiBgaXNQbGF5aW5nKClgIG1pZ2h0IHJldHVybiBgdHJ1ZWAgYmVmb3JlIHRoaXMgZXZlbnQgaXMgZmlyZWQsXG4gKiBiZWNhdXNlIGBpc1BsYXlpbmcoKWAgcmVwcmVzZW50cyB0aGUgaW50ZW5kZWQgc3RhdGUuXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1BMQVlcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX1BMQVkgPSAncGxheWJhY2s6cGxheSdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgZm9yIGEgcGxheWJhY2sgcGF1c2VzLlxuICpcbiAqIEBldmVudCBQTEFZQkFDS19QQVVTRVxuICovXG5FdmVudHMuUExBWUJBQ0tfUEFVU0UgPSAncGxheWJhY2s6cGF1c2UnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG1lZGlhIGZvciBhIHBsYXliYWNrIGlzIHNlZWtpbmcuXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1NFRUtcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX1NFRUsgPSAncGxheWJhY2s6c2Vlaydcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgZm9yIGEgcGxheWJhY2sgaXMgc2Vla2VkLlxuICpcbiAqIEBldmVudCBQTEFZQkFDS19TRUVLRURcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX1NFRUtFRCA9ICdwbGF5YmFjazpzZWVrZWQnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG1lZGlhIGZvciBhIHBsYXliYWNrIGlzIHN0b3BwZWQuXG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1NUT1BcbiAqL1xuRXZlbnRzLlBMQVlCQUNLX1NUT1AgPSAncGxheWJhY2s6c3RvcCdcbi8qKlxuICogRmlyZWQgaWYgYW4gZXJyb3Igb2NjdXJzIGluIHRoZSBwbGF5YmFjay5cbiAqXG4gKiBAZXZlbnQgUExBWUJBQ0tfRVJST1JcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXJyb3IgZGV0YWlsc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgUGxheWJhY2sgbmFtZVxuICovXG5FdmVudHMuUExBWUJBQ0tfRVJST1IgPSAncGxheWJhY2s6ZXJyb3InXG4vLyBUT0RPIGRvY1xuRXZlbnRzLlBMQVlCQUNLX1NUQVRTX0FERCA9ICdwbGF5YmFjazpzdGF0czphZGQnXG4vLyBUT0RPIGRvY1xuRXZlbnRzLlBMQVlCQUNLX0ZSQUdNRU5UX0xPQURFRCA9ICdwbGF5YmFjazpmcmFnbWVudDpsb2FkZWQnXG4vLyBUT0RPIGRvY1xuRXZlbnRzLlBMQVlCQUNLX0xFVkVMX1NXSVRDSCA9ICdwbGF5YmFjazpsZXZlbDpzd2l0Y2gnXG4vKipcbiAqIEZpcmVkIHdoZW4gc3VidGl0bGUgaXMgYXZhaWxhYmxlIG9uIHBsYXliYWNrIGZvciBkaXNwbGF5XG4gKlxuICogQGV2ZW50IFBMQVlCQUNLX1NVQlRJVExFX0FWQUlMQUJMRVxuICovXG5FdmVudHMuUExBWUJBQ0tfU1VCVElUTEVfQVZBSUxBQkxFID0gJ3BsYXliYWNrOnN1YnRpdGxlOmF2YWlsYWJsZSdcbi8qKlxuICogRmlyZWQgd2hlbiBwbGF5YmFjayBzdWJ0aXRsZSB0cmFjayBoYXMgY2hhbmdlZFxuICpcbiAqIEBldmVudCBDT05UQUlORVJfU1VCVElUTEVfQ0hBTkdFRFxuICogQHBhcmFtIHtPYmplY3R9IHRyYWNrIERhdGFcbiAqIHRyYWNrIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IFt0cmFjay5pZF1cbiAqIHNlbGVjdGVkIHRyYWNrIGlkXG4gKi9cbkV2ZW50cy5QTEFZQkFDS19TVUJUSVRMRV9DSEFOR0VEID0gJ3BsYXliYWNrOnN1YnRpdGxlOmNoYW5nZWQnXG5cbi8vIENvcmUgRXZlbnRzXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGNvbnRhaW5lcnMgYXJlIGNyZWF0ZWRcbiAqXG4gKiBAZXZlbnQgQ09SRV9DT05UQUlORVJTX0NSRUFURURcbiAqL1xuRXZlbnRzLkNPUkVfQ09OVEFJTkVSU19DUkVBVEVEID0gJ2NvcmU6Y29udGFpbmVyczpjcmVhdGVkJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBhY3RpdmUgY29udGFpbmVyIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgQ09SRV9BQ1RJVkVfQ09OVEFJTkVSX0NIQU5HRURcbiAqL1xuRXZlbnRzLkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VEID0gJ2NvcmU6YWN0aXZlOmNvbnRhaW5lcjpjaGFuZ2VkJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBvcHRpb25zIHdlcmUgY2hhbmdlZCBmb3IgdGhlIGNvcmVcbiAqXG4gKiBAZXZlbnQgQ09SRV9PUFRJT05TX0NIQU5HRVxuICogQHBhcmFtIHtPYmplY3R9IG5ldyBvcHRpb25zIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZSgpIG1ldGhvZFxuICovXG5FdmVudHMuQ09SRV9PUFRJT05TX0NIQU5HRSA9ICdjb3JlOm9wdGlvbnM6Y2hhbmdlJ1xuLyoqXG4gKiBGaXJlZCBhZnRlciBjcmVhdGluZyBjb250YWluZXJzLCB3aGVuIHRoZSBjb3JlIGlzIHJlYWR5XG4gKlxuICogQGV2ZW50IENPUkVfUkVBRFlcbiAqL1xuRXZlbnRzLkNPUkVfUkVBRFkgPSAnY29yZTpyZWFkeSdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgZnVsbHNjcmVlbiBzdGF0ZSBjaGFuZ2VcbiAqXG4gKiBAZXZlbnQgQ09SRV9GVUxMU0NSRUVOXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgb24gZnVsbHNjcmVlbiBtb2RlXG4gKi9cbkV2ZW50cy5DT1JFX0ZVTExTQ1JFRU4gPSAnY29yZTpmdWxsc2NyZWVuJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIGNvcmUgdXBkYXRlcyBzaXplXG4gKlxuICogQGV2ZW50IENPUkVfUkVTSVpFXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFNpemUgYW4gb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgc2l6ZVxuICovXG5FdmVudHMuQ09SRV9SRVNJWkUgPSAnY29yZTpyZXNpemUnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHNjcmVlbiBvcmllbnRhdGlvbiBoYXMgY2hhbmdlZC5cbiAqIFRoaXMgZXZlbnQgaXMgdHJpZ2dlciBvbmx5IGZvciBtb2JpbGUgZGV2aWNlcy5cbiAqXG4gKiBAZXZlbnQgQ09SRV9TQ1JFRU5fT1JJRU5UQVRJT05fQ0hBTkdFRFxuICogQHBhcmFtIHtPYmplY3R9IHNjcmVlbiBBbiBvYmplY3Qgd2l0aCBzY3JlZW4gb3JpZW50YXRpb25cbiAqIHNjcmVlbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NyZWVuLmV2ZW50XVxuICogd2luZG93IHJlc2l6ZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NyZWVuLm9yaWVudGF0aW9uXVxuICogc2NyZWVuIG9yaWVudGF0aW9uIChpZTogJ2xhbmRzY2FwZScgb3IgJ3BvcnRyYWl0JylcbiAqL1xuRXZlbnRzLkNPUkVfU0NSRUVOX09SSUVOVEFUSU9OX0NIQU5HRUQgPSAnY29yZTpzY3JlZW46b3JpZW50YXRpb246Y2hhbmdlZCdcbi8qKlxuICogRmlyZWQgd2hlbiBvY2N1cnMgbW91c2UgbW92ZSBldmVudCBvbiBjb3JlIGVsZW1lbnRcbiAqXG4gKiBAZXZlbnQgQ09SRV9NT1VTRV9NT1ZFXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgYSBET00gZXZlbnRcbiAqL1xuRXZlbnRzLkNPUkVfTU9VU0VfTU9WRSA9ICdjb3JlOm1vdXNlbW92ZSdcbi8qKlxuICogRmlyZWQgd2hlbiBvY2N1cnMgbW91c2UgbGVhdmUgZXZlbnQgb24gY29yZSBlbGVtZW50XG4gKlxuICogQGV2ZW50IENPUkVfTU9VU0VfTEVBVkVcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBhIERPTSBldmVudFxuICovXG5FdmVudHMuQ09SRV9NT1VTRV9MRUFWRSA9ICdjb3JlOm1vdXNlbGVhdmUnXG5cbi8vIENvbnRhaW5lciBFdmVudHNcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY29udGFpbmVyIGludGVybmFsIHN0YXRlIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgQ09OVEFJTkVSX1BMQVlCQUNLU1RBVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBEYXRhXG4gKiBzdGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGUudHlwZV1cbiAqIHRoZSBwbGF5YmFjayB0eXBlXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfUExBWUJBQ0tTVEFURSA9ICdjb250YWluZXI6cGxheWJhY2tzdGF0ZSdcbkV2ZW50cy5DT05UQUlORVJfUExBWUJBQ0tEVlJTVEFURUNIQU5HRUQgPSAnY29udGFpbmVyOmR2cidcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY29udGFpbmVyIHVwZGF0ZXMgaXRzIGJpdHJhdGVcbiAqXG4gKiBAZXZlbnQgQ09OVEFJTkVSX0JJVFJBVEVcbiAqIEBwYXJhbSB7T2JqZWN0fSBiaXRyYXRlIERhdGFcbiAqIGJpdHJhdGUgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHJhdGUuYmFuZHdpZHRoXVxuICogYml0cmF0ZSBiYW5kd2lkdGggd2hlbiBpdCdzIGF2YWlsYWJsZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRyYXRlLndpZHRoXVxuICogcGxheWJhY2sgd2lkdGggKGV4OiA3MjAsIDY0MCwgMTA4MClcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cmF0ZS5oZWlnaHRdXG4gKiBwbGF5YmFjayBoZWlnaHQgKGV4OiAyNDAsIDQ4MCwgNzIwKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRyYXRlLmxldmVsXVxuICogcGxheWJhY2sgbGV2ZWwgd2hlbiBpdCdzIGF2YWlsYWJsZSwgaXQgY291bGQgYmUganVzdCBhIG1hcCBmb3Igd2lkdGggKDAgPT4gMjQwLCAxID0+IDQ4MCwgMiA9PiA3MjApXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfQklUUkFURSA9ICdjb250YWluZXI6Yml0cmF0ZSdcbkV2ZW50cy5DT05UQUlORVJfU1RBVFNfUkVQT1JUID0gJ2NvbnRhaW5lcjpzdGF0czpyZXBvcnQnXG5FdmVudHMuQ09OVEFJTkVSX0RFU1RST1lFRCA9ICdjb250YWluZXI6ZGVzdHJveWVkJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjb250YWluZXIgaXMgcmVhZHlcbiAqXG4gKiBAZXZlbnQgQ09OVEFJTkVSX1JFQURZXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfUkVBRFkgPSAnY29udGFpbmVyOnJlYWR5J1xuRXZlbnRzLkNPTlRBSU5FUl9FUlJPUiA9ICdjb250YWluZXI6ZXJyb3InXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGNvbnRhaW5lciBsb2FkZWQgaXRzIG1ldGFkYXRhXG4gKlxuICogQGV2ZW50IENPTlRBSU5FUl9MT0FERURNRVRBREFUQVxuICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIERhdGFcbiAqIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IFttZXRhZGF0YS5kdXJhdGlvbl1cbiAqIHRoZSBwbGF5YmFjayBkdXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFttZXRhZGF0YS5kYXRhXVxuICogZXh0cmEgbWV0YSBkYXRhXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfTE9BREVETUVUQURBVEEgPSAnY29udGFpbmVyOmxvYWRlZG1ldGFkYXRhJ1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gc3VidGl0bGUgaXMgYXZhaWxhYmxlIG9uIGNvbnRhaW5lciBmb3IgZGlzcGxheVxuICpcbiAqIEBldmVudCBDT05UQUlORVJfU1VCVElUTEVfQVZBSUxBQkxFXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfU1VCVElUTEVfQVZBSUxBQkxFID0gJ2NvbnRhaW5lcjpzdWJ0aXRsZTphdmFpbGFibGUnXG4vKipcbiAqIEZpcmVkIHdoZW4gc3VidGl0bGUgdHJhY2sgaGFzIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgQ09OVEFJTkVSX1NVQlRJVExFX0NIQU5HRURcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFjayBEYXRhXG4gKiB0cmFjayBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbdHJhY2suaWRdXG4gKiBzZWxlY3RlZCB0cmFjayBpZFxuICovXG5FdmVudHMuQ09OVEFJTkVSX1NVQlRJVExFX0NIQU5HRUQgPSAnY29udGFpbmVyOnN1YnRpdGxlOmNoYW5nZWQnXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIG9uIGNvbnRhaW5lclxuICpcbiAqIEBldmVudCBDT05UQUlORVJfVElNRVVQREFURVxuICogQHBhcmFtIHtPYmplY3R9IHByb2dyZXNzIERhdGFcbiAqIHByb2dyZXNzIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy5jdXJyZW50XVxuICogY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy50b3RhbF1cbiAqIHRvdGFsIHRpbWUgKGluIHNlY29uZHMpXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfVElNRVVQREFURSA9ICdjb250YWluZXI6dGltZXVwZGF0ZSdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY29udGFpbmVyIGlzIGRvd25sb2FkaW5nIHRoZSBtZWRpYVxuICpcbiAqIEBldmVudCBDT05UQUlORVJfUFJPR1JFU1NcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9ncmVzcyBEYXRhXG4gKiBwcm9ncmVzcyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJvZ3Jlc3Muc3RhcnRdXG4gKiBpbml0aWFsIGRvd25sb2FkZWQgY29udGVudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy5jdXJyZW50XVxuICogY3VycmVudCBkb3dsb2FkZWQgY29udGVudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy50b3RhbF1cbiAqIHRvdGFsIGNvbnRlbnQgdG8gYmUgZG93bmxvYWRlZFxuICovXG5FdmVudHMuQ09OVEFJTkVSX1BST0dSRVNTID0gJ2NvbnRhaW5lcjpwcm9ncmVzcydcbkV2ZW50cy5DT05UQUlORVJfUExBWSA9ICdjb250YWluZXI6cGxheSdcbkV2ZW50cy5DT05UQUlORVJfU1RPUCA9ICdjb250YWluZXI6c3RvcCdcbkV2ZW50cy5DT05UQUlORVJfUEFVU0UgPSAnY29udGFpbmVyOnBhdXNlJ1xuRXZlbnRzLkNPTlRBSU5FUl9FTkRFRCA9ICdjb250YWluZXI6ZW5kZWQnXG5FdmVudHMuQ09OVEFJTkVSX0NMSUNLID0gJ2NvbnRhaW5lcjpjbGljaydcbkV2ZW50cy5DT05UQUlORVJfREJMQ0xJQ0sgPSAnY29udGFpbmVyOmRibGNsaWNrJ1xuRXZlbnRzLkNPTlRBSU5FUl9DT05URVhUTUVOVSA9ICdjb250YWluZXI6Y29udGV4dG1lbnUnXG5FdmVudHMuQ09OVEFJTkVSX01PVVNFX0VOVEVSID0gJ2NvbnRhaW5lcjptb3VzZWVudGVyJ1xuRXZlbnRzLkNPTlRBSU5FUl9NT1VTRV9MRUFWRSA9ICdjb250YWluZXI6bW91c2VsZWF2ZSdcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY29udGFpbmVyIHNlZWtzIHRoZSB2aWRlb1xuICpcbiAqIEBldmVudCBDT05UQUlORVJfU0VFS1xuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfU0VFSyA9ICdjb250YWluZXI6c2Vlaydcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY29udGFpbmVyIHdhcyBmaW5pc2hlZCB0aGUgc2VlayB2aWRlb1xuICpcbiAqIEBldmVudCBDT05UQUlORVJfU0VFS0VEXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHNcbiAqL1xuRXZlbnRzLkNPTlRBSU5FUl9TRUVLRUQgPSAnY29udGFpbmVyOnNlZWtlZCdcbkV2ZW50cy5DT05UQUlORVJfVk9MVU1FID0gJ2NvbnRhaW5lcjp2b2x1bWUnXG5FdmVudHMuQ09OVEFJTkVSX0ZVTExTQ1JFRU4gPSAnY29udGFpbmVyOmZ1bGxzY3JlZW4nXG4vKipcbiAqIEZpcmVkIHdoZW4gY29udGFpbmVyIGlzIGJ1ZmZlcmluZ1xuICpcbiAqIEBldmVudCBDT05UQUlORVJfU1RBVEVfQlVGRkVSSU5HXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfU1RBVEVfQlVGRkVSSU5HID0gJ2NvbnRhaW5lcjpzdGF0ZTpidWZmZXJpbmcnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGNvbnRhaW5lciBmaWxsZWQgdGhlIGJ1ZmZlclxuICpcbiAqIEBldmVudCBDT05UQUlORVJfU1RBVEVfQlVGRkVSRlVMTFxuICovXG5FdmVudHMuQ09OVEFJTkVSX1NUQVRFX0JVRkZFUkZVTEwgPSAnY29udGFpbmVyOnN0YXRlOmJ1ZmZlcmZ1bGwnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGNvbnRhaW5lciBjaGFuZ2VzIGFueSBzZXR0aW5ncyAodm9sdW1lLCBzZWVrIGFuZCBldGMpXG4gKlxuICogQGV2ZW50IENPTlRBSU5FUl9TRVRUSU5HU1VQREFURVxuICovXG5FdmVudHMuQ09OVEFJTkVSX1NFVFRJTkdTVVBEQVRFID0gJ2NvbnRhaW5lcjpzZXR0aW5nc3VwZGF0ZSdcbi8qKlxuICogRmlyZWQgd2hlbiBjb250YWluZXIgdXBkYXRlcyBpdHMgdmlkZW8gcXVhbGl0eVxuICpcbiAqIEBldmVudCBDT05UQUlORVJfSElHSERFRklOSVRJT05VUERBVEVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNIRFxuICogdHJ1ZSB3aGVuIGlzIG9uIEhELCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuRXZlbnRzLkNPTlRBSU5FUl9ISUdIREVGSU5JVElPTlVQREFURSA9ICdjb250YWluZXI6aGlnaGRlZmluaXRpb251cGRhdGUnXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgY29udHJvbCBzaG93c1xuICpcbiAqIEBldmVudCBDT05UQUlORVJfTUVESUFDT05UUk9MX1NIT1dcbiAqL1xuRXZlbnRzLkNPTlRBSU5FUl9NRURJQUNPTlRST0xfU0hPVyA9ICdjb250YWluZXI6bWVkaWFjb250cm9sOnNob3cnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG1lZGlhIGNvbnRyb2wgaGlkZXNcbiAqXG4gKiBAZXZlbnQgQ09OVEFJTkVSX01FRElBQ09OVFJPTF9ISURFXG4gKi9cbkV2ZW50cy5DT05UQUlORVJfTUVESUFDT05UUk9MX0hJREUgPSAnY29udGFpbmVyOm1lZGlhY29udHJvbDpoaWRlJ1xuXG5FdmVudHMuQ09OVEFJTkVSX01FRElBQ09OVFJPTF9ESVNBQkxFID0gJ2NvbnRhaW5lcjptZWRpYWNvbnRyb2w6ZGlzYWJsZSdcbkV2ZW50cy5DT05UQUlORVJfTUVESUFDT05UUk9MX0VOQUJMRSA9ICdjb250YWluZXI6bWVkaWFjb250cm9sOmVuYWJsZSdcbkV2ZW50cy5DT05UQUlORVJfU1RBVFNfQUREID0gJ2NvbnRhaW5lcjpzdGF0czphZGQnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG9wdGlvbnMgd2VyZSBjaGFuZ2VkIGZvciB0aGUgY29udGFpbmVyXG4gKlxuICogQGV2ZW50IENPTlRBSU5FUl9PUFRJT05TX0NIQU5HRVxuICovXG5FdmVudHMuQ09OVEFJTkVSX09QVElPTlNfQ0hBTkdFID0gJ2NvbnRhaW5lcjpvcHRpb25zOmNoYW5nZSdcblxuLy8gTWVkaWFDb250cm9sIEV2ZW50c1xuRXZlbnRzLk1FRElBQ09OVFJPTF9SRU5ERVJFRCA9ICdtZWRpYWNvbnRyb2w6cmVuZGVyZWQnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBlbnRlcnMvZXhpdCBvbiBmdWxsc2NyZWVuXG4gKlxuICogQGV2ZW50IE1FRElBQ09OVFJPTF9GVUxMU0NSRUVOXG4gKi9cbkV2ZW50cy5NRURJQUNPTlRST0xfRlVMTFNDUkVFTiA9ICdtZWRpYWNvbnRyb2w6ZnVsbHNjcmVlbidcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgY29udHJvbCBzaG93c1xuICpcbiAqIEBldmVudCBNRURJQUNPTlRST0xfU0hPV1xuICovXG5FdmVudHMuTUVESUFDT05UUk9MX1NIT1cgPSAnbWVkaWFjb250cm9sOnNob3cnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG1lZGlhIGNvbnRyb2wgaGlkZXNcbiAqXG4gKiBAZXZlbnQgTUVESUFDT05UUk9MX0hJREVcbiAqL1xuRXZlbnRzLk1FRElBQ09OVFJPTF9ISURFID0gJ21lZGlhY29udHJvbDpoaWRlJ1xuLyoqXG4gKiBGaXJlZCB3aGVuIG1vdXNlIGVudGVycyBvbiB0aGUgc2Vla2JhclxuICpcbiAqIEBldmVudCBNRURJQUNPTlRST0xfTU9VU0VNT1ZFX1NFRUtCQVJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogdGhlIGphdmFzY3JpcHQgZXZlbnRcbiAqL1xuRXZlbnRzLk1FRElBQ09OVFJPTF9NT1VTRU1PVkVfU0VFS0JBUiA9ICdtZWRpYWNvbnRyb2w6bW91c2Vtb3ZlOnNlZWtiYXInXG4vKipcbiAqIEZpcmVkIHdoZW4gbW91c2UgbGVhdmVzIHRoZSBzZWVrYmFyXG4gKlxuICogQGV2ZW50IE1FRElBQ09OVFJPTF9NT1VTRUxFQVZFX1NFRUtCQVJcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogdGhlIGphdmFzY3JpcHQgZXZlbnRcbiAqL1xuRXZlbnRzLk1FRElBQ09OVFJPTF9NT1VTRUxFQVZFX1NFRUtCQVIgPSAnbWVkaWFjb250cm9sOm1vdXNlbGVhdmU6c2Vla2Jhcidcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgaXMgYmVpbmcgcGxheWVkXG4gKlxuICogQGV2ZW50IE1FRElBQ09OVFJPTF9QTEFZSU5HXG4gKi9cbkV2ZW50cy5NRURJQUNPTlRST0xfUExBWUlORyA9ICdtZWRpYWNvbnRyb2w6cGxheWluZydcbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgbWVkaWEgaXMgbm90IGJlaW5nIHBsYXllZFxuICpcbiAqIEBldmVudCBNRURJQUNPTlRST0xfTk9UUExBWUlOR1xuICovXG5FdmVudHMuTUVESUFDT05UUk9MX05PVFBMQVlJTkcgPSAnbWVkaWFjb250cm9sOm5vdHBsYXlpbmcnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGNvbnRhaW5lciB3YXMgY2hhbmdlZFxuICpcbiAqIEBldmVudCBNRURJQUNPTlRST0xfQ09OVEFJTkVSQ0hBTkdFRFxuICovXG5FdmVudHMuTUVESUFDT05UUk9MX0NPTlRBSU5FUkNIQU5HRUQgPSAnbWVkaWFjb250cm9sOmNvbnRhaW5lcmNoYW5nZWQnXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIG9wdGlvbnMgd2VyZSBjaGFuZ2VkIGZvciB0aGUgbWVkaWFjb250cm9sXG4gKlxuICogQGV2ZW50IE1FRElBQ09OVFJPTF9PUFRJT05TX0NIQU5HRVxuICovXG5FdmVudHMuTUVESUFDT05UUk9MX09QVElPTlNfQ0hBTkdFID0gJ21lZGlhY29udHJvbDpvcHRpb25zOmNoYW5nZSdcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3NtYWxsXG5leHBvcnQgY29uc3QgbXA0ID0gJ2RhdGE6dmlkZW8vbXA0O2Jhc2U2NCxBQUFBSEdaMGVYQnBjMjl0QUFBQ0FHbHpiMjFwYzI4eWJYQTBNUUFBQUFobWNtVmxBQUFDNzIxa1lYUWhFQVVncEJ2L3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBM3B3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQ0VRQlNDa0cvL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZW5nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0FBQUFzSnRiMjkyQUFBQWJHMTJhR1FBQUFBQUFBQUFBQUFBQUFBQUFBUG9BQUFBTHdBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQjdIUnlZV3NBQUFCY2RHdG9aQUFBQUFNQUFBQUFBQUFBQUFBQUFBSUFBQUFBQUFBQUx3QUFBQUFBQUFBQUFBQUFBUUVBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFDUmxaSFJ6QUFBQUhHVnNjM1FBQUFBQUFBQUFBUUFBQUM4QUFBQUFBQUVBQUFBQUFXUnRaR2xoQUFBQUlHMWthR1FBQUFBQUFBQUFBQUFBQUFBQUFLeEVBQUFJQUZYRUFBQUFBQUF0YUdSc2NnQUFBQUFBQUFBQWMyOTFiZ0FBQUFBQUFBQUFBQUFBQUZOdmRXNWtTR0Z1Wkd4bGNnQUFBQUVQYldsdVpnQUFBQkJ6Yldoa0FBQUFBQUFBQUFBQUFBQWtaR2x1WmdBQUFCeGtjbVZtQUFBQUFBQUFBQUVBQUFBTWRYSnNJQUFBQUFFQUFBRFRjM1JpYkFBQUFHZHpkSE5rQUFBQUFBQUFBQUVBQUFCWGJYQTBZUUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBZ0FRQUFBQUFLeEVBQUFBQUFBelpYTmtjd0FBQUFBRGdJQ0FJZ0FDQUFTQWdJQVVRQlVBQUFBQUFmUUFBQUh6K1FXQWdJQUNFaEFHZ0lDQUFRSUFBQUFZYzNSMGN3QUFBQUFBQUFBQkFBQUFBZ0FBQkFBQUFBQWNjM1J6WXdBQUFBQUFBQUFCQUFBQUFRQUFBQUlBQUFBQkFBQUFISE4wYzNvQUFBQUFBQUFBQUFBQUFBSUFBQUZ6QUFBQmRBQUFBQlJ6ZEdOdkFBQUFBQUFBQUFFQUFBQXNBQUFBWW5Wa2RHRUFBQUJhYldWMFlRQUFBQUFBQUFBaGFHUnNjZ0FBQUFBQUFBQUFiV1JwY21Gd2NHd0FBQUFBQUFBQUFBQUFBQUF0YVd4emRBQUFBQ1dwZEc5dkFBQUFIV1JoZEdFQUFBQUJBQUFBQUV4aGRtWTFOaTQwTUM0eE1ERT0nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbXA0OiBtcDQsXG59XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IFVJT2JqZWN0IGZyb20gJy4vdWlfb2JqZWN0J1xuaW1wb3J0IEVycm9yTWl4aW4gZnJvbSAnLi9lcnJvcl9taXhpbidcblxuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuXG4vKipcbiAqIEFuIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIGdlbmVyaWMgcGxheWJhY2ssIGl0J3MgbGlrZSBhbiBpbnRlcmZhY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlcy5cbiAqIEBjbGFzcyBQbGF5YmFja1xuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBVSU9iamVjdFxuICogQG1vZHVsZSBiYXNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXliYWNrIGV4dGVuZHMgVUlPYmplY3Qge1xuICAvKipcbiAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXliYWNrIGRvZXMgbm90IGNvbnRhaW4gdmlkZW8vaGFzIHZpZGVvIGJ1dCB2aWRlbyBzaG91bGQgYmUgaWdub3JlZC5cbiAgKiBAcHJvcGVydHkgaXNBdWRpb09ubHlcbiAgKiBAdHlwZSBCb29sZWFuXG4gICovXG4gIGdldCBpc0F1ZGlvT25seSgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldCBpc0FkYXB0aXZlKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgcGxheWJhY2sgaGFzIGVuZGVkLlxuICAgKiBAcHJvcGVydHkgZW5kZWRcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKi9cbiAgZ2V0IGVuZGVkKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBwbHVnaW4uXG4gICAqIEBwcm9wZXJ0eSBpMThuXG4gICAqIEB0eXBlIHtTdHJpbmdzfVxuICAgKi9cbiAgZ2V0IGkxOG4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kxOG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXliYWNrIGlzIGhhdmluZyB0byBidWZmZXIgaW4gb3JkZXIgZm9yXG4gICAqIHBsYXliYWNrIHRvIGJlIHNtb290aC5cbiAgICogKGkuZSBpZiBhIGxpdmUgc3RyZWFtIGlzIHBsYXlpbmcgc21vb3RobHksIHRoaXMgd2lsbCBiZSBmYWxzZSlcbiAgICogQHByb3BlcnR5IGJ1ZmZlcmluZ1xuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgYnVmZmVyaW5nKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgcGxheWJhY2sgaGFzIHVzZXIgY29uc2VudC5cbiAgICogQHByb3BlcnR5IGNvbnNlbnRlZFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgY29uc2VudGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zZW50ZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ3N9IGkxOG4gdGhlIGludGVybmF0aW9uYWxpemF0aW9uIGNvbXBvbmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaTE4biwgcGxheWVyRXJyb3IpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMuc2V0dGluZ3MgPSB7fVxuICAgIHRoaXMuX2kxOG4gPSBpMThuXG4gICAgdGhpcy5wbGF5ZXJFcnJvciA9IHBsYXllckVycm9yXG4gICAgdGhpcy5fY29uc2VudGVkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlcyB1c2VyIGNvbnNlbnQgdG8gcGxheWJhY2sgKG1vYmlsZSBkZXZpY2VzKS5cbiAgICogQG1ldGhvZCBjb25zZW50XG4gICAqL1xuICBjb25zZW50KCkge1xuICAgIHRoaXMuX2NvbnNlbnRlZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBwbGF5cyB0aGUgcGxheWJhY2suXG4gICAqIEBtZXRob2QgcGxheVxuICAgKi9cbiAgcGxheSgpIHt9XG5cbiAgLyoqXG4gICAqIHBhdXNlcyB0aGUgcGxheWJhY2suXG4gICAqIEBtZXRob2QgcGF1c2VcbiAgICovXG4gIHBhdXNlKCkge31cblxuICAvKipcbiAgICogc3RvcHMgdGhlIHBsYXliYWNrLlxuICAgKiBAbWV0aG9kIHN0b3BcbiAgICovXG4gIHN0b3AoKSB7fVxuXG4gIC8qKlxuICAgKiBzZWVrcyB0aGUgcGxheWJhY2sgdG8gYSBnaXZlbiBgdGltZWAgaW4gc2Vjb25kc1xuICAgKiBAbWV0aG9kIHNlZWtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgdGhlIHZpZGVvIGR1cmF0aW9uXG4gICAqL1xuICBzZWVrKHRpbWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogc2Vla3MgdGhlIHBsYXliYWNrIHRvIGEgZ2l2ZW4gYHBlcmNlbnRhZ2VgIGluIHBlcmNlbnRhZ2VcbiAgICogQG1ldGhvZCBzZWVrUGVyY2VudGFnZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDBcbiAgICovXG4gIHNlZWtQZXJjZW50YWdlKHBlcmNlbnRhZ2UpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcbiAgICogVGhlIHRpbWUgdGhhdCBcIjBcIiBub3cgcmVwcmVzZW50cyByZWxhdGl2ZSB0byB3aGVuIHBsYXliYWNrIHN0YXJ0ZWQuXG4gICAqIEZvciBhIHN0cmVhbSB3aXRoIGEgc2xpZGluZyB3aW5kb3cgdGhpcyB3aWxsIGluY3JlYXNlIGFzIGNvbnRlbnQgaXNcbiAgICogcmVtb3ZlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAqIEBtZXRob2QgZ2V0U3RhcnRUaW1lT2Zmc2V0XG4gICAqIEByZXR1cm4ge051bWJlcn0gdGltZSAoaW4gc2Vjb25kcykgdGhhdCB0aW1lIFwiMFwiIHJlcHJlc2VudHMuXG4gICAqL1xuICBnZXRTdGFydFRpbWVPZmZzZXQoKSB7IHJldHVybiAwIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAbWV0aG9kIGdldER1cmF0aW9uXG4gICAqIEByZXR1cm4ge051bWJlcn0gZHVyYXRpb24gKGluIHNlY29uZHMpIG9mIHRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cbiAgZ2V0RHVyYXRpb24oKSB7IHJldHVybiAwIH1cblxuICAvKipcbiAgICogY2hlY2tzIGlmIHRoZSBwbGF5YmFjayBpcyBwbGF5aW5nLlxuICAgKiBAbWV0aG9kIGlzUGxheWluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgcGxheWJhY2sgaXMgcGxheWluZywgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdGhlIHBsYXliYWNrIGlzIHJlYWR5LlxuICAgKiBAcHJvcGVydHkgaXNSZWFkeVxuICAgKiBAdHlwZSB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBjdXJyZW50IHBsYXliYWNrIGlzIHJlYWR5LCBvdGhlcndpc2UgYGZhbHNlYFxuICAgKi9cbiAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogY2hlY2tzIGlmIHRoZSBwbGF5YmFjayBoYXMgY2xvc2VkIGNhcHRpb24gdHJhY2tzLlxuICAgKiBAcHJvcGVydHkgaGFzQ2xvc2VkQ2FwdGlvbnNUcmFja3NcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaGFzQ2xvc2VkQ2FwdGlvbnNUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkQ2FwdGlvbnNUcmFja3MubGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHBsYXliYWNrIGF2YWlsYWJsZSBjbG9zZWQgY2FwdGlvbiB0cmFja3MuXG4gICAqIEBwcm9wZXJ0eSBjbG9zZWRDYXB0aW9uc1RyYWNrc1xuICAgKiBAdHlwZSB7QXJyYXl9IGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhdCBsZWFzdCAnaWQnIGFuZCAnbmFtZScgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IGNsb3NlZENhcHRpb25zVHJhY2tzKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHNlbGVjdGVkIGNsb3NlZCBjYXB0aW9uIHRyYWNrIGluZGV4LiAoLTEgaXMgZGlzYWJsZWQpXG4gICAqIEBwcm9wZXJ0eSBjbG9zZWRDYXB0aW9uc1RyYWNrSWRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjbG9zZWRDYXB0aW9uc1RyYWNrSWQoKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgc2VsZWN0ZWQgY2xvc2VkIGNhcHRpb24gdHJhY2sgaW5kZXguICgtMSBpcyBkaXNhYmxlZClcbiAgICogQHByb3BlcnR5IGNsb3NlZENhcHRpb25zVHJhY2tJZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IGNsb3NlZENhcHRpb25zVHJhY2tJZCh0cmFja0lkKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHBsYXliYWNrIHR5cGUgKGAndm9kJywgJ2xpdmUnLCAnYW9kJ2ApXG4gICAqIEBtZXRob2QgZ2V0UGxheWJhY2tUeXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30geW91IHNob3VsZCB3cml0ZSB0aGUgcGxheWJhY2sgdHlwZSBvdGhlcndpc2UgaXQnbGwgYXNzdW1lIGAnbm9fb3AnYFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGh0bWw1VmlkZW9QbGF5YmFjay5nZXRQbGF5YmFja1R5cGUoKSAvL3ZvZFxuICAgKiBodG1sNUF1ZGlvUGxheWJhY2suZ2V0UGxheWJhY2tUeXBlKCkgLy9hb2RcbiAgICogaHRtbDVWaWRlb1BsYXliYWNrLmdldFBsYXliYWNrVHlwZSgpIC8vbGl2ZVxuICAgKiBmbGFzaEhsc1BsYXliYWNrLmdldFBsYXliYWNrVHlwZSgpIC8vbGl2ZVxuICAgKiBgYGBcbiAgICovXG4gIGdldFBsYXliYWNrVHlwZSgpIHtcbiAgICByZXR1cm4gUGxheWJhY2suTk9fT1BcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdGhlIHBsYXliYWNrIGlzIGluIEhELlxuICAgKiBAbWV0aG9kIGlzSGlnaERlZmluaXRpb25JblVzZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHBsYXliYWNrIGlzIHBsYXlpbmcgaW4gSEQsIG90aGVyd2lzZSBgZmFsc2VgXG4gICAqL1xuICBpc0hpZ2hEZWZpbml0aW9uSW5Vc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIGZvciB0aGUgcGxheWJhY2tcbiAgICogQG1ldGhvZCB2b2x1bWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIGEgbnVtYmVyIGJldHdlZW4gMCAoYG11dGVkYCkgdG8gMTAwIChgbWF4YClcbiAgICovXG4gIHZvbHVtZSh2YWx1ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuICAgKiBlbmFibGVzIHRvIGNvbmZpZ3VyZSB0aGUgcGxheWJhY2sgYWZ0ZXIgaXRzIGNyZWF0aW9uXG4gICAqIEBtZXRob2QgY29uZmlndXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFsbCB0aGUgb3B0aW9ucyB0byBjaGFuZ2UgaW4gZm9ybSBvZiBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh0aGlzLl9vcHRpb25zLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIGF0dGVtcHQgdG8gYXV0b3BsYXlzIHRoZSBwbGF5YmFjay5cbiAgICogQG1ldGhvZCBhdHRlbXB0QXV0b1BsYXlcbiAgICovXG4gIGF0dGVtcHRBdXRvUGxheSgpIHtcbiAgICB0aGlzLmNhbkF1dG9QbGF5KChyZXN1bHQsIGVycm9yKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJlc3VsdCAmJiB0aGlzLnBsYXkoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogY2hlY2tzIGlmIHRoZSBwbGF5YmFjayBjYW4gYXV0b3BsYXkuXG4gICAqIEBtZXRob2QgY2FuQXV0b1BsYXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gd2hlcmUgZmlyc3QgcGFyYW0gaXMgQm9vbGVhbiBhbmQgc2Vjb25kIHBhcmFtIGlzIHBsYXliYWNrIEVycm9yIG9yIG51bGxcbiAgICovXG4gIGNhbkF1dG9QbGF5KGNiKSB7XG4gICAgY2IodHJ1ZSwgbnVsbCkgLy8gQXNzdW1lIHBsYXliYWNrIGNhbiBhdXRvcGxheSBieSBkZWZhdWx0XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihQbGF5YmFjay5wcm90b3R5cGUsIEVycm9yTWl4aW4pXG5cblBsYXliYWNrLmV4dGVuZCA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIGV4dGVuZChQbGF5YmFjaywgcHJvcGVydGllcylcbn1cblxuLyoqXG4gKiBjaGVja3MgaWYgdGhlIHBsYXliYWNrIGNhbiBwbGF5IGEgZ2l2ZW4gYHNvdXJjZWBcbiAqIElmIGEgbWltZVR5cGUgaXMgcHJvdmlkZWQgdGhlbiB0aGlzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIGluZmVycmluZyB0aGUgbWltZXR5cGVcbiAqIGZyb20gdGhlIHNvdXJjZSBleHRlbnNpb24uXG4gKiBAbWV0aG9kIGNhblBsYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgdGhlIGdpdmVuIHNvdXJjZSBleDogYGh0dHA6Ly9leGFtcGxlLmNvbS9wbGF5Lm1wNGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGVdIHRoZSBnaXZlbiBtaW1lIHR5cGUsIGV4OiBgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJ2BcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcGxheWJhY2sgaXMgcGxheWFibGUsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblBsYXliYWNrLmNhblBsYXkgPSAoc291cmNlLCBtaW1lVHlwZSkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIGEgcGxheWJhY2sgdHlwZSBmb3IgdmlkZW8gb24gZGVtYW5kXG4gKlxuICogQHByb3BlcnR5IFZPRFxuICogQHN0YXRpY1xuICogQHR5cGUgU3RyaW5nXG4gKi9cblBsYXliYWNrLlZPRCA9ICd2b2QnXG4vKipcbiAqIGEgcGxheWJhY2sgdHlwZSBmb3IgYXVkaW8gb24gZGVtYW5kXG4gKlxuICogQHByb3BlcnR5IEFPRFxuICogQHN0YXRpY1xuICogQHR5cGUgU3RyaW5nXG4gKi9cblBsYXliYWNrLkFPRCA9ICdhb2QnXG4vKipcbiAqIGEgcGxheWJhY2sgdHlwZSBmb3IgbGl2ZSB2aWRlb1xuICpcbiAqIEBwcm9wZXJ0eSBMSVZFXG4gKiBAc3RhdGljXG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuUGxheWJhY2suTElWRSA9ICdsaXZlJ1xuLyoqXG4gKiBhIGRlZmF1bHQgcGxheWJhY2sgdHlwZVxuICpcbiAqIEBwcm9wZXJ0eSBOT19PUFxuICogQHN0YXRpY1xuICogQHR5cGUgU3RyaW5nXG4gKi9cblBsYXliYWNrLk5PX09QID0gJ25vX29wJ1xuLyoqXG4gKiB0aGUgcGx1Z2luIHR5cGVcbiAqXG4gKiBAcHJvcGVydHkgdHlwZVxuICogQHN0YXRpY1xuICogQHR5cGUgU3RyaW5nXG4gKi9cblBsYXliYWNrLnR5cGUgPSAncGxheWJhY2snXG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG4vKipcbiAqIEFycmF5LnByb3RvdHlwZS5maW5kXG4gKlxuICogT3JpZ2luYWwgc291cmNlIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZFxuICogU2VlIGFsc28gOiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmluZCcsIHtcbiAgICAvLyBOb3RlOiBFUzYgYXJyb3cgZnVuY3Rpb24gc3ludGF4IGlzIG5vdCB1c2VkIG9uIHB1cnBvc2UgdG8gYXZvaWQgdGhpcyB0byBiZSB1bmRlZmluZWRcbiAgICB2YWx1ZTogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAvLyAxLiBMZXQgTyBiZSA/IFRvT2JqZWN0KHRoaXMgdmFsdWUpLlxuICAgICAgaWYgKHRoaXMgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpXG5cblxuICAgICAgbGV0IG8gPSBPYmplY3QodGhpcylcblxuICAgICAgLy8gMi4gTGV0IGxlbiBiZSA/IFRvTGVuZ3RoKD8gR2V0KE8sIFwibGVuZ3RoXCIpKS5cbiAgICAgIGxldCBsZW4gPSBvLmxlbmd0aCA+Pj4gMFxuXG4gICAgICAvLyAzLiBJZiBJc0NhbGxhYmxlKHByZWRpY2F0ZSkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJylcblxuXG4gICAgICAvLyA0LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgICBsZXQgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXVxuXG4gICAgICAvLyA1LiBMZXQgayBiZSAwLlxuICAgICAgbGV0IGsgPSAwXG5cbiAgICAgIC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgLy8gYS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXG4gICAgICAgIC8vIGIuIExldCBrVmFsdWUgYmUgPyBHZXQoTywgUGspLlxuICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXG4gICAgICAgIC8vIGQuIElmIHRlc3RSZXN1bHQgaXMgdHJ1ZSwgcmV0dXJuIGtWYWx1ZS5cbiAgICAgICAgbGV0IGtWYWx1ZSA9IG9ba11cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpXG4gICAgICAgICAgcmV0dXJuIGtWYWx1ZVxuXG4gICAgICAgIC8vIGUuIEluY3JlYXNlIGsgYnkgMS5cbiAgICAgICAgaysrXG4gICAgICB9XG5cbiAgICAgIC8vIDcuIFJldHVybiB1bmRlZmluZWQuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9KVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vdGVtcGxhdGUnXG5cbmNvbnN0IFN0eWxlciA9IHtcbiAgZ2V0U3R5bGVGb3I6IGZ1bmN0aW9uKHN0eWxlLCBvcHRpb25zPXsgYmFzZVVybDogJycgfSkge1xuICAgIHJldHVybiAkKCc8c3R5bGUgY2xhc3M9XCJjbGFwcHItc3R5bGVcIj48L3N0eWxlPicpLmh0bWwodGVtcGxhdGUoc3R5bGUudG9TdHJpbmcoKSkob3B0aW9ucykpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3R5bGVyXG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgcGxheUljb24gZnJvbSAnLi4vaWNvbnMvMDEtcGxheS5zdmcnXG5pbXBvcnQgcGF1c2VJY29uIGZyb20gJy4uL2ljb25zLzAyLXBhdXNlLnN2ZydcbmltcG9ydCBzdG9wSWNvbiBmcm9tICcuLi9pY29ucy8wMy1zdG9wLnN2ZydcbmltcG9ydCB2b2x1bWVJY29uIGZyb20gJy4uL2ljb25zLzA0LXZvbHVtZS5zdmcnXG5pbXBvcnQgdm9sdW1lTXV0ZUljb24gZnJvbSAnLi4vaWNvbnMvMDUtbXV0ZS5zdmcnXG5pbXBvcnQgZnVsbHNjcmVlbkljb24gZnJvbSAnLi4vaWNvbnMvMDYtZXhwYW5kLnN2ZydcbmltcG9ydCBleGl0RnVsbHNjcmVlbkljb24gZnJvbSAnLi4vaWNvbnMvMDctc2hyaW5rLnN2ZydcbmltcG9ydCBoZEljb24gZnJvbSAnLi4vaWNvbnMvMDgtaGQuc3ZnJ1xuaW1wb3J0IGNjSWNvbiBmcm9tICcuLi9pY29ucy8wOS1jYy5zdmcnXG5pbXBvcnQgcmVsb2FkSWNvbiBmcm9tICcuLi9pY29ucy8xMC1yZWxvYWQuc3ZnJ1xuXG5leHBvcnQgbGV0IGNjID0gY2NJY29uXG5leHBvcnQgbGV0IGV4aXRGdWxsc2NyZWVuID0gZXhpdEZ1bGxzY3JlZW5JY29uXG5leHBvcnQgbGV0IGZ1bGxzY3JlZW4gPSBmdWxsc2NyZWVuSWNvblxuZXhwb3J0IGxldCBoZCA9IGhkSWNvblxuZXhwb3J0IGxldCBwYXVzZSA9IHBhdXNlSWNvblxuZXhwb3J0IGxldCBwbGF5ID0gcGxheUljb25cbmV4cG9ydCBsZXQgcmVsb2FkID0gcmVsb2FkSWNvblxuZXhwb3J0IGxldCBzdG9wID0gc3RvcEljb25cbmV4cG9ydCBsZXQgdm9sdW1lID0gdm9sdW1lSWNvblxuZXhwb3J0IGxldCB2b2x1bWVNdXRlID0gdm9sdW1lTXV0ZUljb25cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjYzogY2NJY29uLFxuICBleGl0RnVsbHNjcmVlbjogZXhpdEZ1bGxzY3JlZW5JY29uLFxuICBmdWxsc2NyZWVuOiBmdWxsc2NyZWVuSWNvbixcbiAgaGQ6IGhkSWNvbixcbiAgcGF1c2U6IHBhdXNlSWNvbixcbiAgcGxheTogcGxheUljb24sXG4gIHJlbG9hZDogcmVsb2FkSWNvbixcbiAgc3RvcDogc3RvcEljb24sXG4gIHZvbHVtZTogdm9sdW1lSWNvbixcbiAgdm9sdW1lTXV0ZTogdm9sdW1lTXV0ZUljb24sXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbi8vIFNpbXBsZSBKYXZhU2NyaXB0IFRlbXBsYXRpbmdcbi8vIFBhdWwgTWlsbGVyIChodHRwOi8vcGF1bG1pbGxyLmNvbSlcbi8vIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAoYykgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG5cbi8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxudmFyIHNldHRpbmdzID0ge1xuICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbn1cblxuLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG52YXIgbm9NYXRjaCA9IC8oLileL1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgZXNjYXBlcyA9IHtcbiAgJ1xcJyc6ICAgICAgJ1xcJycsXG4gICdcXFxcJzogICAgICdcXFxcJyxcbiAgJ1xccic6ICAgICAncicsXG4gICdcXG4nOiAgICAgJ24nLFxuICAnXFx0JzogICAgICd0JyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn1cblxudmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nXG5cbi8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG52YXIgaHRtbEVudGl0aWVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gICdcXCcnOiAnJiN4Mjc7J1xufVxuXG52YXIgZW50aXR5UmUgPSBuZXcgUmVnRXhwKCdbJjw+XCJcXCddJywgJ2cnKVxuXG52YXIgZXNjYXBlRXhwciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAoc3RyaW5nID09PSBudWxsKSByZXR1cm4gJydcbiAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gaHRtbEVudGl0aWVzW21hdGNoXVxuICB9KVxufVxuXG52YXIgY291bnRlciA9IDBcblxuLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbi8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbi8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxudmFyIHRtcGwgPSBmdW5jdGlvbih0ZXh0LCBkYXRhKSB7XG4gIHZhciByZW5kZXJcblxuICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFtcbiAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpXG5cbiAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgc291cmNlID0gJ19fcCs9XFwnJ1xuICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdIH0pXG5cbiAgICBpZiAoZXNjYXBlKVxuICAgICAgc291cmNlICs9ICdcXCcrXFxuKChfX3Q9KCcgKyBlc2NhcGUgKyAnKSk9PW51bGw/XFwnXFwnOmVzY2FwZUV4cHIoX190KSkrXFxuXFwnJ1xuXG4gICAgaWYgKGludGVycG9sYXRlKVxuICAgICAgc291cmNlICs9ICdcXCcrXFxuKChfX3Q9KCcgKyBpbnRlcnBvbGF0ZSArICcpKT09bnVsbD9cXCdcXCc6X190KStcXG5cXCcnXG5cbiAgICBpZiAoZXZhbHVhdGUpXG4gICAgICBzb3VyY2UgKz0gJ1xcJztcXG4nICsgZXZhbHVhdGUgKyAnXFxuX19wKz1cXCcnXG5cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aFxuICAgIHJldHVybiBtYXRjaFxuICB9KVxuICBzb3VyY2UgKz0gJ1xcJztcXG4nXG5cbiAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJ1xuXG4gIHNvdXJjZSA9ICd2YXIgX190LF9fcD1cXCdcXCcsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLCcgK1xuICAgICdwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLFxcJ1xcJyk7fTtcXG4nICtcbiAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4vLyMgc291cmNlVVJMPS9taWNyb3RlbXBsYXRlcy9zb3VyY2VbJyArIGNvdW50ZXIrKyArICddJ1xuXG4gIHRyeSB7XG4gICAgLypqc2hpbnQgLVcwNTQgKi9cbiAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIGV2YWxcbiAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdlc2NhcGVFeHByJywgc291cmNlKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZS5zb3VyY2UgPSBzb3VyY2VcbiAgICB0aHJvdyBlXG4gIH1cblxuICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBlc2NhcGVFeHByKVxuICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIGVzY2FwZUV4cHIpXG4gIH1cblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbiBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSdcblxuICByZXR1cm4gdGVtcGxhdGVcbn1cbnRtcGwuc2V0dGluZ3MgPSBzZXR0aW5nc1xuXG5leHBvcnQgZGVmYXVsdCB0bXBsXG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IFVJT2JqZWN0IGZyb20gJy4vdWlfb2JqZWN0J1xuaW1wb3J0IEVycm9yTWl4aW4gZnJvbSAnLi9lcnJvcl9taXhpbidcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYW4gdWkgY29udGFpbmVyIHBsdWdpblxuICogQGNsYXNzIFVJQ29udGFpbmVyUGx1Z2luXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFVJT2JqZWN0XG4gKiBAbW9kdWxlIGJhc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlDb250YWluZXJQbHVnaW4gZXh0ZW5kcyBVSU9iamVjdCB7XG4gIGdldCBwbGF5ZXJFcnJvcigpIHsgcmV0dXJuIHRoaXMuY29udGFpbmVyLnBsYXllckVycm9yIH1cblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICBzdXBlcihjb250YWluZXIub3B0aW9ucylcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICB0aGlzLmJpbmRFdmVudHMoKVxuICB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgICAgdGhpcy4kZWwuc2hvdygpXG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuJGVsLmhpZGUoKVxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICBiaW5kRXZlbnRzKCkge31cblxufVxuXG5PYmplY3QuYXNzaWduKFVJQ29udGFpbmVyUGx1Z2luLnByb3RvdHlwZSwgRXJyb3JNaXhpbilcblxuVUlDb250YWluZXJQbHVnaW4uZXh0ZW5kID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICByZXR1cm4gZXh0ZW5kKFVJQ29udGFpbmVyUGx1Z2luLCBwcm9wZXJ0aWVzKVxufVxuXG5VSUNvbnRhaW5lclBsdWdpbi50eXBlID0gJ2NvbnRhaW5lcidcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgVUlPYmplY3QgZnJvbSAnLi91aV9vYmplY3QnXG5pbXBvcnQgRXJyb3JNaXhpbiBmcm9tICcuL2Vycm9yX21peGluJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSUNvcmVQbHVnaW4gZXh0ZW5kcyBVSU9iamVjdCB7XG4gIGdldCBwbGF5ZXJFcnJvcigpIHsgcmV0dXJuIHRoaXMuY29yZS5wbGF5ZXJFcnJvciB9XG5cbiAgY29uc3RydWN0b3IoY29yZSkge1xuICAgIHN1cGVyKGNvcmUub3B0aW9ucylcbiAgICB0aGlzLmNvcmUgPSBjb3JlXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbiAgYmluZEV2ZW50cygpIHt9XG5cbiAgZ2V0RXh0ZXJuYWxJbnRlcmZhY2UoKSB7IHJldHVybiB7fSB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKVxuICAgICAgdGhpcy4kZWwuc2hvdygpXG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuJGVsLmhpZGUoKVxuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFVJQ29yZVBsdWdpbi5wcm90b3R5cGUsIEVycm9yTWl4aW4pXG5cblVJQ29yZVBsdWdpbi5leHRlbmQgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBleHRlbmQoVUlDb3JlUGx1Z2luLCBwcm9wZXJ0aWVzKVxufVxuXG5VSUNvcmVQbHVnaW4udHlwZSA9ICdjb3JlJ1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuaW1wb3J0IHsgdW5pcXVlSWQsIERvbVJlY3ljbGVyIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vYmFzZV9vYmplY3QnXG5cbmNvbnN0IGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkL1xuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyB0byBjcmVhdGUgdWkgb2JqZWN0LlxuICogQGNsYXNzIFVJT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJhc2VPYmplY3RcbiAqIEBtb2R1bGUgYmFzZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSU9iamVjdCBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAvKipcbiAgICogYSB1bmlxdWUgaWQgcHJlZml4ZWQgd2l0aCBgJ2MnYCwgYGMxLCBjMjMyYFxuICAgKlxuICAgKiBAcHJvcGVydHkgY2lkXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cbiAgLyoqXG4gICAqIHRoZSBkb20gZWxlbWVudCBpdHNlbGZcbiAgICpcbiAgICogQHByb3BlcnR5IGVsXG4gICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAqL1xuICAvKipcbiAgICogdGhlIGRvbSBlbGVtZW50IHdyYXBwZWQgYnkgYCRgXG4gICAqXG4gICAqIEBwcm9wZXJ0eSAkZWxcbiAgICogQHR5cGUgSFRNTEVsZW1lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldHMgdGhlIHRhZyBuYW1lIGZvciB0aGUgdWkgY29tcG9uZW50XG4gICAqIEBtZXRob2QgdGFnTmFtZVxuICAgKiBAZGVmYXVsdCBkaXZcbiAgICogQHJldHVybiB7U3RyaW5nfSB0YWcncyBuYW1lXG4gICAqL1xuICBnZXQgdGFnTmFtZSgpIHsgcmV0dXJuICdkaXYnIH1cbiAgLyoqXG4gICAqIGEgbGl0ZXJhbCBvYmplY3QgbWFwcGluZyBlbGVtZW50J3MgZXZlbnRzIHRvIG1ldGhvZHNcbiAgICogQHByb3BlcnR5IGV2ZW50c1xuICAgKiBAdHlwZSBPYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICpgYGBqYXZhc2NyaXB0XG4gICAqXG4gICAqIGNsYXNzIE15QnV0dG9uIGV4dGVuZHMgVUlPYmplY3Qge1xuICAgKiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICogICAgIHN1cGVyKG9wdGlvbnMpXG4gICAqICAgICB0aGlzLm15SWQgPSAwXG4gICAqICAgfVxuICAgKiAgIGdldCBldmVudHMoKSB7IHJldHVybiB7ICdjbGljayc6ICdteUNsaWNrJyB9IH1cbiAgICogICBteUNsaWNrKCl7IHRoaXMubXlJZCA9IDQyIH1cbiAgICogfVxuICAgKlxuICAgKiAvLyB3aGVuIHlvdSBjbGljayBvbiBNeUJ1dHRvbiB0aGUgbWV0aG9kIGBteUNsaWNrYCB3aWxsIGJlIGNhbGxlZFxuICAgKmBgYFxuICAgKi9cbiAgZ2V0IGV2ZW50cygpIHsgcmV0dXJuIHt9IH1cbiAgLyoqXG4gICAqIGEgbGl0ZXJhbCBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGVzIGFuZCB2YWx1ZXMgdG8gdGhlIGVsZW1lbnRcbiAgICogZWxlbWVudCdzIGF0dHJpYnV0ZSBuYW1lIGFuZCB0aGUgdmFsdWUgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAcHJvcGVydHkgYXR0cmlidXRlc1xuICAgKiBAdHlwZSBPYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICpgYGBqYXZhc2NyaXB0XG4gICAqXG4gICAqIGNsYXNzIE15QnV0dG9uIGV4dGVuZHMgVUlPYmplY3Qge1xuICAgKiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7IHN1cGVyKG9wdGlvbnMpIH1cbiAgICogICAgZ2V0IGF0dHJpYnV0ZXMoKSB7IHJldHVybiB7IGNsYXNzOiAnbXktYnV0dG9uJ30gfVxuICAgKiB9XG4gICAqXG4gICAqIC8vIE15QnV0dG9uLmVsLmNsYXNzTmFtZSB3aWxsIGJlICdteS1idXR0b24nXG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7IHJldHVybiB7fSB9XG5cbiAgLyoqXG4gICAqIGl0IGJ1aWxkcyBhbiB1aSBjb21wb25lbnQgYnk6XG4gICAqICAqIGNyZWF0aW5nIGFuIGlkIGZvciB0aGUgY29tcG9uZW50IGBjaWRgXG4gICAqICAqIG1ha2luZyBzdXJlIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQgYCRlbGBcbiAgICogICogZGVsZWdhdGluZyBhbGwgYGV2ZW50c2AgdG8gdGhlIGVsZW1lbnRcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMuY2lkID0gdW5pcXVlSWQoJ2MnKVxuICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnQoKVxuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdHMgd2l0aGluIHRoZSBjb21wb25lbnQuXG4gICAqIEBtZXRob2QgJFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgYSBzZWxlY3RvciB0byBmaW5kIHdpdGhpbiB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gYW4gZWxlbWVudCwgaWYgaXQgZXhpc3RzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bGxTY3JlZW5CYXJVSUNvbXBvbmVudC4kKCcuYnV0dG9uLWZ1bGwnKSAvL3dpbGwgcmV0dXJuIG9ubHkgYC5idXR0b24tZnVsbGAgd2l0aGluIHRoZSBjb21wb25lbnRcbiAgICogYGBgXG4gICAqL1xuICAkKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpXG4gIH1cblxuICAvKipcbiAgICogcmVuZGVyIHRoZSBjb21wb25lbnQsIHVzdWFsbHkgYXR0YWNoIGl0IHRvIGEgcmVhbCBleGlzdGVudCBgZWxlbWVudGBcbiAgICogQG1ldGhvZCByZW5kZXJcbiAgICogQHJldHVybiB7VUlPYmplY3R9IGl0c2VsZlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlcyB0aGUgdWkgY29tcG9uZW50IGZyb20gRE9NXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKiBAcmV0dXJuIHtVSU9iamVjdH0gaXRzZWxmXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZSgpXG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogc2V0IGVsZW1lbnQgdG8gYGVsYCBhbmQgYCRlbGBcbiAgICogQG1ldGhvZCBzZXRFbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWxlZ2F0ZSB3aGV0aGVyIGlzIGRlbGVnYXRlIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtVSU9iamVjdH0gaXRzZWxmXG4gICAqL1xuICBzZXRFbGVtZW50KGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgaWYgKHRoaXMuJGVsKSB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKVxuICAgIHRoaXMuJGVsID0gJC56ZXB0by5pc1ooZWxlbWVudCkgPyBlbGVtZW50IDogJChlbGVtZW50KVxuICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXVxuICAgIGlmIChkZWxlZ2F0ZSAhPT0gZmFsc2UpIHRoaXMuZGVsZWdhdGVFdmVudHMoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogZGVsZWdhdGVzIGFsbCB0aGUgb3JpZ2luYWwgYGV2ZW50c2Agb24gYGVsZW1lbnRgIHRvIGl0cyBjYWxsYmFja3NcbiAgICogQG1ldGhvZCBkZWxlZ2F0ZUV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzXG4gICAqIEByZXR1cm4ge1VJT2JqZWN0fSBpdHNlbGZcbiAgICovXG4gIGRlbGVnYXRlRXZlbnRzKGV2ZW50cykge1xuICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gdGhpcy5ldmVudHMpKSkgcmV0dXJuIHRoaXNcbiAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKVxuICAgIGZvciAoY29uc3Qga2V5IGluIGV2ZW50cykge1xuICAgICAgbGV0IG1ldGhvZCA9IGV2ZW50c1trZXldXG4gICAgICBpZiAoKG1ldGhvZCAmJiBtZXRob2QuY29uc3RydWN0b3IgIT09IEZ1bmN0aW9uKSkgbWV0aG9kID0gdGhpc1tldmVudHNba2V5XV1cbiAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZVxuXG4gICAgICBjb25zdCBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpXG4gICAgICBsZXQgZXZlbnROYW1lID0gbWF0Y2hbMV0sIHNlbGVjdG9yID0gbWF0Y2hbMl1cbiAgICAgIGV2ZW50TmFtZSArPSAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkXG4gICAgICBpZiAoc2VsZWN0b3IgPT09ICcnKVxuICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZC5iaW5kKHRoaXMpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIHNlbGVjdG9yLCBtZXRob2QuYmluZCh0aGlzKSlcblxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIHVuZGVsZWdhdHMgYWxsIHRoZSBgZXZlbnRzYFxuICAgKiBAbWV0aG9kIHVuZGVsZWdhdGVFdmVudHNcbiAgICogQHJldHVybiB7VUlPYmplY3R9IGl0c2VsZlxuICAgKi9cbiAgdW5kZWxlZ2F0ZUV2ZW50cygpIHtcbiAgICB0aGlzLiRlbC5vZmYoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIGVuc3VyZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdWkgY29tcG9uZW50XG4gICAqIEBtZXRob2QgX2Vuc3VyZUVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9lbnN1cmVFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgY29uc3QgYXR0cnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzKVxuICAgICAgaWYgKHRoaXMuaWQpIGF0dHJzLmlkID0gdGhpcy5pZFxuICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IHRoaXMuY2xhc3NOYW1lXG4gICAgICBjb25zdCAkZWwgPSBEb21SZWN5Y2xlci5jcmVhdGUodGhpcy50YWdOYW1lKS5hdHRyKGF0dHJzKVxuICAgICAgdGhpcy5zZXRFbGVtZW50KCRlbCwgZmFsc2UpXG4gICAgfSBlbHNlIHsgdGhpcy5zZXRFbGVtZW50KHRoaXMuZWwsIGZhbHNlKSB9XG5cbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cbi8qanNoaW50IC1XMDc5ICovXG5cbmltcG9ydCAnLi9wb2x5ZmlsbHMnXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi9jb21wb25lbnRzL2Jyb3dzZXInXG5pbXBvcnQgJCBmcm9tICdjbGFwcHItemVwdG8nXG5pbXBvcnQgTWVkaWEgZnJvbSAnLi9tZWRpYSdcbmltcG9ydCBJY29ucyBmcm9tICcuL3N2Z19pY29ucydcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHNvdXJjZSkge1xuICBpZiAoc291cmNlKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgY29uc3QgcHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcClcbiAgICAgIHByb3BEZXNjcmlwdG9yID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgcHJvcERlc2NyaXB0b3IpIDogb2JqW3Byb3BdID0gc291cmNlW3Byb3BdXG4gICAgfVxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIHByb3BlcnRpZXMpIHtcbiAgY2xhc3MgU3Vycm9nYXRlIGV4dGVuZHMgcGFyZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKVxuICAgICAgaWYgKHByb3BlcnRpZXMuaW5pdGlhbGl6ZSlcbiAgICAgICAgcHJvcGVydGllcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3MpXG5cbiAgICB9XG4gIH1cbiAgYXNzaWduKFN1cnJvZ2F0ZS5wcm90b3R5cGUsIHByb3BlcnRpZXMpXG4gIHJldHVybiBTdXJyb2dhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWUodGltZSwgcGFkZGVkSG91cnMpIHtcbiAgaWYgKCFpc0Zpbml0ZSh0aW1lKSlcbiAgICByZXR1cm4gJy0tOi0tJ1xuXG4gIHRpbWUgPSB0aW1lICogMTAwMFxuICB0aW1lID0gcGFyc2VJbnQodGltZS8xMDAwKVxuICBjb25zdCBzZWNvbmRzID0gdGltZSAlIDYwXG4gIHRpbWUgPSBwYXJzZUludCh0aW1lLzYwKVxuICBjb25zdCBtaW51dGVzID0gdGltZSAlIDYwXG4gIHRpbWUgPSBwYXJzZUludCh0aW1lLzYwKVxuICBjb25zdCBob3VycyA9IHRpbWUgJSAyNFxuICBjb25zdCBkYXlzID0gcGFyc2VJbnQodGltZS8yNClcbiAgbGV0IG91dCA9ICcnXG4gIGlmIChkYXlzICYmIGRheXMgPiAwKSB7XG4gICAgb3V0ICs9IGRheXMgKyAnOidcbiAgICBpZiAoaG91cnMgPCAxKSBvdXQgKz0gJzAwOidcbiAgfVxuICBpZiAoaG91cnMgJiYgaG91cnMgPiAwIHx8IHBhZGRlZEhvdXJzKSBvdXQgKz0gKCcwJyArIGhvdXJzKS5zbGljZSgtMikgKyAnOidcbiAgb3V0ICs9ICgnMCcgKyBtaW51dGVzKS5zbGljZSgtMikgKyAnOidcbiAgb3V0ICs9ICgnMCcgKyBzZWNvbmRzKS5zbGljZSgtMilcbiAgcmV0dXJuIG91dC50cmltKClcbn1cblxuZXhwb3J0IGNvbnN0IEZ1bGxzY3JlZW4gPSB7XG4gIGZ1bGxzY3JlZW5FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudFxuICB9LFxuICByZXF1ZXN0RnVsbHNjcmVlbjogZnVuY3Rpb24oZWwpIHtcbiAgICBpZiAoZWwucmVxdWVzdEZ1bGxzY3JlZW4pXG4gICAgICBlbC5yZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgZWxzZSBpZiAoZWwud2Via2l0RW50ZXJGdWxsU2NyZWVuKVxuICAgICAgZWwud2Via2l0RW50ZXJGdWxsU2NyZWVuKCkgICAgICAgICAgICBcbiAgICBlbHNlIGlmIChlbC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbilcbiAgICAgIGVsLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICBlbHNlIGlmIChlbC5tb3pSZXF1ZXN0RnVsbFNjcmVlbilcbiAgICAgIGVsLm1velJlcXVlc3RGdWxsU2NyZWVuKClcbiAgICBlbHNlIGlmIChlbC5tc1JlcXVlc3RGdWxsc2NyZWVuKVxuICAgICAgZWwubXNSZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgZWxzZSBpZiAoZWwucXVlcnlTZWxlY3RvciAmJiBlbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpICYmIGVsLnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJykud2Via2l0RW50ZXJGdWxsU2NyZWVuKVxuICAgICAgZWwucXVlcnlTZWxlY3RvcigndmlkZW8nKS53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKVxuICB9LFxuICBjYW5jZWxGdWxsc2NyZWVuOiBmdW5jdGlvbihlbD1kb2N1bWVudCkge1xuICAgIGlmIChlbC5leGl0RnVsbHNjcmVlbilcbiAgICAgIGVsLmV4aXRGdWxsc2NyZWVuKClcbiAgICBlbHNlIGlmIChlbC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKVxuICAgICAgZWwud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpXG4gICAgZWxzZSBpZiAoZWwud2Via2l0RXhpdEZ1bGxzY3JlZW4pXG4gICAgICBlbC53ZWJraXRFeGl0RnVsbHNjcmVlbigpXG4gICAgZWxzZSBpZiAoZWwubW96Q2FuY2VsRnVsbFNjcmVlbilcbiAgICAgIGVsLm1vekNhbmNlbEZ1bGxTY3JlZW4oKVxuICAgIGVsc2UgaWYgKGVsLm1zRXhpdEZ1bGxzY3JlZW4pXG4gICAgICBlbC5tc0V4aXRGdWxsc2NyZWVuKClcblxuICB9LFxuICBmdWxsc2NyZWVuRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHxcbiAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkIHx8XG4gICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fFxuICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZFxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29uZmlnIHtcblxuICBzdGF0aWMgX2RlZmF1bHRDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvbHVtZToge1xuICAgICAgICB2YWx1ZTogMTAwLFxuICAgICAgICBwYXJzZTogcGFyc2VJbnRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2RlZmF1bHRWYWx1ZUZvcihrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb25maWcoKVtrZXldLnBhcnNlKHRoaXMuX2RlZmF1bHRDb25maWcoKVtrZXldLnZhbHVlKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2NyZWF0ZUtleXNwYWNlKGtleSkge1xuICAgIHJldHVybiBgY2xhcHByLiR7ZG9jdW1lbnQuZG9tYWlufS4ke2tleX1gXG4gIH1cblxuICBzdGF0aWMgcmVzdG9yZShrZXkpIHtcbiAgICBpZiAoQnJvd3Nlci5oYXNMb2NhbHN0b3JhZ2UgJiYgbG9jYWxTdG9yYWdlW3RoaXMuX2NyZWF0ZUtleXNwYWNlKGtleSldKVxuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDb25maWcoKVtrZXldLnBhcnNlKGxvY2FsU3RvcmFnZVt0aGlzLl9jcmVhdGVLZXlzcGFjZShrZXkpXSlcblxuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWVGb3Ioa2V5KVxuICB9XG5cbiAgc3RhdGljIHBlcnNpc3Qoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChCcm93c2VyLmhhc0xvY2Fsc3RvcmFnZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlW3RoaXMuX2NyZWF0ZUtleXNwYWNlKGtleSldID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBRdWVyeVN0cmluZyB7XG4gIHN0YXRpYyBnZXQgcGFyYW1zKCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSlcbiAgICBpZiAocXVlcnkgIT09IHRoaXMucXVlcnkpIHtcbiAgICAgIHRoaXMuX3VybFBhcmFtcyA9IHRoaXMucGFyc2UocXVlcnkpXG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybFBhcmFtc1xuICB9XG5cbiAgc3RhdGljIGdldCBoYXNoUGFyYW1zKCkge1xuICAgIGNvbnN0IGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSlcbiAgICBpZiAoaGFzaCAhPT0gdGhpcy5oYXNoKSB7XG4gICAgICB0aGlzLl9oYXNoUGFyYW1zID0gdGhpcy5wYXJzZShoYXNoKVxuICAgICAgdGhpcy5oYXNoID0gaGFzaFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGFzaFBhcmFtc1xuICB9XG5cbiAgc3RhdGljIHBhcnNlKHBhcmFtc1N0cmluZykge1xuICAgIGxldCBtYXRjaFxuICAgIGNvbnN0IHBsID0gL1xcKy9nLCAgLy8gUmVnZXggZm9yIHJlcGxhY2luZyBhZGRpdGlvbiBzeW1ib2wgd2l0aCBhIHNwYWNlXG4gICAgICBzZWFyY2ggPSAvKFteJj1dKyk9PyhbXiZdKikvZyxcbiAgICAgIGRlY29kZSA9IChzKSA9PiBkZWNvZGVVUklDb21wb25lbnQocy5yZXBsYWNlKHBsLCAnICcpKSxcbiAgICAgIHBhcmFtcyA9IHt9XG4gICAgd2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocGFyYW1zU3RyaW5nKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICBwYXJhbXNbZGVjb2RlKG1hdGNoWzFdKS50b0xvd2VyQ2FzZSgpXSA9IGRlY29kZShtYXRjaFsyXSlcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWVrU3RyaW5nVG9TZWNvbmRzKHBhcmFtTmFtZSA9ICd0Jykge1xuICBsZXQgc2Vjb25kcyA9IDBcbiAgY29uc3Qgc2Vla1N0cmluZyA9IFF1ZXJ5U3RyaW5nLnBhcmFtc1twYXJhbU5hbWVdIHx8IFF1ZXJ5U3RyaW5nLmhhc2hQYXJhbXNbcGFyYW1OYW1lXSB8fCAnJ1xuICBjb25zdCBwYXJ0cyA9IHNlZWtTdHJpbmcubWF0Y2goL1swLTldK1tobXNdKy9nKSB8fCBbXVxuICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZhY3RvciA9IHsgJ2gnOiAzNjAwLCAnbSc6IDYwLCAncyc6IDEgfVxuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSBlbFtlbC5sZW5ndGggLSAxXVxuICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VJbnQoZWwuc2xpY2UoMCwgZWwubGVuZ3RoIC0gMSksIDEwKVxuICAgICAgICBzZWNvbmRzICs9IHRpbWUgKiAoZmFjdG9yW3N1ZmZpeF0pXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIGlmIChzZWVrU3RyaW5nKSB7IHNlY29uZHMgPSBwYXJzZUludChzZWVrU3RyaW5nLCAxMCkgfVxuXG4gIHJldHVybiBzZWNvbmRzXG59XG5cbmNvbnN0IGlkc0NvdW50ZXIgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gIGlkc0NvdW50ZXJbcHJlZml4XSB8fCAoaWRzQ291bnRlcltwcmVmaXhdID0gMClcbiAgY29uc3QgaWQgPSArK2lkc0NvdW50ZXJbcHJlZml4XVxuICByZXR1cm4gcHJlZml4ICsgaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpICsgMSA+PSAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50U2NyaXB0VXJsKCkge1xuICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpXG4gIHJldHVybiBzY3JpcHRzLmxlbmd0aCA/IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmMgOiAnJ1xufVxuXG5leHBvcnQgY29uc3QgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZuKSB7IHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxMDAwLzYwKSB9KS5iaW5kKHdpbmRvdylcblxuZXhwb3J0IGNvbnN0IGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQpLmJpbmQod2luZG93KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnJvd3Nlckxhbmd1YWdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdylcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcblxuICByZXR1cm4gRGF0ZS5ub3coKVxufVxuXG4vLyByZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgYXJyYXkgaWYgaXQgZXhpc3RzIGluIHRoZSBhcnJheVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFycmF5SXRlbShhcnIsIGl0ZW0pIHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKGl0ZW0pXG4gIGlmIChpID49IDApXG4gICAgYXJyLnNwbGljZShpLCAxKVxuXG59XG5cbi8vIGZpbmQgYW4gaXRlbSByZWdhcmRsZXNzIG9mIGl0cyBsZXR0ZXIgY2FzZVxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RDb250YWluc0lnbm9yZUNhc2UoaXRlbSwgaXRlbXMpIHtcbiAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGl0ZW1zLmZpbmQoKGl0ZW1FYWNoKSA9PiBpdGVtLnRvTG93ZXJDYXNlKCkgPT09IGl0ZW1FYWNoLnRvTG93ZXJDYXNlKCkpICE9PSB1bmRlZmluZWRcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9jYW4tYXV0b3BsYXlcbmV4cG9ydCBmdW5jdGlvbiBjYW5BdXRvUGxheU1lZGlhKGNiLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBpbmxpbmU6IGZhbHNlLFxuICAgIG11dGVkOiBmYWxzZSxcbiAgICB0aW1lb3V0OiAyNTAsXG4gICAgdHlwZTogJ3ZpZGVvJyxcbiAgICBzb3VyY2U6IE1lZGlhLm1wNCxcbiAgICBlbGVtZW50OiBudWxsXG4gIH0sIG9wdGlvbnMpXG5cbiAgbGV0IGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQgPyBvcHRpb25zLmVsZW1lbnQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMudHlwZSlcblxuICBlbGVtZW50Lm11dGVkID0gb3B0aW9ucy5tdXRlZFxuICBpZiAob3B0aW9ucy5tdXRlZCA9PT0gdHJ1ZSlcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAnbXV0ZWQnKVxuXG4gIGlmIChvcHRpb25zLmlubGluZSA9PT0gdHJ1ZSlcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAncGxheXNpbmxpbmUnKVxuXG4gIGVsZW1lbnQuc3JjID0gb3B0aW9ucy5zb3VyY2VcblxuICBsZXQgcHJvbWlzZSA9IGVsZW1lbnQucGxheSgpXG5cbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHNldFJlc3VsdChmYWxzZSwgbmV3IEVycm9yKGBUaW1lb3V0ICR7b3B0aW9ucy50aW1lb3V0fSBtcyBoYXMgYmVlbiByZWFjaGVkYCkpXG4gIH0sIG9wdGlvbnMudGltZW91dClcblxuICBsZXQgc2V0UmVzdWx0ID0gKHJlc3VsdCwgZXJyb3IgPSBudWxsKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjYihyZXN1bHQsIGVycm9yKVxuICB9XG5cbiAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHByb21pc2VcbiAgICAgIC50aGVuKCgpID0+IHNldFJlc3VsdCh0cnVlKSlcbiAgICAgIC5jYXRjaChlcnIgPT4gc2V0UmVzdWx0KGZhbHNlLCBlcnIpKVxuICB9IGVsc2Uge1xuICAgIHNldFJlc3VsdCh0cnVlKVxuICB9XG59XG5cbi8vIFNpbXBsZSBaZXB0byBlbGVtZW50IGZhY3Rvcnkgd2l0aCB2aWRlbyByZWN5Y2xlIGZlYXR1cmUuXG5jb25zdCB2aWRlb1N0YWNrID0gW11cblxuZXhwb3J0IGNsYXNzIERvbVJlY3ljbGVyIHtcbiAgc3RhdGljIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWN5Y2xlVmlkZW8gJiYgbmFtZSA9PT0gJ3ZpZGVvJyAmJiB2aWRlb1N0YWNrLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gdmlkZW9TdGFjay5zaGlmdCgpXG5cbiAgICByZXR1cm4gJCgnPCcgKyBuYW1lICsgJz4nKVxuICB9XG5cbiAgc3RhdGljIGdhcmJhZ2UoJGVsKSB7XG4gICAgLy8gRXhwZWN0IFplcHRvIGNvbGxlY3Rpb24gd2l0aCBzaW5nbGUgZWxlbWVudCAoZG9lcyBub3QgaXRlcmF0ZSEpXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVjeWNsZVZpZGVvIHx8ICRlbFswXS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdWSURFTycpIHJldHVyblxuICAgICRlbC5jaGlsZHJlbigpLnJlbW92ZSgpXG4gICAgdmlkZW9TdGFjay5wdXNoKCRlbClcbiAgfVxufVxuXG5Eb21SZWN5Y2xlci5vcHRpb25zID0geyByZWN5Y2xlVmlkZW86IGZhbHNlIH1cblxuZXhwb3J0IGNsYXNzIERvdWJsZUV2ZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGRlbGF5ID0gNTAwKSB7XG4gICAgdGhpcy5kZWxheSA9IGRlbGF5XG4gICAgdGhpcy5sYXN0VGltZSA9IDBcbiAgfVxuXG4gIGhhbmRsZShldmVudCwgY2IsIHByZXZlbnRlZCA9IHRydWUpIHtcbiAgICAvLyBCYXNlZCBvbiBodHRwOi8vanNmaWRkbGUubmV0L2JyZXR0d3AvSjRkalkvXG4gICAgbGV0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICBsZXQgZGlmZlRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWVcblxuICAgIGlmIChkaWZmVGltZSA8IHRoaXMuZGVsYXkgJiYgZGlmZlRpbWUgPiAwKSB7XG4gICAgICBjYigpXG4gICAgICBwcmV2ZW50ZWQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZVxuICB9XG59XG5cbmV4cG9ydCBsZXQgU3ZnSWNvbnMgPSBJY29uc1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIENvbmZpZyxcbiAgRnVsbHNjcmVlbixcbiAgUXVlcnlTdHJpbmcsXG4gIERvbVJlY3ljbGVyLFxuICBleHRlbmQsXG4gIGZvcm1hdFRpbWUsXG4gIHNlZWtTdHJpbmdUb1NlY29uZHMsXG4gIHVuaXF1ZUlkLFxuICBjdXJyZW50U2NyaXB0VXJsLFxuICBpc051bWJlcixcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICBjYW5jZWxBbmltYXRpb25GcmFtZSxcbiAgZ2V0QnJvd3Nlckxhbmd1YWdlLFxuICBub3csXG4gIHJlbW92ZUFycmF5SXRlbSxcbiAgY2FuQXV0b1BsYXlNZWRpYSxcbiAgTWVkaWEsXG4gIERvdWJsZUV2ZW50SGFuZGxlcixcbiAgU3ZnSWNvbnM6IEljb25zLFxufVxuIiwiaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuaW1wb3J0IEJST1dTRVJfREFUQSBmcm9tICcuL2Jyb3dzZXJfZGF0YSdcbmltcG9ydCBPU19EQVRBIGZyb20gJy4vb3NfZGF0YSdcblxuY29uc3QgQnJvd3NlciA9IHt9XG5cbmNvbnN0IGhhc0xvY2Fsc3RvcmFnZSA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjbGFwcHInLCAnY2xhcHByJylcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY2xhcHByJylcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgaGFzRmxhc2ggPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmbyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpXG4gICAgcmV0dXJuICEhZm9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAhIShuYXZpZ2F0b3IubWltZVR5cGVzICYmIG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgbmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXS5lbmFibGVkUGx1Z2luKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRCcm93c2VySW5mbyA9IGZ1bmN0aW9uKHVhKSB7XG4gIGxldCBwYXJ0cyA9IHVhLm1hdGNoKC9cXGIocGxheXN0YXRpb24gNHxueHxvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihcXGQrKS9pKSB8fCBbXSxcbiAgICBleHRyYVxuICBpZiAoL3RyaWRlbnQvaS50ZXN0KHBhcnRzWzFdKSkge1xuICAgIGV4dHJhID0gL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnSUUnLFxuICAgICAgdmVyc2lvbjogcGFyc2VJbnQoZXh0cmFbMV0gfHwgJycpXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcnRzWzFdID09PSAnQ2hyb21lJykge1xuICAgIGV4dHJhID0gdWEubWF0Y2goL1xcYk9QUlxcLyhcXGQrKS8pXG4gICAgaWYgKGV4dHJhICE9IG51bGwpIHJldHVybiB7IG5hbWU6ICdPcGVyYScsIHZlcnNpb246IHBhcnNlSW50KGV4dHJhWzFdKSB9XG5cbiAgICBleHRyYSA9IHVhLm1hdGNoKC9cXGJFZGdlXFwvKFxcZCspLylcbiAgICBpZiAoZXh0cmEgIT0gbnVsbCkgcmV0dXJuIHsgbmFtZTogJ0VkZ2UnLCB2ZXJzaW9uOiBwYXJzZUludChleHRyYVsxXSkgfVxuXG4gIH0gZWxzZSBpZiAoL2FuZHJvaWQvaS50ZXN0KHVhKSAmJiAoZXh0cmEgPSB1YS5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS9pKSkpIHtcbiAgICBwYXJ0cy5zcGxpY2UoMSwgMSwgJ0FuZHJvaWQgV2ViVmlldycpXG4gICAgcGFydHMuc3BsaWNlKDIsIDEsIGV4dHJhWzFdKVxuICB9XG4gIHBhcnRzID0gcGFydHNbMl0gPyBbcGFydHNbMV0sIHBhcnRzWzJdXSA6IFtuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwYXJ0c1swXSxcbiAgICB2ZXJzaW9uOiBwYXJzZUludChwYXJ0c1sxXSlcbiAgfVxufVxuXG4vLyAgR2V0IGJyb3dzZXIgZGF0YVxuZXhwb3J0IGNvbnN0IGdldEJyb3dzZXJEYXRhID0gZnVuY3Rpb24oKSB7XG4gIGxldCBicm93c2VyT2JqZWN0ID0ge31cbiAgbGV0IHVzZXJBZ2VudCA9IEJyb3dzZXIudXNlckFnZW50LnRvTG93ZXJDYXNlKClcblxuICAvLyBDaGVjayBicm93c2VyIHR5cGVcbiAgZm9yIChsZXQgYnJvd3NlciBvZiBCUk9XU0VSX0RBVEEpIHtcbiAgICBsZXQgYnJvd3NlclJlZ0V4cCA9IG5ldyBSZWdFeHAoYnJvd3Nlci5pZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpXG4gICAgbGV0IGJyb3dzZXJSZWdFeHBSZXN1bHQgPSBicm93c2VyUmVnRXhwLmV4ZWModXNlckFnZW50KVxuXG4gICAgaWYgKGJyb3dzZXJSZWdFeHBSZXN1bHQgIT0gbnVsbCAmJiBicm93c2VyUmVnRXhwUmVzdWx0WzFdKSB7XG4gICAgICBicm93c2VyT2JqZWN0Lm5hbWUgPSBicm93c2VyLm5hbWVcbiAgICAgIGJyb3dzZXJPYmplY3QuZ3JvdXAgPSBicm93c2VyLmdyb3VwXG5cbiAgICAgIC8vIENoZWNrIHZlcnNpb25cbiAgICAgIGlmIChicm93c2VyLnZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIGxldCB2ZXJzaW9uUmVnRXhwID0gbmV3IFJlZ0V4cChicm93c2VyLnZlcnNpb25JZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIGxldCB2ZXJzaW9uUmVnRXhwUmVzdWx0ID0gdmVyc2lvblJlZ0V4cC5leGVjKHVzZXJBZ2VudClcblxuICAgICAgICBpZiAodmVyc2lvblJlZ0V4cFJlc3VsdCAhPSBudWxsICYmIHZlcnNpb25SZWdFeHBSZXN1bHRbMV0pXG4gICAgICAgICAgc2V0QnJvd3NlclZlcnNpb24odmVyc2lvblJlZ0V4cFJlc3VsdFsxXSwgYnJvd3Nlck9iamVjdClcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0QnJvd3NlclZlcnNpb24oYnJvd3NlclJlZ0V4cFJlc3VsdFsxXSwgYnJvd3Nlck9iamVjdClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBicm93c2VyT2JqZWN0XG59XG5cbi8vIFNldCBicm93c2VyIHZlcnNpb25cbmNvbnN0IHNldEJyb3dzZXJWZXJzaW9uID0gZnVuY3Rpb24odmVyc2lvbiwgYnJvd3Nlck9iamVjdCkge1xuICBsZXQgc3BsaXRWZXJzaW9uID0gdmVyc2lvbi5zcGxpdCgnLicsIDIpXG4gIGJyb3dzZXJPYmplY3QuZnVsbFZlcnNpb24gPSB2ZXJzaW9uXG5cbiAgLy8gTWFqb3IgdmVyc2lvblxuICBpZiAoc3BsaXRWZXJzaW9uWzBdKSBicm93c2VyT2JqZWN0Lm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHNwbGl0VmVyc2lvblswXSlcblxuICAvLyBNaW5vciB2ZXJzaW9uXG4gIGlmIChzcGxpdFZlcnNpb25bMV0pIGJyb3dzZXJPYmplY3QubWlub3JWZXJzaW9uID0gcGFyc2VJbnQoc3BsaXRWZXJzaW9uWzFdKVxufVxuXG4vLyAgR2V0IE9TIGRhdGFcbmV4cG9ydCBjb25zdCBnZXRPc0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgbGV0IG9zT2JqZWN0ID0ge31cbiAgbGV0IHVzZXJBZ2VudCA9IEJyb3dzZXIudXNlckFnZW50LnRvTG93ZXJDYXNlKClcblxuICAvLyBDaGVjayBicm93c2VyIHR5cGVcbiAgZm9yIChsZXQgb3Mgb2YgT1NfREFUQSkge1xuICAgIGxldCBvc1JlZ0V4cCA9IG5ldyBSZWdFeHAob3MuaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpKVxuICAgIGxldCBvc1JlZ0V4cFJlc3VsdCA9IG9zUmVnRXhwLmV4ZWModXNlckFnZW50KVxuXG4gICAgaWYgKG9zUmVnRXhwUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIG9zT2JqZWN0Lm5hbWUgPSBvcy5uYW1lXG4gICAgICBvc09iamVjdC5ncm91cCA9IG9zLmdyb3VwXG5cbiAgICAgIC8vIFZlcnNpb24gZGVmaW5lZFxuICAgICAgaWYgKG9zLnZlcnNpb24pIHtcbiAgICAgICAgc2V0T3NWZXJzaW9uKG9zLnZlcnNpb24sIChvcy52ZXJzaW9uU2VwYXJhdG9yKSA/IG9zLnZlcnNpb25TZXBhcmF0b3IgOiAnLicsIG9zT2JqZWN0KVxuXG4gICAgICAgIC8vIFZlcnNpb24gZGV0ZWN0ZWRcbiAgICAgIH0gZWxzZSBpZiAob3NSZWdFeHBSZXN1bHRbMV0pIHtcbiAgICAgICAgc2V0T3NWZXJzaW9uKG9zUmVnRXhwUmVzdWx0WzFdLCAob3MudmVyc2lvblNlcGFyYXRvcikgPyBvcy52ZXJzaW9uU2VwYXJhdG9yIDogJy4nLCBvc09iamVjdClcblxuICAgICAgICAvLyBWZXJzaW9uIGlkZW50aWZpZXJcbiAgICAgIH0gZWxzZSBpZiAob3MudmVyc2lvbklkZW50aWZpZXIpIHtcbiAgICAgICAgbGV0IHZlcnNpb25SZWdFeHAgPSBuZXcgUmVnRXhwKG9zLnZlcnNpb25JZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIGxldCB2ZXJzaW9uUmVnRXhwUmVzdWx0ID0gdmVyc2lvblJlZ0V4cC5leGVjKHVzZXJBZ2VudClcblxuICAgICAgICBpZiAodmVyc2lvblJlZ0V4cFJlc3VsdCAhPSBudWxsICYmIHZlcnNpb25SZWdFeHBSZXN1bHRbMV0pXG4gICAgICAgICAgc2V0T3NWZXJzaW9uKHZlcnNpb25SZWdFeHBSZXN1bHRbMV0sIChvcy52ZXJzaW9uU2VwYXJhdG9yKSA/IG9zLnZlcnNpb25TZXBhcmF0b3IgOiAnLicsIG9zT2JqZWN0KVxuXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3NPYmplY3Rcbn1cblxuLy8gU2V0IE9TIHZlcnNpb25cbmNvbnN0IHNldE9zVmVyc2lvbiA9IGZ1bmN0aW9uKHZlcnNpb24sIHNlcGFyYXRvciwgb3NPYmplY3QpIHtcbiAgbGV0IGZpbmFsU2VwYXJhdG9yID0gc2VwYXJhdG9yLnN1YnN0cigwLCAxKSA9PSAnWycgPyBuZXcgUmVnRXhwKHNlcGFyYXRvciwgJ2cnKSA6IHNlcGFyYXRvclxuICBjb25zdCBzcGxpdFZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KGZpbmFsU2VwYXJhdG9yLCAyKVxuXG4gIGlmIChzZXBhcmF0b3IgIT0gJy4nKSB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKG5ldyBSZWdFeHAoc2VwYXJhdG9yLCAnZycpLCAnLicpXG5cbiAgb3NPYmplY3QuZnVsbFZlcnNpb24gPSB2ZXJzaW9uXG5cbiAgLy8gTWFqb3IgdmVyc2lvblxuICBpZiAoc3BsaXRWZXJzaW9uICYmIHNwbGl0VmVyc2lvblswXSlcbiAgICBvc09iamVjdC5tYWpvclZlcnNpb24gPSBwYXJzZUludChzcGxpdFZlcnNpb25bMF0pXG5cbiAgLy8gTWlub3IgdmVyc2lvblxuICBpZiAoc3BsaXRWZXJzaW9uICYmIHNwbGl0VmVyc2lvblsxXSlcbiAgICBvc09iamVjdC5taW5vclZlcnNpb24gPSBwYXJzZUludChzcGxpdFZlcnNpb25bMV0pXG59XG5cbi8vIFNldCB2aWV3cG9ydCBzaXplXG5leHBvcnQgY29uc3QgZ2V0Vmlld3BvcnRTaXplID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2aWV3cG9ydE9iamVjdCA9IHt9XG5cbiAgdmlld3BvcnRPYmplY3Qud2lkdGggPSAkKHdpbmRvdykud2lkdGgoKVxuICB2aWV3cG9ydE9iamVjdC5oZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KClcblxuICByZXR1cm4gdmlld3BvcnRPYmplY3Rcbn1cblxuLy8gU2V0IHZpZXdwb3J0IG9yaWVudGF0aW9uXG5jb25zdCBzZXRWaWV3cG9ydE9yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAod2luZG93Lm9yaWVudGF0aW9uKSB7XG4gIGNhc2UgLTkwOlxuICBjYXNlIDkwOlxuICAgIEJyb3dzZXIudmlld3BvcnQub3JpZW50YXRpb24gPSAnbGFuZHNjYXBlJ1xuICAgIGJyZWFrXG4gIGRlZmF1bHQ6XG4gICAgQnJvd3Nlci52aWV3cG9ydC5vcmllbnRhdGlvbiA9ICdwb3J0cmFpdCdcbiAgICBicmVha1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXREZXZpY2UgPSBmdW5jdGlvbih1YSkge1xuICBsZXQgcGxhdGZvcm1SZWdFeHAgPSAvXFwoKGlQKD86aG9uZXxhZHxvZCkpPyg/OlteO10qOyApezAsMn0oW14pXSsoPz1cXCkpKS9cbiAgbGV0IG1hdGNoZXMgPSBwbGF0Zm9ybVJlZ0V4cC5leGVjKHVhKVxuICBsZXQgZGV2aWNlID0gbWF0Y2hlcyAmJiAobWF0Y2hlc1sxXSB8fCBtYXRjaGVzWzJdKSB8fCAnJ1xuICByZXR1cm4gZGV2aWNlXG59XG5cbmNvbnN0IGJyb3dzZXJJbmZvID0gZ2V0QnJvd3NlckluZm8obmF2aWdhdG9yLnVzZXJBZ2VudClcblxuQnJvd3Nlci5pc0VkZ2UgPSAvZWRnZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbkJyb3dzZXIuaXNDaHJvbWUgPSAvY2hyb21lfENyaU9TL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhQnJvd3Nlci5pc0VkZ2VcbkJyb3dzZXIuaXNTYWZhcmkgPSAvc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhQnJvd3Nlci5pc0Nocm9tZSAmJiAhQnJvd3Nlci5pc0VkZ2VcbkJyb3dzZXIuaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5Ccm93c2VyLmlzTGVnYWN5SUUgPSAhISh3aW5kb3cuQWN0aXZlWE9iamVjdClcbkJyb3dzZXIuaXNJRSA9IEJyb3dzZXIuaXNMZWdhY3lJRSB8fCAvdHJpZGVudC4qcnY6MVxcZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbkJyb3dzZXIuaXNJRTExID0gL3RyaWRlbnQuKnJ2OjExL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuQnJvd3Nlci5pc0Nocm9tZWNhc3QgPSBCcm93c2VyLmlzQ2hyb21lICYmIC9DcktleS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbkJyb3dzZXIuaXNNb2JpbGUgPSAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8V2luZG93cyBQaG9uZXxJRU1vYmlsZXxNb2JpbGUgU2FmYXJpfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5Ccm93c2VyLmlzaU9TID0gL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5Ccm93c2VyLmlzQW5kcm9pZCA9IC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuQnJvd3Nlci5pc1dpbmRvd3NQaG9uZSA9IC9XaW5kb3dzIFBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuQnJvd3Nlci5pc1dpbjhBcHAgPSAvTVNBcHBIb3N0L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuQnJvd3Nlci5pc1dpaVUgPSAvV2lpVS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbkJyb3dzZXIuaXNQUzQgPSAvUGxheVN0YXRpb24gNC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbkJyb3dzZXIuaGFzTG9jYWxzdG9yYWdlID0gaGFzTG9jYWxzdG9yYWdlKClcbkJyb3dzZXIuaGFzRmxhc2ggPSBoYXNGbGFzaCgpXG5cbi8qKlxuKiBAZGVwcmVjYXRlZFxuKiBUaGlzIHBhcmFtZXRlciBjdXJyZW50bHkgZXhpc3RzIGZvciByZXRyb2NvbXBhdGliaWxpdHkgcmVhc29ucy5cbiogVXNlIEJyb3dzZXIuZGF0YS5uYW1lIGluc3RlYWQuXG4qL1xuQnJvd3Nlci5uYW1lID0gYnJvd3NlckluZm8ubmFtZVxuXG4vKipcbiogQGRlcHJlY2F0ZWRcbiogVGhpcyBwYXJhbWV0ZXIgY3VycmVudGx5IGV4aXN0cyBmb3IgcmV0cm9jb21wYXRpYmlsaXR5IHJlYXNvbnMuXG4qIFVzZSBCcm93c2VyLmRhdGEuZnVsbFZlcnNpb24gaW5zdGVhZC5cbiovXG5Ccm93c2VyLnZlcnNpb24gPSBicm93c2VySW5mby52ZXJzaW9uXG5cbkJyb3dzZXIudXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudFxuQnJvd3Nlci5kYXRhID0gZ2V0QnJvd3NlckRhdGEoKVxuQnJvd3Nlci5vcyA9IGdldE9zRGF0YSgpXG5Ccm93c2VyLnZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRTaXplKClcbkJyb3dzZXIuZGV2aWNlID0gZ2V0RGV2aWNlKEJyb3dzZXIudXNlckFnZW50KVxudHlwZW9mIHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2V0Vmlld3BvcnRPcmllbnRhdGlvbigpXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG4vLyBUaGUgb3JkZXIgb2YgdGhlIGZvbGxvd2luZyBhcnJheXMgaXMgaW1wb3J0YW50LCBiZSBjYXJlZnVsIGlmIHlvdSBjaGFuZ2UgaXQuXG5cbmNvbnN0IEJST1dTRVJfREFUQSA9IFt7XG4gIG5hbWU6ICdDaHJvbWl1bScsXG4gIGdyb3VwOiAnQ2hyb21lJyxcbiAgaWRlbnRpZmllcjogJ0Nocm9taXVtLyhbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnQ2hyb21lIE1vYmlsZScsXG4gIGdyb3VwOiAnQ2hyb21lJyxcbiAgaWRlbnRpZmllcjogJ0Nocm9tZS8oWzAtOVxcLl0qKSBNb2JpbGUnLFxuICB2ZXJzaW9uSWRlbnRpZmllcjogJ0Nocm9tZS8oWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ0Nocm9tZScsXG4gIGdyb3VwOiAnQ2hyb21lJyxcbiAgaWRlbnRpZmllcjogJ0Nocm9tZS8oWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ0Nocm9tZSBmb3IgaU9TJyxcbiAgZ3JvdXA6ICdDaHJvbWUnLFxuICBpZGVudGlmaWVyOiAnQ3JpT1MvKFswLTlcXC5dKiknXG59LCB7XG4gIG5hbWU6ICdBbmRyb2lkIEJyb3dzZXInLFxuICBncm91cDogJ0Nocm9tZScsXG4gIGlkZW50aWZpZXI6ICdDck1vLyhbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnRmlyZWZveCcsXG4gIGdyb3VwOiAnRmlyZWZveCcsXG4gIGlkZW50aWZpZXI6ICdGaXJlZm94LyhbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnT3BlcmEgTWluaScsXG4gIGdyb3VwOiAnT3BlcmEnLFxuICBpZGVudGlmaWVyOiAnT3BlcmEgTWluaS8oWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ09wZXJhJyxcbiAgZ3JvdXA6ICdPcGVyYScsXG4gIGlkZW50aWZpZXI6ICdPcGVyYSAoWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ09wZXJhJyxcbiAgZ3JvdXA6ICdPcGVyYScsXG4gIGlkZW50aWZpZXI6ICdPcGVyYS8oWzAtOVxcLl0qKScsXG4gIHZlcnNpb25JZGVudGlmaWVyOiAnVmVyc2lvbi8oWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ0lFTW9iaWxlJyxcbiAgZ3JvdXA6ICdFeHBsb3JlcicsXG4gIGlkZW50aWZpZXI6ICdJRU1vYmlsZS8oWzAtOVxcLl0qKSdcbn0sIHtcbiAgbmFtZTogJ0ludGVybmV0IEV4cGxvcmVyJyxcbiAgZ3JvdXA6ICdFeHBsb3JlcicsXG4gIGlkZW50aWZpZXI6ICdNU0lFIChbYS16QS1aMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnSW50ZXJuZXQgRXhwbG9yZXInLFxuICBncm91cDogJ0V4cGxvcmVyJyxcbiAgaWRlbnRpZmllcjogJ1RyaWRlbnQvKFswLTlcXC5dKiknLFxuICB2ZXJzaW9uSWRlbnRpZmllcjogJ3J2OihbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnU3BhcnRhbicsXG4gIGdyb3VwOiAnU3BhcnRhbicsXG4gIGlkZW50aWZpZXI6ICdFZGdlLyhbMC05XFwuXSopJyxcbiAgdmVyc2lvbklkZW50aWZpZXI6ICdFZGdlLyhbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnU2FmYXJpJyxcbiAgZ3JvdXA6ICdTYWZhcmknLFxuICBpZGVudGlmaWVyOiAnU2FmYXJpLyhbMC05XFwuXSopJyxcbiAgdmVyc2lvbklkZW50aWZpZXI6ICdWZXJzaW9uLyhbMC05XFwuXSopJ1xufV1cblxuZXhwb3J0IGRlZmF1bHQgQlJPV1NFUl9EQVRBXG4iLCJpbXBvcnQgQnJvd3NlciBmcm9tICcuL2Jyb3dzZXInXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11c2VsZXNzLWVzY2FwZSAqL1xuLy8gVGhlIG9yZGVyIG9mIHRoZSBmb2xsb3dpbmcgYXJyYXlzIGlzIGltcG9ydGFudCwgYmUgY2FyZWZ1bCBpZiB5b3UgY2hhbmdlIGl0LlxuXG5jb25zdCBPU19EQVRBID0gW3tcbiAgbmFtZTogJ1dpbmRvd3MgMjAwMCcsXG4gIGdyb3VwOiAnV2luZG93cycsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzIE5UIDUuMCcsXG4gIHZlcnNpb246ICc1LjAnXG59LCB7XG4gIG5hbWU6ICdXaW5kb3dzIFhQJyxcbiAgZ3JvdXA6ICdXaW5kb3dzJyxcbiAgaWRlbnRpZmllcjogJ1dpbmRvd3MgTlQgNS4xJyxcbiAgdmVyc2lvbjogJzUuMSdcbn0sIHtcbiAgbmFtZTogJ1dpbmRvd3MgVmlzdGEnLFxuICBncm91cDogJ1dpbmRvd3MnLFxuICBpZGVudGlmaWVyOiAnV2luZG93cyBOVCA2LjAnLFxuICB2ZXJzaW9uOiAnNi4wJ1xufSwge1xuICBuYW1lOiAnV2luZG93cyA3JyxcbiAgZ3JvdXA6ICdXaW5kb3dzJyxcbiAgaWRlbnRpZmllcjogJ1dpbmRvd3MgTlQgNi4xJyxcbiAgdmVyc2lvbjogJzcuMCdcbn0sIHtcbiAgbmFtZTogJ1dpbmRvd3MgOCcsXG4gIGdyb3VwOiAnV2luZG93cycsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzIE5UIDYuMicsXG4gIHZlcnNpb246ICc4LjAnXG59LCB7XG4gIG5hbWU6ICdXaW5kb3dzIDguMScsXG4gIGdyb3VwOiAnV2luZG93cycsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzIE5UIDYuMycsXG4gIHZlcnNpb246ICc4LjEnXG59LCB7XG4gIG5hbWU6ICdXaW5kb3dzIDEwJyxcbiAgZ3JvdXA6ICdXaW5kb3dzJyxcbiAgaWRlbnRpZmllcjogJ1dpbmRvd3MgTlQgMTAuMCcsXG4gIHZlcnNpb246ICcxMC4wJ1xufSwge1xuICBuYW1lOiAnV2luZG93cyBQaG9uZScsXG4gIGdyb3VwOiAnV2luZG93cyBQaG9uZScsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzIFBob25lIChbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnV2luZG93cyBQaG9uZScsXG4gIGdyb3VwOiAnV2luZG93cyBQaG9uZScsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzIFBob25lIE9TIChbMC05XFwuXSopJ1xufSwge1xuICBuYW1lOiAnV2luZG93cycsXG4gIGdyb3VwOiAnV2luZG93cycsXG4gIGlkZW50aWZpZXI6ICdXaW5kb3dzJ1xufSwge1xuICBuYW1lOiAnQ2hyb21lIE9TJyxcbiAgZ3JvdXA6ICdDaHJvbWUgT1MnLFxuICBpZGVudGlmaWVyOiAnQ3JPUydcbn0sIHtcbiAgbmFtZTogJ0FuZHJvaWQnLFxuICBncm91cDogJ0FuZHJvaWQnLFxuICBpZGVudGlmaWVyOiAnQW5kcm9pZCcsXG4gIHZlcnNpb25JZGVudGlmaWVyOiAnQW5kcm9pZCAoW2EtekEtWjAtOVxcLi1dKiknXG59LCB7XG4gIG5hbWU6ICdpUGFkJyxcbiAgZ3JvdXA6ICdpT1MnLFxuICBpZGVudGlmaWVyOiAnaVBhZCcsXG4gIHZlcnNpb25JZGVudGlmaWVyOiAnT1MgKFswLTlfXSopJyxcbiAgdmVyc2lvblNlcGFyYXRvcjogJ1tffFxcLl0nXG59LCB7XG4gIG5hbWU6ICdpUG9kJyxcbiAgZ3JvdXA6ICdpT1MnLFxuICBpZGVudGlmaWVyOiAnaVBvZCcsXG4gIHZlcnNpb25JZGVudGlmaWVyOiAnT1MgKFswLTlfXSopJyxcbiAgdmVyc2lvblNlcGFyYXRvcjogJ1tffFxcLl0nXG59LCB7XG4gIG5hbWU6ICdpUGhvbmUnLFxuICBncm91cDogJ2lPUycsXG4gIGlkZW50aWZpZXI6ICdpUGhvbmUgT1MnLFxuICB2ZXJzaW9uSWRlbnRpZmllcjogJ09TIChbMC05X10qKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggSGlnaCBTaWVycmEnLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSkxMyhbMC05X1xcLl0qKSknLFxuICB2ZXJzaW9uU2VwYXJhdG9yOiAnW198XFwuXSdcbn0sIHtcbiAgbmFtZTogJ01hYyBPUyBYIFNpZXJyYScsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUyBYICgxMChbX3xcXC5dKTEyKFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggRWwgQ2FwaXRhbicsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUyBYICgxMChbX3xcXC5dKTExKFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggWW9zZW1pdGUnLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSkxMChbMC05X1xcLl0qKSknLFxuICB2ZXJzaW9uU2VwYXJhdG9yOiAnW198XFwuXSdcbn0sIHtcbiAgbmFtZTogJ01hYyBPUyBYIE1hdmVyaWNrcycsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUyBYICgxMChbX3xcXC5dKTkoWzAtOV9cXC5dKikpJyxcbiAgdmVyc2lvblNlcGFyYXRvcjogJ1tffFxcLl0nXG59LCB7XG4gIG5hbWU6ICdNYWMgT1MgWCBNb3VudGFpbiBMaW9uJyxcbiAgZ3JvdXA6ICdNYWMgT1MnLFxuICBpZGVudGlmaWVyOiAnTWFjIE9TIFggKDEwKFtffFxcLl0pOChbMC05X1xcLl0qKSknLFxuICB2ZXJzaW9uU2VwYXJhdG9yOiAnW198XFwuXSdcbn0sIHtcbiAgbmFtZTogJ01hYyBPUyBYIExpb24nLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSk3KFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggU25vdyBMZW9wYXJkJyxcbiAgZ3JvdXA6ICdNYWMgT1MnLFxuICBpZGVudGlmaWVyOiAnTWFjIE9TIFggKDEwKFtffFxcLl0pNihbMC05X1xcLl0qKSknLFxuICB2ZXJzaW9uU2VwYXJhdG9yOiAnW198XFwuXSdcbn0sIHtcbiAgbmFtZTogJ01hYyBPUyBYIExlb3BhcmQnLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSk1KFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggVGlnZXInLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSk0KFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggUGFudGhlcicsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUyBYICgxMChbX3xcXC5dKTMoWzAtOV9cXC5dKikpJyxcbiAgdmVyc2lvblNlcGFyYXRvcjogJ1tffFxcLl0nXG59LCB7XG4gIG5hbWU6ICdNYWMgT1MgWCBKYWd1YXInLFxuICBncm91cDogJ01hYyBPUycsXG4gIGlkZW50aWZpZXI6ICdNYWMgT1MgWCAoMTAoW198XFwuXSkyKFswLTlfXFwuXSopKScsXG4gIHZlcnNpb25TZXBhcmF0b3I6ICdbX3xcXC5dJ1xufSwge1xuICBuYW1lOiAnTWFjIE9TIFggUHVtYScsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUyBYICgxMChbX3xcXC5dKTEoWzAtOV9cXC5dKikpJyxcbiAgdmVyc2lvblNlcGFyYXRvcjogJ1tffFxcLl0nXG59LCB7XG4gIG5hbWU6ICdNYWMgT1MgWCBDaGVldGFoJyxcbiAgZ3JvdXA6ICdNYWMgT1MnLFxuICBpZGVudGlmaWVyOiAnTWFjIE9TIFggKDEwKFtffFxcLl0pMChbMC05X1xcLl0qKSknLFxuICB2ZXJzaW9uU2VwYXJhdG9yOiAnW198XFwuXSdcbn0sIHtcbiAgbmFtZTogJ01hYyBPUycsXG4gIGdyb3VwOiAnTWFjIE9TJyxcbiAgaWRlbnRpZmllcjogJ01hYyBPUydcbn0sIHtcbiAgbmFtZTogJ1VidW50dScsXG4gIGdyb3VwOiAnTGludXgnLFxuICBpZGVudGlmaWVyOiAnVWJ1bnR1JyxcbiAgdmVyc2lvbklkZW50aWZpZXI6ICdVYnVudHUvKFswLTlcXC5dKiknXG59LCB7XG4gIG5hbWU6ICdEZWJpYW4nLFxuICBncm91cDogJ0xpbnV4JyxcbiAgaWRlbnRpZmllcjogJ0RlYmlhbidcbn0sIHtcbiAgbmFtZTogJ0dlbnRvbycsXG4gIGdyb3VwOiAnTGludXgnLFxuICBpZGVudGlmaWVyOiAnR2VudG9vJ1xufSwge1xuICBuYW1lOiAnTGludXgnLFxuICBncm91cDogJ0xpbnV4JyxcbiAgaWRlbnRpZmllcjogJ0xpbnV4J1xufSwge1xuICBuYW1lOiAnQmxhY2tCZXJyeScsXG4gIGdyb3VwOiAnQmxhY2tCZXJyeScsXG4gIGlkZW50aWZpZXI6ICdCbGFja0JlcnJ5J1xufV1cblxuZXhwb3J0IGRlZmF1bHQgT1NfREFUQVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuLyoqXG4gKiBDb250YWluZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB2aWRlbyByZW5kZXJpbmcgYW5kIHN0YXRlXG4gKi9cblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCBVSU9iamVjdCBmcm9tICcuLi8uLi9iYXNlL3VpX29iamVjdCdcbmltcG9ydCBFcnJvck1peGluIGZyb20gJy4uLy4uL2Jhc2UvZXJyb3JfbWl4aW4nXG5pbXBvcnQgeyBEb3VibGVFdmVudEhhbmRsZXIgfSBmcm9tICcuLi8uLi9iYXNlL3V0aWxzJ1xuXG5pbXBvcnQgJy4vcHVibGljL3N0eWxlLnNjc3MnXG5cbmltcG9ydCAkIGZyb20gJ2NsYXBwci16ZXB0bydcblxuLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiB0byByZXByZXNlbnQgYSBjb250YWluZXIgZm9yIGEgZ2l2ZW4gcGxheWJhY2tcbiAqIFRPRE86IGRlc2NyaWJlIGl0cyByZXNwb25zYWJpbGl0aWVzXG4gKiBAY2xhc3MgQ29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFVJT2JqZWN0XG4gKiBAbW9kdWxlIGJhc2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgVUlPYmplY3Qge1xuICAvKipcbiAgICogY29udGFpbmVyJ3MgbmFtZVxuICAgKiBAbWV0aG9kIG5hbWVcbiAgICogQGRlZmF1bHQgQ29udGFpbmVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gY29udGFpbmVyJ3MgbmFtZVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnQ29udGFpbmVyJyB9XG4gIGdldCBhdHRyaWJ1dGVzKCkgeyByZXR1cm4geyBjbGFzczogJ2NvbnRhaW5lcicsICdkYXRhLWNvbnRhaW5lcic6ICcnIH0gfVxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnY2xpY2snOiAnY2xpY2tlZCcsXG4gICAgICAnZGJsY2xpY2snOiAnZGJsQ2xpY2tlZCcsXG4gICAgICAndG91Y2hlbmQnOiAnZGJsVGFwJyxcbiAgICAgICdjb250ZXh0bWVudSc6ICdvbkNvbnRleHRNZW51JyxcbiAgICAgICdtb3VzZWVudGVyJzogJ21vdXNlRW50ZXInLFxuICAgICAgJ21vdXNlbGVhdmUnOiAnbW91c2VMZWF2ZSdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBwbGF5YmFjayBoYXMgZW5kZWQuXG4gICAqIEBwcm9wZXJ0eSBlbmRlZFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2suZW5kZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXliYWNrIGlzIGhhdmluZyB0byBidWZmZXIgaW4gb3JkZXIgZm9yXG4gICAqIHBsYXliYWNrIHRvIGJlIHNtb290aC5cbiAgICogKGkuZSBpZiBhIGxpdmUgc3RyZWFtIGlzIHBsYXlpbmcgc21vb3RobHksIHRoaXMgd2lsbCBiZSBmYWxzZSlcbiAgICogQHByb3BlcnR5IGJ1ZmZlcmluZ1xuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgYnVmZmVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrLmJ1ZmZlcmluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnRlcm5hdGlvbmFsaXphdGlvbiBwbHVnaW4uXG4gICAqIEBwcm9wZXJ0eSBpMThuXG4gICAqIEB0eXBlIHtTdHJpbmdzfVxuICAgKi9cbiAgZ2V0IGkxOG4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2kxOG5cbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgaGFzIGNsb3NlZCBjYXB0aW9uIHRyYWNrcy5cbiAgICogQHByb3BlcnR5IGhhc0Nsb3NlZENhcHRpb25zVHJhY2tzXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGhhc0Nsb3NlZENhcHRpb25zVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrLmhhc0Nsb3NlZENhcHRpb25zVHJhY2tzXG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgYXZhaWxhYmxlIGNsb3NlZCBjYXB0aW9uIHRyYWNrcy5cbiAgICogQHByb3BlcnR5IGNsb3NlZENhcHRpb25zVHJhY2tzXG4gICAqIEB0eXBlIHtBcnJheX0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGF0IGxlYXN0ICdpZCcgYW5kICduYW1lJyBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXQgY2xvc2VkQ2FwdGlvbnNUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2suY2xvc2VkQ2FwdGlvbnNUcmFja3NcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRzIHRoZSBzZWxlY3RlZCBjbG9zZWQgY2FwdGlvbiB0cmFjayBpbmRleC4gKC0xIGlzIGRpc2FibGVkKVxuICAgKiBAcHJvcGVydHkgY2xvc2VkQ2FwdGlvbnNUcmFja0lkXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY2xvc2VkQ2FwdGlvbnNUcmFja0lkKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrLmNsb3NlZENhcHRpb25zVHJhY2tJZFxuICB9XG5cbiAgLyoqXG4gICAqIHNldHMgdGhlIHNlbGVjdGVkIGNsb3NlZCBjYXB0aW9uIHRyYWNrIGluZGV4LiAoLTEgaXMgZGlzYWJsZWQpXG4gICAqIEBwcm9wZXJ0eSBjbG9zZWRDYXB0aW9uc1RyYWNrSWRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBjbG9zZWRDYXB0aW9uc1RyYWNrSWQodHJhY2tJZCkge1xuICAgIHRoaXMucGxheWJhY2suY2xvc2VkQ2FwdGlvbnNUcmFja0lkID0gdHJhY2tJZFxuICB9XG5cbiAgLyoqXG4gICAqIGl0IGJ1aWxkcyBhIGNvbnRhaW5lclxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ3N9IGkxOG4gdGhlIGludGVybmF0aW9uYWxpemF0aW9uIGNvbXBvbmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaTE4biwgcGxheWVyRXJyb3IpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMuX2kxOG4gPSBpMThuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDBcbiAgICB0aGlzLnZvbHVtZSA9IDEwMFxuICAgIHRoaXMucGxheWJhY2sgPSBvcHRpb25zLnBsYXliYWNrXG4gICAgdGhpcy5wbGF5ZXJFcnJvciA9IHBsYXllckVycm9yXG4gICAgdGhpcy5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLnBsYXliYWNrLnNldHRpbmdzKVxuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlXG4gICAgdGhpcy5tZWRpYUNvbnRyb2xEaXNhYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5wbHVnaW5zID0gW3RoaXMucGxheWJhY2tdXG4gICAgdGhpcy5kYmxUYXBIYW5kbGVyID0gbmV3IERvdWJsZUV2ZW50SGFuZGxlcig1MDApXG4gICAgdGhpcy5jbGlja1RpbWVyID0gbnVsbFxuICAgIHRoaXMuY2xpY2tEZWxheSA9IDIwMCAgLy8gRklYTUU6IGNvdWxkIGJlIGEgcGxheWVyIG9wdGlvblxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cblxuICAvKipcbiAgICogYmluZHMgcGxheWJhY2sgZXZlbnRzIHRvIHRoZSBtZXRob2RzIG9mIHRoZSBjb250YWluZXIuXG4gICAqIGl0IGxpc3RlbnMgdG8gcGxheWJhY2sncyBldmVudHMgYW5kIHRyaWdnZXJzIHRoZW0gYXMgY29udGFpbmVyIGV2ZW50cy5cbiAgICpcbiAgICogfCBQbGF5YmFjayB8XG4gICAqIHwtLS0tLS0tLS0tfFxuICAgKiB8IHByb2dyZXNzIHxcbiAgICogfCB0aW1ldXBkYXRlIHxcbiAgICogfCByZWFkeSB8XG4gICAqIHwgYnVmZmVyaW5nIHxcbiAgICogfCBidWZmZXJmdWxsIHxcbiAgICogfCBzZXR0aW5nc3VwZGF0ZSB8XG4gICAqIHwgbG9hZGVkbWV0YWRhdGEgfFxuICAgKiB8IGhpZ2hkZWZpbml0aW9udXBkYXRlIHxcbiAgICogfCBiaXRyYXRlIHxcbiAgICogfCBwbGF5YmFja3N0YXRlIHxcbiAgICogfCBkdnIgfFxuICAgKiB8IG1lZGlhY29udHJvbF9kaXNhYmxlIHxcbiAgICogfCBtZWRpYWNvbnRyb2xfZW5hYmxlIHxcbiAgICogfCBlbmRlZCB8XG4gICAqIHwgcGxheSB8XG4gICAqIHwgcGF1c2UgfFxuICAgKiB8IGVycm9yIHxcbiAgICpcbiAgICogcHM6IHRoZSBldmVudHMgdXN1YWxseSB0cmFuc2xhdGUgZnJvbSBQTEFCQUNLX3ggdG8gQ09OVEFJTkVSX3gsIHlvdSBjYW4gY2hlY2sgYWxsIHRoZSBldmVudHMgYXQgYEV2ZW50YCBjbGFzcy5cbiAgICpcbiAgICogQG1ldGhvZCBiaW5kRXZlbnRzXG4gICAqL1xuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX1BST0dSRVNTLCB0aGlzLm9uUHJvZ3Jlc3MpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnBsYXliYWNrLCBFdmVudHMuUExBWUJBQ0tfVElNRVVQREFURSwgdGhpcy50aW1lVXBkYXRlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19SRUFEWSwgdGhpcy5yZWFkeSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19CVUZGRVJJTkcsIHRoaXMub25CdWZmZXJpbmcpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnBsYXliYWNrLCBFdmVudHMuUExBWUJBQ0tfQlVGRkVSRlVMTCwgdGhpcy5idWZmZXJmdWxsKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX1NFVFRJTkdTVVBEQVRFLCB0aGlzLnNldHRpbmdzVXBkYXRlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX0xPQURFRE1FVEFEQVRBLCB0aGlzLmxvYWRlZE1ldGFkYXRhKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX0hJR0hERUZJTklUSU9OVVBEQVRFLCB0aGlzLmhpZ2hEZWZpbml0aW9uVXBkYXRlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX0JJVFJBVEUsIHRoaXMudXBkYXRlQml0cmF0ZSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19QTEFZQkFDS1NUQVRFLCB0aGlzLnBsYXliYWNrU3RhdGVDaGFuZ2VkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX0RWUiwgdGhpcy5wbGF5YmFja0R2clN0YXRlQ2hhbmdlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19NRURJQUNPTlRST0xfRElTQUJMRSwgdGhpcy5kaXNhYmxlTWVkaWFDb250cm9sKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX01FRElBQ09OVFJPTF9FTkFCTEUsIHRoaXMuZW5hYmxlTWVkaWFDb250cm9sKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX1NFRUtFRCwgdGhpcy5vblNlZWtlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19FTkRFRCwgdGhpcy5vbkVuZGVkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX1BMQVksIHRoaXMucGxheWluZylcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19QQVVTRSwgdGhpcy5wYXVzZWQpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnBsYXliYWNrLCBFdmVudHMuUExBWUJBQ0tfU1RPUCwgdGhpcy5zdG9wcGVkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX0VSUk9SLCB0aGlzLmVycm9yKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5wbGF5YmFjaywgRXZlbnRzLlBMQVlCQUNLX1NVQlRJVExFX0FWQUlMQUJMRSwgdGhpcy5zdWJ0aXRsZUF2YWlsYWJsZSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19TVUJUSVRMRV9DSEFOR0VELCB0aGlzLnN1YnRpdGxlQ2hhbmdlZClcbiAgfVxuXG4gIHN1YnRpdGxlQXZhaWxhYmxlKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1NVQlRJVExFX0FWQUlMQUJMRSlcbiAgfVxuXG4gIHN1YnRpdGxlQ2hhbmdlZCh0cmFjaykge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1NVQlRJVExFX0NIQU5HRUQsIHRyYWNrKVxuICB9XG5cbiAgcGxheWJhY2tTdGF0ZUNoYW5nZWQoc3RhdGUpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9QTEFZQkFDS1NUQVRFLCBzdGF0ZSlcbiAgfVxuXG4gIHBsYXliYWNrRHZyU3RhdGVDaGFuZ2VkKGR2ckluVXNlKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMucGxheWJhY2suc2V0dGluZ3NcbiAgICB0aGlzLmR2ckluVXNlID0gZHZySW5Vc2VcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9QTEFZQkFDS0RWUlNUQVRFQ0hBTkdFRCwgZHZySW5Vc2UpXG4gIH1cblxuICB1cGRhdGVCaXRyYXRlKG5ld0JpdHJhdGUpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9CSVRSQVRFLCBuZXdCaXRyYXRlKVxuICB9XG5cbiAgc3RhdHNSZXBvcnQobWV0cmljcykge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1NUQVRTX1JFUE9SVCwgbWV0cmljcylcbiAgfVxuXG4gIGdldFBsYXliYWNrVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFjay5nZXRQbGF5YmFja1R5cGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYHRydWVgIGlmIERWUiBpcyBlbmFibGUgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqIEBtZXRob2QgaXNEdnJFbmFibGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0R2ckVuYWJsZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wbGF5YmFjay5kdnJFbmFibGVkXG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBgdHJ1ZWAgaWYgRFZSIGlzIGluIHVzZSBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICogQG1ldGhvZCBpc0R2ckluVXNlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0R2ckluVXNlKCkge1xuICAgIHJldHVybiAhIXRoaXMuZHZySW5Vc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBkZXN0cm95cyB0aGUgY29udGFpbmVyXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9ERVNUUk9ZRUQsIHRoaXMsIHRoaXMubmFtZSlcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHBsdWdpbi5kZXN0cm95KCkpXG4gICAgdGhpcy4kZWwucmVtb3ZlKClcbiAgfVxuXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy4kZWwuY3NzKHN0eWxlKVxuICB9XG5cbiAgYW5pbWF0ZShzdHlsZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy4kZWwuYW5pbWF0ZShzdHlsZSwgZHVyYXRpb24pLnByb21pc2UoKVxuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1JFQURZLCB0aGlzLm5hbWUpXG4gIH1cblxuICBpc1BsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2suaXNQbGF5aW5nKClcbiAgfVxuXG4gIGdldFN0YXJ0VGltZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFjay5nZXRTdGFydFRpbWVPZmZzZXQoKVxuICB9XG5cbiAgZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWVcbiAgfVxuXG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrLmdldER1cmF0aW9uKClcbiAgfVxuXG4gIGVycm9yKGVycm9yKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpXG4gICAgICB0aGlzLnJlYWR5KClcblxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX0VSUk9SLCBlcnJvciwgdGhpcy5uYW1lKVxuICB9XG5cbiAgbG9hZGVkTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9MT0FERURNRVRBREFUQSwgbWV0YWRhdGEpXG4gIH1cblxuICB0aW1lVXBkYXRlZCh0aW1lUHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZVByb2dyZXNzLmN1cnJlbnRcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9USU1FVVBEQVRFLCB0aW1lUHJvZ3Jlc3MsIHRoaXMubmFtZSlcbiAgfVxuXG4gIG9uUHJvZ3Jlc3MoLi4uYXJncykge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1BST0dSRVNTLCAuLi5hcmdzLCB0aGlzLm5hbWUpXG4gIH1cblxuICBwbGF5aW5nKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1BMQVksIHRoaXMubmFtZSlcbiAgfVxuXG4gIHBhdXNlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9QQVVTRSwgdGhpcy5uYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIHBsYXlzIHRoZSBwbGF5YmFja1xuICAgKiBAbWV0aG9kIHBsYXlcbiAgICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5wbGF5YmFjay5wbGF5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBzdG9wcyB0aGUgcGxheWJhY2tcbiAgICogQG1ldGhvZCBzdG9wXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMucGxheWJhY2suc3RvcCgpXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXVzZXMgdGhlIHBsYXliYWNrXG4gICAqIEBtZXRob2QgcGF1c2VcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHRoaXMucGxheWJhY2sucGF1c2UoKVxuICB9XG5cbiAgb25FbmRlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9FTkRFRCwgdGhpcywgdGhpcy5uYW1lKVxuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwXG4gIH1cblxuICBzdG9wcGVkKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1NUT1ApXG4gIH1cblxuICBjbGlja2VkKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNocm9tZWxlc3MgfHwgdGhpcy5vcHRpb25zLmFsbG93VXNlckludGVyYWN0aW9uKSB7XG4gICAgICAvLyBUaGUgZXZlbnQgaXMgZGVsYXllZCBiZWNhdXNlIGl0IGNhbiBiZSBjYW5jZWxlZCBieSBhIGRvdWJsZS1jbGljayBldmVudFxuICAgICAgLy8gQW4gZXhhbXBsZSBvZiB1c2UgaXMgdG8gcHJldmVudCBwbGF5YmFjayBmcm9tIHBhdXNpbmcgd2hlbiBzd2l0Y2hpbmcgdG8gZnVsbCBzY3JlZW5cbiAgICAgIHRoaXMuY2xpY2tUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWNrVGltZXIgJiYgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfQ0xJQ0ssIHRoaXMsIHRoaXMubmFtZSlcbiAgICAgIH0sIHRoaXMuY2xpY2tEZWxheSlcbiAgICB9XG4gIH1cblxuICBjYW5jZWxDbGlja2VkKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZXIpXG4gICAgdGhpcy5jbGlja1RpbWVyID0gbnVsbFxuICB9XG5cbiAgZGJsQ2xpY2tlZCgpIHtcbiAgICBpZiAoKCF0aGlzLm9wdGlvbnMuY2hyb21lbGVzcyB8fCB0aGlzLm9wdGlvbnMuYWxsb3dVc2VySW50ZXJhY3Rpb24pICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZURibENsaWNrRnVsbHNjcmVlbikge1xuICAgICAgdGhpcy5jYW5jZWxDbGlja2VkKClcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX0RCTENMSUNLLCB0aGlzLCB0aGlzLm5hbWUpXG4gICAgfVxuICB9XG5cbiAgZGJsVGFwKGV2dCkge1xuICAgIGlmICgoIXRoaXMub3B0aW9ucy5jaHJvbWVsZXNzIHx8IHRoaXMub3B0aW9ucy5hbGxvd1VzZXJJbnRlcmFjdGlvbikgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlRGJsQ2xpY2tGdWxsc2NyZWVuKSB7XG4gICAgICB0aGlzLmRibFRhcEhhbmRsZXIuaGFuZGxlKGV2dCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNhbmNlbENsaWNrZWQoKVxuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9EQkxDTElDSywgdGhpcywgdGhpcy5uYW1lKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2hyb21lbGVzcyB8fCB0aGlzLm9wdGlvbnMuYWxsb3dVc2VySW50ZXJhY3Rpb24pXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9DT05URVhUTUVOVSwgZXZlbnQsIHRoaXMubmFtZSlcblxuICB9XG5cbiAgc2Vlayh0aW1lKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfU0VFSywgdGltZSwgdGhpcy5uYW1lKVxuICAgIHRoaXMucGxheWJhY2suc2Vlayh0aW1lKVxuICB9XG5cbiAgb25TZWVrZWQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfU0VFS0VELCB0aGlzLm5hbWUpXG4gIH1cblxuICBzZWVrUGVyY2VudGFnZShwZXJjZW50YWdlKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmdldER1cmF0aW9uKClcbiAgICBpZiAocGVyY2VudGFnZSA+PSAwICYmIHBlcmNlbnRhZ2UgPD0gMTAwKSB7XG4gICAgICBjb25zdCB0aW1lID0gZHVyYXRpb24gKiAocGVyY2VudGFnZSAvIDEwMClcbiAgICAgIHRoaXMuc2Vlayh0aW1lKVxuICAgIH1cbiAgfVxuXG4gIHNldFZvbHVtZSh2YWx1ZSkge1xuICAgIHRoaXMudm9sdW1lID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9WT0xVTUUsIHRoaXMudm9sdW1lLCB0aGlzLm5hbWUpXG4gICAgdGhpcy5wbGF5YmFjay52b2x1bWUodGhpcy52b2x1bWUpXG4gIH1cblxuICBmdWxsc2NyZWVuKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX0ZVTExTQ1JFRU4sIHRoaXMubmFtZSlcbiAgfVxuXG4gIG9uQnVmZmVyaW5nKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX1NUQVRFX0JVRkZFUklORywgdGhpcy5uYW1lKVxuICB9XG5cbiAgYnVmZmVyZnVsbCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPTlRBSU5FUl9TVEFURV9CVUZGRVJGVUxMLCB0aGlzLm5hbWUpXG4gIH1cblxuICAvKipcbiAgICogYWRkcyBwbHVnaW4gdG8gdGhlIGNvbnRhaW5lclxuICAgKiBAbWV0aG9kIGFkZFBsdWdpblxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gICAqL1xuICBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKVxuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiBhIHBsdWdpbiwgZ2l2ZW4gaXRzIG5hbWUsIGV4aXN0XG4gICAqIEBtZXRob2QgaGFzUGx1Z2luXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNQbHVnaW4obmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0UGx1Z2luKG5hbWUpXG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBwbHVnaW4gZ2l2ZW4gaXRzIG5hbWVcbiAgICogQG1ldGhvZCBnZXRQbHVnaW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIGdldFBsdWdpbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5uYW1lID09PSBuYW1lKVswXVxuICB9XG5cbiAgbW91c2VFbnRlcigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jaHJvbWVsZXNzIHx8IHRoaXMub3B0aW9ucy5hbGxvd1VzZXJJbnRlcmFjdGlvbilcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX01PVVNFX0VOVEVSKVxuXG4gIH1cblxuICBtb3VzZUxlYXZlKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmNocm9tZWxlc3MgfHwgdGhpcy5vcHRpb25zLmFsbG93VXNlckludGVyYWN0aW9uKVxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfTU9VU0VfTEVBVkUpXG5cbiAgfVxuXG4gIHNldHRpbmdzVXBkYXRlKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB0aGlzLnBsYXliYWNrLnNldHRpbmdzXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfU0VUVElOR1NVUERBVEUpXG4gIH1cblxuICBoaWdoRGVmaW5pdGlvblVwZGF0ZShpc0hEKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfSElHSERFRklOSVRJT05VUERBVEUsIGlzSEQpXG4gIH1cblxuICBpc0hpZ2hEZWZpbml0aW9uSW5Vc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2suaXNIaWdoRGVmaW5pdGlvbkluVXNlKClcbiAgfVxuXG4gIGRpc2FibGVNZWRpYUNvbnRyb2woKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhQ29udHJvbERpc2FibGVkKSB7XG4gICAgICB0aGlzLm1lZGlhQ29udHJvbERpc2FibGVkID0gdHJ1ZVxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfTUVESUFDT05UUk9MX0RJU0FCTEUpXG4gICAgfVxuICB9XG5cbiAgZW5hYmxlTWVkaWFDb250cm9sKCkge1xuICAgIGlmICh0aGlzLm1lZGlhQ29udHJvbERpc2FibGVkKSB7XG4gICAgICB0aGlzLm1lZGlhQ29udHJvbERpc2FibGVkID0gZmFsc2VcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX01FRElBQ09OVFJPTF9FTkFCTEUpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3R5bGUoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY2hyb21lbGVzcyB8fCB0aGlzLm9wdGlvbnMuYWxsb3dVc2VySW50ZXJhY3Rpb24pXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnY2hyb21lbGVzcycpXG4gICAgZWxzZVxuICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2Nocm9tZWxlc3MnKVxuXG4gIH1cblxuICAvKipcbiAgICogZW5hYmxlcyB0byBjb25maWd1cmUgdGhlIGNvbnRhaW5lciBhZnRlciBpdHMgY3JlYXRpb25cbiAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWxsIHRoZSBvcHRpb25zIHRvIGNoYW5nZSBpbiBmb3JtIG9mIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICovXG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpXG4gICAgdGhpcy51cGRhdGVTdHlsZSgpXG4gICAgdGhpcy5wbGF5YmFjay5jb25maWd1cmUodGhpcy5vcHRpb25zKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX09QVElPTlNfQ0hBTkdFKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLnBsYXliYWNrLnJlbmRlcigpLmVsKVxuICAgIHRoaXMudXBkYXRlU3R5bGUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihDb250YWluZXIucHJvdG90eXBlLCBFcnJvck1peGluKVxuIiwiaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbnRhaW5lcidcbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lclxuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJzaW5nbGV0b25cIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbi8qKlxuICogVGhlIENvbnRhaW5lckZhY3RvcnkgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnZSBwbGF5YmFjayBib290c3RyYXAgYW5kIGNyZWF0ZSBjb250YWluZXJzLlxuICovXG5cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uLy4uL2Jhc2UvYmFzZV9vYmplY3QnXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvbnRhaW5lcidcbmltcG9ydCAkIGZyb20gJ2NsYXBwci16ZXB0bydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGFpbmVyRmFjdG9yeSBleHRlbmRzIEJhc2VPYmplY3Qge1xuICBnZXQgb3B0aW9ucygpIHsgcmV0dXJuIHRoaXMuX29wdGlvbnMgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7IHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBsb2FkZXIsIGkxOG4sIHBsYXllckVycm9yKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLl9pMThuID0gaTE4blxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyXG4gICAgdGhpcy5wbGF5ZXJFcnJvciA9IHBsYXllckVycm9yXG4gIH1cblxuICBjcmVhdGVDb250YWluZXJzKCkge1xuICAgIHJldHVybiAkLkRlZmVycmVkKChwcm9taXNlKSA9PiB7XG4gICAgICBwcm9taXNlLnJlc29sdmUodGhpcy5vcHRpb25zLnNvdXJjZXMubWFwKChzb3VyY2UpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29udGFpbmVyKHNvdXJjZSlcbiAgICAgIH0pKVxuICAgIH0pXG4gIH1cblxuICBmaW5kUGxheWJhY2tQbHVnaW4oc291cmNlLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlci5wbGF5YmFja1BsdWdpbnMuZmlsdGVyKHAgPT4gcC5jYW5QbGF5KHNvdXJjZSwgbWltZVR5cGUpKVswXVxuICB9XG5cbiAgY3JlYXRlQ29udGFpbmVyKHNvdXJjZSkge1xuICAgIGxldCByZXNvbHZlZFNvdXJjZSA9IG51bGwsXG4gICAgICBtaW1lVHlwZSA9IHRoaXMub3B0aW9ucy5taW1lVHlwZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzb2x2ZWRTb3VyY2UgPSBzb3VyY2Uuc291cmNlLnRvU3RyaW5nKClcbiAgICAgIGlmIChzb3VyY2UubWltZVR5cGUpXG4gICAgICAgIG1pbWVUeXBlID0gc291cmNlLm1pbWVUeXBlXG5cbiAgICB9IGVsc2UgeyByZXNvbHZlZFNvdXJjZSA9IHNvdXJjZS50b1N0cmluZygpIH1cblxuXG4gICAgaWYgKHJlc29sdmVkU291cmNlLm1hdGNoKC9eXFwvXFwvLykpIHJlc29sdmVkU291cmNlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgcmVzb2x2ZWRTb3VyY2VcblxuICAgIGxldCBvcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgc3JjOiByZXNvbHZlZFNvdXJjZSxcbiAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZVxuICAgIH0pXG4gICAgY29uc3QgcGxheWJhY2tQbHVnaW4gPSB0aGlzLmZpbmRQbGF5YmFja1BsdWdpbihyZXNvbHZlZFNvdXJjZSwgbWltZVR5cGUpXG4gICAgY29uc3QgcGxheWJhY2sgPSBuZXcgcGxheWJhY2tQbHVnaW4ob3B0aW9ucywgdGhpcy5faTE4biwgdGhpcy5wbGF5ZXJFcnJvcilcblxuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywgeyBwbGF5YmFjazogcGxheWJhY2sgfSlcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIob3B0aW9ucywgdGhpcy5faTE4biwgdGhpcy5wbGF5ZXJFcnJvcilcbiAgICBjb25zdCBkZWZlciA9ICQuRGVmZXJyZWQoKVxuICAgIGRlZmVyLnByb21pc2UoY29udGFpbmVyKVxuICAgIHRoaXMuYWRkQ29udGFpbmVyUGx1Z2lucyhjb250YWluZXIpXG4gICAgdGhpcy5saXN0ZW5Ub09uY2UoY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1JFQURZLCAoKSA9PiBkZWZlci5yZXNvbHZlKGNvbnRhaW5lcikpXG4gICAgcmV0dXJuIGNvbnRhaW5lclxuICB9XG5cbiAgYWRkQ29udGFpbmVyUGx1Z2lucyhjb250YWluZXIpIHtcbiAgICB0aGlzLmxvYWRlci5jb250YWluZXJQbHVnaW5zLmZvckVhY2goKFBsdWdpbikgPT4ge1xuICAgICAgY29udGFpbmVyLmFkZFBsdWdpbihuZXcgUGx1Z2luKGNvbnRhaW5lcikpXG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IENvbnRhaW5lckZhY3RvcnkgZnJvbSAnLi9jb250YWluZXJfZmFjdG9yeSdcbmV4cG9ydCBkZWZhdWx0IENvbnRhaW5lckZhY3RvcnlcbiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCB7IGlzTnVtYmVyLCBGdWxsc2NyZWVuLCBEb21SZWN5Y2xlciB9IGZyb20gJy4uLy4uL2Jhc2UvdXRpbHMnXG5cbmltcG9ydCBTdHlsZXIgZnJvbSAnLi4vLi4vYmFzZS9zdHlsZXInXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IFVJT2JqZWN0IGZyb20gJy4uLy4uL2Jhc2UvdWlfb2JqZWN0J1xuaW1wb3J0IFVJQ29yZVBsdWdpbiBmcm9tICcuLi8uLi9iYXNlL3VpX2NvcmVfcGx1Z2luJ1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9icm93c2VyJ1xuaW1wb3J0IENvbnRhaW5lckZhY3RvcnkgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb250YWluZXJfZmFjdG9yeSdcbmltcG9ydCBNZWRpYXRvciBmcm9tICcuLi8uLi9jb21wb25lbnRzL21lZGlhdG9yJ1xuaW1wb3J0IFBsYXllckluZm8gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9wbGF5ZXJfaW5mbydcbmltcG9ydCBQbGF5ZXJFcnJvciBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Vycm9yJ1xuaW1wb3J0IEVycm9yTWl4aW4gZnJvbSAnLi4vLi4vYmFzZS9lcnJvcl9taXhpbidcblxuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuXG5pbXBvcnQgJy4vcHVibGljL3N0eWxlLnNjc3MnXG5pbXBvcnQgZm9udFN0eWxlIGZyb20gJy4vcHVibGljL2ZvbnRzLmNzcydcblxubGV0IHN0eWxlXG5cbi8qKlxuICogVGhlIENvcmUgaXMgcmVzcG9uc2libGUgdG8gbWFuYWdlIENvbnRhaW5lcnMsIHRoZSBtZWRpYXRvciwgTWVkaWFDb250cm9sXG4gKiBhbmQgdGhlIHBsYXllciBzdGF0ZS5cbiAqIEBjbGFzcyBDb3JlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFVJT2JqZWN0XG4gKiBAbW9kdWxlIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZSBleHRlbmRzIFVJT2JqZWN0IHtcbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnOiAnaGFuZGxlRnVsbHNjcmVlbkNoYW5nZScsXG4gICAgICAnbW91c2Vtb3ZlJzogJ29uTW91c2VNb3ZlJyxcbiAgICAgICdtb3VzZWxlYXZlJzogJ29uTW91c2VMZWF2ZSdcbiAgICB9XG4gIH1cblxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2RhdGEtcGxheWVyJzogJycsXG4gICAgICB0YWJpbmRleDogOTk5OVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdGhlIGNvcmUgaXMgcmVhZHkuXG4gICAqIEBwcm9wZXJ0eSBpc1JlYWR5XG4gICAqIEB0eXBlIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGNvcmUgaXMgcmVhZHksIG90aGVyd2lzZSBgZmFsc2VgXG4gICAqL1xuICBnZXQgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnJlYWR5XG4gIH1cblxuICAvKipcbiAgICogVGhlIGludGVybmF0aW9uYWxpemF0aW9uIHBsdWdpbi5cbiAgICogQHByb3BlcnR5IGkxOG5cbiAgICogQHR5cGUge1N0cmluZ3N9XG4gICAqL1xuICBnZXQgaTE4bigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW4oJ3N0cmluZ3MnKSB8fCB7IHQ6IChrZXkpID0+IGtleSB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhpcyBwcm9wZXJ0eSBjdXJyZW50bHkgZXhpc3RzIGZvciByZXRyb2NvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAgICogSWYgeW91IHdhbnQgdG8gYWNjZXNzIHRoZSBtZWRpYSBjb250cm9sIGluc3RhbmNlLCB1c2UgdGhlIG1ldGhvZCBnZXRQbHVnaW4oJ21lZGlhX2NvbnRyb2wnKS5cbiAgICovXG4gIGdldCBtZWRpYUNvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luKCdtZWRpYV9jb250cm9sJykgfHwgdGhpcy5kdW1teU1lZGlhQ29udHJvbFxuICB9XG5cbiAgZ2V0IGR1bW15TWVkaWFDb250cm9sKCkge1xuICAgIGlmICh0aGlzLl9kdW1teU1lZGlhQ29udHJvbCkgcmV0dXJuIHRoaXMuX2R1bW15TWVkaWFDb250cm9sXG4gICAgdGhpcy5fZHVtbXlNZWRpYUNvbnRyb2wgPSBuZXcgVUlDb3JlUGx1Z2luKHRoaXMpXG4gICAgcmV0dXJuIHRoaXMuX2R1bW15TWVkaWFDb250cm9sXG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgYWN0aXZlIGNvbnRhaW5lciByZWZlcmVuY2UuXG4gICAqIEBwcm9wZXJ0eSBhY3RpdmVDb250YWluZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldCBhY3RpdmVDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNvbnRhaW5lclxuICB9XG5cbiAgLyoqXG4gICAqIHNldHMgdGhlIGFjdGl2ZSBjb250YWluZXIgcmVmZXJlbmNlIGFuZCB0cmlnZ2VyIGEgZXZlbnQgd2l0aCB0aGUgbmV3IHJlZmVyZW5jZS5cbiAgICogQHByb3BlcnR5IGFjdGl2ZUNvbnRhaW5lclxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc2V0IGFjdGl2ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLl9hY3RpdmVDb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VELCB0aGlzLl9hY3RpdmVDb250YWluZXIpXG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgYWN0aXZlIHBsYXliYWNrIHJlZmVyZW5jZS5cbiAgICogQHByb3BlcnR5IGFjdGl2ZVBsYXliYWNrXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgYWN0aXZlUGxheWJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQ29udGFpbmVyICYmIHRoaXMuYWN0aXZlQ29udGFpbmVyLnBsYXliYWNrXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLnBsYXllckVycm9yID0gbmV3IFBsYXllckVycm9yKG9wdGlvbnMsIHRoaXMpXG4gICAgdGhpcy5jb25maWd1cmVEb21SZWN5Y2xlcigpXG4gICAgdGhpcy5wbGF5ZXJJbmZvID0gUGxheWVySW5mby5nZXRJbnN0YW5jZShvcHRpb25zLnBsYXllcklkKVxuICAgIHRoaXMuZmlyc3RSZXNpemUgPSB0cnVlXG4gICAgdGhpcy5wbHVnaW5zID0gW11cbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbXVxuICAgIC8vRklYTUUgZnVsbHNjcmVlbiBhcGkgc3Vja3NcbiAgICB0aGlzLl9ib3VuZEZ1bGxzY3JlZW5IYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKClcbiAgICAkKGRvY3VtZW50KS5iaW5kKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5fYm91bmRGdWxsc2NyZWVuSGFuZGxlcilcbiAgICAkKGRvY3VtZW50KS5iaW5kKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCB0aGlzLl9ib3VuZEZ1bGxzY3JlZW5IYW5kbGVyKVxuICAgICQoZG9jdW1lbnQpLmJpbmQoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl9ib3VuZEZ1bGxzY3JlZW5IYW5kbGVyKVxuICAgIEJyb3dzZXIuaXNNb2JpbGUgJiYgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIChvKSA9PiB7IHRoaXMuaGFuZGxlV2luZG93UmVzaXplKG8pIH0pXG4gIH1cblxuICBjb25maWd1cmVEb21SZWN5Y2xlcigpIHtcbiAgICBsZXQgcmVjeWNsZVZpZGVvID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wbGF5YmFjayAmJiB0aGlzLm9wdGlvbnMucGxheWJhY2sucmVjeWNsZVZpZGVvXG4gICAgRG9tUmVjeWNsZXIuY29uZmlndXJlKHsgcmVjeWNsZVZpZGVvIH0pXG4gIH1cblxuICBjcmVhdGVDb250YWluZXJzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZmVyID0gJC5EZWZlcnJlZCgpXG4gICAgdGhpcy5kZWZlci5wcm9taXNlKHRoaXMpXG4gICAgdGhpcy5jb250YWluZXJGYWN0b3J5ID0gbmV3IENvbnRhaW5lckZhY3Rvcnkob3B0aW9ucywgb3B0aW9ucy5sb2FkZXIsIHRoaXMuaTE4biwgdGhpcy5wbGF5ZXJFcnJvcilcbiAgICB0aGlzLnByZXBhcmVDb250YWluZXJzKClcbiAgfVxuXG4gIHByZXBhcmVDb250YWluZXJzKCkge1xuICAgIHRoaXMuY29udGFpbmVyRmFjdG9yeS5jcmVhdGVDb250YWluZXJzKClcbiAgICAgIC50aGVuKChjb250YWluZXJzKSA9PiB0aGlzLnNldHVwQ29udGFpbmVycyhjb250YWluZXJzKSlcbiAgICAgIC50aGVuKChjb250YWluZXJzKSA9PiB0aGlzLnJlc29sdmVPbkNvbnRhaW5lcnNSZWFkeShjb250YWluZXJzKSlcbiAgfVxuXG4gIHVwZGF0ZVNpemUoKSB7XG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4oKSA/IHRoaXMuc2V0RnVsbHNjcmVlbigpIDogdGhpcy5zZXRQbGF5ZXJTaXplKClcbiAgfVxuXG4gIHNldEZ1bGxzY3JlZW4oKSB7XG4gICAgaWYgKCFCcm93c2VyLmlzaU9TKSB7XG4gICAgICB0aGlzLiRlbC5hZGRDbGFzcygnZnVsbHNjcmVlbicpXG4gICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyKCdzdHlsZScpXG4gICAgICB0aGlzLnBsYXllckluZm8ucHJldmlvdXNTaXplID0geyB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLCBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oZWlnaHQgfVxuICAgICAgdGhpcy5wbGF5ZXJJbmZvLmN1cnJlbnRTaXplID0geyB3aWR0aDogJCh3aW5kb3cpLndpZHRoKCksIGhlaWdodDogJCh3aW5kb3cpLmhlaWdodCgpIH1cbiAgICB9XG4gIH1cblxuICBzZXRQbGF5ZXJTaXplKCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdmdWxsc2NyZWVuJylcbiAgICB0aGlzLnBsYXllckluZm8uY3VycmVudFNpemUgPSB0aGlzLnBsYXllckluZm8ucHJldmlvdXNTaXplXG4gICAgdGhpcy5wbGF5ZXJJbmZvLnByZXZpb3VzU2l6ZSA9IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9XG4gICAgdGhpcy5yZXNpemUodGhpcy5wbGF5ZXJJbmZvLmN1cnJlbnRTaXplKVxuICB9XG5cbiAgcmVzaXplKG9wdGlvbnMpIHtcbiAgICBpZiAoIWlzTnVtYmVyKG9wdGlvbnMuaGVpZ2h0KSAmJiAhaXNOdW1iZXIob3B0aW9ucy53aWR0aCkpICB7XG4gICAgICB0aGlzLmVsLnN0eWxlLmhlaWdodCA9IGAke29wdGlvbnMuaGVpZ2h0fWBcbiAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSBgJHtvcHRpb25zLndpZHRofWBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5zdHlsZS5oZWlnaHQgPSBgJHtvcHRpb25zLmhlaWdodH1weGBcbiAgICAgIHRoaXMuZWwuc3R5bGUud2lkdGggPSBgJHtvcHRpb25zLndpZHRofXB4YFxuICAgIH1cbiAgICB0aGlzLnBsYXllckluZm8ucHJldmlvdXNTaXplID0geyB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLCBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oZWlnaHQgfVxuICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGhcbiAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHRcbiAgICB0aGlzLnBsYXllckluZm8uY3VycmVudFNpemUgPSBvcHRpb25zXG4gICAgdGhpcy50cmlnZ2VyUmVzaXplKHRoaXMucGxheWVySW5mby5jdXJyZW50U2l6ZSlcbiAgfVxuXG4gIGVuYWJsZVJlc2l6ZU9ic2VydmVyKCkge1xuICAgIGNvbnN0IGNoZWNrU2l6ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyUmVzaXplKHsgd2lkdGg6IHRoaXMuZWwuY2xpZW50V2lkdGgsIGhlaWdodDogdGhpcy5lbC5jbGllbnRIZWlnaHQgfSlcbiAgICB9XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlckludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tTaXplQ2FsbGJhY2ssIDUwMClcbiAgfVxuXG4gIHRyaWdnZXJSZXNpemUobmV3U2l6ZSkge1xuICAgIGNvbnN0IHRoZXJlV2FzQ2hhbmdlID0gdGhpcy5maXJzdFJlc2l6ZSB8fCB0aGlzLm9sZEhlaWdodCAhPT0gbmV3U2l6ZS5oZWlnaHQgfHwgdGhpcy5vbGRXaWR0aCAhPT0gbmV3U2l6ZS53aWR0aFxuICAgIGlmICh0aGVyZVdhc0NoYW5nZSkge1xuICAgICAgdGhpcy5vbGRIZWlnaHQgPSBuZXdTaXplLmhlaWdodFxuICAgICAgdGhpcy5vbGRXaWR0aCA9IG5ld1NpemUud2lkdGhcbiAgICAgIHRoaXMucGxheWVySW5mby5jb21wdXRlZFNpemUgPSBuZXdTaXplXG4gICAgICB0aGlzLmZpcnN0UmVzaXplID0gZmFsc2VcbiAgICAgIE1lZGlhdG9yLnRyaWdnZXIoYCR7dGhpcy5vcHRpb25zLnBsYXllcklkfToke0V2ZW50cy5QTEFZRVJfUkVTSVpFfWAsIG5ld1NpemUpXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfUkVTSVpFLCBuZXdTaXplKVxuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVSZXNpemVPYnNlcnZlcigpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVySW50ZXJ2YWwgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLnJlc2l6ZU9ic2VydmVySW50ZXJ2YWwpXG4gIH1cblxuICByZXNvbHZlT25Db250YWluZXJzUmVhZHkoY29udGFpbmVycykge1xuICAgICQud2hlbi5hcHBseSgkLCBjb250YWluZXJzKS5kb25lKCgpID0+IHtcbiAgICAgIHRoaXMuZGVmZXIucmVzb2x2ZSh0aGlzKVxuICAgICAgdGhpcy5yZWFkeSA9IHRydWVcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09SRV9SRUFEWSlcbiAgICB9KVxuICB9XG5cbiAgYWRkUGx1Z2luKHBsdWdpbikge1xuICAgIHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbilcbiAgfVxuXG4gIGhhc1BsdWdpbihuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQbHVnaW4obmFtZSlcbiAgfVxuXG4gIGdldFBsdWdpbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbi5uYW1lID09PSBuYW1lKVswXVxuICB9XG5cbiAgbG9hZChzb3VyY2VzLCBtaW1lVHlwZSkge1xuICAgIHRoaXMub3B0aW9ucy5taW1lVHlwZSA9IG1pbWVUeXBlXG4gICAgc291cmNlcyA9IHNvdXJjZXMgJiYgc291cmNlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBzb3VyY2VzIDogW3NvdXJjZXNdXG4gICAgdGhpcy5vcHRpb25zLnNvdXJjZXMgPSBzb3VyY2VzXG4gICAgdGhpcy5jb250YWluZXJzLmZvckVhY2goKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLmRlc3Ryb3koKSlcbiAgICB0aGlzLmNvbnRhaW5lckZhY3Rvcnkub3B0aW9ucyA9ICQuZXh0ZW5kKHRoaXMub3B0aW9ucywgeyBzb3VyY2VzIH0pXG4gICAgdGhpcy5wcmVwYXJlQ29udGFpbmVycygpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZVJlc2l6ZU9ic2VydmVyKClcbiAgICB0aGlzLmNvbnRhaW5lcnMuZm9yRWFjaCgoY29udGFpbmVyKSA9PiBjb250YWluZXIuZGVzdHJveSgpKVxuICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHBsdWdpbi5kZXN0cm95KCkpXG4gICAgdGhpcy4kZWwucmVtb3ZlKClcbiAgICAkKGRvY3VtZW50KS51bmJpbmQoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl9ib3VuZEZ1bGxzY3JlZW5IYW5kbGVyKVxuICAgICQoZG9jdW1lbnQpLnVuYmluZCgnTVNGdWxsc2NyZWVuQ2hhbmdlJywgdGhpcy5fYm91bmRGdWxsc2NyZWVuSGFuZGxlcilcbiAgICAkKGRvY3VtZW50KS51bmJpbmQoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl9ib3VuZEZ1bGxzY3JlZW5IYW5kbGVyKVxuICAgIHRoaXMuc3RvcExpc3RlbmluZygpXG4gIH1cblxuICBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuQ09SRV9GVUxMU0NSRUVOLCB0aGlzLmlzRnVsbHNjcmVlbigpKVxuICAgIHRoaXMudXBkYXRlU2l6ZSgpXG4gIH1cblxuICBoYW5kbGVXaW5kb3dSZXNpemUoZXZlbnQpIHtcbiAgICBjb25zdCBvcmllbnRhdGlvbiA9ICh3aW5kb3cuaW5uZXJXaWR0aCA+IHdpbmRvdy5pbm5lckhlaWdodCkgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCdcbiAgICBpZiAodGhpcy5fc2NyZWVuT3JpZW50YXRpb24gPT09IG9yaWVudGF0aW9uKSByZXR1cm5cbiAgICB0aGlzLl9zY3JlZW5PcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uXG4gICAgdGhpcy50cmlnZ2VyUmVzaXplKHsgd2lkdGg6IHRoaXMuZWwuY2xpZW50V2lkdGgsIGhlaWdodDogdGhpcy5lbC5jbGllbnRIZWlnaHQgfSlcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfU0NSRUVOX09SSUVOVEFUSU9OX0NIQU5HRUQsIHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIG9yaWVudGF0aW9uOiB0aGlzLl9zY3JlZW5PcmllbnRhdGlvblxuICAgIH0pXG4gIH1cblxuICByZW1vdmVDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKGNvbnRhaW5lcilcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKChjKSA9PiBjICE9PSBjb250YWluZXIpXG4gIH1cblxuICBzZXR1cENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICB0aGlzLmxpc3RlblRvKGNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9ERVNUUk9ZRUQsIHRoaXMucmVtb3ZlQ29udGFpbmVyKVxuICAgIHRoaXMuY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcilcbiAgfVxuXG4gIHNldHVwQ29udGFpbmVycyhjb250YWluZXJzKSB7XG4gICAgY29udGFpbmVycy5mb3JFYWNoKHRoaXMuc2V0dXBDb250YWluZXIuYmluZCh0aGlzKSlcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfQ09OVEFJTkVSU19DUkVBVEVEKVxuICAgIHRoaXMucmVuZGVyQ29udGFpbmVycygpXG4gICAgdGhpcy5hY3RpdmVDb250YWluZXIgPSBjb250YWluZXJzWzBdXG4gICAgdGhpcy5yZW5kZXIoKVxuICAgIHRoaXMuYXBwZW5kVG9QYXJlbnQoKVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcnNcbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcnMoKSB7XG4gICAgdGhpcy5jb250YWluZXJzLmZvckVhY2goKGNvbnRhaW5lcikgPT4gdGhpcy5lbC5hcHBlbmRDaGlsZChjb250YWluZXIucmVuZGVyKCkuZWwpKVxuICB9XG5cbiAgY3JlYXRlQ29udGFpbmVyKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRmFjdG9yeS5jcmVhdGVDb250YWluZXIoc291cmNlLCBvcHRpb25zKVxuICAgIHRoaXMuc2V0dXBDb250YWluZXIoY29udGFpbmVyKVxuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoY29udGFpbmVyLnJlbmRlcigpLmVsKVxuICAgIHJldHVybiBjb250YWluZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBjdXJyZW50bHkgZXhpc3RzIGZvciByZXRyb2NvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAgICogSWYgeW91IHdhbnQgdGhlIGN1cnJlbnQgY29udGFpbmVyIHJlZmVyZW5jZSwgdXNlIHRoZSBhY3RpdmVDb250YWluZXIgZ2V0dGVyLlxuICAgKi9cbiAgZ2V0Q3VycmVudENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVDb250YWluZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIG1ldGhvZCBjdXJyZW50bHkgZXhpc3RzIGZvciByZXRyb2NvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAgICogSWYgeW91IHdhbnQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmVmZXJlbmNlLCB1c2UgdGhlIGFjdGl2ZVBsYXliYWNrIGdldHRlci5cbiAgICovXG4gIGdldEN1cnJlbnRQbGF5YmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVQbGF5YmFja1xuICB9XG5cbiAgZ2V0UGxheWJhY2tUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUNvbnRhaW5lciAmJiB0aGlzLmFjdGl2ZUNvbnRhaW5lci5nZXRQbGF5YmFja1R5cGUoKVxuICB9XG5cbiAgaXNGdWxsc2NyZWVuKCkge1xuICAgIC8vIEVuc3VyZSBjdXJyZW50IGluc3RhbmNlIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSBieSBjaGVja2luZyBmdWxsc2NyZWVuIGVsZW1lbnRcbiAgICBjb25zdCBlbCA9IEJyb3dzZXIuaXNpT1MgPyB0aGlzLmFjdGl2ZUNvbnRhaW5lciAmJiB0aGlzLmFjdGl2ZUNvbnRhaW5lci5lbCB8fCB0aGlzLmVsIDogdGhpcy5lbFxuICAgIHJldHVybiBGdWxsc2NyZWVuLmZ1bGxzY3JlZW5FbGVtZW50KCkgPT09IGVsXG4gIH1cblxuICB0b2dnbGVGdWxsc2NyZWVuKCkge1xuICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICBGdWxsc2NyZWVuLmNhbmNlbEZ1bGxzY3JlZW4oKVxuICAgICAgIUJyb3dzZXIuaXNpT1MgJiYgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoJ2Z1bGxzY3JlZW4gbm9jdXJzb3InKVxuICAgIH0gZWxzZSB7XG4gICAgICBGdWxsc2NyZWVuLnJlcXVlc3RGdWxsc2NyZWVuKEJyb3dzZXIuaXNpT1MgPyB0aGlzLmFjdGl2ZUNvbnRhaW5lci5lbCA6IHRoaXMuZWwpXG4gICAgICAhQnJvd3Nlci5pc2lPUyAmJiB0aGlzLiRlbC5hZGRDbGFzcygnZnVsbHNjcmVlbicpXG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfTU9VU0VfTU9WRSwgZXZlbnQpXG4gIH1cblxuICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkNPUkVfTU9VU0VfTEVBVkUsIGV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIGVuYWJsZXMgdG8gY29uZmlndXJlIHRoZSBjb250YWluZXIgYWZ0ZXIgaXRzIGNyZWF0aW9uXG4gICAqIEBtZXRob2QgY29uZmlndXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFsbCB0aGUgb3B0aW9ucyB0byBjaGFuZ2UgaW4gZm9ybSBvZiBhIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICBjb25maWd1cmUob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh0aGlzLl9vcHRpb25zLCBvcHRpb25zKVxuICAgIHRoaXMuY29uZmlndXJlRG9tUmVjeWNsZXIoKVxuXG4gICAgY29uc3Qgc291cmNlcyA9IG9wdGlvbnMuc291cmNlIHx8IG9wdGlvbnMuc291cmNlc1xuICAgIHNvdXJjZXMgJiYgdGhpcy5sb2FkKHNvdXJjZXMsIG9wdGlvbnMubWltZVR5cGUgfHwgdGhpcy5vcHRpb25zLm1pbWVUeXBlKVxuXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5DT1JFX09QVElPTlNfQ0hBTkdFLCBvcHRpb25zKSAvLyBUcmlnZ2VyIHdpdGggbmV3bHkgcHJvdmlkZWQgb3B0aW9uc1xuICAgIHRoaXMuY29udGFpbmVycy5mb3JFYWNoKChjb250YWluZXIpID0+IGNvbnRhaW5lci5jb25maWd1cmUodGhpcy5vcHRpb25zKSlcbiAgfVxuXG4gIGFwcGVuZFRvUGFyZW50KCkge1xuICAgIGxldCBoYXNDb3JlUGFyZW50ID0gdGhpcy4kZWwucGFyZW50KCkgJiYgdGhpcy4kZWwucGFyZW50KCkubGVuZ3RoXG4gICAgIWhhc0NvcmVQYXJlbnQgJiYgdGhpcy4kZWwuYXBwZW5kVG8odGhpcy5vcHRpb25zLnBhcmVudEVsZW1lbnQpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKCFzdHlsZSlcbiAgICAgIHN0eWxlID0gU3R5bGVyLmdldFN0eWxlRm9yKGZvbnRTdHlsZSwgeyBiYXNlVXJsOiB0aGlzLm9wdGlvbnMuYmFzZVVybCB9KVxuXG4gICAgJCgnaGVhZCcpLmFwcGVuZChzdHlsZSlcblxuICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aCB8fCB0aGlzLiRlbC53aWR0aCgpXG4gICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy4kZWwuaGVpZ2h0KClcbiAgICBjb25zdCBzaXplID0geyB3aWR0aDogdGhpcy5vcHRpb25zLndpZHRoLCBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oZWlnaHQgfVxuICAgIHRoaXMucGxheWVySW5mby5wcmV2aW91c1NpemUgPSB0aGlzLnBsYXllckluZm8uY3VycmVudFNpemUgPSB0aGlzLnBsYXllckluZm8uY29tcHV0ZWRTaXplID0gc2l6ZVxuICAgIHRoaXMudXBkYXRlU2l6ZSgpXG5cbiAgICB0aGlzLnByZXZpb3VzU2l6ZSA9IHsgd2lkdGg6IHRoaXMuJGVsLndpZHRoKCksIGhlaWdodDogdGhpcy4kZWwuaGVpZ2h0KCkgfVxuXG4gICAgdGhpcy5lbmFibGVSZXNpemVPYnNlcnZlcigpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oQ29yZS5wcm90b3R5cGUsIEVycm9yTWl4aW4pXG4iLCJpbXBvcnQgQ29yZSBmcm9tICcuL2NvcmUnXG5leHBvcnQgZGVmYXVsdCBDb3JlXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCU9YmFzZVVybCU+LzM4ODYxY2JhNjFjNjY3MzljMTQ1MmMzYTcxZTM5ODUyLnR0ZlwiOyIsInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJSb2JvdG9cXFwiO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIHNyYzogbG9jYWwoXFxcIlJvYm90b1xcXCIpLCBsb2NhbChcXFwiUm9ib3RvLVJlZ3VsYXJcXFwiKSwgdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL1JvYm90by50dGZcIikpICsgXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJzaW5nbGV0b25cIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uLy4uL2Jhc2UvYmFzZV9vYmplY3QnXG5pbXBvcnQgQ29yZSBmcm9tICcuLi9jb3JlJ1xuXG4vKipcbiAqIFRoZSBDb3JlIEZhY3RvcnkgaXMgcmVzcG9uc2libGUgZm9yIGluc3RhbnRpYXRlIHRoZSBjb3JlIGFuZCBpdCdzIHBsdWdpbnMuXG4gKiBAY2xhc3MgQ29yZUZhY3RvcnlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmFzZU9iamVjdFxuICogQG1vZHVsZSBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVGYWN0b3J5IGV4dGVuZHMgQmFzZU9iamVjdCB7XG5cbiAgZ2V0IGxvYWRlcigpIHsgcmV0dXJuIHRoaXMucGxheWVyLmxvYWRlciB9XG5cbiAgLyoqXG4gICAqIGl0IGJ1aWxkcyB0aGUgY29yZSBmYWN0b3J5XG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllciB0aGUgcGxheWVyIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IocGxheWVyKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucGxheWVyID0gcGxheWVyXG4gICAgdGhpcy5fb3B0aW9ucyA9IHBsYXllci5vcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlcyBhIGNvcmUgYW5kIGl0cyBwbHVnaW5zXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEByZXR1cm4ge0NvcmV9IGNyZWF0ZWQgY29yZVxuICAgKi9cbiAgY3JlYXRlKCkge1xuICAgIHRoaXMub3B0aW9ucy5sb2FkZXIgPSB0aGlzLmxvYWRlclxuICAgIHRoaXMuY29yZSA9IG5ldyBDb3JlKHRoaXMub3B0aW9ucylcbiAgICB0aGlzLmFkZENvcmVQbHVnaW5zKClcbiAgICB0aGlzLmNvcmUuY3JlYXRlQ29udGFpbmVycyh0aGlzLm9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMuY29yZVxuICB9XG5cbiAgLyoqXG4gICAqIGdpdmVuIHRoZSBjb3JlIHBsdWdpbnMgKGBsb2FkZXIuY29yZVBsdWdpbnNgKSBpdCBidWlsZHMgZWFjaCBvbmVcbiAgICogQG1ldGhvZCBhZGRDb3JlUGx1Z2luc1xuICAgKiBAcmV0dXJuIHtDb3JlfSB0aGUgY29yZSB3aXRoIGFsbCBwbHVnaW5zXG4gICAqL1xuICBhZGRDb3JlUGx1Z2lucygpIHtcbiAgICB0aGlzLmxvYWRlci5jb3JlUGx1Z2lucy5mb3JFYWNoKChQbHVnaW4pID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4odGhpcy5jb3JlKVxuICAgICAgdGhpcy5jb3JlLmFkZFBsdWdpbihwbHVnaW4pXG4gICAgICB0aGlzLnNldHVwRXh0ZXJuYWxJbnRlcmZhY2UocGx1Z2luKVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuY29yZVxuICB9XG5cbiAgc2V0dXBFeHRlcm5hbEludGVyZmFjZShwbHVnaW4pIHtcbiAgICBjb25zdCBleHRlcm5hbEZ1bmN0aW9ucyA9IHBsdWdpbi5nZXRFeHRlcm5hbEludGVyZmFjZSgpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZXJuYWxGdW5jdGlvbnMpIHtcbiAgICAgIHRoaXMucGxheWVyW2tleV0gPSBleHRlcm5hbEZ1bmN0aW9uc1trZXldLmJpbmQocGx1Z2luKVxuICAgICAgdGhpcy5jb3JlW2tleV0gPSBleHRlcm5hbEZ1bmN0aW9uc1trZXldLmJpbmQocGx1Z2luKVxuICAgIH1cblxuICB9XG59XG4iLCJpbXBvcnQgQ29yZUZhY3RvcnkgZnJvbSAnLi9jb3JlX2ZhY3RvcnknXG5leHBvcnQgZGVmYXVsdCBDb3JlRmFjdG9yeVxuIiwiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uLy4uL2Jhc2UvYmFzZV9vYmplY3QnXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3BsdWdpbnMvbG9nJ1xuXG4vKipcbiAqIFRoZSBQbGF5ZXJFcnJvciBpcyByZXNwb25zaWJsZSB0byByZWNlaXZlIGFuZCBwcm9wYWdhdGUgZXJyb3JzLlxuICogQGNsYXNzIFBsYXllckVycm9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJhc2VPYmplY3RcbiAqIEBtb2R1bGUgY29tcG9uZW50c1xuICovXG5jbGFzcyBQbGF5ZXJFcnJvciBleHRlbmRzIEJhc2VPYmplY3Qge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdlcnJvcicgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgTGV2ZWxzXG4gICAqIEB0eXBlIHtPYmplY3R9IG9iamVjdCB3aXRoIGVycm9yIGxldmVsc1xuICAgKi9cbiAgc3RhdGljIGdldCBMZXZlbHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEZBVEFMOiAnRkFUQUwnLFxuICAgICAgV0FSTjogJ1dBUk4nLFxuICAgICAgSU5GTzogJ0lORk8nLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM9e30sIGNvcmUpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIHRoaXMuY29yZSA9IGNvcmVcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuZCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgKiBAbWV0aG9kIGNyZWF0ZUVycm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGNvZGUsIGRlc2NyaXB0aW9uLCBsZXZlbCwgb3JpZ2luLCBzY29wZSBhbmQgcmF3IGVycm9yLlxuICAgKi9cbiAgY3JlYXRlRXJyb3IoZXJyKSB7XG4gICAgaWYgKCF0aGlzLmNvcmUpIHtcbiAgICAgIExvZy53YXJuKHRoaXMubmFtZSwgJ0NvcmUgaXMgbm90IHNldC4gRXJyb3I6ICcsIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmNvcmUudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXJFcnJvclxuIiwiaW1wb3J0IEVycm9yIGZyb20gJy4vZXJyb3InXG5leHBvcnQgZGVmYXVsdCBFcnJvclxuIiwiaW1wb3J0IExvYWRlciBmcm9tICcuL2xvYWRlcidcbmV4cG9ydCBkZWZhdWx0IExvYWRlclxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vLi4vYmFzZS9iYXNlX29iamVjdCdcbmltcG9ydCBQbGF5ZXJJbmZvIGZyb20gJy4uL3BsYXllcl9pbmZvJ1xuXG4vKiBQbGF5YmFjayBQbHVnaW5zICovXG5pbXBvcnQgSFRNTDVWaWRlb1BsYXliYWNrIGZyb20gJy4uLy4uL3BsYXliYWNrcy9odG1sNV92aWRlbydcbmltcG9ydCBIVE1MNUF1ZGlvUGxheWJhY2sgZnJvbSAnLi4vLi4vcGxheWJhY2tzL2h0bWw1X2F1ZGlvJ1xuaW1wb3J0IEhMU1ZpZGVvUGxheWJhY2sgZnJvbSAnLi4vLi4vcGxheWJhY2tzL2hscydcbmltcG9ydCBIVE1MSW1nUGxheWJhY2sgZnJvbSAnLi4vLi4vcGxheWJhY2tzL2h0bWxfaW1nJ1xuaW1wb3J0IE5vT3AgZnJvbSAnLi4vLi4vcGxheWJhY2tzL25vX29wJ1xuXG4vKiBDb250YWluZXIgUGx1Z2lucyAqL1xuaW1wb3J0IFNwaW5uZXJUaHJlZUJvdW5jZVBsdWdpbiBmcm9tICcuLi8uLi9wbHVnaW5zL3NwaW5uZXJfdGhyZWVfYm91bmNlJ1xuaW1wb3J0IFN0YXRzUGx1Z2luIGZyb20gJy4uLy4uL3BsdWdpbnMvc3RhdHMnXG5pbXBvcnQgV2F0ZXJNYXJrUGx1Z2luIGZyb20gJy4uLy4uL3BsdWdpbnMvd2F0ZXJtYXJrJ1xuaW1wb3J0IFBvc3RlclBsdWdpbiBmcm9tICcuLi8uLi9wbHVnaW5zL3Bvc3RlcidcbmltcG9ydCBHb29nbGVBbmFseXRpY3NQbHVnaW4gZnJvbSAnLi4vLi4vcGx1Z2lucy9nb29nbGVfYW5hbHl0aWNzJ1xuaW1wb3J0IENsaWNrVG9QYXVzZVBsdWdpbiBmcm9tICcuLi8uLi9wbHVnaW5zL2NsaWNrX3RvX3BhdXNlJ1xuXG4vKiBDb3JlIFBsdWdpbnMgKi9cbmltcG9ydCBNZWRpYUNvbnRyb2wgZnJvbSAnLi4vLi4vcGx1Z2lucy9tZWRpYV9jb250cm9sJ1xuaW1wb3J0IERWUkNvbnRyb2xzIGZyb20gJy4uLy4uL3BsdWdpbnMvZHZyX2NvbnRyb2xzJ1xuaW1wb3J0IENsb3NlZENhcHRpb25zIGZyb20gJy4uLy4uL3BsdWdpbnMvY2xvc2VkX2NhcHRpb25zJ1xuaW1wb3J0IEZhdmljb24gZnJvbSAnLi4vLi4vcGx1Z2lucy9mYXZpY29uJ1xuaW1wb3J0IFNlZWtUaW1lIGZyb20gJy4uLy4uL3BsdWdpbnMvc2Vla190aW1lJ1xuaW1wb3J0IFNvdXJjZXNQbHVnaW4gZnJvbSAnLi4vLi4vcGx1Z2lucy9zb3VyY2VzJ1xuaW1wb3J0IEVuZFZpZGVvIGZyb20gJy4uLy4uL3BsdWdpbnMvZW5kX3ZpZGVvJ1xuaW1wb3J0IFN0cmluZ3MgZnJvbSAnLi4vLi4vcGx1Z2lucy9zdHJpbmdzJ1xuaW1wb3J0IEVycm9yU2NyZWVuIGZyb20gJy4uLy4uL3BsdWdpbnMvZXJyb3Jfc2NyZWVuJ1xuXG4vKipcbiAqIEl0IGtlZXBzIGEgbGlzdCBvZiB0aGUgZGVmYXVsdCBwbHVnaW5zIChwbGF5YmFjaywgY29udGFpbmVyLCBjb3JlKSBhbmQgaXQgbWVyZ2VzIGV4dGVybmFsIHBsdWdpbnMgd2l0aCBpdHMgaW50ZXJuYWxzLlxuICogQGNsYXNzIExvYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCYXNlT2JqZWN0XG4gKiBAbW9kdWxlIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9hZGVyIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBidWlsZHMgdGhlIGxvYWRlclxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlcm5hbFBsdWdpbnMgdGhlIGV4dGVybmFsIHBsdWdpbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBsYXllcklkIHlvdSBjYW4gZW1iZWQgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIGNsYXBwciwgdGhlcmVmb3JlIHRoaXMgaXMgdGhlIHVuaXF1ZSBpZCBvZiBlYWNoIG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4dGVybmFsUGx1Z2lucyA9IFtdLCBwbGF5ZXJJZCA9IDAsIHVzZU9ubHlQbGFpbkh0bWw1UGx1Z2lucyA9IFBMQUlOX0hUTUw1X09OTFkpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5wbGF5ZXJJZCA9IHBsYXllcklkXG4gICAgdGhpcy5wbGF5YmFja1BsdWdpbnMgPSBbXVxuXG4gICAgaWYgKCF1c2VPbmx5UGxhaW5IdG1sNVBsdWdpbnMpIHtcbiAgICAgIHRoaXMucGxheWJhY2tQbHVnaW5zID0gW1xuICAgICAgICAuLi50aGlzLnBsYXliYWNrUGx1Z2lucyxcbiAgICAgICAgSExTVmlkZW9QbGF5YmFjayxcbiAgICAgIF1cbiAgICB9XG5cbiAgICB0aGlzLnBsYXliYWNrUGx1Z2lucyA9IFtcbiAgICAgIC4uLnRoaXMucGxheWJhY2tQbHVnaW5zLFxuICAgICAgSFRNTDVWaWRlb1BsYXliYWNrLFxuICAgICAgSFRNTDVBdWRpb1BsYXliYWNrLFxuICAgIF1cblxuICAgIHRoaXMucGxheWJhY2tQbHVnaW5zID0gW1xuICAgICAgLi4udGhpcy5wbGF5YmFja1BsdWdpbnMsXG4gICAgICBIVE1MSW1nUGxheWJhY2ssXG4gICAgICBOb09wXG4gICAgXVxuXG4gICAgdGhpcy5jb250YWluZXJQbHVnaW5zID0gW1NwaW5uZXJUaHJlZUJvdW5jZVBsdWdpbiwgV2F0ZXJNYXJrUGx1Z2luLCBQb3N0ZXJQbHVnaW4sIFN0YXRzUGx1Z2luLCBHb29nbGVBbmFseXRpY3NQbHVnaW4sIENsaWNrVG9QYXVzZVBsdWdpbl1cbiAgICB0aGlzLmNvcmVQbHVnaW5zID0gW01lZGlhQ29udHJvbCwgRFZSQ29udHJvbHMsIENsb3NlZENhcHRpb25zLCBGYXZpY29uLCBTZWVrVGltZSwgU291cmNlc1BsdWdpbiwgRW5kVmlkZW8sIEVycm9yU2NyZWVuLCBTdHJpbmdzXVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4dGVybmFsUGx1Z2lucykpXG4gICAgICB0aGlzLnZhbGlkYXRlRXh0ZXJuYWxQbHVnaW5zVHlwZShleHRlcm5hbFBsdWdpbnMpXG5cbiAgICB0aGlzLmFkZEV4dGVybmFsUGx1Z2lucyhleHRlcm5hbFBsdWdpbnMpXG4gIH1cblxuICAvKipcbiAgICogZ3JvdXBzIGJ5IHR5cGUgdGhlIGV4dGVybmFsIHBsdWdpbnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGBvcHRpb25zLnBsdWdpbnNgIGl0IHRoZXkncmUgb24gYSBmbGF0IGFycmF5XG4gICAqIEBtZXRob2QgYWRkRXh0ZXJuYWxQbHVnaW5zXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbiBjb25maWcgb2JqZWN0IG9yIGFuIGFycmF5IG9mIHBsdWdpbnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBwbHVnaW5zIHRoZSBjb25maWcgb2JqZWN0IHdpdGggdGhlIHBsdWdpbnMgc2VwYXJhdGVkIGJ5IHR5cGVcbiAgICovXG4gIGdyb3VwUGx1Z2luc0J5VHlwZShwbHVnaW5zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgIHBsdWdpbnMgPSBwbHVnaW5zLnJlZHVjZShmdW5jdGlvbihtZW1vLCBwbHVnaW4pIHtcbiAgICAgICAgbWVtb1twbHVnaW4udHlwZV0gfHwgKG1lbW9bcGx1Z2luLnR5cGVdID0gW10pXG4gICAgICAgIG1lbW9bcGx1Z2luLnR5cGVdLnB1c2gocGx1Z2luKVxuICAgICAgICByZXR1cm4gbWVtb1xuICAgICAgfSwge30pXG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zXG4gIH1cblxuICByZW1vdmVEdXBzKGxpc3QpIHtcbiAgICBjb25zdCBncm91cFVwID0gKHBsdWdpbnMsIHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luc1twbHVnaW4ucHJvdG90eXBlLm5hbWVdICYmIGRlbGV0ZSBwbHVnaW5zW3BsdWdpbi5wcm90b3R5cGUubmFtZV1cbiAgICAgIHBsdWdpbnNbcGx1Z2luLnByb3RvdHlwZS5uYW1lXSA9IHBsdWdpblxuICAgICAgcmV0dXJuIHBsdWdpbnNcbiAgICB9XG4gICAgY29uc3QgcGx1Z2luc01hcCA9IGxpc3QucmVkdWNlUmlnaHQoZ3JvdXBVcCwgT2JqZWN0LmNyZWF0ZShudWxsKSlcblxuICAgIGNvbnN0IHBsdWdpbnMgPSBbXVxuICAgIGZvciAobGV0IGtleSBpbiBwbHVnaW5zTWFwKVxuICAgICAgcGx1Z2lucy51bnNoaWZ0KHBsdWdpbnNNYXBba2V5XSlcblxuICAgIHJldHVybiBwbHVnaW5zXG4gIH1cblxuICAvKipcbiAgICogYWRkcyBhbGwgdGhlIGV4dGVybmFsIHBsdWdpbnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGBvcHRpb25zLnBsdWdpbnNgXG4gICAqIEBtZXRob2QgYWRkRXh0ZXJuYWxQbHVnaW5zXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5zIHRoZSBjb25maWcgb2JqZWN0IHdpdGggYWxsIHBsdWdpbnNcbiAgICovXG4gIGFkZEV4dGVybmFsUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgcGx1Z2lucyA9IHRoaXMuZ3JvdXBQbHVnaW5zQnlUeXBlKHBsdWdpbnMpXG4gICAgaWYgKHBsdWdpbnMucGxheWJhY2spXG4gICAgICB0aGlzLnBsYXliYWNrUGx1Z2lucyA9IHRoaXMucmVtb3ZlRHVwcyhwbHVnaW5zLnBsYXliYWNrLmNvbmNhdCh0aGlzLnBsYXliYWNrUGx1Z2lucykpXG5cbiAgICBpZiAocGx1Z2lucy5jb250YWluZXIpXG4gICAgICB0aGlzLmNvbnRhaW5lclBsdWdpbnMgPSB0aGlzLnJlbW92ZUR1cHMocGx1Z2lucy5jb250YWluZXIuY29uY2F0KHRoaXMuY29udGFpbmVyUGx1Z2lucykpXG5cbiAgICBpZiAocGx1Z2lucy5jb3JlKVxuICAgICAgdGhpcy5jb3JlUGx1Z2lucyA9IHRoaXMucmVtb3ZlRHVwcyhwbHVnaW5zLmNvcmUuY29uY2F0KHRoaXMuY29yZVBsdWdpbnMpKVxuXG5cbiAgICBQbGF5ZXJJbmZvLmdldEluc3RhbmNlKHRoaXMucGxheWVySWQpLnBsYXliYWNrUGx1Z2lucyA9IHRoaXMucGxheWJhY2tQbHVnaW5zXG4gIH1cblxuICAvKipcbiAgICogdmFsaWRhdGUgaWYgdGhlIGV4dGVybmFsIHBsdWdpbnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGBvcHRpb25zLnBsdWdpbnNgIGFyZSBhc3NvY2lhdGVkIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICogQG1ldGhvZCB2YWxpZGF0ZUV4dGVybmFsUGx1Z2luc1R5cGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbnMgdGhlIGNvbmZpZyBvYmplY3Qgd2l0aCBhbGwgcGx1Z2luc1xuICAgKi9cbiAgdmFsaWRhdGVFeHRlcm5hbFBsdWdpbnNUeXBlKHBsdWdpbnMpIHtcbiAgICBjb25zdCBwbHVnaW50eXBlcyA9IFsncGxheWJhY2snLCAnY29udGFpbmVyJywgJ2NvcmUnXVxuICAgIHBsdWdpbnR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIChwbHVnaW5zW3R5cGVdIHx8IFtdKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnZXh0ZXJuYWwgJyArIGVsLnR5cGUgKyAnIHBsdWdpbiBvbiAnICsgdHlwZSArICcgYXJyYXknXG4gICAgICAgIGlmIChlbC50eXBlICE9PSB0eXBlKSAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuLyoqXG4gKiBUaGUgbWVkaWF0b3IgaXMgYSBzaW5nbGV0b24gZm9yIGhhbmRsaW5nIGdsb2JhbCBldmVudHMuXG4gKi9cblxuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9iYXNlL2V2ZW50cydcblxuY29uc3QgZXZlbnRzID0gbmV3IEV2ZW50cygpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhdG9yIHtcbn1cblxuTWVkaWF0b3Iub24gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBldmVudHMub24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpXG4gIHJldHVyblxufVxuXG5NZWRpYXRvci5vbmNlID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgZXZlbnRzLm9uY2UobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpXG4gIHJldHVyblxufVxuXG5NZWRpYXRvci5vZmYgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICBldmVudHMub2ZmKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KVxuICByZXR1cm5cbn1cblxuTWVkaWF0b3IudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIC4uLm9wdHMpIHtcbiAgZXZlbnRzLnRyaWdnZXIuYXBwbHkoZXZlbnRzLCBbbmFtZSwgLi4ub3B0c10pXG4gIHJldHVyblxufVxuXG5NZWRpYXRvci5zdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICBldmVudHMuc3RvcExpc3RlbmluZyhvYmosIG5hbWUsIGNhbGxiYWNrKVxuICByZXR1cm5cbn1cbiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCB7IHVuaXF1ZUlkLCBjdXJyZW50U2NyaXB0VXJsIH0gZnJvbSAnLi4vYmFzZS91dGlscydcblxuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vYmFzZS9iYXNlX29iamVjdCdcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuL2Jyb3dzZXInXG5pbXBvcnQgQ29yZUZhY3RvcnkgZnJvbSAnLi9jb3JlX2ZhY3RvcnknXG5pbXBvcnQgTG9hZGVyIGZyb20gJy4vbG9hZGVyJ1xuaW1wb3J0IFBsYXllckluZm8gZnJvbSAnLi9wbGF5ZXJfaW5mbydcbmltcG9ydCBFcnJvck1peGluIGZyb20gJy4uL2Jhc2UvZXJyb3JfbWl4aW4nXG5pbXBvcnQgJCBmcm9tICdjbGFwcHItemVwdG8nXG5cbmNvbnN0IGJhc2VVcmwgPSBjdXJyZW50U2NyaXB0VXJsKCkucmVwbGFjZSgvXFwvW14vXSskLywgJycpXG5cbi8qKlxuICogQGNsYXNzIFBsYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCYXNlT2JqZWN0XG4gKiBAbW9kdWxlIGNvbXBvbmVudHNcbiAqIEBleGFtcGxlXG4gKiAjIyMgVXNpbmcgdGhlIFBsYXllclxuICpcbiAqIEFkZCB0aGUgZm9sbG93aW5nIHNjcmlwdCBvbiB5b3VyIEhUTUw6XG4gKiBgYGBodG1sXG4gKiA8aGVhZD5cbiAqICAgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwiaHR0cDovL2Nkbi5jbGFwcHIuaW8vbGF0ZXN0L2NsYXBwci5taW4uanNcIj48L3NjcmlwdD5cbiAqIDwvaGVhZD5cbiAqIGBgYFxuICogTm93LCBjcmVhdGUgdGhlIHBsYXllcjpcbiAqIGBgYGh0bWxcbiAqIDxib2R5PlxuICogICA8ZGl2IGlkPVwicGxheWVyXCI+PC9kaXY+XG4gKiAgIDxzY3JpcHQ+XG4gKiAgICAgdmFyIHBsYXllciA9IG5ldyBDbGFwcHIuUGxheWVyKHtzb3VyY2U6IFwiaHR0cDovL3lvdXIudmlkZW8vaGVyZS5tcDRcIiwgcGFyZW50SWQ6IFwiI3BsYXllclwifSk7XG4gKiAgIDwvc2NyaXB0PlxuICogPC9ib2R5PlxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXllciBleHRlbmRzIEJhc2VPYmplY3Qge1xuXG4gIHNldCBsb2FkZXIobG9hZGVyKSB7IHRoaXMuX2xvYWRlciA9IGxvYWRlciB9XG4gIGdldCBsb2FkZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9sb2FkZXIpXG4gICAgICB0aGlzLl9sb2FkZXIgPSBuZXcgTG9hZGVyKHRoaXMub3B0aW9ucy5wbHVnaW5zIHx8IHt9LCB0aGlzLm9wdGlvbnMucGxheWVySWQpXG5cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyXG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBwbGF5YmFjayBoYXMgZW5kZWQuXG4gICAqIEBwcm9wZXJ0eSBlbmRlZFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZS5hY3RpdmVDb250YWluZXIuZW5kZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXliYWNrIGlzIGhhdmluZyB0byBidWZmZXIgaW4gb3JkZXIgZm9yXG4gICAqIHBsYXliYWNrIHRvIGJlIHNtb290aC5cbiAgICogKGkuZSBpZiBhIGxpdmUgc3RyZWFtIGlzIHBsYXlpbmcgc21vb3RobHksIHRoaXMgd2lsbCBiZSBmYWxzZSlcbiAgICogQHByb3BlcnR5IGJ1ZmZlcmluZ1xuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgYnVmZmVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLmJ1ZmZlcmluZ1xuICB9XG5cbiAgLypcbiAgICogZGV0ZXJtaW5lIGlmIHRoZSBwbGF5ZXIgaXMgcmVhZHkuXG4gICAqIEBwcm9wZXJ0eSBpc1JlYWR5XG4gICAqIEB0eXBlIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHBsYXllciBpcyByZWFkeS4gaWUgUExBWUVSX1JFQURZIGV2ZW50IGhhcyBmaXJlZFxuICAgKi9cbiAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcmVhZHlcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBldmVudHMgbWFwIHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGFkZCBjdXN0b20gY2FsbGJhY2tzIGluIHBsYXllcidzIG9wdGlvbnMuXG4gICAqIEBwcm9wZXJ0eSBldmVudHNNYXBwaW5nXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgZXZlbnRzTWFwcGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25SZWFkeTogRXZlbnRzLlBMQVlFUl9SRUFEWSxcbiAgICAgIG9uUmVzaXplOiBFdmVudHMuUExBWUVSX1JFU0laRSxcbiAgICAgIG9uUGxheTogRXZlbnRzLlBMQVlFUl9QTEFZLFxuICAgICAgb25QYXVzZTogRXZlbnRzLlBMQVlFUl9QQVVTRSxcbiAgICAgIG9uU3RvcDogRXZlbnRzLlBMQVlFUl9TVE9QLFxuICAgICAgb25FbmRlZDogRXZlbnRzLlBMQVlFUl9FTkRFRCxcbiAgICAgIG9uU2VlazogRXZlbnRzLlBMQVlFUl9TRUVLLFxuICAgICAgb25FcnJvcjogRXZlbnRzLlBMQVlFUl9FUlJPUixcbiAgICAgIG9uVGltZVVwZGF0ZTogRXZlbnRzLlBMQVlFUl9USU1FVVBEQVRFLFxuICAgICAgb25Wb2x1bWVVcGRhdGU6IEV2ZW50cy5QTEFZRVJfVk9MVU1FVVBEQVRFLFxuICAgICAgb25TdWJ0aXRsZUF2YWlsYWJsZTogRXZlbnRzLlBMQVlFUl9TVUJUSVRMRV9BVkFJTEFCTEVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUGxheWJhY2tDb25maWdcbiAgICogQHByb3Age2Jvb2xlYW59IGRpc2FibGVDb250ZXh0TWVudVxuICAgKiBkaXNhYmxlcyB0aGUgY29udGV4dCBtZW51IChyaWdodCBjbGljaykgb24gdGhlIHZpZGVvIGVsZW1lbnQgaWYgYSBIVE1MNVZpZGVvIHBsYXliYWNrIGlzIHVzZWQuXG4gICAqIEBwcm9wIHtib29sZWFufSBwcmVsb2FkXG4gICAqIHZpZGVvIHdpbGwgYmUgcHJlbG9hZGVkIGFjY29yZGluZyB0byBgcHJlbG9hZGAgYXR0cmlidXRlIG9wdGlvbnMgKipkZWZhdWx0Kio6IGAnbWV0YWRhdGEnYFxuICAgKiBAcHJvcCB7Ym9vbGVhbn0gY29udHJvbHNcbiAgICogZW5hYmxlZC9kaXNhYmxlcyBkaXNwbGF5aW5nIGNvbnRyb2xzXG4gICAqIEBwcm9wIHtib29sZWFufSBjcm9zc09yaWdpblxuICAgKiBlbmFibGVzIGNyb3NzLW9yaWdpbiBjYXBhYmlsaXR5IGZvciBtZWRpYS1yZXNvdXJjZXNcbiAgICogQHByb3Age2Jvb2xlYW59IHBsYXlJbmxpbmVcbiAgICogZW5hYmxlcyBpbi1saW5lIHZpZGVvIGVsZW1lbnRzXG4gICAqIEBwcm9wIHtib29sZWFufSBhdWRpb09ubHlcbiAgICogZW5mb3JjZSBhdWRpby1vbmx5IHBsYXliYWNrICh3aGVuIHBvc3NpYmxlKVxuICAgKiBAcHJvcCB7T2JqZWN0fSBleHRlcm5hbFRyYWNrc1xuICAgKiBwYXNzIGV4dGVybmFseSBsb2FkZWQgdHJhY2sgdG8gcGxheWJhY2tcbiAgICogQHByb3Age051bWJlcn0gW21heEJ1ZmZlckxlbmd0aF1cbiAgICogVGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHRoZSAqKkhMUyBwbGF5YmFjayoqIGlzIHRvIGtlZXAgYnVmZmVyaW5nIGluZGVmaW5pdGVseSwgZXZlbiBvbiBWb0QuXG4gICAqIFRoaXMgcmVwbGljYXRlcyB0aGUgYmVoYXZpb3IgZm9yIHByb2dyZXNzaXZlIGRvd25sb2FkLCB3aGljaCBjb250aW51ZXMgYnVmZmVyaW5nIHdoZW4gcGF1c2luZyB0aGUgdmlkZW8sIHRodXMgbWFraW5nIHRoZSB2aWRlbyBhdmFpbGFibGUgZm9yIHBsYXliYWNrIGV2ZW4gb24gc2xvdyBuZXR3b3Jrcy5cbiAgICogVG8gY2hhbmdlIHRoaXMgYmVoYXZpb3IgdXNlIGBtYXhCdWZmZXJMZW5ndGhgIHdoZXJlICoqdmFsdWUgaXMgaW4gc2Vjb25kcyoqLlxuICAgKiBAcHJvcCB7TnVtYmVyfSBbbWF4QmFja0J1ZmZlckxlbmd0aF1cbiAgICogQWZ0ZXIgaG93IG11Y2ggZGlzdGFuY2Ugb2YgdGhlIHBsYXloZWFkIGRhdGEgc2hvdWxkIGJlIHBydW5lZCBmcm9tIHRoZSBidWZmZXIgKGluZmx1ZW5jZXMgbWVtb3J5IGNvbnN1bXB0aW9uXG4gICAqIG9mIGFkYXB0aXZlIG1lZGlhLWVuZ2luZXMgbGlrZSBIbHMuanMgb3IgU2hha2EpXG4gICAqIEBwcm9wIHtOdW1iZXJ9IFttaW5CdWZmZXJMZW5ndGhdXG4gICAqIEFmdGVyIGhvdyBtdWNoIGRhdGEgaW4gdGhlIGJ1ZmZlciBhdCBsZWFzdCB3ZSBhdHRlbXB0IHRvIGNvbnN1bWUgaXQgKGluZmx1ZW5jZXMgUW9TLXJlbGF0ZWQgYmVoYXZpb3JcbiAgICogb2YgYWRhcHRpdmUgbWVkaWEtZW5naW5lcyBsaWtlIEhscy5qcyBvciBTaGFrYSkuIElmIHRoaXMgaXMgdG9vIGxvdywgYW5kIHRoZSBhdmFpbGFibGUgYmFuZHdpZHRoIGlzIHZhcnlpbmcgYSBsb3RcbiAgICogYW5kIHRvbyBjbG9zZSB0byB0aGUgc3RyZWFtZWQgYml0cmF0ZSwgd2UgbWF5IGNvbnRpbnVvdXNseSBoaXQgdW5kZXItcnVucy5cbiAgICogQHByb3Age051bWJlcn0gW2luaXRpYWxCYW5kd2lkdGhFc3RpbWF0ZV1cbiAgICogZGVmaW5lIGFuIGluaXRpYWwgYmFuZHdpZHRoIFwiZ3Vlc3NcIiAob3IgcHJldmlvdXNseSBzdG9yZWQvZXN0YWJsaXNoZWQgdmFsdWUpIGZvciB1bmRlcmx5aW5nIGFkYXB0aXZlLWJpdHJlYXRlIGVuZ2luZXNcbiAgICogb2YgYWRhcHRpdmUgcGxheWJhY2sgaW1wbGVtZW50YXRpb25zLCBsaWtlIEhscy5qcyBvciBTaGFrYVxuICAgKiBAcHJvcCB7TnVtYmVyfSBbbWF4QWRhcHRpdmVCaXRyYXRlXVxuICAgKiBMaW1pdHMgdGhlIHN0cmVhbWVkIGJpdHJhdGUgKGZvciBhZGFwdGl2ZSBtZWRpYS1lbmdpbmVzIGluIHVuZGVybHlpbmcgcGxheWJhY2sgaW1wbGVtZW50YXRpb25zKVxuICAgKiBAcHJvcCB7T2JqZWN0fSBbbWF4QWRhcHRpdmVWaWRlb0RpbWVuc2lvbnNdXG4gICAqIExpbWl0cyB0aGUgdmlkZW8gZGltZW5zaW9ucyBpbiBhZGFwdGl2ZSBtZWRpYS1lbmdpbmVzLiBTaG91bGQgYmUgYSBsaXRlcmFsIG9iamVjdCB3aXRoIGBoZWlnaHRgIGFuZCBgd2lkdGhgLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn1bZW5hYmxlQXV0b21hdGljQUJSXSAqKmRlZmF1bHQqKjogYHRydWVgXG4gICAqIEFsbG93cyB0byBlbmFibGUvZGlzYWJsZSBhdXRvbWF0aWMgYml0cmF0ZSBzd2l0Y2hpbmcgaW4gYWRhcHRpdmUgbWVkaWEtZW5naW5lc1xuICAgKiBAcHJvcCB7U3RyaW5nfSBbcHJlZmVycmVkVGV4dExhbmd1YWdlXSAqKmRlZmF1bHQqKjogYCdwdC1CUidgXG4gICAqIEFsbG93cyB0byBzZXQgYSBwcmVmZXJyZWQgdGV4dCBsYW5ndWFnZSwgdGhhdCBtYXkgYmUgZW5hYmxlZCBieSB0aGUgbWVkaWEtZW5naW5lIGlmIGF2YWlsYWJsZS5cbiAgICogQHByb3Age1N0cmluZ30gW3ByZWZlcnJlZEF1ZGlvTGFuZ3VhZ2VdICoqZGVmYXVsdCoqOiBgJ3B0LUJSJ2BcbiAgICogQWxsb3dzIHRvIHNldCBhIHByZWZlcnJlZCBhdWRpbyBsYW5ndWFnZSwgdGhhdCBtYXkgYmUgZW5hYmxlZCBieSB0aGUgbWVkaWEtZW5naW5lIGlmIGF2YWlsYWJsZS5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIFBsYXllcidzIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIFlvdSBtaWdodCBwYXNzIHRoZSBvcHRpb25zIG9iamVjdCB0byBidWlsZCB0aGUgcGxheWVyLlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBvcHRpb25zID0ge3NvdXJjZTogXCJodHRwOi8vZXhhbXBsZS5jb20vdmlkZW8ubXA0XCIsIHBhcmFtMTogXCJ2YWwxXCJ9O1xuICAgKiB2YXIgcGxheWVyID0gbmV3IENsYXBwci5QbGF5ZXIob3B0aW9ucyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIERhdGFcbiAgICogb3B0aW9ucyB0byBidWlsZCBhIHBsYXllciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdXG4gICAqIHBsYXllcidzIHdpZHRoICoqZGVmYXVsdCoqOiBgNjQwYFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XVxuICAgKiBwbGF5ZXIncyBoZWlnaHQgKipkZWZhdWx0Kio6IGAzNjBgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJlbnRJZF1cbiAgICogdGhlIGlkIG9mIHRoZSBlbGVtZW50IG9uIHRoZSBwYWdlIHRoYXQgdGhlIHBsYXllciBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50XVxuICAgKiBhIHJlZmVyZW5jZSB0byBhIGRvbSBlbGVtZW50IHRoYXQgdGhlIHBsYXllciBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc291cmNlXVxuICAgKiBUaGUgbWVkaWEgc291cmNlIFVSTCwgb3Ige3NvdXJjZTogPDxzb3VyY2UgVVJMPj4sIG1pbWVUeXBlOiA8PHNvdXJjZSBtaW1lIHR5cGU+Pn1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnNvdXJjZXNdXG4gICAqIEFuIGFycmF5IG9mIG1lZGlhIHNvdXJjZSBVUkwncywgb3IgYW4gYXJyYXkgb2Yge3NvdXJjZTogPDxzb3VyY2UgVVJMPj4sIG1pbWVUeXBlOiA8PHNvdXJjZSBtaW1lIHR5cGU+Pn1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUGxheV1cbiAgICogYXV0b21hdGljYWxseSBwbGF5IGFmdGVyIHBhZ2UgbG9hZCAqKmRlZmF1bHQqKjogYGZhbHNlYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmxvb3BdXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVwbGF5IGFmdGVyIGl0IGVuZHMgKipkZWZhdWx0Kio6IGBmYWxzZWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaHJvbWVsZXNzXVxuICAgKiBwbGF5ZXIgYWN0cyBpbiBjaHJvbWVsZXNzIG1vZGUgKipkZWZhdWx0Kio6IGBmYWxzZWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1VzZXJJbnRlcmFjdGlvbl1cbiAgICogd2hldGhlciBvciBub3QgdGhlIHBsYXllciBzaG91bGQgaGFuZGxlIGNsaWNrIGV2ZW50cyB3aGVuIGluIGNocm9tZWxlc3MgbW9kZSAqKmRlZmF1bHQqKjogYGZhbHNlYCBvbiBkZXNrdG9wcyBicm93c2VycywgYHRydWVgIG9uIG1vYmlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlS2V5Ym9hcmRTaG9ydGN1dHNdXG4gICAqIGRpc2FibGUga2V5Ym9hcmQgc2hvcnRjdXRzLiAqKmRlZmF1bHQqKjogYGZhbHNlYC4gYHRydWVgIGlmIGBhbGxvd1VzZXJJbnRlcmFjdGlvbmAgaXMgYGZhbHNlYC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdXRlXVxuICAgKiBzdGFydCB0aGUgdmlkZW8gbXV0ZWQgKipkZWZhdWx0Kio6IGBmYWxzZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1pbWVUeXBlXVxuICAgKiBhZGQgYG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCJgIGlmIHlvdSBuZWVkIHRvIHVzZSBhIHVybCB3aXRob3V0IGV4dGVuc2lvbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hY3R1YWxMaXZlVGltZV1cbiAgICogc2hvdyBkdXJhdGlvbiBhbmQgc2VlayB0aW1lIHJlbGF0aXZlIHRvIGFjdHVhbCB0aW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWN0dWFsTGl2ZVNlcnZlclRpbWVdXG4gICAqIHNwZWNpZnkgc2VydmVyIHRpbWUgYXMgYSBzdHJpbmcsIGZvcm1hdDogXCIyMDE1LzExLzI2IDA2OjAxOjAzXCIuIFRoaXMgb3B0aW9uIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aCBhY3R1YWxMaXZlVGltZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wZXJzaXN0Q29uZmlnXVxuICAgKiBwZXJzaXN0IHBsYXllcidzIHNldHRpbmdzICh2b2x1bWUpIHRocm91Z2ggdGhlIHNhbWUgZG9tYWluICoqZGVmYXVsdCoqOiBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByZWxvYWRdIEBkZXByZWNhdGVkXG4gICAqIHZpZGVvIHdpbGwgYmUgcHJlbG9hZGVkIGFjY29yZGluZyB0byBgcHJlbG9hZGAgYXR0cmlidXRlIG9wdGlvbnMgKipkZWZhdWx0Kio6IGAnbWV0YWRhdGEnYFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4QnVmZmVyTGVuZ3RoXSBAZGVwcmVjYXRlZFxuICAgKiB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgdGhlICoqSExTIHBsYXliYWNrKiogaXMgdG8ga2VlcCBidWZmZXJpbmcgaW5kZWZpbml0ZWx5LCBldmVuIG9uIFZvRC5cbiAgICogVGhpcyByZXBsaWNhdGVzIHRoZSBiZWhhdmlvciBmb3IgcHJvZ3Jlc3NpdmUgZG93bmxvYWQsIHdoaWNoIGNvbnRpbnVlcyBidWZmZXJpbmcgd2hlbiBwYXVzaW5nIHRoZSB2aWRlbywgdGh1cyBtYWtpbmcgdGhlIHZpZGVvIGF2YWlsYWJsZSBmb3IgcGxheWJhY2sgZXZlbiBvbiBzbG93IG5ldHdvcmtzLlxuICAgKiBUbyBjaGFuZ2UgdGhpcyBiZWhhdmlvciB1c2UgYG1heEJ1ZmZlckxlbmd0aGAgd2hlcmUgKip2YWx1ZSBpcyBpbiBzZWNvbmRzKiouXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5nYUFjY291bnRdXG4gICAqIGVuYWJsZSBHb29nbGUgQW5hbHl0aWNzIGV2ZW50cyBkaXNwYXRjaCAqKihwbGF5L3BhdXNlL3N0b3AvYnVmZmVyaW5nL2V0YykqKiBieSBhZGRpbmcgeW91ciBgZ2FBY2NvdW50YFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZ2FUcmFja2VyTmFtZV1cbiAgICogYmVzaWRlcyBgZ2FBY2NvdW50YCB5b3UgY2FuIG9wdGlvbmFsbHksIHBhc3MgeW91ciBmYXZvcml0ZSB0cmFja2VyTmFtZSBhcyBgZ2FUcmFja2VyTmFtZWBcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1lZGlhY29udHJvbF1cbiAgICogY3VzdG9taXplIGNvbnRyb2wgYmFyIGNvbG9ycywgZXhhbXBsZTogYG1lZGlhY29udHJvbDoge3NlZWtiYXI6IFwiI0UxMTNEM1wiLCBidXR0b25zOiBcIiM2NkIyRkZcIn1gXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaGlkZU1lZGlhQ29udHJvbF1cbiAgICogY29udHJvbCBtZWRpYSBjb250cm9sIGF1dG8gaGlkZSAqKmRlZmF1bHQqKjogYHRydWVgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaGlkZVZvbHVtZUJhcl1cbiAgICogd2hlbiBlbWJlZGRlZCB3aXRoIHdpZHRoIGxlc3MgdGhhbiAzMjAsIHZvbHVtZSBiYXIgd2lsbCBoaWRlLiBZb3UgY2FuIGZvcmNlIHRoaXMgYmVoYXZpb3IgZm9yIGFsbCBzaXplcyBieSBhZGRpbmcgYHRydWVgICoqZGVmYXVsdCoqOiBgZmFsc2VgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53YXRlcm1hcmtdXG4gICAqIHB1dCBgd2F0ZXJtYXJrOiAnaHR0cDovL3VybC9pbWcucG5nJ2Agb24geW91ciBlbWJlZCBwYXJhbWV0ZXJzIHRvIGF1dG9tYXRpY2FsbHkgYWRkIHdhdGVybWFyayBvbiB5b3VyIHZpZGVvLlxuICAgKiBZb3UgY2FuIGN1c3RvbWl6ZSBjb3JuZXIgcG9zaXRpb24gYnkgZGVmaW5pbmcgcG9zaXRpb24gcGFyYW1ldGVyLiBQb3NpdGlvbnMgY2FuIGJlIGBib3R0b20tbGVmdGAsIGBib3R0b20tcmlnaHRgLCBgdG9wLWxlZnRgIGFuZCBgdG9wLXJpZ2h0YC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndhdGVybWFya0xpbmtdXG4gICAqIGB3YXRlcm1hcmtMaW5rOiAnaHR0cDovL2V4YW1wbGUubmV0LydgIC0gZGVmaW5lIFVSTCB0byBvcGVuIHdoZW4gdGhlIHdhdGVybWFyayBpcyBjbGlja2VkLiBJZiBub3QgcHJvdmlkZWQgd2F0ZXJtYXJrIHdpbGwgbm90IGJlIGNsaWNrYWJsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlVmlkZW9UYWdDb250ZXh0TWVudV0gQGRlcHJlY2F0ZWRcbiAgICogZGlzYWJsZXMgdGhlIGNvbnRleHQgbWVudSAocmlnaHQgY2xpY2spIG9uIHRoZSB2aWRlbyBlbGVtZW50IGlmIGEgSFRNTDVWaWRlbyBwbGF5YmFjayBpcyB1c2VkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9TZWVrRnJvbVVybF1cbiAgICogQXV0b21hdGljYWxseSBzZWVrIHRvIHRoZSBzZWNvbmRzIHByb3ZpZGVkIGluIHRoZSB1cmwgKGUuZyBleGFtcGxlLmNvbT90PTEwMCkgKipkZWZhdWx0Kio6IGB0cnVlYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmV4aXRGdWxsc2NyZWVuT25FbmRdXG4gICAqIEF1dG9tYXRpY2FsbHkgZXhpdCBmdWxsIHNjcmVlbiB3aGVuIHRoZSBtZWRpYSBmaW5pc2hlcy4gKipkZWZhdWx0Kio6IGB0cnVlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zdGVyXVxuICAgKiBkZWZpbmUgYSBwb3N0ZXIgYnkgYWRkaW5nIGl0cyBhZGRyZXNzIGBwb3N0ZXI6ICdodHRwOi8vdXJsL2ltZy5wbmcnYC4gSXQgd2lsbCBhcHBlYXIgYWZ0ZXIgdmlkZW8gZW1iZWQsIGRpc2FwcGVhciBvbiBwbGF5IGFuZCBnbyBiYWNrIHdoZW4gdXNlciBzdG9wcyB0aGUgdmlkZW8uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGF5YmFja05vdFN1cHBvcnRlZE1lc3NhZ2VdXG4gICAqIGRlZmluZSBhIGN1c3RvbSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCB3aGVuIGEgcGxheWJhY2sgaXMgbm90IHN1cHBvcnRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV2ZW50c11cbiAgICogU3BlY2lmeSBsaXN0ZW5lcnMgd2hpY2ggd2lsbCBiZSByZWdpc3RlcmVkIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBwbGF5ZXIgZXZlbnRzLlxuICAgKiBFLmcuIG9uUmVhZHkgLT4gXCJQTEFZRVJfUkVBRFlcIiwgb25UaW1lVXBkYXRlIC0+IFwiUExBWUVSX1RJTUVVUERBVEVcIlxuICAgKiBAcGFyYW0ge1BsYXliYWNrQ29uZmlnfSBbb3B0aW9ucy5wbGF5YmFja11cbiAgICogR2VuZXJpYyBgUGxheWJhY2tgIGNvbXBvbmVudCByZWxhdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kaXNhYmxlRXJyb3JTY3JlZW5dXG4gICAqIGRpc2FibGVzIHRoZSBlcnJvciBzY3JlZW4gcGx1Z2luLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXV0b1BsYXlUaW1lb3V0XVxuICAgKiBhdXRvcGxheSBjaGVjayB0aW1lb3V0LlxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICBjb25zdCBwbGF5YmFja0RlZmF1bHRPcHRpb25zID0geyByZWN5Y2xlVmlkZW8gOiB0cnVlIH1cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHBsYXllcklkOiB1bmlxdWVJZCgnJyksXG4gICAgICBwZXJzaXN0Q29uZmlnOiB0cnVlLFxuICAgICAgd2lkdGg6IDY0MCxcbiAgICAgIGhlaWdodDogMzYwLFxuICAgICAgYmFzZVVybDogYmFzZVVybCxcbiAgICAgIGFsbG93VXNlckludGVyYWN0aW9uOiBCcm93c2VyLmlzTW9iaWxlLFxuICAgICAgcGxheWJhY2s6IHBsYXliYWNrRGVmYXVsdE9wdGlvbnNcbiAgICB9XG4gICAgdGhpcy5fb3B0aW9ucyA9ICQuZXh0ZW5kKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgIHRoaXMub3B0aW9ucy5zb3VyY2VzID0gdGhpcy5fbm9ybWFsaXplU291cmNlcyhvcHRpb25zKVxuICAgIGlmICghdGhpcy5vcHRpb25zLmNocm9tZWxlc3MpIHtcbiAgICAgIC8vIFwiYWxsb3dVc2VySW50ZXJhY3Rpb25cIiBjYW5ub3QgYmUgZmFsc2UgaWYgbm90IGluIGNocm9tZWxlc3MgbW9kZS5cbiAgICAgIHRoaXMub3B0aW9ucy5hbGxvd1VzZXJJbnRlcmFjdGlvbiA9IHRydWVcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dVc2VySW50ZXJhY3Rpb24pIHtcbiAgICAgIC8vIGlmIHVzZXIgaXRlcmFjdGlvbiBpcyBub3QgYWxsb3dlZCBlbnN1cmUga2V5Ym9hcmQgc2hvcnRjdXRzIGFyZSBkaXNhYmxlZFxuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVLZXlib2FyZFNob3J0Y3V0cyA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5fcmVnaXN0ZXJPcHRpb25FdmVudExpc3RlbmVycyh0aGlzLm9wdGlvbnMuZXZlbnRzKVxuICAgIHRoaXMuX2NvcmVGYWN0b3J5ID0gbmV3IENvcmVGYWN0b3J5KHRoaXMpXG4gICAgdGhpcy5wbGF5ZXJJbmZvID0gUGxheWVySW5mby5nZXRJbnN0YW5jZSh0aGlzLm9wdGlvbnMucGxheWVySWQpXG4gICAgdGhpcy5wbGF5ZXJJbmZvLmN1cnJlbnRTaXplID0geyB3aWR0aDogb3B0aW9ucy53aWR0aCwgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCB9XG4gICAgdGhpcy5wbGF5ZXJJbmZvLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudElkKVxuICAgICAgdGhpcy5zZXRQYXJlbnRJZCh0aGlzLm9wdGlvbnMucGFyZW50SWQpXG5cbiAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGFyZW50KVxuICAgICAgdGhpcy5hdHRhY2hUbyh0aGlzLm9wdGlvbnMucGFyZW50KVxuXG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSBhIGBwYXJlbnRJZGAgdG8gdGhlIHBsYXllci5cbiAgICogQG1ldGhvZCBzZXRQYXJlbnRJZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50SWQgdGhlIGVsZW1lbnQgcGFyZW50IGlkLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IGl0c2VsZlxuICAgKi9cbiAgc2V0UGFyZW50SWQocGFyZW50SWQpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50SWQpXG4gICAgaWYgKGVsKVxuICAgICAgdGhpcy5hdHRhY2hUbyhlbClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gYXR0YWNoIHRoZSBwbGF5ZXIgdG8gYSBnaXZlbiBlbGVtZW50LiBZb3UgZG9uJ3QgbmVlZCB0byBkbyB0aGlzIHdoZW4geW91IHNwZWNpZnkgaXQgZHVyaW5nIHRoZSBwbGF5ZXIgaW5zdGFudGlhdGlvbiBwYXNzaW5nIHRoZSBgcGFyZW50SWRgIHBhcmFtLlxuICAgKiBAbWV0aG9kIGF0dGFjaFRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IGEgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHJldHVybiB7UGxheWVyfSBpdHNlbGZcbiAgICovXG4gIGF0dGFjaFRvKGVsZW1lbnQpIHtcbiAgICB0aGlzLm9wdGlvbnMucGFyZW50RWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLmNvcmUgPSB0aGlzLl9jb3JlRmFjdG9yeS5jcmVhdGUoKVxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICghdGhpcy5jb3JlLmlzUmVhZHkpXG4gICAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX1JFQURZLCB0aGlzLl9vblJlYWR5KVxuICAgIGVsc2VcbiAgICAgIHRoaXMuX29uUmVhZHkoKVxuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX0FDVElWRV9DT05UQUlORVJfQ0hBTkdFRCwgdGhpcy5fY29udGFpbmVyQ2hhbmdlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfRlVMTFNDUkVFTiwgdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuQ09SRV9SRVNJWkUsIHRoaXMuX29uUmVzaXplKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfYWRkQ29udGFpbmVyRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lclxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHRoaXMubGlzdGVuVG8oY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1BMQVksIHRoaXMuX29uUGxheSlcbiAgICAgIHRoaXMubGlzdGVuVG8oY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1BBVVNFLCB0aGlzLl9vblBhdXNlKVxuICAgICAgdGhpcy5saXN0ZW5Ubyhjb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfU1RPUCwgdGhpcy5fb25TdG9wKVxuICAgICAgdGhpcy5saXN0ZW5Ubyhjb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfRU5ERUQsIHRoaXMuX29uRW5kZWQpXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TRUVLLCB0aGlzLl9vblNlZWspXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9FUlJPUiwgdGhpcy5fb25FcnJvcilcbiAgICAgIHRoaXMubGlzdGVuVG8oY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1RJTUVVUERBVEUsIHRoaXMuX29uVGltZVVwZGF0ZSlcbiAgICAgIHRoaXMubGlzdGVuVG8oY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1ZPTFVNRSwgdGhpcy5fb25Wb2x1bWVVcGRhdGUpXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVUJUSVRMRV9BVkFJTEFCTEUsIHRoaXMuX29uU3VidGl0bGVBdmFpbGFibGUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfcmVnaXN0ZXJPcHRpb25FdmVudExpc3RlbmVycyhuZXdFdmVudHMgPSB7fSwgZXZlbnRzID0ge30pIHtcbiAgICBjb25zdCBoYXNOZXdFdmVudHMgPSBPYmplY3Qua2V5cyhuZXdFdmVudHMpLmxlbmd0aCA+IDBcbiAgICBoYXNOZXdFdmVudHMgJiYgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKCh1c2VyRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHRoaXMuZXZlbnRzTWFwcGluZ1t1c2VyRXZlbnRdXG4gICAgICBldmVudFR5cGUgJiYgdGhpcy5vZmYoZXZlbnRUeXBlLCBldmVudHNbdXNlckV2ZW50XSlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMobmV3RXZlbnRzKS5mb3JFYWNoKCh1c2VyRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IHRoaXMuZXZlbnRzTWFwcGluZ1t1c2VyRXZlbnRdXG4gICAgICBpZiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGxldCBldmVudEZ1bmN0aW9uID0gbmV3RXZlbnRzW3VzZXJFdmVudF1cbiAgICAgICAgZXZlbnRGdW5jdGlvbiA9IHR5cGVvZiBldmVudEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nICYmIGV2ZW50RnVuY3Rpb25cbiAgICAgICAgZXZlbnRGdW5jdGlvbiAmJiB0aGlzLm9uKGV2ZW50VHlwZSwgZXZlbnRGdW5jdGlvbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfY29udGFpbmVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKClcbiAgfVxuXG4gIF9vblJlYWR5KCkge1xuICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZVxuICAgIHRoaXMuX2FkZENvbnRhaW5lckV2ZW50TGlzdGVuZXJzKClcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlFUl9SRUFEWSlcbiAgfVxuXG4gIF9vbkZ1bGxzY3JlZW5DaGFuZ2UoZnVsbHNjcmVlbikge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUVSX0ZVTExTQ1JFRU4sIGZ1bGxzY3JlZW4pXG4gIH1cblxuICBfb25Wb2x1bWVVcGRhdGUodm9sdW1lKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZRVJfVk9MVU1FVVBEQVRFLCB2b2x1bWUpXG4gIH1cblxuICBfb25TdWJ0aXRsZUF2YWlsYWJsZSgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlFUl9TVUJUSVRMRV9BVkFJTEFCTEUpXG4gIH1cblxuICBfb25SZXNpemUoc2l6ZSkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUVSX1JFU0laRSwgc2l6ZSlcbiAgfVxuXG4gIF9vblBsYXkoKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZRVJfUExBWSlcbiAgfVxuXG4gIF9vblBhdXNlKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUVSX1BBVVNFKVxuICB9XG5cbiAgX29uU3RvcCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlFUl9TVE9QLCB0aGlzLmdldEN1cnJlbnRUaW1lKCkpXG4gIH1cblxuICBfb25FbmRlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlFUl9FTkRFRClcbiAgfVxuXG4gIF9vblNlZWsodGltZSkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUVSX1NFRUssIHRpbWUpXG4gIH1cblxuICBfb25UaW1lVXBkYXRlKHRpbWVQcm9ncmVzcykge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUVSX1RJTUVVUERBVEUsIHRpbWVQcm9ncmVzcylcbiAgfVxuXG4gIF9vbkVycm9yKGVycm9yKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZRVJfRVJST1IsIGVycm9yKVxuICB9XG5cbiAgX25vcm1hbGl6ZVNvdXJjZXMob3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBvcHRpb25zLnNvdXJjZXMgfHwgKG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQ/IFtvcHRpb25zLnNvdXJjZV0gOiBbXSlcbiAgICByZXR1cm4gc291cmNlcy5sZW5ndGggPT09IDAgPyBbeyBzb3VyY2U6JycsIG1pbWVUeXBlOicnIH1dIDogc291cmNlc1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc2l6ZXMgdGhlIGN1cnJlbnQgcGxheWVyIGNhbnZhcy5cbiAgICogQG1ldGhvZCByZXNpemVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNpemUgc2hvdWxkIGJlIGEgbGl0ZXJhbCBvYmplY3Qgd2l0aCBgaGVpZ2h0YCBhbmQgYHdpZHRoYC5cbiAgICogQHJldHVybiB7UGxheWVyfSBpdHNlbGZcbiAgICogQGV4YW1wbGVcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBwbGF5ZXIucmVzaXplKHtoZWlnaHQ6IDM2MCwgd2lkdGg6IDY0MH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcmVzaXplKHNpemUpIHtcbiAgICB0aGlzLmNvcmUucmVzaXplKHNpemUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBsb2FkcyBhIG5ldyBzb3VyY2UuXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gc291cmNlcyBzb3VyY2Ugb3Igc291cmNlcyBvZiB2aWRlby5cbiAgICogQW4gYXJyYXkgaXRlbSBjYW4gYmUgYSBzdHJpbmcgb3Ige3NvdXJjZTogPDxzb3VyY2UgVVJMPj4sIG1pbWVUeXBlOiA8PHNvdXJjZSBtaW1lIHR5cGU+Pn1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIGEgbWltZSB0eXBlLCBleGFtcGxlOiBgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJ2BcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXV0b1BsYXk9ZmFsc2VdIHdoZXRoZXIgcGxheWluZyBzaG91bGQgYmUgc3RhcnRlZCBpbW1lZGlhdGVseVxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IGl0c2VsZlxuICAgKi9cbiAgbG9hZChzb3VyY2VzLCBtaW1lVHlwZSwgYXV0b1BsYXkpIHtcbiAgICBpZiAoYXV0b1BsYXkgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuY29uZmlndXJlKHsgYXV0b1BsYXk6ICEhYXV0b1BsYXkgfSlcblxuICAgIHRoaXMuY29yZS5sb2FkKHNvdXJjZXMsIG1pbWVUeXBlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogZGVzdHJveXMgdGhlIGN1cnJlbnQgcGxheWVyIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcExpc3RlbmluZygpXG4gICAgdGhpcy5jb3JlLmRlc3Ryb3koKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2l2ZXMgdXNlciBjb25zZW50IHRvIHBsYXliYWNrLiBSZXF1aXJlZCBieSBtb2JpbGUgZGV2aWNlIGFmdGVyIGEgY2xpY2sgZXZlbnQgYmVmb3JlIFBsYXllci5sb2FkKCkuXG4gICAqIEBtZXRob2QgY29uc2VudFxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IGl0c2VsZlxuICAgKi9cbiAgY29uc2VudCgpIHtcbiAgICB0aGlzLmNvcmUuZ2V0Q3VycmVudFBsYXliYWNrKCkuY29uc2VudCgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBwbGF5cyB0aGUgY3VycmVudCB2aWRlbyAoYHNvdXJjZWApLlxuICAgKiBAbWV0aG9kIHBsYXlcbiAgICogQHJldHVybiB7UGxheWVyfSBpdHNlbGZcbiAgICovXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5wbGF5KClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIHBhdXNlcyB0aGUgY3VycmVudCB2aWRlbyAoYHNvdXJjZWApLlxuICAgKiBAbWV0aG9kIHBhdXNlXG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLnBhdXNlKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIHN0b3BzIHRoZSBjdXJyZW50IHZpZGVvIChgc291cmNlYCkuXG4gICAqIEBtZXRob2Qgc3RvcFxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9IGl0c2VsZlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLnN0b3AoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8qKlxuICAgKiBzZWVrcyB0aGUgY3VycmVudCB2aWRlbyAoYHNvdXJjZWApLiBGb3IgZXhhbXBsZSwgYHBsYXllci5zZWVrKDEyMClgIHdpbGwgc2VlayB0byBzZWNvbmQgMTIwICgybWludXRlcykgb2YgdGhlIGN1cnJlbnQgdmlkZW8uXG4gICAqIEBtZXRob2Qgc2Vla1xuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCB0aGUgdmlkZW8gZHVyYXRpb24uXG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICBzZWVrKHRpbWUpIHtcbiAgICB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLnNlZWsodGltZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIHNlZWtzIHRoZSBjdXJyZW50IHZpZGVvIChgc291cmNlYCkuIEZvciBleGFtcGxlLCBgcGxheWVyLnNlZWsoNTApYCB3aWxsIHNlZWsgdG8gdGhlIG1pZGRsZSBvZiB0aGUgY3VycmVudCB2aWRlby5cbiAgICogQG1ldGhvZCBzZWVrUGVyY2VudGFnZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxMDAuXG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICBzZWVrUGVyY2VudGFnZShwZXJjZW50YWdlKSB7XG4gICAgdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5zZWVrUGVyY2VudGFnZShwZXJjZW50YWdlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogbXV0ZXMgdGhlIGN1cnJlbnQgdmlkZW8gKGBzb3VyY2VgKS5cbiAgICogQG1ldGhvZCBtdXRlXG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICBtdXRlKCkge1xuICAgIHRoaXMuX211dGVkVm9sdW1lID0gdGhpcy5nZXRWb2x1bWUoKVxuICAgIHRoaXMuc2V0Vm9sdW1lKDApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiB1bm11dGVzIHRoZSBjdXJyZW50IHZpZGVvIChgc291cmNlYCkuXG4gICAqIEBtZXRob2QgdW5tdXRlXG4gICAqIEByZXR1cm4ge1BsYXllcn0gaXRzZWxmXG4gICAqL1xuICB1bm11dGUoKSB7XG4gICAgdGhpcy5zZXRWb2x1bWUodHlwZW9mIHRoaXMuX211dGVkVm9sdW1lID09PSAnbnVtYmVyJyA/IHRoaXMuX211dGVkVm9sdW1lIDogMTAwKVxuICAgIHRoaXMuX211dGVkVm9sdW1lID0gbnVsbFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogY2hlY2tzIGlmIHRoZSBwbGF5ZXIgaXMgcGxheWluZy5cbiAgICogQG1ldGhvZCBpc1BsYXlpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBjdXJyZW50IHNvdXJjZSBpcyBwbGF5aW5nLCBvdGhlcndpc2UgYGZhbHNlYFxuICAgKi9cbiAgaXNQbGF5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLmlzUGxheWluZygpXG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBgdHJ1ZWAgaWYgRFZSIGlzIGVuYWJsZSBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICogQG1ldGhvZCBpc0R2ckVuYWJsZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRHZyRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5pc0R2ckVuYWJsZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYHRydWVgIGlmIERWUiBpcyBpbiB1c2Ugb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqIEBtZXRob2QgaXNEdnJJblVzZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNEdnJJblVzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5pc0R2ckluVXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBlbmFibGVzIHRvIGNvbmZpZ3VyZSBhIHBsYXllciBhZnRlciBpdHMgY3JlYXRpb25cbiAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWxsIHRoZSBvcHRpb25zIHRvIGNoYW5nZSBpbiBmb3JtIG9mIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICogQHJldHVybiB7UGxheWVyfSBpdHNlbGZcbiAgICovXG4gIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9yZWdpc3Rlck9wdGlvbkV2ZW50TGlzdGVuZXJzKG9wdGlvbnMuZXZlbnRzLCB0aGlzLm9wdGlvbnMuZXZlbnRzKVxuICAgIHRoaXMuY29yZS5jb25maWd1cmUob3B0aW9ucylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHBsdWdpbiBieSBpdHMgbmFtZS5cbiAgICogQG1ldGhvZCBnZXRQbHVnaW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGx1Z2luIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIHBvc3RlciA9IHBsYXllci5nZXRQbHVnaW4oJ3Bvc3RlcicpO1xuICAgKiBwb3N0ZXIuaGlkZVBsYXlCdXR0b24oKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXRQbHVnaW4obmFtZSkge1xuICAgIGNvbnN0IHBsdWdpbnMgPSB0aGlzLmNvcmUucGx1Z2lucy5jb25jYXQodGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5wbHVnaW5zKVxuICAgIHJldHVybiBwbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gcGx1Z2luLm5hbWUgPT09IG5hbWUpWzBdXG4gIH1cblxuICAvKipcbiAgICogdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzLlxuICAgKiBAbWV0aG9kIGdldEN1cnJlbnRUaW1lXG4gICAqIEByZXR1cm4ge051bWJlcn0gY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKSBvZiB0aGUgY3VycmVudCBzb3VyY2VcbiAgICovXG4gIGdldEN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLmdldEN1cnJlbnRUaW1lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGF0IFwiMFwiIG5vdyByZXByZXNlbnRzIHJlbGF0aXZlIHRvIHdoZW4gcGxheWJhY2sgc3RhcnRlZC5cbiAgICogRm9yIGEgc3RyZWFtIHdpdGggYSBzbGlkaW5nIHdpbmRvdyB0aGlzIHdpbGwgaW5jcmVhc2UgYXMgY29udGVudCBpc1xuICAgKiByZW1vdmVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICogQG1ldGhvZCBnZXRTdGFydFRpbWVPZmZzZXRcbiAgICogQHJldHVybiB7TnVtYmVyfSB0aW1lIChpbiBzZWNvbmRzKSB0aGF0IHRpbWUgXCIwXCIgcmVwcmVzZW50cy5cbiAgICovXG4gIGdldFN0YXJ0VGltZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lci5nZXRTdGFydFRpbWVPZmZzZXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIHRoZSBkdXJhdGlvbiB0aW1lIGluIHNlY29uZHMuXG4gICAqIEBtZXRob2QgZ2V0RHVyYXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfSBkdXJhdGlvbiB0aW1lIChpbiBzZWNvbmRzKSBvZiB0aGUgY3VycmVudCBzb3VyY2VcbiAgICovXG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyLmdldER1cmF0aW9uKClcbiAgfVxufVxuXG5PYmplY3QuYXNzaWduKFBsYXllci5wcm90b3R5cGUsIEVycm9yTWl4aW4pXG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5jbGFzcyBQbGF5ZXJJbmZvIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge31cbiAgICB0aGlzLnBsYXliYWNrUGx1Z2lucyA9IFtdXG4gICAgdGhpcy5jdXJyZW50U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG4gIH1cbn1cblxuUGxheWVySW5mby5fcGxheWVycyA9IHt9XG5cblBsYXllckluZm8uZ2V0SW5zdGFuY2UgPSAocGxheWVySWQpID0+IHtcbiAgcmV0dXJuIFBsYXllckluZm8uX3BsYXllcnNbcGxheWVySWRdIHx8IChQbGF5ZXJJbmZvLl9wbGF5ZXJzW3BsYXllcklkXSA9IG5ldyBQbGF5ZXJJbmZvKCkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXllckluZm9cbiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJcIiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG4gIFxuaW1wb3J0IFBsYXllciBmcm9tICcuL2NvbXBvbmVudHMvcGxheWVyJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vYmFzZS91dGlscydcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9iYXNlL2V2ZW50cydcbmltcG9ydCBQbGF5YmFjayBmcm9tICcuL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgQ29udGFpbmVyUGx1Z2luIGZyb20gJy4vYmFzZS9jb250YWluZXJfcGx1Z2luJ1xuaW1wb3J0IENvcmVQbHVnaW4gZnJvbSAnLi9iYXNlL2NvcmVfcGx1Z2luJ1xuaW1wb3J0IFVJQ29yZVBsdWdpbiBmcm9tICcuL2Jhc2UvdWlfY29yZV9wbHVnaW4nXG5pbXBvcnQgVUlDb250YWluZXJQbHVnaW4gZnJvbSAnLi9iYXNlL3VpX2NvbnRhaW5lcl9wbHVnaW4nXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL2Jhc2UvYmFzZV9vYmplY3QnXG5pbXBvcnQgVUlPYmplY3QgZnJvbSAnLi9iYXNlL3VpX29iamVjdCdcbmltcG9ydCBCcm93c2VyIGZyb20gJy4vY29tcG9uZW50cy9icm93c2VyJ1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL2NvbXBvbmVudHMvY29udGFpbmVyJ1xuaW1wb3J0IENvcmUgZnJvbSAnLi9jb21wb25lbnRzL2NvcmUnXG5pbXBvcnQgUGxheWVyRXJyb3IgZnJvbSAnLi9jb21wb25lbnRzL2Vycm9yJ1xuaW1wb3J0IExvYWRlciBmcm9tICcuL2NvbXBvbmVudHMvbG9hZGVyJ1xuaW1wb3J0IE1lZGlhdG9yIGZyb20gJy4vY29tcG9uZW50cy9tZWRpYXRvcidcbmltcG9ydCBQbGF5ZXJJbmZvIGZyb20gJy4vY29tcG9uZW50cy9wbGF5ZXJfaW5mbydcbmltcG9ydCBITFMgZnJvbSAnLi9wbGF5YmFja3MvaGxzJ1xuaW1wb3J0IEhUTUw1QXVkaW8gZnJvbSAnLi9wbGF5YmFja3MvaHRtbDVfYXVkaW8nXG5pbXBvcnQgSFRNTDVWaWRlbyBmcm9tICcuL3BsYXliYWNrcy9odG1sNV92aWRlbydcbmltcG9ydCBIVE1MSW1nIGZyb20gJy4vcGxheWJhY2tzL2h0bWxfaW1nJ1xuaW1wb3J0IE5vT3AgZnJvbSAnLi9wbGF5YmFja3Mvbm9fb3AnXG5pbXBvcnQgTWVkaWFDb250cm9sIGZyb20gJy4vcGx1Z2lucy9tZWRpYV9jb250cm9sJ1xuaW1wb3J0IENsaWNrVG9QYXVzZVBsdWdpbiBmcm9tICcuL3BsdWdpbnMvY2xpY2tfdG9fcGF1c2UnXG5pbXBvcnQgRFZSQ29udHJvbHMgZnJvbSAnLi9wbHVnaW5zL2R2cl9jb250cm9scydcbmltcG9ydCBGYXZpY29uIGZyb20gJy4vcGx1Z2lucy9mYXZpY29uJ1xuaW1wb3J0IExvZyBmcm9tICcuL3BsdWdpbnMvbG9nJ1xuaW1wb3J0IFBvc3RlciBmcm9tICcuL3BsdWdpbnMvcG9zdGVyJ1xuaW1wb3J0IFNwaW5uZXJUaHJlZUJvdW5jZVBsdWdpbiBmcm9tICcuL3BsdWdpbnMvc3Bpbm5lcl90aHJlZV9ib3VuY2UnXG5pbXBvcnQgV2F0ZXJNYXJrUGx1Z2luIGZyb20gJy4vcGx1Z2lucy93YXRlcm1hcmsnXG5pbXBvcnQgU3R5bGVyIGZyb20gJy4vYmFzZS9zdHlsZXInXG5pbXBvcnQgVmVuZG9yIGZyb20gJy4vdmVuZG9yJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vYmFzZS90ZW1wbGF0ZSdcblxuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuXG5jb25zdCB2ZXJzaW9uID0gVkVSU0lPTlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBsYXllcixcbiAgTWVkaWF0b3IsXG4gIEV2ZW50cyxcbiAgQnJvd3NlcixcbiAgUGxheWVySW5mbyxcbiAgTWVkaWFDb250cm9sLFxuICBDb250YWluZXJQbHVnaW4sXG4gIFVJQ29udGFpbmVyUGx1Z2luLFxuICBDb3JlUGx1Z2luLFxuICBVSUNvcmVQbHVnaW4sXG4gIFBsYXliYWNrLFxuICBDb250YWluZXIsXG4gIENvcmUsXG4gIFBsYXllckVycm9yLFxuICBMb2FkZXIsXG4gIEJhc2VPYmplY3QsXG4gIFVJT2JqZWN0LFxuICBVdGlscyxcbiAgSExTLFxuICBIVE1MNUF1ZGlvLFxuICBIVE1MNVZpZGVvLFxuICBIVE1MSW1nLFxuICBOb09wLFxuICBDbGlja1RvUGF1c2VQbHVnaW4sXG4gIERWUkNvbnRyb2xzLFxuICBGYXZpY29uLFxuICBMb2csXG4gIFBvc3RlcixcbiAgU3Bpbm5lclRocmVlQm91bmNlUGx1Z2luLFxuICBXYXRlck1hcmtQbHVnaW4sXG4gIFN0eWxlcixcbiAgVmVuZG9yLFxuICB2ZXJzaW9uLFxuICB0ZW1wbGF0ZSxcbiAgJFxufVxuIiwiICBcbi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBIVE1MNVZpZGVvUGxheWJhY2sgZnJvbSAnLi4vLi4vcGxheWJhY2tzL2h0bWw1X3ZpZGVvJ1xuaW1wb3J0IEhMU0pTIGZyb20gJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMuanMnXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IFBsYXliYWNrIGZyb20gJy4uLy4uL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgeyBub3csIGFzc2lnbiwgbGlzdENvbnRhaW5zSWdub3JlQ2FzZSB9IGZyb20gJy4uLy4uL2Jhc2UvdXRpbHMnXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3BsdWdpbnMvbG9nJ1xuaW1wb3J0IFBsYXllckVycm9yIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZXJyb3InXG5cbmNvbnN0IEFVVE8gPSAtMVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBITFMgZXh0ZW5kcyBIVE1MNVZpZGVvUGxheWJhY2sge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdobHMnIH1cblxuICBnZXQgbGV2ZWxzKCkgeyByZXR1cm4gdGhpcy5fbGV2ZWxzIHx8IFtdIH1cblxuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50TGV2ZWwgPT09IG51bGwgfHwgdGhpcy5fY3VycmVudExldmVsID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gQVVUT1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGV2ZWwgLy8wIGlzIGEgdmFsaWQgbGV2ZWwgSURcblxuICB9XG5cbiAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmVhZHlTdGF0ZVxuICB9XG5cbiAgc2V0IGN1cnJlbnRMZXZlbChpZCkge1xuICAgIHRoaXMuX2N1cnJlbnRMZXZlbCA9IGlkXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19MRVZFTF9TV0lUQ0hfU1RBUlQpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbGF5YmFjay5obHNVc2VOZXh0TGV2ZWwpXG4gICAgICB0aGlzLl9obHMubmV4dExldmVsID0gdGhpcy5fY3VycmVudExldmVsXG4gICAgZWxzZVxuICAgICAgdGhpcy5faGxzLmN1cnJlbnRMZXZlbCA9IHRoaXMuX2N1cnJlbnRMZXZlbFxuICB9XG5cbiAgZ2V0IF9zdGFydFRpbWUoKSB7XG4gICAgaWYgKHRoaXMuX3BsYXliYWNrVHlwZSA9PT0gUGxheWJhY2suTElWRSAmJiB0aGlzLl9wbGF5bGlzdFR5cGUgIT09ICdFVkVOVCcpXG4gICAgICByZXR1cm4gdGhpcy5fZXh0cmFwb2xhdGVkU3RhcnRUaW1lXG5cbiAgICByZXR1cm4gdGhpcy5fcGxheWFibGVSZWdpb25TdGFydFRpbWVcbiAgfVxuXG4gIGdldCBfbm93KCkge1xuICAgIHJldHVybiBub3coKVxuICB9XG5cbiAgLy8gdGhlIHRpbWUgaW4gdGhlIHZpZGVvIGVsZW1lbnQgd2hpY2ggc2hvdWxkIHJlcHJlc2VudCB0aGUgc3RhcnQgb2YgdGhlIHNsaWRpbmcgd2luZG93XG4gIC8vIGV4dHJhcG9sYXRlZCB0byBpbmNyZWFzZSBpbiByZWFsIHRpbWUgKGluc3RlYWQgb2YganVtcGluZyBhcyB0aGUgZWFybHkgc2VnbWVudHMgYXJlIHJlbW92ZWQpXG4gIGdldCBfZXh0cmFwb2xhdGVkU3RhcnRUaW1lKCkge1xuICAgIGlmICghdGhpcy5fbG9jYWxTdGFydFRpbWVDb3JyZWxhdGlvbilcbiAgICAgIHJldHVybiB0aGlzLl9wbGF5YWJsZVJlZ2lvblN0YXJ0VGltZVxuXG4gICAgbGV0IGNvcnIgPSB0aGlzLl9sb2NhbFN0YXJ0VGltZUNvcnJlbGF0aW9uXG4gICAgbGV0IHRpbWVQYXNzZWQgPSB0aGlzLl9ub3cgLSBjb3JyLmxvY2FsXG4gICAgbGV0IGV4dHJhcG9sYXRlZFdpbmRvd1N0YXJ0VGltZSA9IChjb3JyLnJlbW90ZSArIHRpbWVQYXNzZWQpIC8gMTAwMFxuICAgIC8vIGNhcCBhdCB0aGUgZW5kIG9mIHRoZSBleHRyYXBvbGF0ZWQgd2luZG93IGR1cmF0aW9uXG4gICAgcmV0dXJuIE1hdGgubWluKGV4dHJhcG9sYXRlZFdpbmRvd1N0YXJ0VGltZSwgdGhpcy5fcGxheWFibGVSZWdpb25TdGFydFRpbWUgKyB0aGlzLl9leHRyYXBvbGF0ZWRXaW5kb3dEdXJhdGlvbilcbiAgfVxuXG4gIC8vIHRoZSB0aW1lIGluIHRoZSB2aWRlbyBlbGVtZW50IHdoaWNoIHNob3VsZCByZXByZXNlbnQgdGhlIGVuZCBvZiB0aGUgY29udGVudFxuICAvLyBleHRyYXBvbGF0ZWQgdG8gaW5jcmVhc2UgaW4gcmVhbCB0aW1lIChpbnN0ZWFkIG9mIGp1bXBpbmcgYXMgc2VnbWVudHMgYXJlIGFkZGVkKVxuICBnZXQgX2V4dHJhcG9sYXRlZEVuZFRpbWUoKSB7XG4gICAgbGV0IGFjdHVhbEVuZFRpbWUgPSB0aGlzLl9wbGF5YWJsZVJlZ2lvblN0YXJ0VGltZSArIHRoaXMuX3BsYXlhYmxlUmVnaW9uRHVyYXRpb25cbiAgICBpZiAoIXRoaXMuX2xvY2FsRW5kVGltZUNvcnJlbGF0aW9uKVxuICAgICAgcmV0dXJuIGFjdHVhbEVuZFRpbWVcblxuICAgIGxldCBjb3JyID0gdGhpcy5fbG9jYWxFbmRUaW1lQ29ycmVsYXRpb25cbiAgICBsZXQgdGltZVBhc3NlZCA9IHRoaXMuX25vdyAtIGNvcnIubG9jYWxcbiAgICBsZXQgZXh0cmFwb2xhdGVkRW5kVGltZSA9IChjb3JyLnJlbW90ZSArIHRpbWVQYXNzZWQpIC8gMTAwMFxuICAgIHJldHVybiBNYXRoLm1heChhY3R1YWxFbmRUaW1lIC0gdGhpcy5fZXh0cmFwb2xhdGVkV2luZG93RHVyYXRpb24sIE1hdGgubWluKGV4dHJhcG9sYXRlZEVuZFRpbWUsIGFjdHVhbEVuZFRpbWUpKVxuICB9XG5cbiAgZ2V0IF9kdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFwb2xhdGVkRW5kVGltZSAtIHRoaXMuX3N0YXJ0VGltZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZHVyYXRpb24gKHNlY29uZHMpIG9mIHRoZSB3aW5kb3cgdGhhdCB0aGUgZXh0cmFwb2xhdGVkIHN0YXJ0IHRpbWUgaXMgYWxsb3dlZFxuICAvLyB0byBtb3ZlIGluIGJlZm9yZSBiZWluZyBjYXBwZWQuXG4gIC8vIFRoZSBleHRyYXBvbGF0ZWQgc3RhcnQgdGltZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhlIGNhcCBhdCB0aGUgZW5kIG9mIHRoZSB3aW5kb3cgYXMgdGhlXG4gIC8vIHdpbmRvdyBzaG91bGQgc2xpZGUgYXMgY2h1bmtzIGFyZSByZW1vdmVkIGZyb20gdGhlIHN0YXJ0LlxuICAvLyBUaGlzIGFsc28gYXBwbGllcyB0byB0aGUgZXh0cmFwb2xhdGVkIGVuZCB0aW1lIGluIHRoZSBzYW1lIHdheS5cbiAgLy9cbiAgLy8gSWYgY2h1bmtzIGFyZW4ndCBiZWluZyByZW1vdmVkIGZvciBzb21lIHJlYXNvbiB0aGF0IHRoZSBzdGFydCB0aW1lIHdpbGwgcmVhY2ggYW5kIHJlbWFpbiBmaXhlZCBhdFxuICAvLyBwbGF5YWJsZVJlZ2lvblN0YXJ0VGltZSArIGV4dHJhcG9sYXRlZFdpbmRvd0R1cmF0aW9uXG4gIC8vXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gd2luZG93IGR1cmF0aW9uIC0tPlxuICAvLyBJLmUgICBwbGF5YWJsZVJlZ2lvblN0YXJ0VGltZSB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgLS0+ICAgLiAgICAgICAuICAgICAgIC5cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLiAgIC0tPiB8IC0tPiAgIC4gICAgICAgLlxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgIC4gICAtLT4gfCAtLT4gICAuXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAgICAgLiAgICAgICAuICAgLS0+IHxcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAuICAgICAgIC4gICAgICAgLlxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhcG9sYXRlZFN0YXJ0VGltZVxuICBnZXQgX2V4dHJhcG9sYXRlZFdpbmRvd0R1cmF0aW9uKCkge1xuICAgIGlmICh0aGlzLl9zZWdtZW50VGFyZ2V0RHVyYXRpb24gPT09IG51bGwpXG4gICAgICByZXR1cm4gMFxuXG4gICAgcmV0dXJuIHRoaXMuX2V4dHJhcG9sYXRlZFdpbmRvd051bVNlZ21lbnRzICogdGhpcy5fc2VnbWVudFRhcmdldER1cmF0aW9uXG4gIH1cblxuICBzdGF0aWMgZ2V0IEhMU0pTKCkge1xuICAgIHJldHVybiBITFNKU1xuICB9XG5cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKFRPRE86IHJlbW92ZSBvbiAwLjMuMClcbiAgICB0aGlzLm9wdGlvbnMucGxheWJhY2sgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4udGhpcy5vcHRpb25zLnBsYXliYWNrIH1cbiAgICB0aGlzLl9taW5EdnJTaXplID0gdHlwZW9mICh0aGlzLm9wdGlvbnMuaGxzTWluaW11bUR2clNpemUpID09PSAndW5kZWZpbmVkJyA/IDYwIDogdGhpcy5vcHRpb25zLmhsc01pbmltdW1EdnJTaXplXG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIHN0YXJ0IHRpbWUgZXh0cmFwb2xhdGlvbiB3aW5kb3cgbWVhc3VyZWQgYXMgYSBtdWx0aXBsZSBvZiBzZWdtZW50cy5cbiAgICAvLyBTaG91bGQgYmUgMiBvciBoaWdoZXIsIG9yIDAgdG8gZGlzYWJsZS4gU2hvdWxkIG9ubHkgbmVlZCB0byBiZSBpbmNyZWFzZWQgYWJvdmUgMiBpZiBtb3JlIHRoYW4gb25lIHNlZ21lbnQgaXNcbiAgICAvLyByZW1vdmVkIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwbGF5bGlzdCBhdCBhIHRpbWUuIEUuZyBpZiB0aGUgcGxheWxpc3QgaXMgY2FjaGVkIGZvciAxMCBzZWNvbmRzIGFuZCBuZXcgY2h1bmtzIGFyZVxuICAgIC8vIGFkZGVkL3JlbW92ZWQgZXZlcnkgNS5cbiAgICB0aGlzLl9leHRyYXBvbGF0ZWRXaW5kb3dOdW1TZWdtZW50cyA9ICF0aGlzLm9wdGlvbnMucGxheWJhY2sgfHwgdHlwZW9mICh0aGlzLm9wdGlvbnMucGxheWJhY2suZXh0cmFwb2xhdGVkV2luZG93TnVtU2VnbWVudHMpID09PSAndW5kZWZpbmVkJyA/IDIgOiAgdGhpcy5vcHRpb25zLnBsYXliYWNrLmV4dHJhcG9sYXRlZFdpbmRvd051bVNlZ21lbnRzXG5cbiAgICB0aGlzLl9wbGF5YmFja1R5cGUgPSB0aGlzLm9wdGlvbnMucGxheWJhY2tUeXBlIHx8IFBsYXliYWNrLlZPRDtcbiAgICB0aGlzLl9sYXN0VGltZVVwZGF0ZSA9IHsgY3VycmVudDogMCwgdG90YWw6IDAgfVxuICAgIHRoaXMuX2xhc3REdXJhdGlvbiA9IG51bGxcbiAgICAvLyBmb3IgaGxzIHN0cmVhbXMgd2hpY2ggaGF2ZSBkdnIgd2l0aCBhIHNsaWRpbmcgd2luZG93LFxuICAgIC8vIHRoZSBjb250ZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgcGxheWxpc3QgaXMgcmVtb3ZlZCBhcyBuZXdcbiAgICAvLyBjb250ZW50IGlzIGFwcGVuZGVkIGF0IHRoZSBlbmQuXG4gICAgLy8gdGhpcyBtZWFucyB0aGUgYWN0dWFsIHBsYXlhYmxlIHN0YXJ0IHRpbWUgd2lsbCBpbmNyZWFzZSBhcyB0aGVcbiAgICAvLyBzdGFydCBjb250ZW50IGlzIGRlbGV0ZWRcbiAgICAvLyBGb3Igc3RyZWFtcyB3aXRoIGR2ciB3aGVyZSB0aGUgZW50aXJlIHJlY29yZGluZyBpcyBrZXB0IGZyb20gdGhlXG4gICAgLy8gYmVnaW5uaW5nIHRoaXMgc2hvdWxkIHN0YXkgYXMgMFxuICAgIHRoaXMuX3BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lID0gMFxuICAgIC8vIHtsb2NhbCwgcmVtb3RlfSByZW1vdGUgaXMgdGhlIHRpbWUgaW4gdGhlIHZpZGVvIGVsZW1lbnQgdGhhdCBzaG91bGQgcmVwcmVzZW50IDBcbiAgICAvLyAgICAgICAgICAgICAgICAgbG9jYWwgaXMgdGhlIHN5c3RlbSB0aW1lIHdoZW4gdGhlICdyZW1vdGUnIG1lYXN1cm1lbnQgdG9vayBwbGFjZVxuICAgIHRoaXMuX2xvY2FsU3RhcnRUaW1lQ29ycmVsYXRpb24gPSBudWxsXG4gICAgLy8ge2xvY2FsLCByZW1vdGV9IHJlbW90ZSBpcyB0aGUgdGltZSBpbiB0aGUgdmlkZW8gZWxlbWVudCB0aGF0IHNob3VsZCByZXByZXNlbnRzIHRoZSBlbmRcbiAgICAvLyAgICAgICAgICAgICAgICAgbG9jYWwgaXMgdGhlIHN5c3RlbSB0aW1lIHdoZW4gdGhlICdyZW1vdGUnIG1lYXN1cm1lbnQgdG9vayBwbGFjZVxuICAgIHRoaXMuX2xvY2FsRW5kVGltZUNvcnJlbGF0aW9uID0gbnVsbFxuICAgIC8vIGlmIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBiZWdpbm5pbmcgdGhlbiB0aGlzIGVtcHR5IGFyZWEgc2hvdWxkXG4gICAgLy8gYmUgaWdub3JlZC4gXCJwbGF5YWJsZVJlZ2lvbkR1cmF0aW9uXCIgZXhjbHVkZXMgdGhlIGVtcHR5IGFyZWFcbiAgICB0aGlzLl9wbGF5YWJsZVJlZ2lvbkR1cmF0aW9uID0gMFxuICAgIC8vICNFWFQtWC1QUk9HUkFNLURBVEUtVElNRVxuICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IDBcbiAgICAvLyB0cnVlIHdoZW4gdGhlIGFjdHVhbCBkdXJhdGlvbiBpcyBsb25nZXIgdGhhbiBobHNqcydzIGxpdmUgc3luYyBwb2ludFxuICAgIC8vIHdoZW4gdGhpcyBpcyBmYWxzZSBwbGF5YWJsZVJlZ2lvbkR1cmF0aW9uIHdpbGwgYmUgdGhlIGFjdHVhbCBkdXJhdGlvblxuICAgIC8vIHdoZW4gdGhpcyBpcyB0cnVlIHBsYXlhYmxlUmVnaW9uRHVyYXRpb24gd2lsbCBleGNsdWRlIHRoZSB0aW1lIGFmdGVyIHRoZSBzeW5jIHBvaW50XG4gICAgdGhpcy5fZHVyYXRpb25FeGNsdWRlc0FmdGVyTGl2ZVN5bmNQb2ludCA9IGZhbHNlXG4gICAgLy8gI0VYVC1YLVRBUkdFVERVUkFUSU9OXG4gICAgdGhpcy5fc2VnbWVudFRhcmdldER1cmF0aW9uID0gbnVsbFxuICAgIC8vICNFWFQtWC1QTEFZTElTVC1UWVBFXG4gICAgdGhpcy5fcGxheWxpc3RUeXBlID0gbnVsbFxuICAgIHRoaXMuX3JlY292ZXJBdHRlbXB0c1JlbWFpbmluZyA9IHRoaXMub3B0aW9ucy5obHNSZWNvdmVyQXR0ZW1wdHMgfHwgMTZcbiAgfVxuXG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLl9jY0lzU2V0dXAgPSBmYWxzZVxuICAgIHRoaXMuX2NjVHJhY2tzVXBkYXRlZCA9IGZhbHNlXG4gICAgdGhpcy5faGxzID0gbmV3IEhMU0pTKGFzc2lnbih7fSwgdGhpcy5vcHRpb25zLnBsYXliYWNrLmhsc2pzQ29uZmlnKSlcbiAgICB0aGlzLl9obHMub24oSExTSlMuRXZlbnRzLk1FRElBX0FUVEFDSEVELCAoKSA9PiB0aGlzLl9obHMubG9hZFNvdXJjZSh0aGlzLm9wdGlvbnMuc3JjKSlcbiAgICB0aGlzLl9obHMub24oSExTSlMuRXZlbnRzLkxFVkVMX0xPQURFRCwgKGV2dCwgZGF0YSkgPT4gdGhpcy5fdXBkYXRlUGxheWJhY2tUeXBlKGV2dCwgZGF0YSkpXG4gICAgdGhpcy5faGxzLm9uKEhMU0pTLkV2ZW50cy5MRVZFTF9VUERBVEVELCAoZXZ0LCBkYXRhKSA9PiB0aGlzLl9vbkxldmVsVXBkYXRlZChldnQsIGRhdGEpKVxuICAgIHRoaXMuX2hscy5vbihITFNKUy5FdmVudHMuTEVWRUxfU1dJVENISU5HLCAoZXZ0LGRhdGEpID0+IHRoaXMuX29uTGV2ZWxTd2l0Y2goZXZ0LCBkYXRhKSlcbiAgICB0aGlzLl9obHMub24oSExTSlMuRXZlbnRzLkZSQUdfTE9BREVELCAoZXZ0LCBkYXRhKSA9PiB0aGlzLl9vbkZyYWdtZW50TG9hZGVkKGV2dCwgZGF0YSkpXG4gICAgdGhpcy5faGxzLm9uKEhMU0pTLkV2ZW50cy5FUlJPUiwgKGV2dCwgZGF0YSkgPT4gdGhpcy5fb25ITFNKU0Vycm9yKGV2dCwgZGF0YSkpXG4gICAgdGhpcy5faGxzLm9uKEhMU0pTLkV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIChldnQsIGRhdGEpID0+IHRoaXMuX29uU3VidGl0bGVMb2FkZWQoZXZ0LCBkYXRhKSlcbiAgICB0aGlzLl9obHMub24oSExTSlMuRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCAoKSA9PiB0aGlzLl9jY1RyYWNrc1VwZGF0ZWQgPSB0cnVlKVxuICAgIHRoaXMuX2hscy5hdHRhY2hNZWRpYSh0aGlzLmVsKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuX3JlYWR5KClcbiAgICByZXR1cm4gc3VwZXIucmVuZGVyKClcbiAgfVxuXG4gIF9yZWFkeSgpIHtcbiAgICB0aGlzLl9pc1JlYWR5U3RhdGUgPSB0cnVlXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19SRUFEWSwgdGhpcy5uYW1lKVxuICB9XG5cbiAgX3JlY292ZXIoZXZ0LCBkYXRhLCBlcnJvcikge1xuICAgIGlmICghdGhpcy5fcmVjb3ZlcmVkRGVjb2RpbmdFcnJvcikge1xuICAgICAgdGhpcy5fcmVjb3ZlcmVkRGVjb2RpbmdFcnJvciA9IHRydWVcbiAgICAgIHRoaXMuX2hscy5yZWNvdmVyTWVkaWFFcnJvcigpXG4gICAgfSBlbHNlIGlmICghdGhpcy5fcmVjb3ZlcmVkQXVkaW9Db2RlY0Vycm9yKSB7XG4gICAgICB0aGlzLl9yZWNvdmVyZWRBdWRpb0NvZGVjRXJyb3IgPSB0cnVlXG4gICAgICB0aGlzLl9obHMuc3dhcEF1ZGlvQ29kZWMoKVxuICAgICAgdGhpcy5faGxzLnJlY292ZXJNZWRpYUVycm9yKClcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmVycm9yKCdobHNqczogZmFpbGVkIHRvIHJlY292ZXInLCB7IGV2dCwgZGF0YSB9KVxuICAgICAgZXJyb3IubGV2ZWwgPSBQbGF5ZXJFcnJvci5MZXZlbHMuRkFUQUxcbiAgICAgIGNvbnN0IGZvcm1hdHRlZEVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihlcnJvcilcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfRVJST1IsIGZvcm1hdHRlZEVycm9yKVxuICAgICAgdGhpcy5zdG9wKClcbiAgICB9XG4gIH1cblxuICAvLyBvdmVycmlkZVxuICBfc2V0dXBTcmMoc3JjVXJsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB0aGlzIHBsYXliYWNrIG1hbmFnZXMgdGhlIHNyYyBvbiB0aGUgdmlkZW8gZWxlbWVudCBpdHNlbGZcbiAgfVxuXG4gIF9zdGFydFRpbWVVcGRhdGVUaW1lcigpIHtcbiAgICBpZiAodGhpcy5fdGltZVVwZGF0ZVRpbWVyKSByZXR1cm5cblxuICAgIHRoaXMuX3RpbWVVcGRhdGVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuX29uRHVyYXRpb25DaGFuZ2UoKVxuICAgICAgdGhpcy5fb25UaW1lVXBkYXRlKClcbiAgICB9LCAxMDApXG4gIH1cblxuICBfc3RvcFRpbWVVcGRhdGVUaW1lcigpIHtcbiAgICBpZiAoIXRoaXMuX3RpbWVVcGRhdGVUaW1lcikgcmV0dXJuXG5cbiAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVVcGRhdGVUaW1lcilcbiAgICB0aGlzLl90aW1lVXBkYXRlVGltZXIgPSBudWxsXG4gIH1cblxuICBnZXRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW1EYXRlVGltZVxuICB9XG4gIC8vIHRoZSBkdXJhdGlvbiBvbiB0aGUgdmlkZW8gZWxlbWVudCBpdHNlbGYgc2hvdWxkIG5vdCBiZSB1c2VkXG4gIC8vIGFzIHRoaXMgZG9lcyBub3QgbmVjZXNhcmlseSByZXByZXNlbnQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzdHJlYW1cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NsYXBwci9jbGFwcHIvaXNzdWVzLzY2OCNpc3N1ZWNvbW1lbnQtMTU3MDM2Njc4XG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvblxuICB9XG5cbiAgZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gZS5nLiBjYW4gYmUgPCAwIGlmIHVzZXIgcGF1c2VzIG5lYXIgdGhlIHN0YXJ0XG4gICAgLy8gZXZlbnR1YWxseSB0aGV5IHdpbGwgdGhlbiBiZSBraWNrZWQgdG8gdGhlIGVuZCBieSBobHNqcyBpZiB0aGV5IHJ1biBvdXQgb2YgYnVmZmVyXG4gICAgLy8gYmVmb3JlIHRoZSBvZmZpY2lhbCBzdGFydCB0aW1lXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuZWwuY3VycmVudFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpXG4gIH1cblxuICAvLyB0aGUgdGltZSB0aGF0IFwiMFwiIG5vdyByZXByZXNlbnRzIHJlbGF0aXZlIHRvIHdoZW4gcGxheWJhY2sgc3RhcnRlZFxuICAvLyBmb3IgYSBzdHJlYW0gd2l0aCBhIHNsaWRpbmcgd2luZG93IHRoaXMgd2lsbCBpbmNyZWFzZSBhcyBjb250ZW50IGlzXG4gIC8vIHJlbW92ZWQgZnJvbSB0aGUgYmVnaW5uaW5nXG4gIGdldFN0YXJ0VGltZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lXG4gIH1cblxuICBzZWVrUGVyY2VudGFnZShwZXJjZW50YWdlKSB7XG4gICAgbGV0IHNlZWtUbyA9IHRoaXMuX2R1cmF0aW9uXG4gICAgaWYgKHBlcmNlbnRhZ2UgPiAwKVxuICAgICAgc2Vla1RvID0gdGhpcy5fZHVyYXRpb24gKiAocGVyY2VudGFnZSAvIDEwMClcblxuICAgIHRoaXMuc2VlayhzZWVrVG8pXG4gIH1cblxuICBzZWVrKHRpbWUpIHtcbiAgICBpZiAodGltZSA8IDApIHtcbiAgICAgIExvZy53YXJuKCdBdHRlbXB0IHRvIHNlZWsgdG8gYSBuZWdhdGl2ZSB0aW1lLiBSZXNldHRpbmcgdG8gbGl2ZSBwb2ludC4gVXNlIHNlZWtUb0xpdmVQb2ludCgpIHRvIHNlZWsgdG8gdGhlIGxpdmUgcG9pbnQuJylcbiAgICAgIHRpbWUgPSB0aGlzLmdldER1cmF0aW9uKClcbiAgICB9XG4gICAgLy8gYXNzdW1lIGxpdmUgaWYgdGltZSB3aXRoaW4gMyBzZWNvbmRzIG9mIGVuZCBvZiBzdHJlYW1cbiAgICB0aGlzLmR2ckVuYWJsZWQgJiYgdGhpcy5fdXBkYXRlRHZyKHRpbWUgPCB0aGlzLmdldER1cmF0aW9uKCktMylcbiAgICB0aW1lICs9IHRoaXMuX3N0YXJ0VGltZVxuICAgIHN1cGVyLnNlZWsodGltZSlcbiAgfVxuXG4gIHNlZWtUb0xpdmVQb2ludCgpIHtcbiAgICB0aGlzLnNlZWsodGhpcy5nZXREdXJhdGlvbigpKVxuICB9XG5cbiAgX3VwZGF0ZUR2cihzdGF0dXMpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX0RWUiwgc3RhdHVzKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfU1RBVFNfQURELCB7ICdkdnInOiBzdGF0dXMgfSlcbiAgfVxuXG4gIF91cGRhdGVTZXR0aW5ncygpIHtcbiAgICBpZiAodGhpcy5fcGxheWJhY2tUeXBlID09PSBQbGF5YmFjay5WT0QpXG4gICAgICB0aGlzLnNldHRpbmdzLmxlZnQgPSBbJ3BsYXlwYXVzZScsICdwb3NpdGlvbicsICdkdXJhdGlvbiddXG4gICAgZWxzZSBpZiAodGhpcy5kdnJFbmFibGVkKVxuICAgICAgdGhpcy5zZXR0aW5ncy5sZWZ0ID0gWydwbGF5cGF1c2UnXVxuICAgIGVsc2VcbiAgICAgIHRoaXMuc2V0dGluZ3MubGVmdCA9IFsncGxheXN0b3AnXVxuXG4gICAgdGhpcy5zZXR0aW5ncy5zZWVrRW5hYmxlZCA9IHRoaXMuaXNTZWVrRW5hYmxlZCgpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TRVRUSU5HU1VQREFURSlcbiAgfVxuXG4gIF9vbkhMU0pTRXJyb3IoZXZ0LCBkYXRhKSB7XG4gICAgY29uc3QgZXJyb3IgPSB7XG4gICAgICBjb2RlOiBgJHtkYXRhLnR5cGV9XyR7ZGF0YS5kZXRhaWxzfWAsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7dGhpcy5uYW1lfSBlcnJvcjogdHlwZTogJHtkYXRhLnR5cGV9LCBkZXRhaWxzOiAke2RhdGEuZGV0YWlsc31gLFxuICAgICAgcmF3OiBkYXRhLFxuICAgIH1cbiAgICBsZXQgZm9ybWF0dGVkRXJyb3JcbiAgICBpZiAoZGF0YS5yZXNwb25zZSkgZXJyb3IuZGVzY3JpcHRpb24gKz0gYCwgcmVzcG9uc2U6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YS5yZXNwb25zZSl9YFxuICAgIC8vIG9ubHkgcmVwb3J0L2hhbmRsZSBlcnJvcnMgaWYgdGhleSBhcmUgZmF0YWxcbiAgICAvLyBobHNqcyBzaG91bGQgYXV0b21hdGljYWxseSBoYW5kbGUgbm9uIGZhdGFsIGVycm9yc1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICBpZiAodGhpcy5fcmVjb3ZlckF0dGVtcHRzUmVtYWluaW5nID4gMCkge1xuICAgICAgICB0aGlzLl9yZWNvdmVyQXR0ZW1wdHNSZW1haW5pbmcgLT0gMVxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICBjYXNlIEhMU0pTLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUjpcbiAgICAgICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbmV0d29yayBlcnJvcnMgY2Fubm90IGJlIHJlY292ZXJlZCB3aXRoIEhMUy5zdGFydExvYWQoKVxuICAgICAgICAgIC8vIEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9ibG9iL21hc3Rlci9kb2MvZGVzaWduLm1kI2Vycm9yLWRldGVjdGlvbi1hbmQtaGFuZGxpbmdcbiAgICAgICAgICAvLyBGb3IgXCJsZXZlbCBsb2FkXCIgZmF0YWwgZXJyb3JzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzExMzhcbiAgICAgICAgICBjYXNlIEhMU0pTLkVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX0VSUk9SOlxuICAgICAgICAgIGNhc2UgSExTSlMuRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBjYXNlIEhMU0pTLkVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAgIGNhc2UgSExTSlMuRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgICAgY2FzZSBITFNKUy5FcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICAgICAgTG9nLmVycm9yKCdobHNqczogdW5yZWNvdmVyYWJsZSBuZXR3b3JrIGZhdGFsIGVycm9yLicsIHsgZXZ0LCBkYXRhIH0pXG4gICAgICAgICAgICBmb3JtYXR0ZWRFcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX0VSUk9SLCBmb3JtYXR0ZWRFcnJvcilcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBMb2cud2FybignaGxzanM6IHRyeWluZyB0byByZWNvdmVyIGZyb20gbmV0d29yayBlcnJvci4nLCB7IGV2dCwgZGF0YSB9KVxuICAgICAgICAgICAgZXJyb3IubGV2ZWwgPSBQbGF5ZXJFcnJvci5MZXZlbHMuV0FSTlxuICAgICAgICAgICAgdGhpcy5jcmVhdGVFcnJvcihlcnJvcilcbiAgICAgICAgICAgIHRoaXMuX2hscy5zdGFydExvYWQoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBITFNKUy5FcnJvclR5cGVzLk1FRElBX0VSUk9SOlxuICAgICAgICAgIExvZy53YXJuKCdobHNqczogdHJ5aW5nIHRvIHJlY292ZXIgZnJvbSBtZWRpYSBlcnJvci4nLCB7IGV2dCwgZGF0YSB9KVxuICAgICAgICAgIGVycm9yLmxldmVsID0gUGxheWVyRXJyb3IuTGV2ZWxzLldBUk5cbiAgICAgICAgICB0aGlzLmNyZWF0ZUVycm9yKGVycm9yKVxuICAgICAgICAgIHRoaXMuX3JlY292ZXIoZXZ0LCBkYXRhLCBlcnJvcilcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIExvZy5lcnJvcignaGxzanM6IGNvdWxkIG5vdCByZWNvdmVyIGZyb20gZXJyb3IuJywgeyBldnQsIGRhdGEgfSlcbiAgICAgICAgICBmb3JtYXR0ZWRFcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoZXJyb3IpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19FUlJPUiwgZm9ybWF0dGVkRXJyb3IpXG4gICAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2cuZXJyb3IoJ2hsc2pzOiBjb3VsZCBub3QgcmVjb3ZlciBmcm9tIGVycm9yIGFmdGVyIG1heGltdW0gbnVtYmVyIG9mIGF0dGVtcHRzLicsIHsgZXZ0LCBkYXRhIH0pXG4gICAgICAgIGZvcm1hdHRlZEVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihlcnJvcilcbiAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19FUlJPUiwgZm9ybWF0dGVkRXJyb3IpXG4gICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybXMgSExTSlMuRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SIG5vbi1mYXRhbCBlcnJvciB0b1xuICAgICAgLy8gcGxheWJhY2sgZmF0YWwgZXJyb3IgaWYgdHJpZ2dlckZhdGFsRXJyb3JPblJlc291cmNlRGVuaWVkIHBsYXliYWNrXG4gICAgICAvLyBvcHRpb24gaXMgc2V0LiBITFNKUy5FcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IgYXJlIGZhdGFsIGVycm9yc1xuICAgICAgLy8gYW5kIHRoZXJlZm9yZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBsYXliYWNrLnRyaWdnZXJGYXRhbEVycm9yT25SZXNvdXJjZURlbmllZCAmJiB0aGlzLl9rZXlJc0RlbmllZChkYXRhKSkge1xuICAgICAgICBMb2cuZXJyb3IoJ2hsc2pzOiBjb3VsZCBub3QgbG9hZCBkZWNyeXB0IGtleS4nLCB7IGV2dCwgZGF0YSB9KVxuICAgICAgICBmb3JtYXR0ZWRFcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfRVJST1IsIGZvcm1hdHRlZEVycm9yKVxuICAgICAgICB0aGlzLnN0b3AoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZXJyb3IubGV2ZWwgPSBQbGF5ZXJFcnJvci5MZXZlbHMuV0FSTlxuICAgICAgdGhpcy5jcmVhdGVFcnJvcihlcnJvcilcbiAgICAgIExvZy53YXJuKCdobHNqczogbm9uLWZhdGFsIGVycm9yIG9jY3VycmVkJywgeyBldnQsIGRhdGEgfSlcbiAgICB9XG4gIH1cblxuICBfa2V5SXNEZW5pZWQoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnR5cGUgPT09IEhMU0pTLkVycm9yVHlwZXMuTkVUV09SS19FUlJPUlxuICAgICAgJiYgZGF0YS5kZXRhaWxzID09PSBITFNKUy5FcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1JcbiAgICAgICYmIGRhdGEucmVzcG9uc2VcbiAgICAgICYmIGRhdGEucmVzcG9uc2UuY29kZSA+PSA0MDBcbiAgICAgIHx8IGRhdGEuZGV0YWlscyA9PT0gSExTSlMuRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SXG4gICAgICB8fCAoZGF0YS5kZXRhaWxzID09PSBITFNKUy5FcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUiAmJiAhdGhpcy5nZXRDdXJyZW50VGltZSgpKTsgICAgICBcbiAgfVxuXG4gIF9vblRpbWVVcGRhdGUoKSB7XG4gICAgbGV0IHVwZGF0ZSA9IHsgY3VycmVudDogdGhpcy5nZXRDdXJyZW50VGltZSgpLCB0b3RhbDogdGhpcy5nZXREdXJhdGlvbigpLCBmaXJzdEZyYWdEYXRlVGltZTogdGhpcy5nZXRQcm9ncmFtRGF0ZVRpbWUoKSB9XG4gICAgbGV0IGlzU2FtZSA9IHRoaXMuX2xhc3RUaW1lVXBkYXRlICYmIChcbiAgICAgIHVwZGF0ZS5jdXJyZW50ID09PSB0aGlzLl9sYXN0VGltZVVwZGF0ZS5jdXJyZW50ICYmXG4gICAgICB1cGRhdGUudG90YWwgPT09IHRoaXMuX2xhc3RUaW1lVXBkYXRlLnRvdGFsKVxuICAgIGlmIChpc1NhbWUpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuX2xhc3RUaW1lVXBkYXRlID0gdXBkYXRlXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19USU1FVVBEQVRFLCB1cGRhdGUsIHRoaXMubmFtZSlcbiAgfVxuXG4gIF9vbkR1cmF0aW9uQ2hhbmdlKCkge1xuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKVxuICAgIGlmICh0aGlzLl9sYXN0RHVyYXRpb24gPT09IGR1cmF0aW9uKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLl9sYXN0RHVyYXRpb24gPSBkdXJhdGlvblxuICAgIHN1cGVyLl9vbkR1cmF0aW9uQ2hhbmdlKClcbiAgfVxuXG4gIF9vblByb2dyZXNzKCkge1xuICAgIGlmICghdGhpcy5lbC5idWZmZXJlZC5sZW5ndGgpXG4gICAgICByZXR1cm5cblxuICAgIGxldCBidWZmZXJlZCA9IFtdXG4gICAgbGV0IGJ1ZmZlcmVkUG9zID0gMFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbC5idWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyZWQgPSBbLi4uYnVmZmVyZWQsIHtcbiAgICAgICAgLy8gZm9yIGEgc3RyZWFtIHdpdGggc2xpZGluZyB3aW5kb3cgZHZyIHNvbWV0aGluZyB0aGF0IGlzIGJ1ZmZlcmVkIG15IHNsaWRlIG9mZiB0aGUgc3RhcnQgb2YgdGhlIHRpbWVsaW5lXG4gICAgICAgIHN0YXJ0OiBNYXRoLm1heCgwLCB0aGlzLmVsLmJ1ZmZlcmVkLnN0YXJ0KGkpIC0gdGhpcy5fcGxheWFibGVSZWdpb25TdGFydFRpbWUpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KDAsIHRoaXMuZWwuYnVmZmVyZWQuZW5kKGkpIC0gdGhpcy5fcGxheWFibGVSZWdpb25TdGFydFRpbWUpXG4gICAgICB9XVxuICAgICAgaWYgKHRoaXMuZWwuY3VycmVudFRpbWUgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgdGhpcy5lbC5jdXJyZW50VGltZSA8PSBidWZmZXJlZFtpXS5lbmQpXG4gICAgICAgIGJ1ZmZlcmVkUG9zID0gaVxuXG4gICAgfVxuICAgIGNvbnN0IHByb2dyZXNzID0ge1xuICAgICAgc3RhcnQ6IGJ1ZmZlcmVkW2J1ZmZlcmVkUG9zXS5zdGFydCxcbiAgICAgIGN1cnJlbnQ6IGJ1ZmZlcmVkW2J1ZmZlcmVkUG9zXS5lbmQsXG4gICAgICB0b3RhbDogdGhpcy5nZXREdXJhdGlvbigpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfUFJPR1JFU1MsIHByb2dyZXNzLCBidWZmZXJlZClcbiAgfVxuXG4gIHBsYXkoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAvLyAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMucGx1Z2lucykuaW5kZXhPZignVmFzdEFkcycpID4gLTFcbiAgICAgICBsZXQgbGliID0gISEod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLmltYSkgfHwgISEod2luZG93LnlhICYmIHdpbmRvdy55YS52aWRlb0FkKVxuICAgICAgaWYobGliICYmIHRoaXMub3B0aW9ucy5wbHVnaW5zICYmIHRoaXMub3B0aW9ucy5WYXN0QWRzLnByZXJvbGwgJiYgdGhpcy5vcHRpb25zLlZhc3RBZHMucHJlcm9sbC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19QUkVST0xMX1JFUVVFU1QpICAgICAgICBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAgICAgIFxuICAgIH0gY2F0Y2goZSkge1xuXG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5faGxzKVxuICAgICAgdGhpcy5fc2V0dXAoKVxuXG4gICAgc3VwZXIucGxheSgpXG4gICAgdGhpcy5fc3RhcnRUaW1lVXBkYXRlVGltZXIoKVxuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgaWYgKCF0aGlzLl9obHMpXG4gICAgICByZXR1cm5cblxuICAgIHN1cGVyLnBhdXNlKClcbiAgICBpZiAodGhpcy5kdnJFbmFibGVkKVxuICAgICAgdGhpcy5fdXBkYXRlRHZyKHRydWUpXG5cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fc3RvcFRpbWVVcGRhdGVUaW1lcigpXG4gICAgaWYgKHRoaXMuX2hscykge1xuICAgICAgc3VwZXIuc3RvcCgpXG4gICAgICB0aGlzLl9obHMuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5faGxzXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdG9wVGltZVVwZGF0ZVRpbWVyKClcbiAgICBpZiAodGhpcy5faGxzKSB7XG4gICAgICB0aGlzLl9obHMuZGVzdHJveSgpXG4gICAgICBkZWxldGUgdGhpcy5faGxzXG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgX3VwZGF0ZVBsYXliYWNrVHlwZShldnQsIGRhdGEpIHtcbiAgICB0aGlzLl9wbGF5YmFja1R5cGUgPSBkYXRhLmRldGFpbHMubGl2ZSA/IFBsYXliYWNrLkxJVkUgOiBQbGF5YmFjay5WT0RcbiAgICB0aGlzLl9vbkxldmVsVXBkYXRlZChldnQsIGRhdGEpXG5cbiAgICAvLyBMaXZlIHN0cmVhbSBzdWJ0aXRsZSB0cmFja3MgZGV0ZWN0aW9uIGhhY2sgKG1heSBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlKVxuICAgIGlmICh0aGlzLl9jY1RyYWNrc1VwZGF0ZWQgJiYgdGhpcy5fcGxheWJhY2tUeXBlID09PSBQbGF5YmFjay5MSVZFICYmIHRoaXMuaGFzQ2xvc2VkQ2FwdGlvbnNUcmFja3MpXG4gICAgICB0aGlzLl9vblN1YnRpdGxlTG9hZGVkKClcblxuICB9XG5cbiAgX2ZpbGxMZXZlbHMoKSB7XG4gICAgdGhpcy5fbGV2ZWxzID0gdGhpcy5faGxzLmxldmVscy5tYXAoKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIHsgaWQ6IGluZGV4LCBsZXZlbDogbGV2ZWwsIGxhYmVsOiBgJHtsZXZlbC5iaXRyYXRlLzEwMDB9S2Jwc2AgfVxuICAgIH0pXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19MRVZFTFNfQVZBSUxBQkxFLCB0aGlzLl9sZXZlbHMpXG4gIH1cblxuICBfb25MZXZlbFVwZGF0ZWQoZXZ0LCBkYXRhKSB7XG4gICAgdGhpcy5fc2VnbWVudFRhcmdldER1cmF0aW9uID0gZGF0YS5kZXRhaWxzLnRhcmdldGR1cmF0aW9uXG4gICAgdGhpcy5fcGxheWxpc3RUeXBlID0gZGF0YS5kZXRhaWxzLnR5cGUgfHwgbnVsbFxuXG4gICAgbGV0IHN0YXJ0VGltZUNoYW5nZWQgPSBmYWxzZVxuICAgIGxldCBkdXJhdGlvbkNoYW5nZWQgPSBmYWxzZVxuICAgIGxldCBmcmFnbWVudHMgPSBkYXRhLmRldGFpbHMuZnJhZ21lbnRzXG4gICAgbGV0IHByZXZpb3VzUGxheWFibGVSZWdpb25TdGFydFRpbWUgPSB0aGlzLl9wbGF5YWJsZVJlZ2lvblN0YXJ0VGltZVxuICAgIGxldCBwcmV2aW91c1BsYXlhYmxlUmVnaW9uRHVyYXRpb24gPSB0aGlzLl9wbGF5YWJsZVJlZ2lvbkR1cmF0aW9uXG5cbiAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVyblxuXG5cbiAgICAvLyAjRVhULVgtUFJPR1JBTS1EQVRFLVRJTUVcbiAgICBpZiAoZnJhZ21lbnRzWzBdLnJhd1Byb2dyYW1EYXRlVGltZSlcbiAgICAgIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IGZyYWdtZW50c1swXS5yYXdQcm9ncmFtRGF0ZVRpbWVcblxuXG4gICAgaWYgKHRoaXMuX3BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lICE9PSBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgIHN0YXJ0VGltZUNoYW5nZWQgPSB0cnVlXG4gICAgICB0aGlzLl9wbGF5YWJsZVJlZ2lvblN0YXJ0VGltZSA9IGZyYWdtZW50c1swXS5zdGFydFxuICAgIH1cblxuICAgIGlmIChzdGFydFRpbWVDaGFuZ2VkKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RhcnRUaW1lQ29ycmVsYXRpb24pIHtcbiAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWxhdGlvbiB0byBtYXAgdG8gbWlkZGxlIG9mIHRoZSBleHRyYXBvbGF0aW9uIHdpbmRvd1xuICAgICAgICB0aGlzLl9sb2NhbFN0YXJ0VGltZUNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgIGxvY2FsOiB0aGlzLl9ub3csXG4gICAgICAgICAgcmVtb3RlOiAoZnJhZ21lbnRzWzBdLnN0YXJ0ICsgKHRoaXMuX2V4dHJhcG9sYXRlZFdpbmRvd0R1cmF0aW9uLzIpKSAqIDEwMDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNvcnJlbGF0aW9uIHN0aWxsIHdvcmtzXG4gICAgICAgIGxldCBjb3JyID0gdGhpcy5fbG9jYWxTdGFydFRpbWVDb3JyZWxhdGlvblxuICAgICAgICBsZXQgdGltZVBhc3NlZCA9IHRoaXMuX25vdyAtIGNvcnIubG9jYWxcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgcG9pbnQgdG8gYSB0aW1lIHdpdGhpbiB0aGUgZXh0cmFwb2xhdGlvbiB3aW5kb3dcbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IChjb3JyLnJlbW90ZSArIHRpbWVQYXNzZWQpIC8gMTAwMFxuICAgICAgICBpZiAoc3RhcnRUaW1lIDwgZnJhZ21lbnRzWzBdLnN0YXJ0KSB7XG4gICAgICAgICAgLy8gb3VyIHN0YXJ0IHRpbWUgaXMgbm93IGVhcmxpZXIgdGhhbiB0aGUgZmlyc3QgY2h1bmtcbiAgICAgICAgICAvLyAobWF5YmUgdGhlIGNodW5rIHdhcyByZW1vdmVkIGVhcmx5KVxuICAgICAgICAgIC8vIHJlc2V0IGNvcnJlbGF0aW9uIHNvIHRoYXQgaXQgc2l0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaXJzdCBhdmFpbGFibGUgY2h1bmtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0YXJ0VGltZUNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgICAgbG9jYWw6IHRoaXMuX25vdyxcbiAgICAgICAgICAgIHJlbW90ZTogZnJhZ21lbnRzWzBdLnN0YXJ0ICogMTAwMFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFRpbWUgPiBwcmV2aW91c1BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lICsgdGhpcy5fZXh0cmFwb2xhdGVkV2luZG93RHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBzdGFydCB0aW1lIHdhcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG9sZCBleHRyYXBvbGF0aW9uIHdpbmRvdyAoc28gd291bGQgaGF2ZSBiZWVuIGNhcHBlZClcbiAgICAgICAgICAvLyBzZWUgaWYgbm93IHRoYXQgdGltZSB3b3VsZCBiZSBpbnNpZGUgdGhlIHdpbmRvdywgYW5kIGlmIGl0IHdvdWxkIGJlIHNldCB0aGUgY29ycmVsYXRpb25cbiAgICAgICAgICAvLyBzbyB0aGF0IGl0IHJlc3VtZXMgZnJvbSB0aGUgdGltZSBpdCB3YXMgYXQgYXQgdGhlIGVuZCBvZiB0aGUgb2xkIHdpbmRvd1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY29ycmVsYXRpb24gc28gdGhhdCB0aGUgdGltZSBzdGFydHMgY291bnRpbmcgYWdhaW4gZnJvbSB0aGUgdmFsdWUgaXQncyBvbiBub3dcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0YXJ0VGltZUNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgICAgbG9jYWw6IHRoaXMuX25vdyxcbiAgICAgICAgICAgIHJlbW90ZTogTWF0aC5tYXgoZnJhZ21lbnRzWzBdLnN0YXJ0LCBwcmV2aW91c1BsYXlhYmxlUmVnaW9uU3RhcnRUaW1lICsgdGhpcy5fZXh0cmFwb2xhdGVkV2luZG93RHVyYXRpb24pICogMTAwMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBuZXdEdXJhdGlvbiA9IGRhdGEuZGV0YWlscy50b3RhbGR1cmF0aW9uXG4gICAgLy8gaWYgaXQncyBhIGxpdmUgc3RyZWFtIHRoZW4gc2hvcnRlbiB0aGUgZHVyYXRpb24gdG8gcmVtb3ZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBhcmVhIGFmdGVyIGhsc2pzJ3MgbGl2ZSBzeW5jIHBvaW50XG4gICAgLy8gc2Vla3MgdG8gYXJlYXMgYWZ0ZXIgdGhpcyBwb2ludCBzb21ldGltZXMgaGF2ZSBpc3N1ZXNcbiAgICBpZiAodGhpcy5fcGxheWJhY2tUeXBlID09PSBQbGF5YmFjay5MSVZFKSB7XG4gICAgICBsZXQgZnJhZ21lbnRUYXJnZXREdXJhdGlvbiA9IGRhdGEuZGV0YWlscy50YXJnZXRkdXJhdGlvblxuICAgICAgbGV0IGhsc2pzQ29uZmlnID0gdGhpcy5vcHRpb25zLnBsYXliYWNrLmhsc2pzQ29uZmlnIHx8IHt9XG4gICAgICBsZXQgbGl2ZVN5bmNEdXJhdGlvbkNvdW50ID0gaGxzanNDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IEhMU0pTLkRlZmF1bHRDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50XG4gICAgICBsZXQgaGlkZGVuQXJlYUR1cmF0aW9uID0gZnJhZ21lbnRUYXJnZXREdXJhdGlvbiAqIGxpdmVTeW5jRHVyYXRpb25Db3VudFxuICAgICAgaWYgKGhpZGRlbkFyZWFEdXJhdGlvbiA8PSBuZXdEdXJhdGlvbikge1xuICAgICAgICBuZXdEdXJhdGlvbiAtPSBoaWRkZW5BcmVhRHVyYXRpb25cbiAgICAgICAgdGhpcy5fZHVyYXRpb25FeGNsdWRlc0FmdGVyTGl2ZVN5bmNQb2ludCA9IHRydWVcbiAgICAgIH0gZWxzZSB7IHRoaXMuX2R1cmF0aW9uRXhjbHVkZXNBZnRlckxpdmVTeW5jUG9pbnQgPSBmYWxzZSB9XG5cbiAgICB9XG5cbiAgICBpZiAobmV3RHVyYXRpb24gIT09IHRoaXMuX3BsYXlhYmxlUmVnaW9uRHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uQ2hhbmdlZCA9IHRydWVcbiAgICAgIHRoaXMuX3BsYXlhYmxlUmVnaW9uRHVyYXRpb24gPSBuZXdEdXJhdGlvblxuICAgIH1cblxuICAgIC8vIE5vdGUgdGhlIGVuZCB0aW1lIGlzIG5vdCB0aGUgcGxheWFibGVSZWdpb25EdXJhdGlvblxuICAgIC8vIFRoZSBlbmQgdGltZSB3aWxsIGFsd2F5cyBpbmNyZWFzZSBldmVuIGlmIGNvbnRlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICBsZXQgZW5kVGltZSA9IGZyYWdtZW50c1swXS5zdGFydCArIG5ld0R1cmF0aW9uXG4gICAgbGV0IHByZXZpb3VzRW5kVGltZSA9IHByZXZpb3VzUGxheWFibGVSZWdpb25TdGFydFRpbWUgKyBwcmV2aW91c1BsYXlhYmxlUmVnaW9uRHVyYXRpb25cbiAgICBsZXQgZW5kVGltZUNoYW5nZWQgPSBlbmRUaW1lICE9PSBwcmV2aW91c0VuZFRpbWVcbiAgICBpZiAoZW5kVGltZUNoYW5nZWQpIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxFbmRUaW1lQ29ycmVsYXRpb24pIHtcbiAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWxhdGlvbiB0byBtYXAgdG8gdGhlIGVuZFxuICAgICAgICB0aGlzLl9sb2NhbEVuZFRpbWVDb3JyZWxhdGlvbiA9IHtcbiAgICAgICAgICBsb2NhbDogdGhpcy5fbm93LFxuICAgICAgICAgIHJlbW90ZTogZW5kVGltZSAqIDEwMDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNvcnJlbGF0aW9uIHN0aWxsIHdvcmtzXG4gICAgICAgIGxldCBjb3JyID0gdGhpcy5fbG9jYWxFbmRUaW1lQ29ycmVsYXRpb25cbiAgICAgICAgbGV0IHRpbWVQYXNzZWQgPSB0aGlzLl9ub3cgLSBjb3JyLmxvY2FsXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIHBvaW50IHRvIGEgdGltZSB3aXRoaW4gdGhlIGV4dHJhcG9sYXRpb24gd2luZG93IGZyb20gdGhlIGVuZFxuICAgICAgICBsZXQgZXh0cmFwb2xhdGVkRW5kVGltZSA9IChjb3JyLnJlbW90ZSArIHRpbWVQYXNzZWQpIC8gMTAwMFxuICAgICAgICBpZiAoZXh0cmFwb2xhdGVkRW5kVGltZSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbEVuZFRpbWVDb3JyZWxhdGlvbiA9IHtcbiAgICAgICAgICAgIGxvY2FsOiB0aGlzLl9ub3csXG4gICAgICAgICAgICByZW1vdGU6IGVuZFRpbWUgKiAxMDAwXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlZEVuZFRpbWUgPCBlbmRUaW1lIC0gdGhpcy5fZXh0cmFwb2xhdGVkV2luZG93RHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXIgZXh0cmFwb2xhdGVkIGVuZCB0aW1lIGlzIG5vdyBlYXJsaWVyIHRoYW4gdGhlIGV4dHJhcG9sYXRpb24gd2luZG93IGZyb20gdGhlIGFjdHVhbCBlbmQgdGltZVxuICAgICAgICAgIC8vIChtYXliZSBhIGNodW5rIGJlY2FtZSBhdmFpbGFibGUgZWFybHkpXG4gICAgICAgICAgLy8gcmVzZXQgY29ycmVsYXRpb24gc28gdGhhdCBpdCBzaXRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGV4dHJhcG9sYXRpb24gd2luZG93IGZyb20gdGhlIGVuZCB0aW1lXG4gICAgICAgICAgdGhpcy5fbG9jYWxFbmRUaW1lQ29ycmVsYXRpb24gPSB7XG4gICAgICAgICAgICBsb2NhbDogdGhpcy5fbm93LFxuICAgICAgICAgICAgcmVtb3RlOiAoZW5kVGltZSAtIHRoaXMuX2V4dHJhcG9sYXRlZFdpbmRvd0R1cmF0aW9uKSAqIDEwMDBcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVkRW5kVGltZSA+IHByZXZpb3VzRW5kVGltZSkge1xuICAgICAgICAgIC8vIGVuZCB0aW1lIHdhcyBwYXN0IHRoZSBvbGQgZW5kIHRpbWUgKHNvIHdvdWxkIGhhdmUgYmVlbiBjYXBwZWQpXG4gICAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWxhdGlvbiBzbyB0aGF0IGl0IHJlc3VtZXMgZnJvbSB0aGUgdGltZSBpdCB3YXMgYXQgYXQgdGhlIGVuZCBvZiB0aGUgb2xkIHdpbmRvd1xuICAgICAgICAgIHRoaXMuX2xvY2FsRW5kVGltZUNvcnJlbGF0aW9uID0ge1xuICAgICAgICAgICAgbG9jYWw6IHRoaXMuX25vdyxcbiAgICAgICAgICAgIHJlbW90ZTogcHJldmlvdXNFbmRUaW1lICogMTAwMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyB0aGF0IHRoZSB2YWx1ZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgY2FsbCBhbnkgbWV0aG9kcyB0aGF0IHVzZSBvbiB0aGVtIHNvIHRoZXkgZ2V0IHRoZSB1cGRhdGVkIHZhbHVlc1xuICAgIC8vIGltbWVkaWF0ZWx5XG4gICAgZHVyYXRpb25DaGFuZ2VkICYmIHRoaXMuX29uRHVyYXRpb25DaGFuZ2UoKVxuICAgIHN0YXJ0VGltZUNoYW5nZWQgJiYgdGhpcy5fb25Qcm9ncmVzcygpXG4gIH1cblxuICBfb25GcmFnbWVudExvYWRlZChldnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX0ZSQUdNRU5UX0xPQURFRCwgZGF0YSlcbiAgfVxuXG4gIF9vblN1YnRpdGxlTG9hZGVkKCkge1xuICAgIC8vIFRoaXMgZXZlbnQgbWF5IGJlIHRyaWdnZXJlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIFNldHVwIENDIG9ubHkgb25jZSAoZGlzYWJsZSBDQyBieSBkZWZhdWx0KVxuICAgIGlmICghdGhpcy5fY2NJc1NldHVwKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1NVQlRJVExFX0FWQUlMQUJMRSlcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSB0aGlzLl9wbGF5YmFja1R5cGUgPT09IFBsYXliYWNrLkxJVkUgPyAtMSA6IHRoaXMuY2xvc2VkQ2FwdGlvbnNUcmFja0lkXG4gICAgICB0aGlzLmNsb3NlZENhcHRpb25zVHJhY2tJZCA9IHRyYWNrSWRcbiAgICAgIHRoaXMuX2NjSXNTZXR1cCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBfb25MZXZlbFN3aXRjaChldnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubGV2ZWxzLmxlbmd0aClcbiAgICAgIHRoaXMuX2ZpbGxMZXZlbHMoKVxuXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19MRVZFTF9TV0lUQ0hfRU5EKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfTEVWRUxfU1dJVENILCBkYXRhKVxuICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLl9obHMubGV2ZWxzW2RhdGEubGV2ZWxdXG4gICAgaWYgKGN1cnJlbnRMZXZlbCkge1xuICAgICAgLy8gVE9ETyBzaG91bGQgaGlnaERlZmluaXRpb24gYmUgcHJpdmF0ZSBhbmQgbWF5YmUgaGF2ZSBhIHJlYWQgb25seSBhY2Nlc3NvciBpZiBpdCdzIHVzZWQgc29tZXdoZXJlXG4gICAgICB0aGlzLmhpZ2hEZWZpbml0aW9uID0gKGN1cnJlbnRMZXZlbC5oZWlnaHQgPj0gNzIwIHx8IChjdXJyZW50TGV2ZWwuYml0cmF0ZSAvIDEwMDApID49IDIwMDApXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX0hJR0hERUZJTklUSU9OVVBEQVRFLCB0aGlzLmhpZ2hEZWZpbml0aW9uKVxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19CSVRSQVRFLCB7XG4gICAgICAgIGhlaWdodDogY3VycmVudExldmVsLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGN1cnJlbnRMZXZlbC53aWR0aCxcbiAgICAgICAgYmFuZHdpZHRoOiBjdXJyZW50TGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgYml0cmF0ZTogY3VycmVudExldmVsLmJpdHJhdGUsXG4gICAgICAgIGxldmVsOiBkYXRhLmxldmVsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGdldCBkdnJFbmFibGVkKCkge1xuICAgIC8vIGVuYWJsZWQgd2hlbjpcbiAgICAvLyAtIHRoZSBkdXJhdGlvbiBkb2VzIG5vdCBpbmNsdWRlIGNvbnRlbnQgYWZ0ZXIgaGxzanMncyBsaXZlIHN5bmMgcG9pbnRcbiAgICAvLyAtIHRoZSBwbGF5YWJsZSByZWdpb24gZHVyYXRpb24gaXMgbG9uZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgZHVyYXRpb24gdG8gZW5hYmxlIGR2ciBhZnRlclxuICAgIC8vIC0gdGhlIHBsYXliYWNrIHR5cGUgaXMgTElWRS5cbiAgICByZXR1cm4gKHRoaXMuX2R1cmF0aW9uRXhjbHVkZXNBZnRlckxpdmVTeW5jUG9pbnQgJiYgdGhpcy5fZHVyYXRpb24gPj0gdGhpcy5fbWluRHZyU2l6ZSAmJiB0aGlzLmdldFBsYXliYWNrVHlwZSgpID09PSBQbGF5YmFjay5MSVZFKVxuICB9XG5cbiAgZ2V0UGxheWJhY2tUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1R5cGVcbiAgfVxuXG4gIGlzU2Vla0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9wbGF5YmFja1R5cGUgPT09IFBsYXliYWNrLlZPRCB8fCB0aGlzLmR2ckVuYWJsZWQpXG4gIH1cbn1cblxuSExTLmNhblBsYXkgPSBmdW5jdGlvbihyZXNvdXJjZSwgbWltZVR5cGUpIHtcbiAgY29uc3QgcmVzb3VyY2VQYXJ0cyA9IHJlc291cmNlLnNwbGl0KCc/JylbMF0ubWF0Y2goLy4qXFwuKC4qKSQvKSB8fCBbXVxuICBjb25zdCBpc0hscyA9ICgocmVzb3VyY2VQYXJ0cy5sZW5ndGggPiAxICYmIHJlc291cmNlUGFydHNbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ20zdTgnKSB8fCBsaXN0Q29udGFpbnNJZ25vcmVDYXNlKG1pbWVUeXBlLCBbJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJywgJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCddKSlcblxuICByZXR1cm4gISEoSExTSlMuaXNTdXBwb3J0ZWQoKSAmJiBpc0hscylcbn0iLCJpbXBvcnQgSExTIGZyb20gJy4vaGxzJ1xuZXhwb3J0IGRlZmF1bHQgSExTXG4iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IFBsYXliYWNrIGZyb20gJy4uLy4uL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgSFRNTDVWaWRlbyBmcm9tICcuLi8uLi9wbGF5YmFja3MvaHRtbDVfdmlkZW8nXG5cbi8vIFRPRE86IHJlbW92ZSB0aGlzIHBsYXliYWNrIGFuZCBjaGFuZ2UgSFRNTDVWaWRlbyB0byBIVE1MNVBsYXliYWNrIChicmVha2luZyBjaGFuZ2UsIG9ubHkgYWZ0ZXIgMC4zLjApXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVE1MNUF1ZGlvIGV4dGVuZHMgSFRNTDVWaWRlbyB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2h0bWw1X2F1ZGlvJyB9XG4gIGdldCB0YWdOYW1lKCkgeyByZXR1cm4gJ2F1ZGlvJyB9XG5cbiAgZ2V0IGlzQXVkaW9Pbmx5KCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB1cGRhdGVTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzLmxlZnQgPSBbJ3BsYXlwYXVzZScsICdwb3NpdGlvbicsICdkdXJhdGlvbiddXG4gICAgdGhpcy5zZXR0aW5ncy5zZWVrRW5hYmxlZCA9IHRoaXMuaXNTZWVrRW5hYmxlZCgpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TRVRUSU5HU1VQREFURSlcbiAgfVxuXG4gIGdldFBsYXliYWNrVHlwZSgpIHtcbiAgICByZXR1cm4gUGxheWJhY2suQU9EXG4gIH1cbn1cblxuSFRNTDVBdWRpby5jYW5QbGF5ID0gZnVuY3Rpb24ocmVzb3VyY2VVcmwsIG1pbWVUeXBlKSB7XG4gIGNvbnN0IG1pbWV0eXBlcyA9IHtcbiAgICAnd2F2JzogWydhdWRpby93YXYnXSxcbiAgICAnbXAzJzogWydhdWRpby9tcDMnLCAnYXVkaW8vbXBlZztjb2RlY3M9XCJtcDNcIiddLFxuICAgICdhYWMnOiBbJ2F1ZGlvL21wNDtjb2RlY3M9XCJtcDRhLjQwLjVcIiddLFxuICAgICdvZ2EnOiBbJ2F1ZGlvL29nZyddXG4gIH1cbiAgcmV0dXJuIEhUTUw1VmlkZW8uX2NhblBsYXkoJ2F1ZGlvJywgbWltZXR5cGVzLCByZXNvdXJjZVVybCwgbWltZVR5cGUpXG59XG4iLCJpbXBvcnQgSFRNTDVBdWRpbyBmcm9tICcuL2h0bWw1X2F1ZGlvJ1xuZXhwb3J0IGRlZmF1bHQgSFRNTDVBdWRpb1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IHsgaXNOdW1iZXIsIHNlZWtTdHJpbmdUb1NlY29uZHMsIERvbVJlY3ljbGVyLCBjYW5BdXRvUGxheU1lZGlhIH0gZnJvbSAnLi4vLi4vYmFzZS91dGlscydcblxuaW1wb3J0IFBsYXliYWNrIGZyb20gJy4uLy4uL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Jyb3dzZXInXG5pbXBvcnQgUGxheWVyRXJyb3IgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9lcnJvcidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3BsdWdpbnMvbG9nJ1xuaW1wb3J0ICQgZnJvbSAnY2xhcHByLXplcHRvJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL2Jhc2UvdGVtcGxhdGUnXG5pbXBvcnQgdHJhY2tzSFRNTCBmcm9tICcuL3B1YmxpYy90cmFja3MuaHRtbCdcbmltcG9ydCAnLi9wdWJsaWMvc3R5bGUuc2NzcydcblxuY29uc3QgTUlNRVRZUEVTID0ge1xuICAnbXA0JzogWydhdmMxLjQyRTAxRScsICdhdmMxLjU4QTAxRScsICdhdmMxLjRENDAxRScsICdhdmMxLjY0MDAxRScsICdtcDR2LjIwLjgnLCAnbXA0di4yMC4yNDAnLCAnbXA0YS40MC4yJ10ubWFwKFxuICAgIChjb2RlYykgPT4geyByZXR1cm4gJ3ZpZGVvL21wNDsgY29kZWNzPVwiJyArIGNvZGVjICsgJywgbXA0YS40MC4yXCInIH0pLFxuICAnb2dnJzogWyd2aWRlby9vZ2c7IGNvZGVjcz1cInRoZW9yYSwgdm9yYmlzXCInLCAndmlkZW8vb2dnOyBjb2RlY3M9XCJkaXJhY1wiJywgJ3ZpZGVvL29nZzsgY29kZWNzPVwidGhlb3JhLCBzcGVleFwiJ10sXG4gICczZ3BwJzogWyd2aWRlby8zZ3BwOyBjb2RlY3M9XCJtcDR2LjIwLjgsIHNhbXJcIiddLFxuICAnd2VibSc6IFsndmlkZW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIiddLFxuICAnbWt2JzogWyd2aWRlby94LW1hdHJvc2thOyBjb2RlY3M9XCJ0aGVvcmEsIHZvcmJpc1wiJ10sXG4gICdtM3U4JzogWydhcHBsaWNhdGlvbi94LW1wZWd1cmwnXVxufVxuTUlNRVRZUEVTWydvZ3YnXSA9IE1JTUVUWVBFU1snb2dnJ11cbk1JTUVUWVBFU1snM2dwJ10gPSBNSU1FVFlQRVNbJzNncHAnXVxuXG5jb25zdCBBVURJT19NSU1FVFlQRVMgPSB7XG4gICd3YXYnOiBbJ2F1ZGlvL3dhdiddLFxuICAnbXAzJzogWydhdWRpby9tcDMnLCAnYXVkaW8vbXBlZztjb2RlY3M9XCJtcDNcIiddLFxuICAnYWFjJzogWydhdWRpby9tcDQ7Y29kZWNzPVwibXA0YS40MC41XCInXSxcbiAgJ29nYSc6IFsnYXVkaW8vb2dnJ11cbn1cblxuY29uc3QgS05PV05fQVVESU9fTUlNRVRZUEVTID0gT2JqZWN0LmtleXMoQVVESU9fTUlNRVRZUEVTKS5yZWR1Y2UoKGFjYywgaykgPT4gWy4uLmFjYywgLi4uQVVESU9fTUlNRVRZUEVTW2tdXSwgW10pXG5cbmNvbnN0IFVOS05PV05fRVJST1IgPSB7IGNvZGU6ICd1bmtub3duJywgbWVzc2FnZTogJ3Vua25vd24nIH1cblxuLy8gVE9ETzogcmVuYW1lIHRoaXMgUGxheWJhY2sgdG8gSFRNTDVQbGF5YmFjayAoYnJlYWtpbmcgY2hhbmdlLCBvbmx5IGFmdGVyIDAuMy4wKVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRNTDVWaWRlbyBleHRlbmRzIFBsYXliYWNrIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnaHRtbDVfdmlkZW8nIH1cbiAgZ2V0IHRhZ05hbWUoKSB7IHJldHVybiB0aGlzLmlzQXVkaW9Pbmx5ID8gJ2F1ZGlvJyA6ICd2aWRlbycgfVxuXG4gIGdldCBpc0F1ZGlvT25seSgpIHtcbiAgICBjb25zdCByZXNvdXJjZVVybCA9IHRoaXMub3B0aW9ucy5zcmNcbiAgICBsZXQgbWltZVR5cGVzID0gSFRNTDVWaWRlby5fbWltZVR5cGVzRm9yVXJsKHJlc291cmNlVXJsLCBBVURJT19NSU1FVFlQRVMsIHRoaXMub3B0aW9ucy5taW1lVHlwZSlcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBsYXliYWNrICYmIHRoaXMub3B0aW9ucy5wbGF5YmFjay5hdWRpb09ubHkgfHwgdGhpcy5vcHRpb25zLmF1ZGlvT25seSB8fCBLTk9XTl9BVURJT19NSU1FVFlQRVMuaW5kZXhPZihtaW1lVHlwZXNbMF0pID49IDBcbiAgfVxuXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnZGF0YS1odG1sNS12aWRlbyc6ICcnXG4gICAgfVxuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2NhbnBsYXknOiAnX29uQ2FuUGxheScsXG4gICAgICAnY2FucGxheXRocm91Z2gnOiAnX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cycsXG4gICAgICAnZHVyYXRpb25jaGFuZ2UnOiAnX29uRHVyYXRpb25DaGFuZ2UnLFxuICAgICAgJ2VuZGVkJzogJ19vbkVuZGVkJyxcbiAgICAgICdlcnJvcic6ICdfb25FcnJvcicsXG4gICAgICAnbG9hZGVkZGF0YSc6ICdfb25Mb2FkZWREYXRhJyxcbiAgICAgICdsb2FkZWRtZXRhZGF0YSc6ICdfb25Mb2FkZWRNZXRhZGF0YScsXG4gICAgICAncGF1c2UnOiAnX29uUGF1c2UnLFxuICAgICAgJ3BsYXlpbmcnOiAnX29uUGxheWluZycsXG4gICAgICAncHJvZ3Jlc3MnOiAnX29uUHJvZ3Jlc3MnLFxuICAgICAgJ3NlZWtpbmcnOiAnX29uU2Vla2luZycsXG4gICAgICAnc2Vla2VkJzogJ19vblNlZWtlZCcsXG4gICAgICAnc3RhbGxlZCc6ICdfaGFuZGxlQnVmZmVyaW5nRXZlbnRzJyxcbiAgICAgICd0aW1ldXBkYXRlJzogJ19vblRpbWVVcGRhdGUnLFxuICAgICAgJ3dhaXRpbmcnOiAnX29uV2FpdGluZydcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBwbGF5YmFjayBoYXMgZW5kZWQuXG4gICAqIEBwcm9wZXJ0eSBlbmRlZFxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqL1xuICBnZXQgZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuZW5kZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHBsYXliYWNrIGlzIGhhdmluZyB0byBidWZmZXIgaW4gb3JkZXIgZm9yXG4gICAqIHBsYXliYWNrIHRvIGJlIHNtb290aC5cbiAgICogVGhpcyBpcyByZWxhdGVkIHRvIHRoZSBQTEFZQkFDS19CVUZGRVJJTkcgYW5kIFBMQVlCQUNLX0JVRkZFUkZVTEwgZXZlbnRzXG4gICAqIEBwcm9wZXJ0eSBidWZmZXJpbmdcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNCdWZmZXJpbmdcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG4gICAgdGhpcy5fbG9hZFN0YXJ0ZWQgPSBmYWxzZVxuICAgIHRoaXMuX2lzQnVmZmVyaW5nID0gZmFsc2VcbiAgICB0aGlzLl9wbGF5aGVhZE1vdmluZyA9IGZhbHNlXG4gICAgdGhpcy5fcGxheWhlYWRNb3ZpbmdUaW1lciA9IG51bGxcbiAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2VcbiAgICB0aGlzLl9jY1RyYWNrSWQgPSAtMVxuICAgIHRoaXMuX3NldHVwU3JjKHRoaXMub3B0aW9ucy5zcmMpXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKFRPRE86IHJlbW92ZSBvbiAwLjMuMClcbiAgICB0aGlzLm9wdGlvbnMucGxheWJhY2sgfHwgKHRoaXMub3B0aW9ucy5wbGF5YmFjayA9IHRoaXMub3B0aW9ucyB8fCB7fSlcbiAgICB0aGlzLm9wdGlvbnMucGxheWJhY2suZGlzYWJsZUNvbnRleHRNZW51ID0gdGhpcy5vcHRpb25zLnBsYXliYWNrLmRpc2FibGVDb250ZXh0TWVudSB8fCB0aGlzLm9wdGlvbnMuZGlzYWJsZVZpZGVvVGFnQ29udGV4dE1lbnVcblxuICAgIGNvbnN0IHBsYXliYWNrQ29uZmlnID0gdGhpcy5vcHRpb25zLnBsYXliYWNrXG4gICAgY29uc3QgcHJlbG9hZCA9IHBsYXliYWNrQ29uZmlnLnByZWxvYWQgfHwgKEJyb3dzZXIuaXNTYWZhcmkgPyAnYXV0bycgOiB0aGlzLm9wdGlvbnMucHJlbG9hZClcblxuICAgIGxldCBwb3N0ZXJVcmwgLy8gRklYTUU6IHBvc3RlciBwbHVnaW4gc2hvdWxkIGFsd2F5cyBjb252ZXJ0IHBvc3RlciB0byBvYmplY3Qgd2l0aCBleHBlY3RlZCBwcm9wZXJ0aWVzID9cbiAgICBpZiAodGhpcy5vcHRpb25zLnBvc3Rlcikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucG9zdGVyID09PSAnc3RyaW5nJylcbiAgICAgICAgcG9zdGVyVXJsID0gdGhpcy5vcHRpb25zLnBvc3RlclxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wb3N0ZXIudXJsID09PSAnc3RyaW5nJylcbiAgICAgICAgcG9zdGVyVXJsID0gdGhpcy5vcHRpb25zLnBvc3Rlci51cmxcblxuICAgIH1cblxuICAgICQuZXh0ZW5kKHRoaXMuZWwsIHtcbiAgICAgIG11dGVkOiB0aGlzLm9wdGlvbnMubXV0ZSxcbiAgICAgIGRlZmF1bHRNdXRlZDogdGhpcy5vcHRpb25zLm11dGUsXG4gICAgICBsb29wOiB0aGlzLm9wdGlvbnMubG9vcCxcbiAgICAgIHBvc3RlcjogcG9zdGVyVXJsLFxuICAgICAgcHJlbG9hZDogcHJlbG9hZCB8fCAnbWV0YWRhdGEnLFxuICAgICAgY29udHJvbHM6IChwbGF5YmFja0NvbmZpZy5jb250cm9scyB8fCB0aGlzLm9wdGlvbnMudXNlVmlkZW9UYWdEZWZhdWx0Q29udHJvbHMpICYmICdjb250cm9scycsXG4gICAgICBjcm9zc09yaWdpbjogcGxheWJhY2tDb25maWcuY3Jvc3NPcmlnaW4sXG4gICAgICAneC13ZWJraXQtcGxheXNpbmxpbmUnOiBwbGF5YmFja0NvbmZpZy5wbGF5SW5saW5lXG4gICAgfSlcblxuICAgIHBsYXliYWNrQ29uZmlnLnBsYXlJbmxpbmUgJiYgKHRoaXMuJGVsLmF0dHIoeyBwbGF5c2lubGluZTogJ3BsYXlzaW5saW5lJyB9KSlcbiAgICBwbGF5YmFja0NvbmZpZy5jcm9zc09yaWdpbiAmJiAodGhpcy4kZWwuYXR0cih7IGNyb3Nzb3JpZ2luOiBwbGF5YmFja0NvbmZpZy5jcm9zc09yaWdpbiB9KSlcblxuICAgIC8vIFRPRE8gc2hvdWxkIHNldHRpbmdzIGJlIHByaXZhdGU/XG4gICAgdGhpcy5zZXR0aW5ncyA9IHsgZGVmYXVsdDogWydzZWVrYmFyJ10gfVxuICAgIHRoaXMuc2V0dGluZ3MubGVmdCA9IFsncGxheXBhdXNlJywgJ3Bvc2l0aW9uJywgJ2R1cmF0aW9uJ11cbiAgICB0aGlzLnNldHRpbmdzLnJpZ2h0ID0gWydmdWxsc2NyZWVuJywgJ3ZvbHVtZScsICdoZC1pbmRpY2F0b3InXVxuXG4gICAgcGxheWJhY2tDb25maWcuZXh0ZXJuYWxUcmFja3MgJiYgKHRoaXMuX3NldHVwRXh0ZXJuYWxUcmFja3MocGxheWJhY2tDb25maWcuZXh0ZXJuYWxUcmFja3MpKVxuXG4gICAgdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmIHRoaXMuYXR0ZW1wdEF1dG9QbGF5KClcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKG9wdGlvbnMpXG4gICAgdGhpcy5lbC5sb29wID0gISFvcHRpb25zLmxvb3BcbiAgfVxuXG4gIC8vIFNlZSBQbGF5YmFjay5hdHRlbXB0QXV0b1BsYXkoKVxuICBhdHRlbXB0QXV0b1BsYXkoKSB7XG4gICAgdGhpcy5jYW5BdXRvUGxheSgocmVzdWx0LCBlcnJvcikgPT4ge1xuICAgICAgZXJyb3IgJiYgTG9nLndhcm4odGhpcy5uYW1lLCAnYXV0b3BsYXkgZXJyb3IuJywgeyByZXN1bHQsIGVycm9yIH0pXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jbGFwcHIvY2xhcHByL2lzc3Vlcy8xMDc2XG4gICAgICByZXN1bHQgJiYgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiAhdGhpcy5fZGVzdHJveWVkICYmIHRoaXMucGxheSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBTZWUgUGxheWJhY2suY2FuQXV0b1BsYXkoKVxuICBjYW5BdXRvUGxheShjYikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNhbkF1dG9QbGF5KSB7XG4gICAgICBjYih0cnVlLCBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBvcHRzID0ge1xuICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLmF1dG9QbGF5VGltZW91dCB8fCA1MDAsXG4gICAgICBpbmxpbmU6IHRoaXMub3B0aW9ucy5wbGF5YmFjay5wbGF5SW5saW5lIHx8IGZhbHNlLFxuICAgICAgbXV0ZWQ6IHRoaXMub3B0aW9ucy5tdXRlIHx8IGZhbHNlLCAvLyBLbm93biBpc3N1ZTogbWVkaWFjb250cm9scyBtYXkgYXN5bmNocm9ub3VzbHkgbXV0ZSB2aWRlb1xuICAgIH1cblxuICAgIC8vIFVzZSBjdXJyZW50IHZpZGVvIGVsZW1lbnQgaWYgcmVjeWNsaW5nIGZlYXR1cmUgZW5hYmxlZCB3aXRoIG1vYmlsZSBkZXZpY2VzXG4gICAgaWYgKEJyb3dzZXIuaXNNb2JpbGUgJiYgRG9tUmVjeWNsZXIub3B0aW9ucy5yZWN5Y2xlVmlkZW8pXG4gICAgICBvcHRzLmVsZW1lbnQgPSB0aGlzLmVsXG5cbiAgICAvLyBEZXNrdG9wIGJyb3dzZXIgYXV0b3BsYXkgcG9saWN5IG1heSByZXF1aXJlIHVzZXIgYWN0aW9uXG4gICAgLy8gTW9iaWxlIGJyb3dzZXIgYXV0b3BsYXkgcmVxdWlyZSB1c2VyIGNvbnNlbnQgYW5kIHZpZGVvIHJlY3ljbGluZyBmZWF0dXJlIGVuYWJsZWRcbiAgICAvLyBJdCBtYXkgcmV0dXJucyBhIGZhbHNlIHBvc2l0aXZlIHdpdGggc291cmNlLWxlc3MgcGxheWVyIGNvbnNlbnRcbiAgICBjYW5BdXRvUGxheU1lZGlhKGNiLCBvcHRzKVxuICB9XG5cbiAgX3NldHVwRXh0ZXJuYWxUcmFja3ModHJhY2tzKSB7XG4gICAgdGhpcy5fZXh0ZXJuYWxUcmFja3MgPSB0cmFja3MubWFwKHRyYWNrID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IHRyYWNrLmtpbmQgfHwgJ3N1YnRpdGxlcycsIC8vIERlZmF1bHQgaXMgJ3N1YnRpdGxlcydcbiAgICAgICAgbGFiZWw6IHRyYWNrLmxhYmVsLFxuICAgICAgICBsYW5nOiB0cmFjay5sYW5nLFxuICAgICAgICBzcmM6IHRyYWNrLnNyYyxcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNvdXJjZSB1cmwgb24gdGhlIDx2aWRlbz4gZWxlbWVudCwgYW5kIGFsc28gdGhlICdzcmMnIHByb3BlcnR5LlxuICAgKiBAbWV0aG9kIHNldHVwU3JjXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNVcmwgVGhlIHNvdXJjZSBVUkwuXG4gICAqL1xuICBfc2V0dXBTcmMoc3JjVXJsKSB7XG4gICAgaWYgKHRoaXMuZWwuc3JjID09PSBzcmNVcmwpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuX2NjSXNTZXR1cCA9IGZhbHNlXG4gICAgdGhpcy5lbC5zcmMgPSBzcmNVcmxcbiAgICB0aGlzLl9zcmMgPSB0aGlzLmVsLnNyY1xuICB9XG5cbiAgX29uTG9hZGVkTWV0YWRhdGEoZSkge1xuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19MT0FERURNRVRBREFUQSwgeyBkdXJhdGlvbjogZS50YXJnZXQuZHVyYXRpb24sIGRhdGE6IGUgfSlcbiAgICB0aGlzLl91cGRhdGVTZXR0aW5ncygpXG4gICAgY29uc3QgYXV0b1NlZWtGcm9tVXJsID0gdHlwZW9mICh0aGlzLl9vcHRpb25zLmF1dG9TZWVrRnJvbVVybCkgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuX29wdGlvbnMuYXV0b1NlZWtGcm9tVXJsXG4gICAgaWYgKHRoaXMuZ2V0UGxheWJhY2tUeXBlKCkgIT09IFBsYXliYWNrLkxJVkUgJiYgYXV0b1NlZWtGcm9tVXJsKVxuICAgICAgdGhpcy5fY2hlY2tJbml0aWFsU2VlaygpXG5cbiAgfVxuXG4gIF9vbkR1cmF0aW9uQ2hhbmdlKCkge1xuICAgIHRoaXMuX3VwZGF0ZVNldHRpbmdzKClcbiAgICB0aGlzLl9vblRpbWVVcGRhdGUoKVxuICAgIC8vIG9uUHJvZ3Jlc3MgdXNlcyB0aGUgZHVyYXRpb25cbiAgICB0aGlzLl9vblByb2dyZXNzKClcbiAgfVxuXG4gIF91cGRhdGVTZXR0aW5ncygpIHtcbiAgICAvLyB3ZSBjYW4ndCBmaWd1cmUgb3V0IGlmIGhscyByZXNvdXJjZSBpcyBWb0Qgb3Igbm90IHVudGlsIGl0IGlzIGJlaW5nIGxvYWRlZCBvciBkdXJhdGlvbiBoYXMgY2hhbmdlZC5cbiAgICAvLyB0aGF0J3Mgd2h5IHdlIGNoZWNrIGl0IGFnYWluIGFuZCB1cGRhdGUgbWVkaWEgY29udHJvbCBhY2NvcmRpbmdseS5cbiAgICBpZiAodGhpcy5nZXRQbGF5YmFja1R5cGUoKSA9PT0gUGxheWJhY2suVk9EIHx8IHRoaXMuZ2V0UGxheWJhY2tUeXBlKCkgPT09IFBsYXliYWNrLkFPRClcbiAgICAgIHRoaXMuc2V0dGluZ3MubGVmdCA9IFsncGxheXBhdXNlJywgJ3Bvc2l0aW9uJywgJ2R1cmF0aW9uJ11cbiAgICBlbHNlXG4gICAgICB0aGlzLnNldHRpbmdzLmxlZnQgPSBbJ3BsYXlzdG9wJ11cblxuICAgIHRoaXMuc2V0dGluZ3Muc2Vla0VuYWJsZWQgPSB0aGlzLmlzU2Vla0VuYWJsZWQoKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfU0VUVElOR1NVUERBVEUpXG4gIH1cblxuICBpc1NlZWtFbmFibGVkKCkge1xuICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLmdldER1cmF0aW9uKCkpXG4gIH1cblxuICBnZXRQbGF5YmFja1R5cGUoKSB7XG4gICAgY29uc3Qgb25EZW1hbmRUeXBlID0gdGhpcy50YWdOYW1lID09PSAnYXVkaW8nID8gUGxheWJhY2suQU9EIDogUGxheWJhY2suVk9EXG4gICAgcmV0dXJuIFswLCB1bmRlZmluZWQsIEluZmluaXR5XS5pbmRleE9mKHRoaXMuZWwuZHVyYXRpb24pID49IDAgPyBQbGF5YmFjay5MSVZFIDogb25EZW1hbmRUeXBlXG4gIH1cblxuICBpc0hpZ2hEZWZpbml0aW9uSW5Vc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBPbiBtb2JpbGUgZGV2aWNlLCBIVE1MNSB2aWRlbyBlbGVtZW50IFwicmV0YWluc1wiIHVzZXIgYWN0aW9uIGNvbnNlbnQgaWZcbiAgLy8gbG9hZCgpIG1ldGhvZCBpcyBjYWxsZWQuIFNlZSBQbGF5ZXIuY29uc2VudCgpLlxuICBjb25zZW50KCkge1xuICAgIGlmICghdGhpcy5pc1BsYXlpbmcoKSkge1xuICAgICAgc3VwZXIuY29uc2VudCgpXG4gICAgICB0aGlzLmVsLmxvYWQoKVxuICAgIH1cbiAgfVxuXG4gIHBsYXkoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAvLyAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMucGx1Z2lucykuaW5kZXhPZignVmFzdEFkcycpID4gLTFcbiAgICAgIGxldCBsaWIgPSAhISh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUuaW1hKSB8fCAhISh3aW5kb3cueWEgJiYgd2luZG93LnlhLnZpZGVvQWQpXG4gICAgICBpZihsaWIgJiYgdGhpcy5vcHRpb25zLnBsdWdpbnMgJiYgdGhpcy5vcHRpb25zLlZhc3RBZHMucHJlcm9sbCAmJiB0aGlzLm9wdGlvbnMuVmFzdEFkcy5wcmVyb2xsLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1BSRVJPTExfUkVRVUVTVCkgICAgICAgIFxuICAgICAgICByZXR1cm47XG4gICAgICB9ICAgICAgXG4gICAgfSBjYXRjaChlKSB7XG5cbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1BMQVlfSU5URU5UKVxuICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZVxuICAgIHRoaXMuX3NldHVwU3JjKHRoaXMuX3NyYylcbiAgICB0aGlzLl9oYW5kbGVCdWZmZXJpbmdFdmVudHMoKVxuICAgIGxldCBwcm9taXNlID0gdGhpcy5lbC5wbGF5KClcbiAgICAvLyBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxNi8wMy9wbGF5LXJldHVybnMtcHJvbWlzZVxuICAgIGlmIChwcm9taXNlICYmIHByb21pc2UuY2F0Y2gpXG4gICAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KVxuXG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLmVsLnBhdXNlKClcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gICAgdGhpcy5fc3RvcHBlZCA9IHRydWVcbiAgICAvLyBzcmMgd2lsbCBiZSBhZGRlZCBhZ2FpbiBpbiBwbGF5KClcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJylcbiAgICB0aGlzLmVsLmxvYWQoKSAvLyBsb2FkIHdpdGggbm8gc3JjIHRvIHN0b3AgbG9hZGluZyBvZiB0aGUgcHJldmlvdXMgc291cmNlIGFuZCBhdm9pZCBsZWFrc1xuICAgIHRoaXMuX3N0b3BQbGF5aGVhZE1vdmluZ0NoZWNrcygpXG4gICAgdGhpcy5faGFuZGxlQnVmZmVyaW5nRXZlbnRzKClcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1NUT1ApXG4gIH1cblxuICB2b2x1bWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuJGVsLmF0dHIoeyBtdXRlZDogJ3RydWUnIH0pXG4gICAgICB0aGlzLmVsLm11dGVkID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbC5hdHRyKHsgbXV0ZWQ6IG51bGwgfSlcbiAgICAgIHRoaXMuZWwubXV0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5lbC52b2x1bWUgPSB2YWx1ZSAvIDEwMFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbXV0ZSgpIHtcbiAgICB0aGlzLmVsLm11dGVkID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm11dGUoKSB7XG4gICAgdGhpcy5lbC5tdXRlZCA9IGZhbHNlXG4gIH1cblxuICBpc011dGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVsLm11dGVkID09PSB0cnVlIHx8IHRoaXMuZWwudm9sdW1lID09PSAwXG4gIH1cblxuICBpc1BsYXlpbmcoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVsLnBhdXNlZCAmJiAhdGhpcy5lbC5lbmRlZFxuICB9XG5cbiAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmVhZHlTdGF0ZVxuICB9XG5cbiAgX3N0YXJ0UGxheWhlYWRNb3ZpbmdDaGVja3MoKSB7XG4gICAgaWYgKHRoaXMuX3BsYXloZWFkTW92aW5nVGltZXIgIT09IG51bGwpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuX3BsYXloZWFkTW92aW5nVGltZU9uQ2hlY2sgPSBudWxsXG4gICAgdGhpcy5fZGV0ZXJtaW5lSWZQbGF5aGVhZE1vdmluZygpXG4gICAgdGhpcy5fcGxheWhlYWRNb3ZpbmdUaW1lciA9IHNldEludGVydmFsKHRoaXMuX2RldGVybWluZUlmUGxheWhlYWRNb3ZpbmcuYmluZCh0aGlzKSwgNTAwKVxuICB9XG5cbiAgX3N0b3BQbGF5aGVhZE1vdmluZ0NoZWNrcygpIHtcbiAgICBpZiAodGhpcy5fcGxheWhlYWRNb3ZpbmdUaW1lciA9PT0gbnVsbClcbiAgICAgIHJldHVyblxuXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wbGF5aGVhZE1vdmluZ1RpbWVyKVxuICAgIHRoaXMuX3BsYXloZWFkTW92aW5nVGltZXIgPSBudWxsXG4gICAgdGhpcy5fcGxheWhlYWRNb3ZpbmcgPSBmYWxzZVxuICB9XG5cbiAgX2RldGVybWluZUlmUGxheWhlYWRNb3ZpbmcoKSB7XG4gICAgY29uc3QgYmVmb3JlID0gdGhpcy5fcGxheWhlYWRNb3ZpbmdUaW1lT25DaGVja1xuICAgIGNvbnN0IG5vdyA9IHRoaXMuZWwuY3VycmVudFRpbWVcbiAgICB0aGlzLl9wbGF5aGVhZE1vdmluZyA9IGJlZm9yZSAhPT0gbm93XG4gICAgdGhpcy5fcGxheWhlYWRNb3ZpbmdUaW1lT25DaGVjayA9IG5vd1xuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gIH1cblxuICAvLyB0aGlzIHNlZW1zIHRvIGhhcHBlbiB3aGVuIHRoZSB1c2VyIGlzIGhhdmluZyB0byB3YWl0XG4gIC8vIGZvciBzb21ldGhpbmcgdG8gaGFwcGVuIEFGVEVSIEEgVVNFUiBJTlRFUkFDVElPTlxuICAvLyBlLmcgdGhlIHBsYXllciBtaWdodCBiZSBidWZmZXJpbmcsIGJ1dCB3aGVuIGBwbGF5KClgIGlzIGNhbGxlZFxuICAvLyBvbmx5IGF0IHRoaXMgcG9pbnQgd2lsbCB0aGlzIGJlIGNhbGxlZC5cbiAgLy8gT3IgdGhlIHVzZXIgbWF5IHNlZWsgc29tZXdoZXJlIGJ1dCB0aGUgbmV3IGFyZWEgcmVxdWlyZXMgYnVmZmVyaW5nLFxuICAvLyBzbyBpdCB3aWxsIGZpcmUgdGhlbiBhcyB3ZWxsLlxuICAvLyBPbiBkZXZpY2VzIHdoZXJlIHBsYXlpbmcgaXMgYmxvY2tlZCB1bnRpbCByZXF1ZXN0ZWQgd2l0aCBhIHVzZXIgYWN0aW9uLFxuICAvLyBidWZmZXJpbmcgbWF5IHN0YXJ0LCBidXQgbmV2ZXIgZmluaXNoIHVudGlsIHRoZSB1c2VyIGluaXRpYXRlcyBhIHBsYXksXG4gIC8vIGJ1dCB0aGlzIG9ubHkgaGFwcGVucyB3aGVuIHBsYXkgaXMgYWN0dWFsbHkgcmVxdWVzdGVkXG4gIF9vbldhaXRpbmcoKSB7XG4gICAgdGhpcy5fbG9hZFN0YXJ0ZWQgPSB0cnVlXG4gICAgdGhpcy5faGFuZGxlQnVmZmVyaW5nRXZlbnRzKClcbiAgfVxuXG4gIC8vIGNhbGxlZCBhZnRlciB0aGUgZmlyc3QgZnJhbWUgaGFzIGxvYWRlZFxuICAvLyBub3RlIHRoaXMgZG9lc24ndCBmaXJlIG9uIGlvcyBiZWZvcmUgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBwbGF5XG4gIC8vIGlkZWFsbHkgdGhlIFwibG9hZHN0YXJ0XCIgZXZlbnQgd291bGQgYmUgdXNlZCBpbnN0ZWFkLCBidXQgdGhpcyBmaXJlc1xuICAvLyBiZWZvcmUgYSB1c2VyIGhhcyByZXF1ZXN0ZWQgcGxheSBvbiBpT1MsIGFuZCBhbHNvIHRoaXMgaXMgYWx3YXlzIGZpcmVkXG4gIC8vIGV2ZW4gaWYgdGhlIHByZWxvYWQgc2V0dGluZyBpcyBcIm5vbmVcIi4gSW4gYm90aCB0aGVzZSBjYXNlcyB0aGlzIGNhdXNlc1xuICAvLyBpbmZpbml0ZSBidWZmZXJpbmcgdW50aWwgdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2hpY2ggaXNuJ3QgZ3JlYXQuXG4gIF9vbkxvYWRlZERhdGEoKSB7XG4gICAgdGhpcy5fbG9hZFN0YXJ0ZWQgPSB0cnVlXG4gICAgdGhpcy5faGFuZGxlQnVmZmVyaW5nRXZlbnRzKClcbiAgfVxuXG4gIC8vIG5vdGUgdGhpcyBkb2Vzbid0IGZpcmUgb24gaW9zIGJlZm9yZSB1c2VyIGhhcyByZXF1ZXN0ZWQgcGxheVxuICBfb25DYW5QbGF5KCkge1xuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gIH1cblxuICBfb25QbGF5aW5nKCkge1xuICAgIHRoaXMuX2NoZWNrRm9yQ2xvc2VkQ2FwdGlvbnMoKVxuICAgIHRoaXMuX3N0YXJ0UGxheWhlYWRNb3ZpbmdDaGVja3MoKVxuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19QTEFZKVxuICB9XG5cbiAgX29uUGF1c2UoKSB7XG4gICAgdGhpcy5fc3RvcFBsYXloZWFkTW92aW5nQ2hlY2tzKClcbiAgICB0aGlzLl9oYW5kbGVCdWZmZXJpbmdFdmVudHMoKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfUEFVU0UpXG4gIH1cblxuICBfb25TZWVraW5nKCkge1xuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TRUVLKVxuICB9XG5cbiAgX29uU2Vla2VkKCkge1xuICAgIHRoaXMuX2hhbmRsZUJ1ZmZlcmluZ0V2ZW50cygpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TRUVLRUQpXG4gIH1cblxuICBfb25FbmRlZCgpIHtcbiAgICB0aGlzLl9oYW5kbGVCdWZmZXJpbmdFdmVudHMoKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfRU5ERUQsIHRoaXMubmFtZSlcbiAgfVxuXG4gIC8vIFRoZSBwbGF5YmFjayBzaG91bGQgYmUgY2xhc3NlZCBhcyBidWZmZXJpbmcgaWYgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZTpcbiAgLy8gLSB0aGUgcmVhZHkgc3RhdGUgaXMgbGVzcyB0aGVuIEhBVkVfRlVUVVJFX0RBVEEgb3IgdGhlIHBsYXloZWFkIGlzbid0IG1vdmluZyBhbmQgaXQgc2hvdWxkIGJlXG4gIC8vIC0gdGhlIG1lZGlhIGhhc24ndCBcImVuZGVkXCIsXG4gIC8vIC0gdGhlIG1lZGlhIGhhc24ndCBiZWVuIHN0b3BwZWRcbiAgLy8gLSBsb2FkaW5nIGhhcyBzdGFydGVkXG4gIF9oYW5kbGVCdWZmZXJpbmdFdmVudHMoKSB7XG4gICAgY29uc3QgcGxheWhlYWRTaG91bGRCZU1vdmluZyA9ICF0aGlzLmVsLmVuZGVkICYmICF0aGlzLmVsLnBhdXNlZFxuICAgIGNvbnN0IGJ1ZmZlcmluZyA9IHRoaXMuX2xvYWRTdGFydGVkICYmICF0aGlzLmVsLmVuZGVkICYmICF0aGlzLl9zdG9wcGVkICYmICgocGxheWhlYWRTaG91bGRCZU1vdmluZyAmJiAhdGhpcy5fcGxheWhlYWRNb3ZpbmcpIHx8IHRoaXMuZWwucmVhZHlTdGF0ZSA8IHRoaXMuZWwuSEFWRV9GVVRVUkVfREFUQSlcbiAgICBpZiAodGhpcy5faXNCdWZmZXJpbmcgIT09IGJ1ZmZlcmluZykge1xuICAgICAgdGhpcy5faXNCdWZmZXJpbmcgPSBidWZmZXJpbmdcbiAgICAgIGlmIChidWZmZXJpbmcpXG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfQlVGRkVSSU5HLCB0aGlzLm5hbWUpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfQlVGRkVSRlVMTCwgdGhpcy5uYW1lKVxuXG4gICAgfVxuICB9XG5cbiAgX29uRXJyb3IoKSB7XG4gICAgY29uc3QgeyBjb2RlLCBtZXNzYWdlIH0gPSB0aGlzLmVsLmVycm9yIHx8IFVOS05PV05fRVJST1JcbiAgICBjb25zdCBpc1Vua25vd25FcnJvciA9IGNvZGUgPT09IFVOS05PV05fRVJST1IuY29kZVxuXG4gICAgY29uc3QgZm9ybWF0dGVkRXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgIGNvZGUsXG4gICAgICBkZXNjcmlwdGlvbjogbWVzc2FnZSxcbiAgICAgIHJhdzogdGhpcy5lbC5lcnJvcixcbiAgICAgIGxldmVsOiBpc1Vua25vd25FcnJvciA/IFBsYXllckVycm9yLkxldmVscy5XQVJOIDogUGxheWVyRXJyb3IuTGV2ZWxzLkZBVEFMXG4gICAgfSlcblxuICAgIGlmIChpc1Vua25vd25FcnJvcilcbiAgICAgIExvZy53YXJuKHRoaXMubmFtZSwgJ0hUTUw1IHVua25vd24gZXJyb3I6ICcsIGZvcm1hdHRlZEVycm9yKVxuICAgIGVsc2VcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfRVJST1IsIGZvcm1hdHRlZEVycm9yKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gICAgdGhpcy5oYW5kbGVUZXh0VHJhY2tDaGFuZ2UgJiYgdGhpcy5lbC50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlVGV4dFRyYWNrQ2hhbmdlKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKVxuICAgIHRoaXMuZWwubG9hZCgpIC8vIGxvYWQgd2l0aCBubyBzcmMgdG8gc3RvcCBsb2FkaW5nIG9mIHRoZSBwcmV2aW91cyBzb3VyY2UgYW5kIGF2b2lkIGxlYWtzXG4gICAgdGhpcy5fc3JjID0gbnVsbFxuICAgIERvbVJlY3ljbGVyLmdhcmJhZ2UodGhpcy4kZWwpXG4gIH1cblxuICBzZWVrKHRpbWUpIHtcbiAgICB0aGlzLmVsLmN1cnJlbnRUaW1lID0gdGltZVxuICB9XG5cbiAgc2Vla1BlcmNlbnRhZ2UocGVyY2VudGFnZSkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLmVsLmR1cmF0aW9uICogKHBlcmNlbnRhZ2UgLyAxMDApXG4gICAgdGhpcy5zZWVrKHRpbWUpXG4gIH1cblxuICBfY2hlY2tJbml0aWFsU2VlaygpIHtcbiAgICBjb25zdCBzZWVrVGltZSA9IHNlZWtTdHJpbmdUb1NlY29uZHMoKVxuICAgIGlmIChzZWVrVGltZSAhPT0gMClcbiAgICAgIHRoaXMuc2VlayhzZWVrVGltZSlcblxuICB9XG5cbiAgZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuY3VycmVudFRpbWVcbiAgfVxuXG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVsLmR1cmF0aW9uXG4gIH1cblxuICBfb25UaW1lVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmdldFBsYXliYWNrVHlwZSgpID09PSBQbGF5YmFjay5MSVZFKVxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19USU1FVVBEQVRFLCB7IGN1cnJlbnQ6IDEsIHRvdGFsOiAxIH0sIHRoaXMubmFtZSlcbiAgICBlbHNlXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1RJTUVVUERBVEUsIHsgY3VycmVudDogdGhpcy5lbC5jdXJyZW50VGltZSwgdG90YWw6IHRoaXMuZWwuZHVyYXRpb24gfSwgdGhpcy5uYW1lKVxuXG4gIH1cblxuICBfb25Qcm9ncmVzcygpIHtcbiAgICBpZiAoIXRoaXMuZWwuYnVmZmVyZWQubGVuZ3RoKVxuICAgICAgcmV0dXJuXG5cbiAgICBsZXQgYnVmZmVyZWQgPSBbXVxuICAgIGxldCBidWZmZXJlZFBvcyA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgIGkgPCB0aGlzLmVsLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmZXJlZCA9IFsuLi5idWZmZXJlZCwgeyBzdGFydDogdGhpcy5lbC5idWZmZXJlZC5zdGFydChpKSwgZW5kOiB0aGlzLmVsLmJ1ZmZlcmVkLmVuZChpKSB9XVxuICAgICAgaWYgKHRoaXMuZWwuY3VycmVudFRpbWUgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgdGhpcy5lbC5jdXJyZW50VGltZSA8PSBidWZmZXJlZFtpXS5lbmQpXG4gICAgICAgIGJ1ZmZlcmVkUG9zID0gaVxuXG4gICAgfVxuICAgIGNvbnN0IHByb2dyZXNzID0ge1xuICAgICAgc3RhcnQ6IGJ1ZmZlcmVkW2J1ZmZlcmVkUG9zXS5zdGFydCxcbiAgICAgIGN1cnJlbnQ6IGJ1ZmZlcmVkW2J1ZmZlcmVkUG9zXS5lbmQsXG4gICAgICB0b3RhbDogdGhpcy5lbC5kdXJhdGlvblxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX1BST0dSRVNTLCBwcm9ncmVzcywgYnVmZmVyZWQpXG4gIH1cblxuICBfdHlwZUZvcihzcmMpIHtcbiAgICBsZXQgbWltZVR5cGVzID0gSFRNTDVWaWRlby5fbWltZVR5cGVzRm9yVXJsKHNyYywgTUlNRVRZUEVTLCB0aGlzLm9wdGlvbnMubWltZVR5cGUpXG4gICAgaWYgKG1pbWVUeXBlcy5sZW5ndGggPT09IDApXG4gICAgICBtaW1lVHlwZXMgPSBIVE1MNVZpZGVvLl9taW1lVHlwZXNGb3JVcmwoc3JjLCBBVURJT19NSU1FVFlQRVMsIHRoaXMub3B0aW9ucy5taW1lVHlwZSlcblxuICAgIGNvbnN0IG1pbWVUeXBlID0gbWltZVR5cGVzWzBdIHx8ICcnXG4gICAgcmV0dXJuIG1pbWVUeXBlLnNwbGl0KCc7JylbMF1cbiAgfVxuXG4gIF9yZWFkeSgpIHtcbiAgICBpZiAodGhpcy5faXNSZWFkeVN0YXRlKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzLl9pc1JlYWR5U3RhdGUgPSB0cnVlXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19SRUFEWSwgdGhpcy5uYW1lKVxuICB9XG5cbiAgX2NoZWNrRm9yQ2xvc2VkQ2FwdGlvbnMoKSB7XG4gICAgLy8gQ2hlY2sgaWYgQ0MgYXZhaWxhYmxlIG9ubHkgaWYgY3VycmVudCBwbGF5YmFjayBpcyBIVE1MNVZpZGVvXG4gICAgaWYgKHRoaXMuaXNIVE1MNVZpZGVvICYmICF0aGlzLl9jY0lzU2V0dXApIHtcbiAgICAgIGlmICh0aGlzLmhhc0Nsb3NlZENhcHRpb25zVHJhY2tzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfU1VCVElUTEVfQVZBSUxBQkxFKVxuICAgICAgICBjb25zdCB0cmFja0lkID0gdGhpcy5jbG9zZWRDYXB0aW9uc1RyYWNrSWRcbiAgICAgICAgdGhpcy5jbG9zZWRDYXB0aW9uc1RyYWNrSWQgPSB0cmFja0lkXG4gICAgICAgIHRoaXMuaGFuZGxlVGV4dFRyYWNrQ2hhbmdlID0gdGhpcy5faGFuZGxlVGV4dFRyYWNrQ2hhbmdlLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5lbC50ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuaGFuZGxlVGV4dFRyYWNrQ2hhbmdlKVxuICAgICAgfVxuICAgICAgdGhpcy5fY2NJc1NldHVwID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVUZXh0VHJhY2tDaGFuZ2UoKSB7XG4gICAgbGV0IHRyYWNrcyA9IHRoaXMuY2xvc2VkQ2FwdGlvbnNUcmFja3NcbiAgICBsZXQgdHJhY2sgPSB0cmFja3MuZmluZCh0cmFjayA9PiB0cmFjay50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHx8IHsgaWQ6IC0xIH1cblxuICAgIGlmICh0aGlzLl9jY1RyYWNrSWQgIT09IHRyYWNrLmlkKSB7XG4gICAgICB0aGlzLl9jY1RyYWNrSWQgPSB0cmFjay5pZFxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TVUJUSVRMRV9DSEFOR0VELCB7XG4gICAgICAgIGlkOiB0cmFjay5pZFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBnZXQgaXNIVE1MNVZpZGVvKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgPT09IEhUTUw1VmlkZW8ucHJvdG90eXBlLm5hbWVcbiAgfVxuXG4gIGdldCBjbG9zZWRDYXB0aW9uc1RyYWNrcygpIHtcbiAgICBsZXQgaWQgPSAwXG4gICAgbGV0IHRyYWNrSWQgPSAoKSA9PiB7IHJldHVybiBpZCsrIH1cbiAgICBsZXQgdGV4dFRyYWNrcyA9IHRoaXMuZWwudGV4dFRyYWNrcyA/IEFycmF5LmZyb20odGhpcy5lbC50ZXh0VHJhY2tzKSA6IFtdXG5cbiAgICByZXR1cm4gdGV4dFRyYWNrc1xuICAgICAgLmZpbHRlcih0cmFjayA9PiB0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyB8fCB0cmFjay5raW5kID09PSAnY2FwdGlvbnMnKVxuICAgICAgLm1hcCh0cmFjayA9PiB7IHJldHVybiB7IGlkOiB0cmFja0lkKCksIG5hbWU6IHRyYWNrLmxhYmVsLCB0cmFjazogdHJhY2sgfSB9KVxuICB9XG5cbiAgZ2V0IGNsb3NlZENhcHRpb25zVHJhY2tJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2NUcmFja0lkXG4gIH1cblxuICBzZXQgY2xvc2VkQ2FwdGlvbnNUcmFja0lkKHRyYWNrSWQpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHRyYWNrSWQpKVxuICAgICAgcmV0dXJuXG5cblxuICAgIGxldCB0cmFja3MgPSB0aGlzLmNsb3NlZENhcHRpb25zVHJhY2tzXG4gICAgbGV0IHNob3dpbmdUcmFja1xuXG4gICAgLy8gTm90ZTogLTEgaXMgZm9yIGhpZGUgYWxsIHRyYWNrc1xuICAgIGlmICh0cmFja0lkICE9PSAtMSkge1xuICAgICAgc2hvd2luZ1RyYWNrID0gdHJhY2tzLmZpbmQodHJhY2sgPT4gdHJhY2suaWQgPT09IHRyYWNrSWQpXG4gICAgICBpZiAoIXNob3dpbmdUcmFjaylcbiAgICAgICAgcmV0dXJuIC8vIFRyYWNrIGlkIG5vdCBmb3VuZFxuXG4gICAgICBpZiAoc2hvd2luZ1RyYWNrLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJylcbiAgICAgICAgcmV0dXJuIC8vIFRyYWNrIGFscmVhZHkgc2hvd2luZ1xuXG4gICAgfVxuXG4gICAgLy8gU2luY2UgaXQgaXMgcG9zc2libGUgdG8gZGlzcGxheSBtdWx0aXBsZSB0cmFja3MsXG4gICAgLy8gZW5zdXJlIHRoYXQgYWxsIHRyYWNrcyBhcmUgaGlkZGVuLlxuICAgIHRyYWNrc1xuICAgICAgLmZpbHRlcih0cmFjayA9PiB0cmFjay50cmFjay5tb2RlICE9PSAnaGlkZGVuJylcbiAgICAgIC5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnRyYWNrLm1vZGUgPSAnaGlkZGVuJylcblxuICAgIHNob3dpbmdUcmFjayAmJiAoc2hvd2luZ1RyYWNrLnRyYWNrLm1vZGUgPSAnc2hvd2luZycpXG5cbiAgICB0aGlzLl9jY1RyYWNrSWQgPSB0cmFja0lkXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19TVUJUSVRMRV9DSEFOR0VELCB7XG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0pXG4gIH1cblxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZSh0cmFja3NIVE1MKSB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGxheWJhY2suZGlzYWJsZUNvbnRleHRNZW51KSB7XG4gICAgICB0aGlzLiRlbC5vbignY29udGV4dG1lbnUnLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZXJuYWxUcmFja3MgJiYgdGhpcy5fZXh0ZXJuYWxUcmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHtcbiAgICAgICAgdHJhY2tzOiB0aGlzLl9leHRlcm5hbFRyYWNrcyxcbiAgICAgIH0pKVxuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5KClcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbkhUTUw1VmlkZW8uX21pbWVUeXBlc0ZvclVybCA9IGZ1bmN0aW9uKHJlc291cmNlVXJsLCBtaW1lVHlwZXNCeUV4dGVuc2lvbiwgbWltZVR5cGUpIHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gKHJlc291cmNlVXJsLnNwbGl0KCc/JylbMF0ubWF0Y2goLy4qXFwuKC4qKSQvKSB8fCBbXSlbMV1cbiAgbGV0IG1pbWVUeXBlcyA9IG1pbWVUeXBlIHx8IChleHRlbnNpb24gJiYgbWltZVR5cGVzQnlFeHRlbnNpb25bZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCldKSB8fCBbXVxuICByZXR1cm4gKG1pbWVUeXBlcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpID8gbWltZVR5cGVzIDogW21pbWVUeXBlc11cbn1cblxuSFRNTDVWaWRlby5fY2FuUGxheSA9IGZ1bmN0aW9uKHR5cGUsIG1pbWVUeXBlc0J5RXh0ZW5zaW9uLCByZXNvdXJjZVVybCwgbWltZVR5cGUpIHtcbiAgbGV0IG1pbWVUeXBlcyA9IEhUTUw1VmlkZW8uX21pbWVUeXBlc0ZvclVybChyZXNvdXJjZVVybCwgbWltZVR5cGVzQnlFeHRlbnNpb24sIG1pbWVUeXBlKVxuICBjb25zdCBtZWRpYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSlcbiAgcmV0dXJuICEhKG1pbWVUeXBlcy5maWx0ZXIobWVkaWFUeXBlID0+ICEhbWVkaWEuY2FuUGxheVR5cGUobWVkaWFUeXBlKS5yZXBsYWNlKC9uby8sICcnKSlbMF0pXG59XG5cbkhUTUw1VmlkZW8uY2FuUGxheSA9IGZ1bmN0aW9uKHJlc291cmNlVXJsLCBtaW1lVHlwZSkge1xuICByZXR1cm4gSFRNTDVWaWRlby5fY2FuUGxheSgnYXVkaW8nLCBBVURJT19NSU1FVFlQRVMsIHJlc291cmNlVXJsLCBtaW1lVHlwZSkgfHxcbiAgICAgICAgIEhUTUw1VmlkZW8uX2NhblBsYXkoJ3ZpZGVvJywgTUlNRVRZUEVTLCByZXNvdXJjZVVybCwgbWltZVR5cGUpXG59XG4iLCJpbXBvcnQgSFRNTDVWaWRlbyBmcm9tICAnLi9odG1sNV92aWRlbydcbmV4cG9ydCBkZWZhdWx0IEhUTUw1VmlkZW9cbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wic2luZ2xldG9uXCI6dHJ1ZSxcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3N0eWxlLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCUgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHsgJT5cXG4gIDx0cmFjayBkYXRhLWh0bWw1LXZpZGVvLXRyYWNrPVxcXCI8JT0gaSAlPlxcXCIga2luZD1cXFwiPCU9IHRyYWNrc1tpXS5raW5kICU+XFxcIiBsYWJlbD1cXFwiPCU9IHRyYWNrc1tpXS5sYWJlbCAlPlxcXCIgc3JjbGFuZz1cXFwiPCU9IHRyYWNrc1tpXS5sYW5nICU+XFxcIiBzcmM9XFxcIjwlPSB0cmFja3NbaV0uc3JjICU+XFxcIiAvPlxcbjwlIH07ICU+XFxuXCI7IiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IFBsYXliYWNrIGZyb20gJy4uLy4uL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0ICcuL3B1YmxpYy9zdHlsZS5zY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVE1MSW1nIGV4dGVuZHMgUGxheWJhY2sge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdodG1sX2ltZycgfVxuICBnZXQgdGFnTmFtZSgpIHsgcmV0dXJuICdpbWcnIH1cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdkYXRhLWh0bWwtaW1nJzogJydcbiAgICB9XG4gIH1cblxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnbG9hZCc6ICdfb25Mb2FkJyxcbiAgICAgICdhYm9ydCc6ICdfb25FcnJvcicsXG4gICAgICAnZXJyb3InOiAnX29uRXJyb3InXG4gICAgfVxuICB9XG5cbiAgZ2V0UGxheWJhY2tUeXBlKCkge1xuICAgIHJldHVybiBQbGF5YmFjay5OT19PUFxuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKVxuICAgIHRoaXMuZWwuc3JjID0gcGFyYW1zLnNyY1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuUExBWUJBQ0tfUkVBRFksIHRoaXMubmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgX29uTG9hZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlBMQVlCQUNLX0VOREVELCB0aGlzLm5hbWUpXG4gIH1cblxuICBfb25FcnJvcihldnQpIHtcbiAgICBjb25zdCBtID0gKGV2dC50eXBlID09PSAnZXJyb3InKSA/ICdsb2FkIGVycm9yJyA6ICdsb2FkaW5nIGFib3J0ZWQnXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19FUlJPUiwgeyBtZXNzYWdlOiBtIH0sIHRoaXMubmFtZSlcbiAgfVxufVxuXG5IVE1MSW1nLmNhblBsYXkgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICByZXR1cm4gL1xcLihwbmd8anBnfGpwZWd8Z2lmfGJtcHx0aWZmfHBnbXxwbm18d2VicCkofFxcPy4qKSQvaS50ZXN0KHJlc291cmNlKVxufVxuIiwiaW1wb3J0IEhUTUxJbWcgZnJvbSAnLi9odG1sX2ltZydcbmV4cG9ydCBkZWZhdWx0IEhUTUxJbWdcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wic2luZ2xldG9uXCI6dHJ1ZSxcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3N0eWxlLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJpbXBvcnQgTm9PcCBmcm9tICcuL25vX29wJ1xuZXhwb3J0IGRlZmF1bHQgTm9PcFxuIiwiaW1wb3J0IHsgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSB9IGZyb20gJy4uLy4uL2Jhc2UvdXRpbHMnXG5pbXBvcnQgUGxheWJhY2sgZnJvbSAnLi4vLi4vYmFzZS9wbGF5YmFjaydcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuLi8uLi9iYXNlL3RlbXBsYXRlJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCBub09wSFRNTCBmcm9tICcuL3B1YmxpYy9lcnJvci5odG1sJ1xuaW1wb3J0ICcuL3B1YmxpYy9zdHlsZS5zY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb09wIGV4dGVuZHMgUGxheWJhY2sge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdub19vcCcgfVxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZShub09wSFRNTCkgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4geyAnZGF0YS1uby1vcCc6ICcnIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX25vaXNlRnJhbWVOdW0gPSAtMVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHBsYXliYWNrTm90U3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLnBsYXliYWNrTm90U3VwcG9ydGVkTWVzc2FnZSB8fCB0aGlzLmkxOG4udCgncGxheWJhY2tfbm90X3N1cHBvcnRlZCcpXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHsgbWVzc2FnZTogcGxheWJhY2tOb3RTdXBwb3J0ZWQgfSkpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5QTEFZQkFDS19SRUFEWSwgdGhpcy5uYW1lKVxuICAgIGNvbnN0IHNob3dGb3JOb09wID0gISEodGhpcy5vcHRpb25zLnBvc3RlciAmJiB0aGlzLm9wdGlvbnMucG9zdGVyLnNob3dGb3JOb09wKVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgfHwgIXNob3dGb3JOb09wKVxuICAgICAgdGhpcy5fYW5pbWF0ZSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgX25vaXNlKCkge1xuICAgIHRoaXMuX25vaXNlRnJhbWVOdW0gPSAodGhpcy5fbm9pc2VGcmFtZU51bSsxKSU1XG4gICAgaWYgKHRoaXMuX25vaXNlRnJhbWVOdW0pIHtcbiAgICAgIC8vIG9ubHkgdXBkYXRlIG5vaXNlIGV2ZXJ5IDUgZnJhbWVzIHRvIHNhdmUgY3B1XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpZGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodGhpcy5jb250ZXh0LmNhbnZhcy53aWR0aCwgdGhpcy5jb250ZXh0LmNhbnZhcy5oZWlnaHQpXG4gICAgbGV0IGJ1ZmZlcjMyXG4gICAgdHJ5IHtcbiAgICAgIGJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGlkYXRhLmRhdGEuYnVmZmVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgYnVmZmVyMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5jb250ZXh0LmNhbnZhcy53aWR0aCAqIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0ICogNClcbiAgICAgIGNvbnN0IGRhdGE9aWRhdGEuZGF0YVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICBidWZmZXIzMltpXT1kYXRhW2ldXG5cbiAgICB9XG5cbiAgICBjb25zdCBsZW4gPSBidWZmZXIzMi5sZW5ndGgsXG4gICAgICBtID0gTWF0aC5yYW5kb20oKSAqIDYgKyA0XG4gICAgbGV0IHJ1biA9IDAsXG4gICAgICBjb2xvciA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgIGlmIChydW4gPCAwKSB7XG4gICAgICAgIHJ1biA9IG0gKiBNYXRoLnJhbmRvbSgpXG4gICAgICAgIGNvbnN0IHAgPSBNYXRoLnBvdyhNYXRoLnJhbmRvbSgpLCAwLjQpXG4gICAgICAgIGNvbG9yID0gKDI1NSAqIHApIDw8IDI0XG4gICAgICB9XG4gICAgICBydW4gLT0gMVxuICAgICAgYnVmZmVyMzJbaSsrXSA9IGNvbG9yXG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEoaWRhdGEsIDAsIDApXG4gIH1cblxuICBfbG9vcCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcClcbiAgICAgIHJldHVyblxuXG4gICAgdGhpcy5fbm9pc2UoKVxuICAgIHRoaXMuX2FuaW1hdGlvbkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl9sb29wKCkpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9hbmltYXRpb25IYW5kbGUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkhhbmRsZSlcbiAgICAgIHRoaXMuX3N0b3AgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX2FuaW1hdGUoKSB7XG4gICAgdGhpcy5jYW52YXMgPSB0aGlzLiRlbC5maW5kKCdjYW52YXNbZGF0YS1uby1vcC1jYW52YXNdJylbMF1cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5fbG9vcCgpXG4gIH1cbn1cblxuTm9PcC5jYW5QbGF5ID0gKHNvdXJjZSkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiB0cnVlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGNhbnZhcyBkYXRhLW5vLW9wLWNhbnZhcz48L2NhbnZhcz5cXG48cCBkYXRhLW5vLW9wLW1zZz48JT1tZXNzYWdlJT48cD5cXG5cIjsiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcInNpbmdsZXRvblwiOnRydWUsXCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3R5bGUuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy9Db3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgQ29udGFpbmVyUGx1Z2luIGZyb20gJy4uLy4uL2Jhc2UvY29udGFpbmVyX3BsdWdpbidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgUGxheWJhY2sgZnJvbSAnLi4vLi4vYmFzZS9wbGF5YmFjaydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpY2tUb1BhdXNlUGx1Z2luIGV4dGVuZHMgQ29udGFpbmVyUGx1Z2luIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnY2xpY2tfdG9fcGF1c2UnIH1cblxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICBzdXBlcihjb250YWluZXIpXG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfQ0xJQ0ssIHRoaXMuY2xpY2spXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TRVRUSU5HU1VQREFURSwgdGhpcy5zZXR0aW5nc1VwZGF0ZSlcbiAgfVxuXG4gIGNsaWNrKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lci5nZXRQbGF5YmFja1R5cGUoKSAhPT0gUGxheWJhY2suTElWRSB8fCB0aGlzLmNvbnRhaW5lci5pc0R2ckVuYWJsZWQoKSkge1xuICAgICAgaWYodGhpcy50aW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7ICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmlzUGxheWluZygpKVxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhdXNlKClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBsYXkoKSAgICAgICAgXG4gICAgICB9LCAzMDApXG5cblxuICAgIH1cbiAgfVxuXG4gIHNldHRpbmdzVXBkYXRlKCkge1xuICAgIGNvbnN0IHBvaW50ZXJFbmFibGVkID0gdGhpcy5jb250YWluZXIuZ2V0UGxheWJhY2tUeXBlKCkgIT09IFBsYXliYWNrLkxJVkUgfHwgdGhpcy5jb250YWluZXIuaXNEdnJFbmFibGVkKClcbiAgICBpZiAocG9pbnRlckVuYWJsZWQgPT09IHRoaXMucG9pbnRlckVuYWJsZWQpIHJldHVyblxuXG4gICAgY29uc3QgbWV0aG9kID0gcG9pbnRlckVuYWJsZWQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ1xuICAgIHRoaXMuY29udGFpbmVyLiRlbFttZXRob2RdKCdwb2ludGVyLWVuYWJsZWQnKVxuICAgIHRoaXMucG9pbnRlckVuYWJsZWQgPSBwb2ludGVyRW5hYmxlZFxuICB9XG59XG4iLCJpbXBvcnQgQ2xpY2tUb1BhdXNlUGx1Z2luIGZyb20gJy4vY2xpY2tfdG9fcGF1c2UnXG5leHBvcnQgZGVmYXVsdCBDbGlja1RvUGF1c2VQbHVnaW5cbiIsImltcG9ydCBVSUNvcmVQbHVnaW4gZnJvbSAnLi4vLi4vYmFzZS91aV9jb3JlX3BsdWdpbidcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuLi8uLi9iYXNlL3RlbXBsYXRlJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCB7IFN2Z0ljb25zIH0gZnJvbSAnLi4vLi4vYmFzZS91dGlscydcbmltcG9ydCBjY0hUTUwgZnJvbSAnLi9wdWJsaWMvY2xvc2VkX2NhcHRpb25zLmh0bWwnXG5pbXBvcnQgJy4vcHVibGljL2Nsb3NlZF9jYXB0aW9ucy5zY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbG9zZWRDYXB0aW9ucyBleHRlbmRzIFVJQ29yZVBsdWdpbiB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2Nsb3NlZF9jYXB0aW9ucycgfVxuXG4gIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIHRlbXBsYXRlKGNjSFRNTCkgfVxuXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjbGljayBbZGF0YS1jYy1idXR0b25dJzogJ3RvZ2dsZUNvbnRleHRNZW51JyxcbiAgICAgICdjbGljayBbZGF0YS1jYy1zZWxlY3RdJzogJ29uVHJhY2tTZWxlY3QnLFxuICAgIH1cbiAgfVxuXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnY2xhc3MnOiAnY2MtY29udHJvbHMnLFxuICAgICAgJ2RhdGEtY2MtY29udHJvbHMnOiAnJ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvcmUpIHtcbiAgICBzdXBlcihjb3JlKVxuICAgIGNvbnN0IGNvbmZpZyA9IGNvcmUub3B0aW9ucy5jbG9zZWRDYXB0aW9uc0NvbmZpZ1xuICAgIHRoaXMuX3RpdGxlID0gY29uZmlnICYmIGNvbmZpZy50aXRsZSA/IGNvbmZpZy50aXRsZSA6IG51bGxcbiAgICB0aGlzLl9hcmlhTGFiZWwgPSBjb25maWcgJiYgY29uZmlnLmFyaWFMYWJlbCA/IGNvbmZpZy5hcmlhTGFiZWwgOiAnY2MtYnV0dG9uJ1xuICAgIHRoaXMuX2xhYmVsQ2IgPSBjb25maWcgJiYgY29uZmlnLmxhYmVsQ2FsbGJhY2sgJiYgdHlwZW9mIGNvbmZpZy5sYWJlbENhbGxiYWNrID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGNvbmZpZy5sYWJlbENhbGxiYWNrXG4gICAgICA6IHRyYWNrID0+IHsgcmV0dXJuIHRyYWNrLm5hbWUgfVxuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VELCB0aGlzLmNvbnRhaW5lckNoYW5nZWQpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUubWVkaWFDb250cm9sLCBFdmVudHMuTUVESUFDT05UUk9MX1JFTkRFUkVELCB0aGlzLnJlbmRlcilcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZS5tZWRpYUNvbnRyb2wsIEV2ZW50cy5NRURJQUNPTlRST0xfSElERSwgdGhpcy5oaWRlQ29udGV4dE1lbnUpXG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLmNvcmUuZ2V0Q3VycmVudENvbnRhaW5lcigpXG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NVQlRJVExFX0FWQUlMQUJMRSwgdGhpcy5vblN1YnRpdGxlQXZhaWxhYmxlKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVUJUSVRMRV9DSEFOR0VELCB0aGlzLm9uU3VidGl0bGVDaGFuZ2VkKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVE9QLCB0aGlzLm9uQ29udGFpbmVyU3RvcClcbiAgICB9XG4gIH1cblxuICBvbkNvbnRhaW5lclN0b3AoKSB7XG4gICAgdGhpcy5jY0F2YWlsYWJsZShmYWxzZSlcbiAgfVxuXG4gIGNvbnRhaW5lckNoYW5nZWQoKSB7XG4gICAgdGhpcy5jY0F2YWlsYWJsZShmYWxzZSlcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cblxuICBvblN1YnRpdGxlQXZhaWxhYmxlKCkge1xuICAgIHRoaXMucmVuZGVyQ2NCdXR0b24oKVxuICAgIHRoaXMuY2NBdmFpbGFibGUodHJ1ZSlcbiAgfVxuXG4gIG9uU3VidGl0bGVDaGFuZ2VkKHRyYWNrKSB7XG4gICAgdGhpcy5zZXRDdXJyZW50Q29udGV4dE1lbnVFbGVtZW50KHRyYWNrLmlkKVxuICB9XG5cbiAgb25UcmFja1NlbGVjdChldmVudCkge1xuICAgIGNvbnN0IHRyYWNrSWQgPSBwYXJzZUludChldmVudC50YXJnZXQuZGF0YXNldC5jY1NlbGVjdCwgMTApXG4gICAgdGhpcy5jb250YWluZXIuY2xvc2VkQ2FwdGlvbnNUcmFja0lkID0gdHJhY2tJZFxuICAgIHRoaXMuaGlkZUNvbnRleHRNZW51KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY2NBdmFpbGFibGUoaGFzQ0MpIHtcbiAgICBjb25zdCBtZXRob2QgPSBoYXNDQyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXG4gICAgdGhpcy4kZWxbbWV0aG9kXSgnYXZhaWxhYmxlJylcbiAgfVxuXG4gIHRvZ2dsZUNvbnRleHRNZW51KCkge1xuICAgIHRoaXMuJGVsLmZpbmQoJ3VsJykudG9nZ2xlKClcbiAgfVxuXG4gIGhpZGVDb250ZXh0TWVudSgpIHtcbiAgICB0aGlzLiRlbC5maW5kKCd1bCcpLmhpZGUoKVxuICB9XG5cbiAgY29udGV4dE1lbnVFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoJ3VsIGEnKyghaXNOYU4oaWQpID8gJ1tkYXRhLWNjLXNlbGVjdD1cIicraWQrJ1wiXScgOiAnJykpLnBhcmVudCgpXG4gIH1cblxuICBzZXRDdXJyZW50Q29udGV4dE1lbnVFbGVtZW50KHRyYWNrSWQpIHtcbiAgICBpZiAodGhpcy5fdHJhY2tJZCAhPT0gdHJhY2tJZCkge1xuICAgICAgdGhpcy5jb250ZXh0TWVudUVsZW1lbnQoKS5yZW1vdmVDbGFzcygnY3VycmVudCcpXG4gICAgICB0aGlzLmNvbnRleHRNZW51RWxlbWVudCh0cmFja0lkKS5hZGRDbGFzcygnY3VycmVudCcpXG4gICAgICBjb25zdCBtZXRob2QgPSB0cmFja0lkID4gLTEgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ1xuICAgICAgdGhpcy4kY2NCdXR0b25bbWV0aG9kXSgnZW5hYmxlZCcpXG4gICAgICB0aGlzLl90cmFja0lkID0gdHJhY2tJZFxuICAgIH1cbiAgfVxuXG4gIHJlbmRlckNjQnV0dG9uKCkge1xuICAgIGxldCB0cmFja3MgPSB0aGlzLmNvbnRhaW5lciA/IHRoaXMuY29udGFpbmVyLmNsb3NlZENhcHRpb25zVHJhY2tzIDogW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgIHRyYWNrc1tpXS5sYWJlbCA9IHRoaXMuX2xhYmVsQ2IodHJhY2tzW2ldKVxuXG5cbiAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe1xuICAgICAgYXJpYUxhYmVsOiB0aGlzLl9hcmlhTGFiZWwsXG4gICAgICBkaXNhYmxlZExhYmVsOiB0aGlzLmNvcmUuaTE4bi50KCdkaXNhYmxlZCcpLFxuICAgICAgdGl0bGU6IHRoaXMuX3RpdGxlLFxuICAgICAgdHJhY2tzOiB0cmFja3NcbiAgICB9KSlcblxuICAgIHRoaXMuJGNjQnV0dG9uID0gdGhpcy4kZWwuZmluZCgnYnV0dG9uLmNjLWJ1dHRvbltkYXRhLWNjLWJ1dHRvbl0nKVxuICAgIHRoaXMuJGNjQnV0dG9uLmFwcGVuZChTdmdJY29ucy5jYylcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5zdHlsZSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlckNjQnV0dG9uKClcblxuICAgIGNvbnN0ICRmdWxsc2NyZWVuID0gdGhpcy5jb3JlLm1lZGlhQ29udHJvbC4kZWwuZmluZCgnYnV0dG9uW2RhdGEtZnVsbHNjcmVlbl0nKVxuICAgIGlmICgkZnVsbHNjcmVlblswXSlcbiAgICAgIHRoaXMuJGVsLmluc2VydEFmdGVyKCRmdWxsc2NyZWVuKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuY29yZS5tZWRpYUNvbnRyb2wuJGVsLmZpbmQoJy5tZWRpYS1jb250cm9sLXJpZ2h0LXBhbmVsW2RhdGEtbWVkaWEtY29udHJvbF0nKS5wcmVwZW5kKHRoaXMuJGVsKVxuXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG4iLCJpbXBvcnQgQ2xvc2VkQ2FwdGlvbnMgZnJvbSAnLi9jbG9zZWRfY2FwdGlvbnMnXG5leHBvcnQgZGVmYXVsdCBDbG9zZWRDYXB0aW9uc1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2MtYnV0dG9uIG1lZGlhLWNvbnRyb2wtYnV0dG9uIG1lZGlhLWNvbnRyb2wtaWNvblxcXCIgZGF0YS1jYy1idXR0b24gYXJpYS1sYWJlbD1cXFwiPCU9IGFyaWFMYWJlbCAlPlxcXCI+PC9idXR0b24+XFxuPHVsPlxcbiAgPCUgaWYgKHRpdGxlKSB7ICU+XFxuICA8bGkgZGF0YS10aXRsZT48JT0gdGl0bGUgJT48L2xpPlxcbiAgPCUgfTsgJT5cXG4gIDxsaT48YSBocmVmPVxcXCIjXFxcIiBkYXRhLWNjLXNlbGVjdD1cXFwiLTFcXFwiPjwlPSBkaXNhYmxlZExhYmVsICU+PC9hPjwvbGk+XFxuICA8JSBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykgeyAlPlxcbiAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCIgZGF0YS1jYy1zZWxlY3Q9XFxcIjwlPSB0cmFja3NbaV0uaWQgJT5cXFwiPjwlPSB0cmFja3NbaV0ubGFiZWwgJT48L2E+PC9saT5cXG4gIDwlIH07ICU+XFxuPC91bD5cXG5cIjsiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Nsb3NlZF9jYXB0aW9ucy5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJzaW5nbGV0b25cIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Nsb3NlZF9jYXB0aW9ucy5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Nsb3NlZF9jYXB0aW9ucy5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiaW1wb3J0IFVJQ29yZVBsdWdpbiBmcm9tICcuLi8uLi9iYXNlL3VpX2NvcmVfcGx1Z2luJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL2Jhc2UvdGVtcGxhdGUnXG5pbXBvcnQgUGxheWJhY2sgZnJvbSAnLi4vLi4vYmFzZS9wbGF5YmFjaydcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgZHZySFRNTCBmcm9tICcuL3B1YmxpYy9pbmRleC5odG1sJ1xuaW1wb3J0ICcuL3B1YmxpYy9kdnJfY29udHJvbHMuc2NzcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRFZSQ29udHJvbHMgZXh0ZW5kcyBVSUNvcmVQbHVnaW4ge1xuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZShkdnJIVE1MKSB9XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2R2cl9jb250cm9scycgfVxuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnY2xpY2sgLmxpdmUtYnV0dG9uJzogJ2NsaWNrJ1xuICAgIH1cbiAgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2NsYXNzJzogJ2R2ci1jb250cm9scycsXG4gICAgICAnZGF0YS1kdnItY29udHJvbHMnOiAnJ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvcmUpIHtcbiAgICBzdXBlcihjb3JlKVxuICAgIHRoaXMuc2V0dGluZ3NVcGRhdGUoKVxuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZS5tZWRpYUNvbnRyb2wsIEV2ZW50cy5NRURJQUNPTlRST0xfQ09OVEFJTkVSQ0hBTkdFRCwgdGhpcy5jb250YWluZXJDaGFuZ2VkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLm1lZGlhQ29udHJvbCwgRXZlbnRzLk1FRElBQ09OVFJPTF9SRU5ERVJFRCwgdGhpcy5zZXR0aW5nc1VwZGF0ZSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfT1BUSU9OU19DSEFOR0UsIHRoaXMucmVuZGVyKVxuICAgIGlmICh0aGlzLmNvcmUuZ2V0Q3VycmVudENvbnRhaW5lcigpKSB7XG4gICAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLmNvcmUuZ2V0Q3VycmVudENvbnRhaW5lcigpLCBFdmVudHMuQ09OVEFJTkVSX1RJTUVVUERBVEUsIHRoaXMucmVuZGVyKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUuZ2V0Q3VycmVudENvbnRhaW5lcigpLCBFdmVudHMuQ09OVEFJTkVSX1BMQVlCQUNLRFZSU1RBVEVDSEFOR0VELCB0aGlzLmR2ckNoYW5nZWQpXG4gICAgfVxuICB9XG5cbiAgY29udGFpbmVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cblxuICBkdnJDaGFuZ2VkKGR2ckVuYWJsZWQpIHtcbiAgICBpZiAodGhpcy5jb3JlLmdldFBsYXliYWNrVHlwZSgpICE9PSBQbGF5YmFjay5MSVZFKSByZXR1cm5cbiAgICB0aGlzLnNldHRpbmdzVXBkYXRlKClcbiAgICB0aGlzLmNvcmUubWVkaWFDb250cm9sLiRlbC5hZGRDbGFzcygnbGl2ZScpXG4gICAgaWYgKGR2ckVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY29yZS5tZWRpYUNvbnRyb2wuJGVsLmFkZENsYXNzKCdkdnInKVxuICAgICAgdGhpcy5jb3JlLm1lZGlhQ29udHJvbC4kZWwuZmluZCgnLm1lZGlhLWNvbnRyb2wtaW5kaWNhdG9yW2RhdGEtcG9zaXRpb25dLCAubWVkaWEtY29udHJvbC1pbmRpY2F0b3JbZGF0YS1kdXJhdGlvbl0nKS5oaWRlKClcbiAgICB9IGVsc2UgeyB0aGlzLmNvcmUubWVkaWFDb250cm9sLiRlbC5yZW1vdmVDbGFzcygnZHZyJykgfVxuXG4gIH1cblxuICBjbGljaygpIHtcbiAgICBjb25zdCBtZWRpYUNvbnRyb2wgPSB0aGlzLmNvcmUubWVkaWFDb250cm9sXG4gICAgY29uc3QgY29udGFpbmVyID0gbWVkaWFDb250cm9sLmNvbnRhaW5lclxuICAgIGlmICghY29udGFpbmVyLmlzUGxheWluZygpKVxuICAgICAgY29udGFpbmVyLnBsYXkoKVxuXG4gICAgaWYgKG1lZGlhQ29udHJvbC4kZWwuaGFzQ2xhc3MoJ2R2cicpKVxuICAgICAgY29udGFpbmVyLnNlZWsoY29udGFpbmVyLmdldER1cmF0aW9uKCkpXG5cbiAgfVxuXG4gIHNldHRpbmdzVXBkYXRlKCkge1xuICAgIHRoaXMuc3RvcExpc3RlbmluZygpXG4gICAgdGhpcy5jb3JlLm1lZGlhQ29udHJvbC4kZWwucmVtb3ZlQ2xhc3MoJ2xpdmUnKVxuICAgIGlmICh0aGlzLnNob3VsZFJlbmRlcigpKSB7XG4gICAgICB0aGlzLnJlbmRlcigpXG4gICAgICB0aGlzLiRlbC5jbGljaygoKSA9PiB0aGlzLmNsaWNrKCkpXG4gICAgfVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cblxuICBzaG91bGRSZW5kZXIoKSB7XG4gICAgY29uc3QgdXNlRHZyQ29udHJvbHMgPSB0aGlzLmNvcmUub3B0aW9ucy51c2VEdnJDb250cm9scyA9PT0gdW5kZWZpbmVkIHx8ICEhdGhpcy5jb3JlLm9wdGlvbnMudXNlRHZyQ29udHJvbHNcbiAgICByZXR1cm4gdXNlRHZyQ29udHJvbHMgJiYgdGhpcy5jb3JlLmdldFBsYXliYWNrVHlwZSgpID09PSBQbGF5YmFjay5MSVZFXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHtcbiAgICAgIGxpdmU6IHRoaXMuY29yZS5pMThuLnQoJ2xpdmUnKSxcbiAgICAgIGJhY2tUb0xpdmU6IHRoaXMuY29yZS5pMThuLnQoJ2JhY2tfdG9fbGl2ZScpXG4gICAgfSkpXG4gICAgaWYgKHRoaXMuc2hvdWxkUmVuZGVyKCkpIHtcbiAgICAgIHRoaXMuY29yZS5tZWRpYUNvbnRyb2wuJGVsLmFkZENsYXNzKCdsaXZlJylcbiAgICAgIHRoaXMuY29yZS5tZWRpYUNvbnRyb2wuJCgnLm1lZGlhLWNvbnRyb2wtbGVmdC1wYW5lbFtkYXRhLW1lZGlhLWNvbnRyb2xdJykuYXBwZW5kKHRoaXMuJGVsKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG4iLCJpbXBvcnQgRFZSQ29udHJvbHMgZnJvbSAnLi9kdnJfY29udHJvbHMnXG5leHBvcnQgZGVmYXVsdCBEVlJDb250cm9sc1xuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9kdnJfY29udHJvbHMuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wic2luZ2xldG9uXCI6dHJ1ZSxcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9kdnJfY29udHJvbHMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9kdnJfY29udHJvbHMuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJsaXZlLWluZm9cXFwiPjwlPSBsaXZlICU+PC9kaXY+XFxuPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJsaXZlLWJ1dHRvblxcXCIgYXJpYS1sYWJlbD1cXFwiPCU9IGJhY2tUb0xpdmUgJT5cXFwiPjwlPSBiYWNrVG9MaXZlICU+PC9idXR0b24+XFxuXCI7IiwiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9iYXNlL2V2ZW50cydcbmltcG9ydCBDb3JlUGx1Z2luIGZyb20gJy4uL2Jhc2UvY29yZV9wbHVnaW4nXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZFZpZGVvIGV4dGVuZHMgQ29yZVBsdWdpbiB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2VuZF92aWRlbycgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuQ09SRV9BQ1RJVkVfQ09OVEFJTkVSX0NIQU5HRUQsIHRoaXMuY29udGFpbmVyQ2hhbmdlZClcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvcmUuYWN0aXZlQ29udGFpbmVyXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5saXN0ZW5Ubyhjb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfRU5ERUQsIHRoaXMuZW5kZWQpXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVE9QLCB0aGlzLmVuZGVkKVxuICAgIH1cbiAgfVxuXG4gIGNvbnRhaW5lckNoYW5nZWQoKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgICB0aGlzLmJpbmRFdmVudHMoKVxuICB9XG5cbiAgZW5kZWQoKSB7XG4gICAgY29uc3QgZXhpdE9uRW5kID0gdHlwZW9mICh0aGlzLmNvcmUub3B0aW9ucy5leGl0RnVsbHNjcmVlbk9uRW5kKSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5jb3JlLm9wdGlvbnMuZXhpdEZ1bGxzY3JlZW5PbkVuZFxuICAgIGlmIChleGl0T25FbmQgJiYgdGhpcy5jb3JlLmlzRnVsbHNjcmVlbigpKVxuICAgICAgdGhpcy5jb3JlLnRvZ2dsZUZ1bGxzY3JlZW4oKVxuXG4gIH1cbn1cbiIsImltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgVUlDb3JlUGx1Z2luIGZyb20gJy4uLy4uL2Jhc2UvdWlfY29yZV9wbHVnaW4nXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi4vLi4vYmFzZS90ZW1wbGF0ZSdcbmltcG9ydCBQbGF5ZXJFcnJvciBmcm9tICcuLi8uLi9jb21wb25lbnRzL2Vycm9yLydcbmltcG9ydCB7IFN2Z0ljb25zIH0gZnJvbSAnLi4vLi4vYmFzZS91dGlscydcbmltcG9ydCB0ZW1wbGF0ZUh0bWwgZnJvbSAnLi9wdWJsaWMvZXJyb3Jfc2NyZWVuLmh0bWwnXG5pbXBvcnQgJy4vcHVibGljL2Vycm9yX3NjcmVlbi5zY3NzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvclNjcmVlbiBleHRlbmRzIFVJQ29yZVBsdWdpbiB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2Vycm9yX3NjcmVlbicgfVxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZSh0ZW1wbGF0ZUh0bWwpIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHsgcmV0dXJuIHRoaXMuY29yZS5nZXRDdXJyZW50Q29udGFpbmVyKCkgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2NsYXNzJzogJ3BsYXllci1lcnJvci1zY3JlZW4nLFxuICAgICAgJ2RhdGEtZXJyb3Itc2NyZWVuJzogJycsXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoY29yZSkge1xuICAgIHN1cGVyKGNvcmUpXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVFcnJvclNjcmVlbikgcmV0dXJuIHRoaXMuZGlzYWJsZSgpXG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuRVJST1IsIHRoaXMub25FcnJvcilcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VELCB0aGlzLm9uQ29udGFpbmVyQ2hhbmdlZClcbiAgfVxuXG4gIGJpbmRSZWxvYWQoKSB7XG4gICAgdGhpcy5yZWxvYWRCdXR0b24gPSB0aGlzLiRlbC5maW5kKCcucGxheWVyLWVycm9yLXNjcmVlbl9fcmVsb2FkJylcbiAgICB0aGlzLnJlbG9hZEJ1dHRvbiAmJiB0aGlzLnJlbG9hZEJ1dHRvbi5vbignY2xpY2snLCB0aGlzLnJlbG9hZC5iaW5kKHRoaXMpKVxuICB9XG5cbiAgcmVsb2FkKCkge1xuICAgIHRoaXMubGlzdGVuVG9PbmNlKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfUkVBRFksICgpID0+IHRoaXMuY29udGFpbmVyLnBsYXkoKSlcbiAgICB0aGlzLmNvcmUubG9hZCh0aGlzLm9wdGlvbnMuc291cmNlcywgdGhpcy5vcHRpb25zLm1pbWVUeXBlKVxuICAgIHRoaXMudW5iaW5kUmVsb2FkKClcbiAgfVxuXG4gIHVuYmluZFJlbG9hZCgpIHtcbiAgICB0aGlzLnJlbG9hZEJ1dHRvbiAmJiB0aGlzLnJlbG9hZEJ1dHRvbi5vZmYoJ2NsaWNrJylcbiAgfVxuXG4gIG9uQ29udGFpbmVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmVyciA9IG51bGxcbiAgICB0aGlzLnVuYmluZFJlbG9hZCgpXG4gICAgdGhpcy5oaWRlKClcbiAgfVxuXG4gIG9uRXJyb3IoZXJyID0ge30pIHtcbiAgICBpZiAoZXJyLmxldmVsID09PSBQbGF5ZXJFcnJvci5MZXZlbHMuRkFUQUwpIHtcbiAgICAgIHRoaXMuZXJyID0gZXJyXG4gICAgICB0aGlzLmNvbnRhaW5lci5kaXNhYmxlTWVkaWFDb250cm9sKClcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0b3AoKVxuICAgICAgdGhpcy5zaG93KClcbiAgICB9XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMucmVuZGVyKClcbiAgICB0aGlzLiRlbC5zaG93KClcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy4kZWwuaGlkZSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmVycikgcmV0dXJuXG5cbiAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe1xuICAgICAgdGl0bGU6IHRoaXMuZXJyLlVJLnRpdGxlLFxuICAgICAgbWVzc2FnZTogdGhpcy5lcnIuVUkubWVzc2FnZSxcbiAgICAgIGNvZGU6IHRoaXMuZXJyLmNvZGUsXG4gICAgICBpY29uOiB0aGlzLmVyci5VSS5pY29uIHx8ICcnLFxuICAgICAgcmVsb2FkSWNvbjogU3ZnSWNvbnMucmVsb2FkLFxuICAgIH0pKVxuXG4gICAgdGhpcy5jb3JlLiRlbC5hcHBlbmQodGhpcy5lbClcblxuICAgIHRoaXMuYmluZFJlbG9hZCgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG4iLCJpbXBvcnQgRXJyb3JTY3JlZW4gZnJvbSAnLi9lcnJvcl9zY3JlZW4nXG5leHBvcnQgZGVmYXVsdCBFcnJvclNjcmVlblxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInBsYXllci1lcnJvci1zY3JlZW5fX2NvbnRlbnRcXFwiIGRhdGEtZXJyb3Itc2NyZWVuPlxcbiAgPCUgaWYgKGljb24pIHsgJT5cXG4gIDxkaXYgY2xhc3M9XFxcInBsYXllci1lcnJvci1zY3JlZW5fX2ljb25cXFwiIGRhdGEtZXJyb3Itc2NyZWVuPjwlPSBpY29uICU+PC9kaXY+XFxuICA8JSB9ICU+XFxuICA8ZGl2IGNsYXNzPVxcXCJwbGF5ZXItZXJyb3Itc2NyZWVuX190aXRsZVxcXCIgZGF0YS1lcnJvci1zY3JlZW4+PCU9IHRpdGxlICU+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJwbGF5ZXItZXJyb3Itc2NyZWVuX19tZXNzYWdlXFxcIiBkYXRhLWVycm9yLXNjcmVlbj48JT0gbWVzc2FnZSAlPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicGxheWVyLWVycm9yLXNjcmVlbl9fY29kZVxcXCIgZGF0YS1lcnJvci1zY3JlZW4+RXJyb3IgY29kZTogPCU9IGNvZGUgJT48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInBsYXllci1lcnJvci1zY3JlZW5fX3JlbG9hZFxcXCIgZGF0YS1lcnJvci1zY3JlZW4+PCU9IHJlbG9hZEljb24gJT48L2Rpdj5cXG48L2Rpdj5cXG5cIjsiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Vycm9yX3NjcmVlbi5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJzaW5nbGV0b25cIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Vycm9yX3NjcmVlbi5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL2Vycm9yX3NjcmVlbi5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiaW1wb3J0IENvcmVQbHVnaW4gZnJvbSAnLi4vLi4vYmFzZS9jb3JlX3BsdWdpbidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgJCBmcm9tICdjbGFwcHItemVwdG8nXG5pbXBvcnQgeyBTdmdJY29ucyB9IGZyb20gJy4uLy4uL2Jhc2UvdXRpbHMnXG5cbmNvbnN0IG9sZEljb24gPSAkKCdsaW5rW3JlbD1cInNob3J0Y3V0IGljb25cIl0nKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYXZpY29uIGV4dGVuZHMgQ29yZVBsdWdpbiB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ2Zhdmljb24nIH1cbiAgZ2V0IG9sZEljb24oKSB7IHJldHVybiBvbGRJY29uIH1cblxuICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG4gICAgc3VwZXIoY29yZSlcbiAgICB0aGlzLl9jb250YWluZXIgPSBudWxsXG4gICAgdGhpcy5jb25maWd1cmUoKVxuICB9XG5cbiAgY29uZmlndXJlKCkge1xuICAgIGlmICh0aGlzLmNvcmUub3B0aW9ucy5jaGFuZ2VGYXZpY29uKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcy5jb3JlLCBFdmVudHMuQ09SRV9PUFRJT05TX0NIQU5HRSlcbiAgICAgICAgdGhpcy5lbmFibGUoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX09QVElPTlNfQ0hBTkdFLCB0aGlzLmNvbmZpZ3VyZSlcbiAgICB9XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuQ09SRV9PUFRJT05TX0NIQU5HRSwgdGhpcy5jb25maWd1cmUpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX0FDVElWRV9DT05UQUlORVJfQ0hBTkdFRCwgdGhpcy5jb250YWluZXJDaGFuZ2VkKVxuICAgIHRoaXMuY29yZS5hY3RpdmVDb250YWluZXIgJiYgdGhpcy5jb250YWluZXJDaGFuZ2VkKClcbiAgfVxuXG4gIGNvbnRhaW5lckNoYW5nZWQoKSB7XG4gICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuc3RvcExpc3RlbmluZyh0aGlzLl9jb250YWluZXIpXG4gICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lclxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1BMQVksIHRoaXMuc2V0UGxheUljb24pXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfUEFVU0UsIHRoaXMuc2V0UGF1c2VJY29uKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUT1AsIHRoaXMucmVzZXRJY29uKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5fY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX0VOREVELCB0aGlzLnJlc2V0SWNvbilcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuX2NvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9FUlJPUiwgdGhpcy5yZXNldEljb24pXG4gICAgdGhpcy5yZXNldEljb24oKVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBzdXBlci5kaXNhYmxlKClcbiAgICB0aGlzLnJlc2V0SWNvbigpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIHRoaXMucmVzZXRJY29uKClcbiAgfVxuXG4gIGNyZWF0ZUljb24oc3ZnKSB7XG4gICAgY29uc3QgY2FudmFzID0gJCgnPGNhbnZhcy8+JylcbiAgICBjYW52YXNbMF0ud2lkdGggPSAxNlxuICAgIGNhbnZhc1swXS5oZWlnaHQgPSAxNlxuICAgIGNvbnN0IGN0eCA9IGNhbnZhc1swXS5nZXRDb250ZXh0KCcyZCcpXG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJ1xuICAgIGNvbnN0IGQgPSAkKHN2ZykuZmluZCgncGF0aCcpLmF0dHIoJ2QnKVxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKGQpXG4gICAgY3R4LmZpbGwocGF0aClcbiAgICBjb25zdCBpY29uID0gJCgnPGxpbmsgcmVsPVwic2hvcnRjdXQgaWNvblwiIHR5cGU9XCJpbWFnZS9wbmdcIi8+JylcbiAgICBpY29uLmF0dHIoJ2hyZWYnLCBjYW52YXNbMF0udG9EYXRhVVJMKCdpbWFnZS9wbmcnKSlcbiAgICByZXR1cm4gaWNvblxuICB9XG5cbiAgc2V0UGxheUljb24oKSB7XG4gICAgaWYgKCF0aGlzLnBsYXlJY29uKVxuICAgICAgdGhpcy5wbGF5SWNvbiA9IHRoaXMuY3JlYXRlSWNvbihTdmdJY29ucy5wbGF5KVxuXG4gICAgdGhpcy5jaGFuZ2VJY29uKHRoaXMucGxheUljb24pXG4gIH1cblxuICBzZXRQYXVzZUljb24oKSB7XG4gICAgaWYgKCF0aGlzLnBhdXNlSWNvbilcbiAgICAgIHRoaXMucGF1c2VJY29uID0gdGhpcy5jcmVhdGVJY29uKFN2Z0ljb25zLnBhdXNlKVxuXG4gICAgdGhpcy5jaGFuZ2VJY29uKHRoaXMucGF1c2VJY29uKVxuICB9XG5cbiAgcmVzZXRJY29uKCkge1xuICAgICQoJ2xpbmtbcmVsPVwic2hvcnRjdXQgaWNvblwiXScpLnJlbW92ZSgpXG4gICAgJCgnaGVhZCcpLmFwcGVuZCh0aGlzLm9sZEljb24pXG4gIH1cblxuICBjaGFuZ2VJY29uKGljb24pIHtcbiAgICBpZiAoaWNvbikge1xuICAgICAgJCgnbGlua1tyZWw9XCJzaG9ydGN1dCBpY29uXCJdJykucmVtb3ZlKClcbiAgICAgICQoJ2hlYWQnKS5hcHBlbmQoaWNvbilcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBGYXZpY29uIGZyb20gJy4vZmF2aWNvbi5qcydcbmV4cG9ydCBkZWZhdWx0IEZhdmljb25cbiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBDb250YWluZXJQbHVnaW4gZnJvbSAnLi4vLi4vYmFzZS9jb250YWluZXJfcGx1Z2luJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29vZ2xlQW5hbHl0aWNzIGV4dGVuZHMgQ29udGFpbmVyUGx1Z2luIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnZ29vZ2xlX2FuYWx5dGljcycgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICBzdXBlcihjb250YWluZXIpXG4gICAgaWYgKHRoaXMuY29udGFpbmVyLm9wdGlvbnMuZ2FBY2NvdW50KSB7XG4gICAgICB0aGlzLmFjY291bnQgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zLmdhQWNjb3VudFxuICAgICAgdGhpcy50cmFja2VyTmFtZSA9ICh0aGlzLmNvbnRhaW5lci5vcHRpb25zLmdhVHJhY2tlck5hbWUpID8gdGhpcy5jb250YWluZXIub3B0aW9ucy5nYVRyYWNrZXJOYW1lICsgJy4nIDogJ0NsYXBwci4nXG4gICAgICB0aGlzLmRvbWFpbk5hbWUgPSB0aGlzLmNvbnRhaW5lci5vcHRpb25zLmdhRG9tYWluTmFtZVxuICAgICAgdGhpcy5jdXJyZW50SERTdGF0ZSA9IHVuZGVmaW5lZFxuICAgICAgdGhpcy5lbWJlZFNjcmlwdCgpXG4gICAgfVxuICB9XG5cbiAgZW1iZWRTY3JpcHQoKSB7XG4gICAgaWYgKCF3aW5kb3cuX2dhdCkge1xuICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9qYXZhc2NyaXB0JylcbiAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJ2FzeW5jJylcbiAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ3NyYycsICcvL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9nYS5qcycpXG4gICAgICBzY3JpcHQub25sb2FkID0gKCkgPT4gdGhpcy5hZGRFdmVudExpc3RlbmVycygpXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICB9IGVsc2UgeyB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCkgfVxuXG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfUkVBRFksIHRoaXMub25SZWFkeSlcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfUExBWSwgdGhpcy5vblBsYXkpXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUT1AsIHRoaXMub25TdG9wKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QQVVTRSwgdGhpcy5vblBhdXNlKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9FTkRFRCwgdGhpcy5vbkVuZGVkKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVEFURV9CVUZGRVJJTkcsIHRoaXMub25CdWZmZXJpbmcpXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUQVRFX0JVRkZFUkZVTEwsIHRoaXMub25CdWZmZXJGdWxsKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9FUlJPUiwgdGhpcy5vbkVycm9yKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QTEFZQkFDS1NUQVRFLCB0aGlzLm9uUGxheWJhY2tDaGFuZ2VkKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9WT0xVTUUsIChldmVudCkgPT4gdGhpcy5vblZvbHVtZUNoYW5nZWQoZXZlbnQpKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TRUVLLCAoZXZlbnQpID0+IHRoaXMub25TZWVrKGV2ZW50KSlcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfRlVMTF9TQ1JFRU4sIHRoaXMub25GdWxsc2NyZWVuKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9ISUdIREVGSU5JVElPTlVQREFURSwgdGhpcy5vbkhEKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QTEFZQkFDS0RWUlNUQVRFQ0hBTkdFRCwgdGhpcy5vbkRWUilcbiAgICB9XG4gICAgX2dhcS5wdXNoKFt0aGlzLnRyYWNrZXJOYW1lICsgJ19zZXRBY2NvdW50JywgdGhpcy5hY2NvdW50XSlcbiAgICBpZiAodGhpcy5kb21haW5OYW1lKVxuICAgICAgX2dhcS5wdXNoKFt0aGlzLnRyYWNrZXJOYW1lICsgJ19zZXREb21haW5OYW1lJywgdGhpcy5kb21haW5OYW1lXSlcbiAgfVxuXG4gIG9uUmVhZHkoKSB7XG4gICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnUGxheWJhY2snLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5uYW1lXSlcbiAgfVxuXG4gIG9uUGxheSgpIHtcbiAgICB0aGlzLnB1c2goWydWaWRlbycsICdQbGF5JywgdGhpcy5jb250YWluZXIucGxheWJhY2suc3JjXSlcbiAgfVxuXG4gIG9uU3RvcCgpIHtcbiAgICB0aGlzLnB1c2goWydWaWRlbycsICdTdG9wJywgdGhpcy5jb250YWluZXIucGxheWJhY2suc3JjXSlcbiAgfVxuXG4gIG9uRW5kZWQoKSB7XG4gICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnRW5kZWQnLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5zcmNdKVxuICB9XG5cbiAgb25CdWZmZXJpbmcoKSB7XG4gICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnQnVmZmVyaW5nJywgdGhpcy5jb250YWluZXIucGxheWJhY2suc3JjXSlcbiAgfVxuXG4gIG9uQnVmZmVyRnVsbCgpIHtcbiAgICB0aGlzLnB1c2goWydWaWRlbycsICdCdWZmZXJmdWxsJywgdGhpcy5jb250YWluZXIucGxheWJhY2suc3JjXSlcbiAgfVxuXG4gIG9uRXJyb3IoKSB7XG4gICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnRXJyb3InLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5zcmNdKVxuICB9XG5cbiAgb25IRChpc0hEKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gaXNIRCA/ICdPTic6ICdPRkYnXG4gICAgaWYgKHN0YXR1cyAhPT0gdGhpcy5jdXJyZW50SERTdGF0ZSkge1xuICAgICAgdGhpcy5jdXJyZW50SERTdGF0ZSA9IHN0YXR1c1xuICAgICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnSEQgLSAnICsgc3RhdHVzLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5zcmNdKVxuICAgIH1cbiAgfVxuXG4gIG9uUGxheWJhY2tDaGFuZ2VkKHBsYXliYWNrU3RhdGUpIHtcbiAgICBpZiAocGxheWJhY2tTdGF0ZS50eXBlICE9PSBudWxsKVxuICAgICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnUGxheWJhY2sgVHlwZSAtICcgKyBwbGF5YmFja1N0YXRlLnR5cGUsIHRoaXMuY29udGFpbmVyLnBsYXliYWNrLnNyY10pXG5cbiAgfVxuXG4gIG9uRFZSKGR2ckluVXNlKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gZHZySW5Vc2U/ICdPTic6ICdPRkYnXG4gICAgdGhpcy5wdXNoKFsnSW50ZXJhY3Rpb24nLCAnRFZSIC0gJyArIHN0YXR1cywgdGhpcy5jb250YWluZXIucGxheWJhY2suc3JjXSlcbiAgfVxuXG4gIG9uUGF1c2UoKSB7XG4gICAgdGhpcy5wdXNoKFsnVmlkZW8nLCAnUGF1c2UnLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5zcmNdKVxuICB9XG5cbiAgb25TZWVrKCkge1xuICAgIHRoaXMucHVzaChbJ1ZpZGVvJywgJ1NlZWsnLCB0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5zcmNdKVxuICB9XG5cbiAgb25Wb2x1bWVDaGFuZ2VkKCkge1xuICAgIHRoaXMucHVzaChbJ0ludGVyYWN0aW9uJywgJ1ZvbHVtZScsIHRoaXMuY29udGFpbmVyLnBsYXliYWNrLnNyY10pXG4gIH1cblxuICBvbkZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy5wdXNoKFsnSW50ZXJhY3Rpb24nLCAnRnVsbHNjcmVlbicsIHRoaXMuY29udGFpbmVyLnBsYXliYWNrLnNyY10pXG4gIH1cblxuXG4gIHB1c2goYXJyYXkpIHtcbiAgICBjb25zdCByZXMgPSBbdGhpcy50cmFja2VyTmFtZSArICdfdHJhY2tFdmVudCddLmNvbmNhdChhcnJheSlcbiAgICBfZ2FxLnB1c2gocmVzKVxuICB9XG5cbn1cbiIsImltcG9ydCBHb29nbGVBbmFseXRpY3MgZnJvbSAnLi9nb29nbGVfYW5hbHl0aWNzJ1xuZXhwb3J0IGRlZmF1bHQgR29vZ2xlQW5hbHl0aWNzXG4iLCJpbXBvcnQgTG9nIGZyb20gJy4vbG9nJ1xuZXhwb3J0IGRlZmF1bHQgTG9nXG4iLCJcbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCB7IEtpYm8gfSBmcm9tICcuLi8uLi92ZW5kb3InXG5cbmNvbnN0IEJPTEQgPSAnZm9udC13ZWlnaHQ6IGJvbGQ7IGZvbnQtc2l6ZTogMTNweDsnXG5jb25zdCBJTkZPID0gJ2NvbG9yOiAjMDA2NjAwOycgKyBCT0xEXG5jb25zdCBERUJVRyA9ICdjb2xvcjogIzAwMDBmZjsnICsgQk9MRFxuY29uc3QgV0FSTiA9ICdjb2xvcjogI2ZmODAwMDsnICsgQk9MRFxuY29uc3QgRVJST1IgPSAnY29sb3I6ICNmZjAwMDA7JyArIEJPTERcblxuY29uc3QgTEVWRUxfREVCVUcgPSAwXG5jb25zdCBMRVZFTF9JTkZPID0gMVxuY29uc3QgTEVWRUxfV0FSTiA9IDJcbmNvbnN0IExFVkVMX0VSUk9SID0gM1xuY29uc3QgTEVWRUxfRElTQUJMRUQgPSBMRVZFTF9FUlJPUlxuXG5jb25zdCBDT0xPUlMgPSBbREVCVUcsIElORk8sIFdBUk4sIEVSUk9SLCBFUlJPUl1cbmNvbnN0IERFU0NSSVBUSU9OUyA9IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJywgJ2Rpc2FibGVkJ11cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nIHtcbiAgY29uc3RydWN0b3IobGV2ZWwgPSBMRVZFTF9JTkZPLCBvZmZMZXZlbCA9IExFVkVMX0RJU0FCTEVEKSB7XG4gICAgdGhpcy5raWJvID0gbmV3IEtpYm8oKVxuICAgIHRoaXMua2liby5kb3duKFsnY3RybCBzaGlmdCBkJ10sICgpID0+IHRoaXMub25PZmYoKSlcbiAgICB0aGlzLkJMQUNLTElTVCA9IFsndGltZXVwZGF0ZScsICdwbGF5YmFjazp0aW1ldXBkYXRlJywgJ3BsYXliYWNrOnByb2dyZXNzJywgJ2NvbnRhaW5lcjpob3ZlcicsICdjb250YWluZXI6dGltZXVwZGF0ZScsICdjb250YWluZXI6cHJvZ3Jlc3MnXVxuICAgIHRoaXMubGV2ZWwgPSBsZXZlbFxuICAgIHRoaXMub2ZmTGV2ZWwgPSBvZmZMZXZlbFxuICB9XG5cbiAgZGVidWcoa2xhc3MpIHsgdGhpcy5sb2coa2xhc3MsIExFVkVMX0RFQlVHLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSB9XG4gIGluZm8oa2xhc3MpIHsgdGhpcy5sb2coa2xhc3MsIExFVkVMX0lORk8sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpIH1cbiAgd2FybihrbGFzcykgeyB0aGlzLmxvZyhrbGFzcywgTEVWRUxfV0FSTiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkgfVxuICBlcnJvcihrbGFzcykgeyB0aGlzLmxvZyhrbGFzcywgTEVWRUxfRVJST1IsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpIH1cblxuICBvbk9mZigpIHtcbiAgICBpZiAodGhpcy5sZXZlbCA9PT0gdGhpcy5vZmZMZXZlbCkgeyB0aGlzLmxldmVsID0gdGhpcy5wcmV2aW91c0xldmVsIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXZpb3VzTGV2ZWwgPSB0aGlzLmxldmVsXG4gICAgICB0aGlzLmxldmVsID0gdGhpcy5vZmZMZXZlbFxuICAgIH1cbiAgICAvLyBoYW5kbGUgaW5zdGFuY2VzIHdoZXJlIGNvbnNvbGUubG9nIGlzIHVuYXZhaWxhYmxlXG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZylcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZygnJWNbQ2xhcHByLkxvZ10gc2V0IGxvZyBsZXZlbCB0byAnICsgREVTQ1JJUFRJT05TW3RoaXMubGV2ZWxdLCBXQVJOKVxuXG4gIH1cblxuICBsZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbFxuICB9XG5cbiAgbG9nKGtsYXNzLCBsZXZlbCwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLkJMQUNLTElTVC5pbmRleE9mKG1lc3NhZ2VbMF0pID49IDApIHJldHVyblxuICAgIGlmIChsZXZlbCA8IHRoaXMubGV2ZWwpIHJldHVyblxuXG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0ga2xhc3NcbiAgICAgIGtsYXNzID0gbnVsbFxuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IENPTE9SU1tsZXZlbF1cbiAgICBsZXQga2xhc3NEZXNjcmlwdGlvbiA9ICcnXG4gICAgaWYgKGtsYXNzKVxuICAgICAga2xhc3NEZXNjcmlwdGlvbiA9ICdbJyArIGtsYXNzICsgJ10nXG5cbiAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKVxuICAgICAgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnJWNbJyArIERFU0NSSVBUSU9OU1tsZXZlbF0gKyAnXScgKyBrbGFzc0Rlc2NyaXB0aW9uLCBjb2xvcl0uY29uY2F0KG1lc3NhZ2UpKVxuXG4gIH1cbn1cblxuTG9nLkxFVkVMX0RFQlVHID0gTEVWRUxfREVCVUdcbkxvZy5MRVZFTF9JTkZPID0gTEVWRUxfSU5GT1xuTG9nLkxFVkVMX1dBUk4gPSBMRVZFTF9XQVJOXG5Mb2cuTEVWRUxfRVJST1IgPSBMRVZFTF9FUlJPUlxuXG5Mb2cuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2luc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyB0aGlzKClcbiAgICB0aGlzLl9pbnN0YW5jZS5wcmV2aW91c0xldmVsID0gdGhpcy5faW5zdGFuY2UubGV2ZWxcbiAgICB0aGlzLl9pbnN0YW5jZS5sZXZlbCA9IHRoaXMuX2luc3RhbmNlLm9mZkxldmVsXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2luc3RhbmNlXG59XG5cbkxvZy5zZXRMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7IHRoaXMuZ2V0SW5zdGFuY2UoKS5sZXZlbCA9IGxldmVsIH1cblxuTG9nLmRlYnVnID0gZnVuY3Rpb24oKSB7IHRoaXMuZ2V0SW5zdGFuY2UoKS5kZWJ1Zy5hcHBseSh0aGlzLmdldEluc3RhbmNlKCksIGFyZ3VtZW50cykgfVxuTG9nLmluZm8gPSBmdW5jdGlvbigpIHsgdGhpcy5nZXRJbnN0YW5jZSgpLmluZm8uYXBwbHkodGhpcy5nZXRJbnN0YW5jZSgpLCBhcmd1bWVudHMpIH1cbkxvZy53YXJuID0gZnVuY3Rpb24oKSB7IHRoaXMuZ2V0SW5zdGFuY2UoKS53YXJuLmFwcGx5KHRoaXMuZ2V0SW5zdGFuY2UoKSwgYXJndW1lbnRzKSB9XG5Mb2cuZXJyb3IgPSBmdW5jdGlvbigpIHsgdGhpcy5nZXRJbnN0YW5jZSgpLmVycm9yLmFwcGx5KHRoaXMuZ2V0SW5zdGFuY2UoKSwgYXJndW1lbnRzKSB9XG4iLCJpbXBvcnQgTWVkaWFDb250cm9sIGZyb20gJy4vbWVkaWFfY29udHJvbCdcbmV4cG9ydCBkZWZhdWx0IE1lZGlhQ29udHJvbFxuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuLyoqXG4gKiBUaGUgTWVkaWFDb250cm9sIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwbGF5aW5nIHRoZSBQbGF5ZXIgY29udHJvbHMuXG4gKi9cblxuaW1wb3J0IHsgQ29uZmlnLCBGdWxsc2NyZWVuLCBmb3JtYXRUaW1lLCBleHRlbmQsIHJlbW92ZUFycmF5SXRlbSB9IGZyb20gJy4uLy4uL2Jhc2UvdXRpbHMnXG5pbXBvcnQgeyBLaWJvIH0gZnJvbSAnLi4vLi4vdmVuZG9yJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCBVSUNvcmVQbHVnaW4gZnJvbSAnLi4vLi4vYmFzZS91aV9jb3JlX3BsdWdpbidcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvYnJvd3NlcidcbmltcG9ydCBNZWRpYXRvciBmcm9tICcuLi8uLi9jb21wb25lbnRzL21lZGlhdG9yJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL2Jhc2UvdGVtcGxhdGUnXG5pbXBvcnQgUGxheWJhY2sgZnJvbSAnLi4vLi4vYmFzZS9wbGF5YmFjaydcbmltcG9ydCAkIGZyb20gJ2NsYXBwci16ZXB0bydcbmltcG9ydCAnLi9wdWJsaWMvbWVkaWEtY29udHJvbC5zY3NzJ1xuaW1wb3J0IG1lZGlhQ29udHJvbEhUTUwgZnJvbSAnLi9wdWJsaWMvbWVkaWEtY29udHJvbC5odG1sJ1xuaW1wb3J0IHsgU3ZnSWNvbnMgfSBmcm9tICcuLi8uLi9iYXNlL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWRpYUNvbnRyb2wgZXh0ZW5kcyBVSUNvcmVQbHVnaW4ge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdtZWRpYV9jb250cm9sJyB9XG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICBsZXQgcGxheWJhY2tJc05PT1AgPSB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5nZXRQbGF5YmFja1R5cGUoKSA9PT0gUGxheWJhY2suTk9fT1BcbiAgICByZXR1cm4gdGhpcy51c2VyRGlzYWJsZWQgfHwgcGxheWJhY2tJc05PT1BcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7IHJldHVybiB0aGlzLmNvcmUgJiYgdGhpcy5jb3JlLmFjdGl2ZUNvbnRhaW5lciB9XG5cbiAgZ2V0IHBsYXliYWNrKCkgeyByZXR1cm4gdGhpcy5jb3JlICYmIHRoaXMuY29yZS5hY3RpdmVQbGF5YmFjayB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjbGFzcyc6ICdtZWRpYS1jb250cm9sJyxcbiAgICAgICdkYXRhLW1lZGlhLWNvbnRyb2wnOiAnJ1xuICAgIH1cbiAgfVxuXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjbGljayBbZGF0YS1wbGF5XSc6ICdwbGF5JyxcbiAgICAgICdjbGljayBbZGF0YS1wYXVzZV0nOiAncGF1c2UnLFxuICAgICAgJ2NsaWNrIFtkYXRhLXBsYXlwYXVzZV0nOiAndG9nZ2xlUGxheVBhdXNlJyxcbiAgICAgICdjbGljayBbZGF0YS1zdG9wXSc6ICdzdG9wJyxcbiAgICAgICdjbGljayBbZGF0YS1wbGF5c3RvcF0nOiAndG9nZ2xlUGxheVN0b3AnLFxuICAgICAgJ2NsaWNrIFtkYXRhLWZ1bGxzY3JlZW5dJzogJ3RvZ2dsZUZ1bGxzY3JlZW4nLFxuICAgICAgJ2NsaWNrIC5iYXItY29udGFpbmVyW2RhdGEtc2Vla2Jhcl0nOiAnc2VlaycsXG4gICAgICAnY2xpY2sgLmJhci1jb250YWluZXJbZGF0YS12b2x1bWVdJzogJ29uVm9sdW1lQ2xpY2snLFxuICAgICAgJ2NsaWNrIC5kcmF3ZXItaWNvbltkYXRhLXZvbHVtZV0nOiAndG9nZ2xlTXV0ZScsXG4gICAgICAnbW91c2VlbnRlciAuZHJhd2VyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nOiAnc2hvd1ZvbHVtZUJhcicsXG4gICAgICAnbW91c2VsZWF2ZSAuZHJhd2VyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nOiAnaGlkZVZvbHVtZUJhcicsXG4gICAgICAnbW91c2Vkb3duIC5iYXItY29udGFpbmVyW2RhdGEtdm9sdW1lXSc6ICdzdGFydFZvbHVtZURyYWcnLFxuICAgICAgJ3RvdWNoZW5kIC5iYXItY29udGFpbmVyW2RhdGEtdm9sdW1lXSc6ICdzdGFydFZvbHVtZURyYWcnLFxuICAgICAgJ21vdXNlbW92ZSAuYmFyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nOiAnbW91c2Vtb3ZlT25Wb2x1bWVCYXInLFxuICAgICAgJ3RvdWNobW92ZSAuYmFyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nOiAnbW91c2Vtb3ZlT25Wb2x1bWVCYXInLFxuICAgICAgJ21vdXNlZG93biAuYmFyLXNjcnViYmVyW2RhdGEtc2Vla2Jhcl0nOiAnc3RhcnRTZWVrRHJhZycsXG4gICAgICAndG91Y2hzdGFydCAuYmFyLXNjcnViYmVyW2RhdGEtc2Vla2Jhcl0nOiAnc3RhcnRTZWVrRHJhZycsXG4gICAgICAnbW91c2Vtb3ZlIC5iYXItY29udGFpbmVyW2RhdGEtc2Vla2Jhcl0nOiAnbW91c2Vtb3ZlT25TZWVrQmFyJyxcbiAgICAgICd0b3VjaG1vdmUgLmJhci1jb250YWluZXJbZGF0YS1zZWVrYmFyXSc6ICdtb3VzZW1vdmVPblNlZWtCYXInLFxuICAgICAgJ21vdXNlbGVhdmUgLmJhci1jb250YWluZXJbZGF0YS1zZWVrYmFyXSc6ICdtb3VzZWxlYXZlT25TZWVrQmFyJyxcbiAgICAgICdtb3VzZWVudGVyIC5tZWRpYS1jb250cm9sLWxheWVyW2RhdGEtY29udHJvbHNdJzogJ3NldFVzZXJLZWVwVmlzaWJsZScsXG4gICAgICAnbW91c2VsZWF2ZSAubWVkaWEtY29udHJvbC1sYXllcltkYXRhLWNvbnRyb2xzXSc6ICdyZXNldFVzZXJLZWVwVmlzaWJsZSdcbiAgICB9XG4gIH1cblxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZShtZWRpYUNvbnRyb2xIVE1MKSB9XG5cbiAgZ2V0IHZvbHVtZSgpIHsgcmV0dXJuICh0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5pc1JlYWR5KSA/IHRoaXMuY29udGFpbmVyLnZvbHVtZSA6IHRoaXMuaW50ZW5kZWRWb2x1bWUgfVxuICBnZXQgbXV0ZWQoKSB7IHJldHVybiB0aGlzLnZvbHVtZSA9PT0gMCB9XG5cbiAgY29uc3RydWN0b3IoY29yZSkge1xuICAgIHN1cGVyKGNvcmUpXG4gICAgdGhpcy5wZXJzaXN0Q29uZmlnID0gdGhpcy5vcHRpb25zLnBlcnNpc3RDb25maWdcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvblZhbHVlID0gbnVsbFxuICAgIHRoaXMuY3VycmVudER1cmF0aW9uVmFsdWUgPSBudWxsXG4gICAgdGhpcy5rZWVwVmlzaWJsZSA9IGZhbHNlXG4gICAgdGhpcy5mdWxsU2NyZWVuT25WaWRlb1RhZ1N1cHBvcnRlZCA9IG51bGwgLy8gdW5rbm93blxuICAgIHRoaXMuc2V0SW5pdGlhbFZvbHVtZSgpXG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIGxlZnQ6IFsncGxheScsICdzdG9wJywgJ3BhdXNlJ10sXG4gICAgICByaWdodDogWyd2b2x1bWUnXSxcbiAgICAgIGRlZmF1bHQ6IFsncG9zaXRpb24nLCAnc2Vla2JhcicsICdkdXJhdGlvbiddXG4gICAgfVxuICAgIHRoaXMua2libyA9IG5ldyBLaWJvKHRoaXMub3B0aW9ucy5mb2N1c0VsZW1lbnQpXG4gICAgdGhpcy5iaW5kS2V5RXZlbnRzKClcblxuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QodGhpcy5jb250YWluZXIuc2V0dGluZ3MpKVxuICAgICAgICB0aGlzLnNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMuY29udGFpbmVyLnNldHRpbmdzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnVzZXJEaXNhYmxlZCA9IGZhbHNlXG4gICAgaWYgKCh0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5tZWRpYUNvbnRyb2xEaXNhYmxlZCkgfHwgdGhpcy5vcHRpb25zLmNocm9tZWxlc3MpXG4gICAgICB0aGlzLmRpc2FibGUoKVxuXG4gICAgdGhpcy5zdG9wRHJhZ0hhbmRsZXIgPSAoZXZlbnQpID0+IHRoaXMuc3RvcERyYWcoZXZlbnQpXG4gICAgdGhpcy51cGRhdGVEcmFnSGFuZGxlciA9IChldmVudCkgPT4gdGhpcy51cGRhdGVEcmFnKGV2ZW50KVxuICAgICQoZG9jdW1lbnQpLmJpbmQoJ21vdXNldXAnLCB0aGlzLnN0b3BEcmFnSGFuZGxlcilcbiAgICAkKGRvY3VtZW50KS5iaW5kKCdtb3VzZW1vdmUnLCB0aGlzLnVwZGF0ZURyYWdIYW5kbGVyKVxuICB9XG5cbiAgZ2V0RXh0ZXJuYWxJbnRlcmZhY2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFZvbHVtZTogdGhpcy5zZXRWb2x1bWUsXG4gICAgICBnZXRWb2x1bWU6ICgpID0+IHRoaXMudm9sdW1lLFxuICAgIH1cbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfQUNUSVZFX0NPTlRBSU5FUl9DSEFOR0VELCB0aGlzLm9uQWN0aXZlQ29udGFpbmVyQ2hhbmdlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29yZSwgRXZlbnRzLkNPUkVfTU9VU0VfTU9WRSwgdGhpcy5zaG93KVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuQ09SRV9NT1VTRV9MRUFWRSwgKCkgPT4gdGhpcy5oaWRlKHRoaXMub3B0aW9ucy5oaWRlTWVkaWFDb250cm9sRGVsYXkpKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb3JlLCBFdmVudHMuQ09SRV9GVUxMU0NSRUVOLCB0aGlzLnNob3cpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX09QVElPTlNfQ0hBTkdFLCB0aGlzLmNvbmZpZ3VyZSlcbiAgICBNZWRpYXRvci5vbihgJHt0aGlzLm9wdGlvbnMucGxheWVySWR9OiR7RXZlbnRzLlBMQVlFUl9SRVNJWkV9YCwgdGhpcy5wbGF5ZXJSZXNpemUsIHRoaXMpXG4gICAgdGhpcy5iaW5kQ29udGFpbmVyRXZlbnRzKClcbiAgfVxuXG4gIGJpbmRDb250YWluZXJFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikgcmV0dXJuXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QTEFZLCB0aGlzLmNoYW5nZVRvZ2dsZVBsYXkpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QQVVTRSwgdGhpcy5jaGFuZ2VUb2dnbGVQbGF5KVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfU1RPUCwgdGhpcy5jaGFuZ2VUb2dnbGVQbGF5KVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfREJMQ0xJQ0ssIHRoaXMudG9nZ2xlRnVsbHNjcmVlbilcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1RJTUVVUERBVEUsIHRoaXMub25UaW1lVXBkYXRlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfUFJPR1JFU1MsIHRoaXMudXBkYXRlUHJvZ3Jlc3NCYXIpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TRVRUSU5HU1VQREFURSwgdGhpcy5zZXR0aW5nc1VwZGF0ZSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1BMQVlCQUNLRFZSU1RBVEVDSEFOR0VELCB0aGlzLnNldHRpbmdzVXBkYXRlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfSElHSERFRklOSVRJT05VUERBVEUsIHRoaXMuaGlnaERlZmluaXRpb25VcGRhdGUpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9NRURJQUNPTlRST0xfRElTQUJMRSwgdGhpcy5kaXNhYmxlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfTUVESUFDT05UUk9MX0VOQUJMRSwgdGhpcy5lbmFibGUpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9FTkRFRCwgdGhpcy5lbmRlZClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1ZPTFVNRSwgdGhpcy5vblZvbHVtZUNoYW5nZWQpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9PUFRJT05TX0NIQU5HRSwgdGhpcy5zZXRJbml0aWFsVm9sdW1lKVxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5lbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nKSB7XG4gICAgICAvLyB3YWl0IHVudGlsIHRoZSBtZXRhZGF0YSBoYXMgbG9hZGVkIGFuZCB0aGVuIGNoZWNrIGlmIGZ1bGxzY3JlZW4gb24gdmlkZW8gdGFnIGlzIHN1cHBvcnRlZFxuICAgICAgdGhpcy5saXN0ZW5Ub09uY2UodGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfTE9BREVETUVUQURBVEEsIHRoaXMub25Mb2FkZWRNZXRhZGF0YU9uVmlkZW9UYWcpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLnVzZXJEaXNhYmxlZCA9IHRydWVcbiAgICB0aGlzLmhpZGUoKVxuICAgIHRoaXMudW5iaW5kS2V5RXZlbnRzKClcbiAgICB0aGlzLiRlbC5oaWRlKClcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNocm9tZWxlc3MpIHJldHVyblxuICAgIHRoaXMudXNlckRpc2FibGVkID0gZmFsc2VcbiAgICB0aGlzLmJpbmRLZXlFdmVudHMoKVxuICAgIHRoaXMuc2hvdygpXG4gIH1cblxuICBwbGF5KCkge1xuICAgIHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLnBsYXkoKVxuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIucGF1c2UoKVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5zdG9wKClcbiAgfVxuXG4gIHNldEluaXRpYWxWb2x1bWUoKSB7XG4gICAgY29uc3QgaW5pdGlhbFZvbHVtZSA9ICh0aGlzLnBlcnNpc3RDb25maWcpID8gQ29uZmlnLnJlc3RvcmUoJ3ZvbHVtZScpIDogMTAwXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLm9wdGlvbnMgfHwgdGhpcy5vcHRpb25zXG4gICAgdGhpcy5zZXRWb2x1bWUob3B0aW9ucy5tdXRlID8gMCA6IGluaXRpYWxWb2x1bWUsIHRydWUpXG4gIH1cblxuICBvblZvbHVtZUNoYW5nZWQoKSB7XG4gICAgdGhpcy51cGRhdGVWb2x1bWVVSSgpXG4gIH1cblxuICBvbkxvYWRlZE1ldGFkYXRhT25WaWRlb1RhZygpIHtcbiAgICBsZXQgdmlkZW8gPSB0aGlzLnBsYXliYWNrICYmIHRoaXMucGxheWJhY2suZWxcbiAgICAvLyB2aWRlby53ZWJraXRTdXBwb3J0c0Z1bGxzY3JlZW4gaXMgZGVwcmVjYXRlZCBidXQgaU9TIGFwcGVhcnMgdG8gb25seSB1c2UgdGhpc1xuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xhcHByL2NsYXBwci9pc3N1ZXMvMTEyN1xuICAgIGlmICghRnVsbHNjcmVlbi5mdWxsc2NyZWVuRW5hYmxlZCgpICYmIHZpZGVvLndlYmtpdFN1cHBvcnRzRnVsbHNjcmVlbikge1xuICAgICAgdGhpcy5mdWxsU2NyZWVuT25WaWRlb1RhZ1N1cHBvcnRlZCA9IHRydWVcbiAgICAgIHRoaXMuc2V0dGluZ3NVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVZvbHVtZVVJKCkge1xuICAgIC8vIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSByZW5kZXJcbiAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHJldHVyblxuXG4gICAgLy8gdXBkYXRlIHZvbHVtZSBiYXIgc2NydWJiZXIvZmlsbCBvbiBiYXIgbW9kZVxuICAgIHRoaXMuJHZvbHVtZUJhckNvbnRhaW5lci5maW5kKCcuYmFyLWZpbGwtMicpLmNzcyh7fSlcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IHRoaXMuJHZvbHVtZUJhckNvbnRhaW5lci53aWR0aCgpXG4gICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLiR2b2x1bWVCYXJCYWNrZ3JvdW5kLndpZHRoKClcbiAgICBjb25zdCBvZmZzZXQgPSAoY29udGFpbmVyV2lkdGggLSBiYXJXaWR0aCkgLyAyLjBcbiAgICBjb25zdCBwb3MgPSBiYXJXaWR0aCAqIHRoaXMudm9sdW1lIC8gMTAwLjAgKyBvZmZzZXRcbiAgICB0aGlzLiR2b2x1bWVCYXJGaWxsLmNzcyh7IHdpZHRoOiBgJHt0aGlzLnZvbHVtZX0lYCB9KVxuICAgIHRoaXMuJHZvbHVtZUJhclNjcnViYmVyLmNzcyh7IGxlZnQ6IHBvcyB9KVxuXG4gICAgLy8gdXBkYXRlIHZvbHVtZSBiYXIgc2VnbWVudHMgb24gc2VnbWVudGVkIGJhciBtb2RlXG4gICAgdGhpcy4kdm9sdW1lQmFyQ29udGFpbmVyLmZpbmQoJy5zZWdtZW50ZWQtYmFyLWVsZW1lbnQnKS5yZW1vdmVDbGFzcygnZmlsbCcpXG4gICAgY29uc3QgaXRlbSA9IE1hdGguY2VpbCh0aGlzLnZvbHVtZSAvIDEwLjApXG4gICAgdGhpcy4kdm9sdW1lQmFyQ29udGFpbmVyLmZpbmQoJy5zZWdtZW50ZWQtYmFyLWVsZW1lbnQnKS5zbGljZSgwLCBpdGVtKS5hZGRDbGFzcygnZmlsbCcpXG4gICAgdGhpcy4kdm9sdW1lSWNvbi5odG1sKCcnKVxuICAgIHRoaXMuJHZvbHVtZUljb24ucmVtb3ZlQ2xhc3MoJ211dGVkJylcbiAgICBpZiAoIXRoaXMubXV0ZWQpIHtcbiAgICAgIHRoaXMuJHZvbHVtZUljb24uYXBwZW5kKFN2Z0ljb25zLnZvbHVtZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kdm9sdW1lSWNvbi5hcHBlbmQoU3ZnSWNvbnMudm9sdW1lTXV0ZSlcbiAgICAgIHRoaXMuJHZvbHVtZUljb24uYWRkQ2xhc3MoJ211dGVkJylcbiAgICB9XG4gICAgdGhpcy5hcHBseUJ1dHRvblN0eWxlKHRoaXMuJHZvbHVtZUljb24pXG4gIH1cblxuICBjaGFuZ2VUb2dnbGVQbGF5KCkge1xuICAgIHRoaXMuJHBsYXlQYXVzZVRvZ2dsZS5odG1sKCcnKVxuICAgIHRoaXMuJHBsYXlTdG9wVG9nZ2xlLmh0bWwoJycpXG4gICAgaWYgKHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLmlzUGxheWluZygpKSB7XG4gICAgICB0aGlzLiRwbGF5UGF1c2VUb2dnbGUuYXBwZW5kKFN2Z0ljb25zLnBhdXNlKVxuICAgICAgdGhpcy4kcGxheVN0b3BUb2dnbGUuYXBwZW5kKFN2Z0ljb25zLnN0b3ApXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBQ09OVFJPTF9QTEFZSU5HKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRwbGF5UGF1c2VUb2dnbGUuYXBwZW5kKFN2Z0ljb25zLnBsYXkpXG4gICAgICB0aGlzLiRwbGF5U3RvcFRvZ2dsZS5hcHBlbmQoU3ZnSWNvbnMucGxheSlcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFDT05UUk9MX05PVFBMQVlJTkcpXG4gICAgICBCcm93c2VyLmlzTW9iaWxlICYmIHRoaXMuc2hvdygpXG4gICAgfVxuICAgIHRoaXMuYXBwbHlCdXR0b25TdHlsZSh0aGlzLiRwbGF5UGF1c2VUb2dnbGUpXG4gICAgdGhpcy5hcHBseUJ1dHRvblN0eWxlKHRoaXMuJHBsYXlTdG9wVG9nZ2xlKVxuICB9XG5cbiAgbW91c2Vtb3ZlT25TZWVrQmFyKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc2Vla0VuYWJsZWQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5wYWdlWCAtIHRoaXMuJHNlZWtCYXJDb250YWluZXIub2Zmc2V0KCkubGVmdCAtICh0aGlzLiRzZWVrQmFySG92ZXIud2lkdGgoKSAvIDIpXG4gICAgICB0aGlzLiRzZWVrQmFySG92ZXIuY3NzKHsgbGVmdDogb2Zmc2V0WCB9KVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBQ09OVFJPTF9NT1VTRU1PVkVfU0VFS0JBUiwgZXZlbnQpXG4gIH1cblxuICBtb3VzZWxlYXZlT25TZWVrQmFyKGV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQUNPTlRST0xfTU9VU0VMRUFWRV9TRUVLQkFSLCBldmVudClcbiAgfVxuXG4gIG9uVm9sdW1lQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmdldFZvbHVtZUZyb21VSUV2ZW50KGV2ZW50KSlcbiAgfVxuXG4gIG1vdXNlbW92ZU9uVm9sdW1lQmFyKGV2ZW50KSB7XG4gICAgdGhpcy5kcmFnZ2luZ1ZvbHVtZUJhciAmJiB0aGlzLnNldFZvbHVtZSh0aGlzLmdldFZvbHVtZUZyb21VSUV2ZW50KGV2ZW50KSlcbiAgfVxuXG4gIHBsYXllclJlc2l6ZShzaXplKSB7XG4gICAgdGhpcy4kZnVsbHNjcmVlblRvZ2dsZS5odG1sKCcnKVxuICAgIGxldCBpY29uID0gdGhpcy5jb3JlLmlzRnVsbHNjcmVlbigpID8gU3ZnSWNvbnMuZXhpdEZ1bGxzY3JlZW4gOiBTdmdJY29ucy5mdWxsc2NyZWVuXG4gICAgdGhpcy4kZnVsbHNjcmVlblRvZ2dsZS5hcHBlbmQoaWNvbilcbiAgICB0aGlzLmFwcGx5QnV0dG9uU3R5bGUodGhpcy4kZnVsbHNjcmVlblRvZ2dsZSlcbiAgICB0aGlzLiRlbC5maW5kKCcubWVkaWEtY29udHJvbCcpLmxlbmd0aCAhPT0gMCAmJiB0aGlzLiRlbC5yZW1vdmVDbGFzcygndzMyMCcpXG4gICAgaWYgKHNpemUud2lkdGggPD0gMzIwIHx8IHRoaXMub3B0aW9ucy5oaWRlVm9sdW1lQmFyKSB0aGlzLiRlbC5hZGRDbGFzcygndzMyMCcpXG4gIH1cblxuICB0b2dnbGVQbGF5UGF1c2UoKSB7XG4gICAgdGhpcy5jb250YWluZXIuaXNQbGF5aW5nKCkgPyB0aGlzLmNvbnRhaW5lci5wYXVzZSgpIDogdGhpcy5jb250YWluZXIucGxheSgpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0b2dnbGVQbGF5U3RvcCgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5pc1BsYXlpbmcoKSA/IHRoaXMuY29udGFpbmVyLnN0b3AoKSA6IHRoaXMuY29udGFpbmVyLnBsYXkoKVxuICB9XG5cbiAgc3RhcnRTZWVrRHJhZyhldmVudCkge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zZWVrRW5hYmxlZCkgcmV0dXJuXG4gICAgdGhpcy5kcmFnZ2luZ1NlZWtCYXIgPSB0cnVlXG4gICAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2RyYWdnaW5nJylcbiAgICB0aGlzLiRzZWVrQmFyTG9hZGVkLmFkZENsYXNzKCdtZWRpYS1jb250cm9sLW5vdHJhbnNpdGlvbicpXG4gICAgdGhpcy4kc2Vla0JhclBvc2l0aW9uLmFkZENsYXNzKCdtZWRpYS1jb250cm9sLW5vdHJhbnNpdGlvbicpXG4gICAgdGhpcy4kc2Vla0JhclNjcnViYmVyLmFkZENsYXNzKCdtZWRpYS1jb250cm9sLW5vdHJhbnNpdGlvbicpXG4gICAgZXZlbnQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgc3RhcnRWb2x1bWVEcmFnKGV2ZW50KSB7XG4gICAgdGhpcy5kcmFnZ2luZ1ZvbHVtZUJhciA9IHRydWVcbiAgICB0aGlzLiRlbC5hZGRDbGFzcygnZHJhZ2dpbmcnKVxuICAgIGV2ZW50ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIHN0b3BEcmFnKGV2ZW50KSB7XG4gICAgdGhpcy5kcmFnZ2luZ1NlZWtCYXIgJiYgdGhpcy5zZWVrKGV2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKCdkcmFnZ2luZycpXG4gICAgdGhpcy4kc2Vla0JhckxvYWRlZC5yZW1vdmVDbGFzcygnbWVkaWEtY29udHJvbC1ub3RyYW5zaXRpb24nKVxuICAgIHRoaXMuJHNlZWtCYXJQb3NpdGlvbi5yZW1vdmVDbGFzcygnbWVkaWEtY29udHJvbC1ub3RyYW5zaXRpb24nKVxuICAgIHRoaXMuJHNlZWtCYXJTY3J1YmJlci5yZW1vdmVDbGFzcygnbWVkaWEtY29udHJvbC1ub3RyYW5zaXRpb24gZHJhZ2dpbmcnKVxuICAgIHRoaXMuZHJhZ2dpbmdTZWVrQmFyID0gZmFsc2VcbiAgICB0aGlzLmRyYWdnaW5nVm9sdW1lQmFyID0gZmFsc2VcbiAgfVxuXG4gIHVwZGF0ZURyYWcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kcmFnZ2luZ1NlZWtCYXIpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5wYWdlWCAtIHRoaXMuJHNlZWtCYXJDb250YWluZXIub2Zmc2V0KCkubGVmdFxuICAgICAgbGV0IHBvcyA9IG9mZnNldFggLyB0aGlzLiRzZWVrQmFyQ29udGFpbmVyLndpZHRoKCkgKiAxMDBcbiAgICAgIHBvcyA9IE1hdGgubWluKDEwMCwgTWF0aC5tYXgocG9zLCAwKSlcbiAgICAgIHRoaXMuc2V0U2Vla1BlcmNlbnRhZ2UocG9zKVxuICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZ1ZvbHVtZUJhcikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5nZXRWb2x1bWVGcm9tVUlFdmVudChldmVudCkpXG4gICAgfVxuICB9XG5cbiAgZ2V0Vm9sdW1lRnJvbVVJRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQucGFnZVggLSB0aGlzLiR2b2x1bWVCYXJDb250YWluZXIub2Zmc2V0KCkubGVmdFxuICAgIGNvbnN0IHZvbHVtZUZyb21VSSA9IChvZmZzZXRZIC8gdGhpcy4kdm9sdW1lQmFyQ29udGFpbmVyLndpZHRoKCkpICogMTAwXG4gICAgcmV0dXJuIHZvbHVtZUZyb21VSVxuICB9XG5cbiAgdG9nZ2xlTXV0ZSgpIHtcbiAgICBpZiAodGhpcy5tdXRlZCkge1xuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5fbXV0ZWRWb2x1bWUgfHwgMTAwKVxuICAgICAgdGhpcy5fbXV0ZWRWb2x1bWUgPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9tdXRlZFZvbHVtZSA9IHRoaXMudm9sdW1lXG4gICAgdGhpcy5zZXRWb2x1bWUoMClcbiAgfVxuXG4gIHNldFZvbHVtZSh2YWx1ZSwgaXNJbml0aWFsVm9sdW1lID0gZmFsc2UpIHtcbiAgICB2YWx1ZSA9IE1hdGgubWluKDEwMCwgTWF0aC5tYXgodmFsdWUsIDApKVxuICAgIC8vIHRoaXMgd2lsbCBob2xkIHRoZSBpbnRlbmRlZCB2b2x1bWVcbiAgICAvLyBpdCBtYXkgbm90IGFjdHVhbGx5IGdldCBzZXQgdG8gdGhpcyBzdHJhaWdodCBhd2F5XG4gICAgLy8gaWYgdGhlIGNvbnRhaW5lciBpcyBub3QgcmVhZHkgZXRjXG4gICAgdGhpcy5pbnRlbmRlZFZvbHVtZSA9IHZhbHVlXG4gICAgdGhpcy5wZXJzaXN0Q29uZmlnICYmICFpc0luaXRpYWxWb2x1bWUgJiYgQ29uZmlnLnBlcnNpc3QoJ3ZvbHVtZScsIHZhbHVlKVxuICAgIGNvbnN0IHNldFdoZW5Db250YWluZXJSZWFkeSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5pc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNldFZvbHVtZSh2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG9PbmNlKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1JFQURZLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIuc2V0Vm9sdW1lKHZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250YWluZXIpXG4gICAgICB0aGlzLmxpc3RlblRvT25jZSh0aGlzLCBFdmVudHMuTUVESUFDT05UUk9MX0NPTlRBSU5FUkNIQU5HRUQsICgpID0+IHNldFdoZW5Db250YWluZXJSZWFkeSgpKVxuICAgIGVsc2VcbiAgICAgIHNldFdoZW5Db250YWluZXJSZWFkeSgpXG5cbiAgfVxuXG4gIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQUNPTlRST0xfRlVMTFNDUkVFTiwgdGhpcy5uYW1lKVxuICAgIHRoaXMuY29udGFpbmVyLmZ1bGxzY3JlZW4oKVxuICAgIHRoaXMuY29yZS50b2dnbGVGdWxsc2NyZWVuKClcbiAgICB0aGlzLnJlc2V0VXNlcktlZXBWaXNpYmxlKClcbiAgfVxuXG4gIG9uQWN0aXZlQ29udGFpbmVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmZ1bGxTY3JlZW5PblZpZGVvVGFnU3VwcG9ydGVkID0gbnVsbFxuICAgIE1lZGlhdG9yLm9mZihgJHt0aGlzLm9wdGlvbnMucGxheWVySWR9OiR7RXZlbnRzLlBMQVlFUl9SRVNJWkV9YCwgdGhpcy5wbGF5ZXJSZXNpemUsIHRoaXMpXG4gICAgdGhpcy5iaW5kRXZlbnRzKClcbiAgICAvLyBzZXQgdGhlIG5ldyBjb250YWluZXIgdG8gbWF0Y2ggdGhlIHZvbHVtZSBvZiB0aGUgbGFzdCBvbmVcbiAgICB0aGlzLnNldEluaXRpYWxWb2x1bWUoKVxuICAgIHRoaXMuY2hhbmdlVG9nZ2xlUGxheSgpXG4gICAgdGhpcy5iaW5kQ29udGFpbmVyRXZlbnRzKClcbiAgICB0aGlzLnNldHRpbmdzVXBkYXRlKClcbiAgICB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfUExBWUJBQ0tEVlJTVEFURUNIQU5HRUQsIHRoaXMuY29udGFpbmVyLmlzRHZySW5Vc2UoKSlcbiAgICB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5tZWRpYUNvbnRyb2xEaXNhYmxlZCAmJiB0aGlzLmRpc2FibGUoKVxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFDT05UUk9MX0NPTlRBSU5FUkNIQU5HRUQpXG4gIH1cblxuICBzaG93Vm9sdW1lQmFyKCkge1xuICAgIHRoaXMuaGlkZVZvbHVtZUlkICYmIGNsZWFyVGltZW91dCh0aGlzLmhpZGVWb2x1bWVJZClcbiAgICB0aGlzLiR2b2x1bWVCYXJDb250YWluZXIucmVtb3ZlQ2xhc3MoJ3ZvbHVtZS1iYXItaGlkZScpXG4gIH1cblxuICBoaWRlVm9sdW1lQmFyKHRpbWVvdXQgPSA0MDApIHtcbiAgICBpZiAoIXRoaXMuJHZvbHVtZUJhckNvbnRhaW5lcikgcmV0dXJuXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmdWb2x1bWVCYXIpIHtcbiAgICAgIHRoaXMuaGlkZVZvbHVtZUlkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGVWb2x1bWVCYXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlVm9sdW1lSWQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVZvbHVtZUlkKVxuICAgICAgdGhpcy5oaWRlVm9sdW1lSWQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuJHZvbHVtZUJhckNvbnRhaW5lci5hZGRDbGFzcygndm9sdW1lLWJhci1oaWRlJyksIHRpbWVvdXQpXG4gICAgfVxuICB9XG5cbiAgZW5kZWQoKSB7XG4gICAgdGhpcy5jaGFuZ2VUb2dnbGVQbGF5KClcbiAgfVxuXG4gIHVwZGF0ZVByb2dyZXNzQmFyKHByb2dyZXNzKSB7XG4gICAgY29uc3QgbG9hZGVkU3RhcnQgPSBwcm9ncmVzcy5zdGFydCAvIHByb2dyZXNzLnRvdGFsICogMTAwXG4gICAgY29uc3QgbG9hZGVkRW5kID0gcHJvZ3Jlc3MuY3VycmVudCAvIHByb2dyZXNzLnRvdGFsICogMTAwXG4gICAgdGhpcy4kc2Vla0JhckxvYWRlZC5jc3MoeyBsZWZ0OiBgJHtsb2FkZWRTdGFydH0lYCwgd2lkdGg6IGAke2xvYWRlZEVuZCAtIGxvYWRlZFN0YXJ0fSVgIH0pXG4gIH1cblxuICBvblRpbWVVcGRhdGUodGltZVByb2dyZXNzKSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmdTZWVrQmFyKSByZXR1cm5cbiAgICAvLyBUT0RPIHdoeSBzaG91bGQgY3VycmVudCB0aW1lIGV2ZXIgYmUgbmVnYXRpdmU/XG4gICAgY29uc3QgcG9zaXRpb24gPSAodGltZVByb2dyZXNzLmN1cnJlbnQgPCAwKSA/IHRpbWVQcm9ncmVzcy50b3RhbCA6IHRpbWVQcm9ncmVzcy5jdXJyZW50XG5cbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvblZhbHVlID0gcG9zaXRpb25cbiAgICB0aGlzLmN1cnJlbnREdXJhdGlvblZhbHVlID0gdGltZVByb2dyZXNzLnRvdGFsXG4gICAgdGhpcy5yZW5kZXJTZWVrQmFyKClcbiAgfVxuXG4gIHJlbmRlclNlZWtCYXIoKSB7XG4gICAgLy8gdGhpcyB3aWxsIGJlIHRyaWdnZXJlZCBhcyBzb29uIGFzIHRoZXNlIGJlY29tZSBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5jdXJyZW50UG9zaXRpb25WYWx1ZSA9PT0gbnVsbCB8fCB0aGlzLmN1cnJlbnREdXJhdGlvblZhbHVlID09PSBudWxsKSByZXR1cm5cblxuICAgIC8vIGRlZmF1bHQgdG8gMTAwJVxuICAgIHRoaXMuY3VycmVudFNlZWtCYXJQZXJjZW50YWdlID0gMTAwXG4gICAgaWYgKHRoaXMuY29udGFpbmVyICYmICh0aGlzLmNvbnRhaW5lci5nZXRQbGF5YmFja1R5cGUoKSAhPT0gUGxheWJhY2suTElWRSB8fCB0aGlzLmNvbnRhaW5lci5pc0R2ckluVXNlKCkpKVxuICAgICAgdGhpcy5jdXJyZW50U2Vla0JhclBlcmNlbnRhZ2UgPSAodGhpcy5jdXJyZW50UG9zaXRpb25WYWx1ZSAvIHRoaXMuY3VycmVudER1cmF0aW9uVmFsdWUpICogMTAwXG5cbiAgICB0aGlzLnNldFNlZWtQZXJjZW50YWdlKHRoaXMuY3VycmVudFNlZWtCYXJQZXJjZW50YWdlKVxuXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSBmb3JtYXRUaW1lKHRoaXMuY3VycmVudFBvc2l0aW9uVmFsdWUpXG4gICAgY29uc3QgbmV3RHVyYXRpb24gPSBmb3JtYXRUaW1lKHRoaXMuY3VycmVudER1cmF0aW9uVmFsdWUpXG4gICAgaWYgKG5ld1Bvc2l0aW9uICE9PSB0aGlzLmRpc3BsYXllZFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLiRwb3NpdGlvbi50ZXh0KG5ld1Bvc2l0aW9uKVxuICAgICAgdGhpcy5kaXNwbGF5ZWRQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uXG4gICAgfVxuICAgIGlmIChuZXdEdXJhdGlvbiAhPT0gdGhpcy5kaXNwbGF5ZWREdXJhdGlvbikge1xuICAgICAgdGhpcy4kZHVyYXRpb24udGV4dChuZXdEdXJhdGlvbilcbiAgICAgIHRoaXMuZGlzcGxheWVkRHVyYXRpb24gPSBuZXdEdXJhdGlvblxuICAgIH1cbiAgfVxuXG4gIHNlZWsoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2Vla0VuYWJsZWQpIHJldHVyblxuICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5wYWdlWCAtIHRoaXMuJHNlZWtCYXJDb250YWluZXIub2Zmc2V0KCkubGVmdFxuICAgIGxldCBwb3MgPSBvZmZzZXRYIC8gdGhpcy4kc2Vla0JhckNvbnRhaW5lci53aWR0aCgpICogMTAwXG4gICAgcG9zID0gTWF0aC5taW4oMTAwLCBNYXRoLm1heChwb3MsIDApKVxuICAgIHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLnNlZWtQZXJjZW50YWdlKHBvcylcbiAgICB0aGlzLnNldFNlZWtQZXJjZW50YWdlKHBvcylcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHNldEtlZXBWaXNpYmxlKCkge1xuICAgIHRoaXMua2VlcFZpc2libGUgPSB0cnVlXG4gIH1cblxuICByZXNldEtlZXBWaXNpYmxlKCkge1xuICAgIHRoaXMua2VlcFZpc2libGUgPSBmYWxzZVxuICB9XG5cbiAgc2V0VXNlcktlZXBWaXNpYmxlKCkge1xuICAgIHRoaXMudXNlcktlZXBWaXNpYmxlID0gdHJ1ZVxuICB9XG5cbiAgcmVzZXRVc2VyS2VlcFZpc2libGUoKSB7XG4gICAgdGhpcy51c2VyS2VlcFZpc2libGUgPSBmYWxzZVxuICB9XG5cbiAgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy4kZWwuaGFzQ2xhc3MoJ21lZGlhLWNvbnRyb2wtaGlkZScpXG4gIH1cblxuICBzaG93KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVyblxuXG4gICAgY29uc3QgdGltZW91dCA9IDIwMDBcbiAgICBsZXQgbW91c2VQb2ludGVyTW92ZWQgPSBldmVudCAmJiAoZXZlbnQuY2xpZW50WCAhPT0gdGhpcy5sYXN0TW91c2VYICYmIGV2ZW50LmNsaWVudFkgIT09IHRoaXMubGFzdE1vdXNlWSlcbiAgICBpZiAoIWV2ZW50IHx8IG1vdXNlUG9pbnRlck1vdmVkIHx8IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3gvaSkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZGVJZClcbiAgICAgIHRoaXMuJGVsLnNob3coKVxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQUNPTlRST0xfU0hPVywgdGhpcy5uYW1lKVxuICAgICAgdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIudHJpZ2dlcihFdmVudHMuQ09OVEFJTkVSX01FRElBQ09OVFJPTF9TSE9XLCB0aGlzLm5hbWUpXG4gICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnbWVkaWEtY29udHJvbC1oaWRlJylcbiAgICAgIHRoaXMuaGlkZUlkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGUoKSwgdGltZW91dClcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVggPSBldmVudC5jbGllbnRYXG4gICAgICAgIHRoaXMubGFzdE1vdXNlWSA9IGV2ZW50LmNsaWVudFlcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hvd2luZyA9IHRydWVcbiAgICB0aGlzLnVwZGF0ZUN1cnNvclN0eWxlKHNob3dpbmcpXG4gIH1cblxuICBoaWRlKGRlbGF5ID0gMCkge1xuICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSkgcmV0dXJuXG5cbiAgICBjb25zdCB0aW1lb3V0ID0gZGVsYXkgfHwgMjAwMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhpZGVJZClcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5vcHRpb25zLmhpZGVNZWRpYUNvbnRyb2wgPT09IGZhbHNlKSByZXR1cm5cblxuICAgIGxldCBoYXNLZWVwVmlzaWJsZVJlcXVlc3RlZCA9IHRoaXMudXNlcktlZXBWaXNpYmxlIHx8IHRoaXMua2VlcFZpc2libGVcbiAgICBsZXQgaGFzRHJhZ2dpbmdBY3Rpb24gPSB0aGlzLmRyYWdnaW5nU2Vla0JhciB8fCB0aGlzLmRyYWdnaW5nVm9sdW1lQmFyXG5cbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgKGRlbGF5IHx8IGhhc0tlZXBWaXNpYmxlUmVxdWVzdGVkIHx8IGhhc0RyYWdnaW5nQWN0aW9uKSkge1xuICAgICAgdGhpcy5oaWRlSWQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGlkZSgpLCB0aW1lb3V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLk1FRElBQ09OVFJPTF9ISURFLCB0aGlzLm5hbWUpXG4gICAgICB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50cmlnZ2VyKEV2ZW50cy5DT05UQUlORVJfTUVESUFDT05UUk9MX0hJREUsIHRoaXMubmFtZSlcbiAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdtZWRpYS1jb250cm9sLWhpZGUnKVxuICAgICAgdGhpcy5oaWRlVm9sdW1lQmFyKDApXG4gICAgICBjb25zdCBzaG93aW5nID0gZmFsc2VcbiAgICAgIHRoaXMudXBkYXRlQ3Vyc29yU3R5bGUoc2hvd2luZylcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDdXJzb3JTdHlsZShzaG93aW5nKSB7XG4gICAgaWYgKHNob3dpbmcpXG4gICAgICB0aGlzLmNvcmUuJGVsLnJlbW92ZUNsYXNzKCdub2N1cnNvcicpXG4gICAgZWxzZSBpZiAodGhpcy5jb3JlLmlzRnVsbHNjcmVlbigpKVxuICAgICAgdGhpcy5jb3JlLiRlbC5hZGRDbGFzcygnbm9jdXJzb3InKVxuICB9XG5cbiAgc2V0dGluZ3NVcGRhdGUoKSB7XG4gICAgY29uc3QgbmV3U2V0dGluZ3MgPSB0aGlzLmdldFNldHRpbmdzKClcbiAgICBpZiAobmV3U2V0dGluZ3MgJiYgIXRoaXMuZnVsbFNjcmVlbk9uVmlkZW9UYWdTdXBwb3J0ZWQgJiYgIUZ1bGxzY3JlZW4uZnVsbHNjcmVlbkVuYWJsZWQoKSkge1xuICAgICAgLy8gcmVtb3ZlIGZ1bGxzY3JlZW4gZnJvbSBzZXR0aW5ncyBpZiBpdCBpcyBwcmVzZW50XG4gICAgICBuZXdTZXR0aW5ncy5kZWZhdWx0ICYmIHJlbW92ZUFycmF5SXRlbShuZXdTZXR0aW5ncy5kZWZhdWx0LCAnZnVsbHNjcmVlbicpXG4gICAgICBuZXdTZXR0aW5ncy5sZWZ0ICYmIHJlbW92ZUFycmF5SXRlbShuZXdTZXR0aW5ncy5sZWZ0LCAnZnVsbHNjcmVlbicpXG4gICAgICBuZXdTZXR0aW5ncy5yaWdodCAmJiByZW1vdmVBcnJheUl0ZW0obmV3U2V0dGluZ3MucmlnaHQsICdmdWxsc2NyZWVuJylcbiAgICB9XG4gICAgY29uc3Qgc2V0dGluZ3NDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5zZXR0aW5ncykgIT09IEpTT04uc3RyaW5naWZ5KG5ld1NldHRpbmdzKVxuICAgIGlmIChzZXR0aW5nc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBuZXdTZXR0aW5nc1xuICAgICAgdGhpcy5yZW5kZXIoKVxuICAgIH1cbiAgfVxuXG4gIGdldFNldHRpbmdzKCkge1xuICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIuc2V0dGluZ3MpXG4gIH1cblxuICBoaWdoRGVmaW5pdGlvblVwZGF0ZShpc0hEKSB7XG4gICAgdGhpcy5pc0hEID0gaXNIRFxuICAgIGNvbnN0IG1ldGhvZCA9IGlzSEQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ1xuICAgIHRoaXMuJGhkSW5kaWNhdG9yW21ldGhvZF0oJ2VuYWJsZWQnKVxuICB9XG5cbiAgY3JlYXRlQ2FjaGVkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgJGxheWVyID0gdGhpcy4kZWwuZmluZCgnLm1lZGlhLWNvbnRyb2wtbGF5ZXInKVxuICAgIHRoaXMuJGR1cmF0aW9uID0gJGxheWVyLmZpbmQoJy5tZWRpYS1jb250cm9sLWluZGljYXRvcltkYXRhLWR1cmF0aW9uXScpXG4gICAgdGhpcy4kZnVsbHNjcmVlblRvZ2dsZSA9ICRsYXllci5maW5kKCdidXR0b24ubWVkaWEtY29udHJvbC1idXR0b25bZGF0YS1mdWxsc2NyZWVuXScpXG4gICAgdGhpcy4kcGxheVBhdXNlVG9nZ2xlID0gJGxheWVyLmZpbmQoJ2J1dHRvbi5tZWRpYS1jb250cm9sLWJ1dHRvbltkYXRhLXBsYXlwYXVzZV0nKVxuICAgIHRoaXMuJHBsYXlTdG9wVG9nZ2xlID0gJGxheWVyLmZpbmQoJ2J1dHRvbi5tZWRpYS1jb250cm9sLWJ1dHRvbltkYXRhLXBsYXlzdG9wXScpXG4gICAgdGhpcy4kcG9zaXRpb24gPSAkbGF5ZXIuZmluZCgnLm1lZGlhLWNvbnRyb2wtaW5kaWNhdG9yW2RhdGEtcG9zaXRpb25dJylcbiAgICB0aGlzLiRzZWVrQmFyQ29udGFpbmVyID0gJGxheWVyLmZpbmQoJy5iYXItY29udGFpbmVyW2RhdGEtc2Vla2Jhcl0nKVxuICAgIHRoaXMuJHNlZWtCYXJIb3ZlciA9ICRsYXllci5maW5kKCcuYmFyLWhvdmVyW2RhdGEtc2Vla2Jhcl0nKVxuICAgIHRoaXMuJHNlZWtCYXJMb2FkZWQgPSAkbGF5ZXIuZmluZCgnLmJhci1maWxsLTFbZGF0YS1zZWVrYmFyXScpXG4gICAgdGhpcy4kc2Vla0JhclBvc2l0aW9uID0gJGxheWVyLmZpbmQoJy5iYXItZmlsbC0yW2RhdGEtc2Vla2Jhcl0nKVxuICAgIHRoaXMuJHNlZWtCYXJTY3J1YmJlciA9ICRsYXllci5maW5kKCcuYmFyLXNjcnViYmVyW2RhdGEtc2Vla2Jhcl0nKVxuICAgIHRoaXMuJHZvbHVtZUJhckNvbnRhaW5lciA9ICRsYXllci5maW5kKCcuYmFyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nKVxuICAgIHRoaXMuJHZvbHVtZUNvbnRhaW5lciA9ICRsYXllci5maW5kKCcuZHJhd2VyLWNvbnRhaW5lcltkYXRhLXZvbHVtZV0nKVxuICAgIHRoaXMuJHZvbHVtZUljb24gPSAkbGF5ZXIuZmluZCgnLmRyYXdlci1pY29uW2RhdGEtdm9sdW1lXScpXG4gICAgdGhpcy4kdm9sdW1lQmFyQmFja2dyb3VuZCA9IHRoaXMuJGVsLmZpbmQoJy5iYXItYmFja2dyb3VuZFtkYXRhLXZvbHVtZV0nKVxuICAgIHRoaXMuJHZvbHVtZUJhckZpbGwgPSB0aGlzLiRlbC5maW5kKCcuYmFyLWZpbGwtMVtkYXRhLXZvbHVtZV0nKVxuICAgIHRoaXMuJHZvbHVtZUJhclNjcnViYmVyID0gdGhpcy4kZWwuZmluZCgnLmJhci1zY3J1YmJlcltkYXRhLXZvbHVtZV0nKVxuICAgIHRoaXMuJGhkSW5kaWNhdG9yID0gdGhpcy4kZWwuZmluZCgnYnV0dG9uLm1lZGlhLWNvbnRyb2wtYnV0dG9uW2RhdGEtaGQtaW5kaWNhdG9yXScpXG4gICAgdGhpcy5yZXNldEluZGljYXRvcnMoKVxuICAgIHRoaXMuaW5pdGlhbGl6ZUljb25zKClcbiAgfVxuXG4gIHJlc2V0SW5kaWNhdG9ycygpIHtcbiAgICB0aGlzLmRpc3BsYXllZFBvc2l0aW9uID0gdGhpcy4kcG9zaXRpb24udGV4dCgpXG4gICAgdGhpcy5kaXNwbGF5ZWREdXJhdGlvbiA9IHRoaXMuJGR1cmF0aW9uLnRleHQoKVxuICB9XG5cbiAgaW5pdGlhbGl6ZUljb25zKCkge1xuICAgIGNvbnN0ICRsYXllciA9IHRoaXMuJGVsLmZpbmQoJy5tZWRpYS1jb250cm9sLWxheWVyJylcbiAgICAkbGF5ZXIuZmluZCgnYnV0dG9uLm1lZGlhLWNvbnRyb2wtYnV0dG9uW2RhdGEtcGxheV0nKS5hcHBlbmQoU3ZnSWNvbnMucGxheSlcbiAgICAkbGF5ZXIuZmluZCgnYnV0dG9uLm1lZGlhLWNvbnRyb2wtYnV0dG9uW2RhdGEtcGF1c2VdJykuYXBwZW5kKFN2Z0ljb25zLnBhdXNlKVxuICAgICRsYXllci5maW5kKCdidXR0b24ubWVkaWEtY29udHJvbC1idXR0b25bZGF0YS1zdG9wXScpLmFwcGVuZChTdmdJY29ucy5zdG9wKVxuICAgIHRoaXMuJHBsYXlQYXVzZVRvZ2dsZS5hcHBlbmQoU3ZnSWNvbnMucGxheSlcbiAgICB0aGlzLiRwbGF5U3RvcFRvZ2dsZS5hcHBlbmQoU3ZnSWNvbnMucGxheSlcbiAgICB0aGlzLiR2b2x1bWVJY29uLmFwcGVuZChTdmdJY29ucy52b2x1bWUpXG4gICAgdGhpcy4kZnVsbHNjcmVlblRvZ2dsZS5hcHBlbmQoU3ZnSWNvbnMuZnVsbHNjcmVlbilcbiAgICB0aGlzLiRoZEluZGljYXRvci5hcHBlbmQoU3ZnSWNvbnMuaGQpXG4gIH1cblxuICBzZXRTZWVrUGVyY2VudGFnZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIDEwMC4wKSwgMClcbiAgICAvLyBub3QgY2hhbmdlZCBzaW5jZSBsYXN0IHVwZGF0ZVxuICAgIGlmICh0aGlzLmRpc3BsYXllZFNlZWtCYXJQZXJjZW50YWdlID09PSB2YWx1ZSkgcmV0dXJuXG5cbiAgICB0aGlzLmRpc3BsYXllZFNlZWtCYXJQZXJjZW50YWdlID0gdmFsdWVcbiAgICB0aGlzLiRzZWVrQmFyUG9zaXRpb24ucmVtb3ZlQ2xhc3MoJ21lZGlhLWNvbnRyb2wtbm90cmFuc2l0aW9uJylcbiAgICB0aGlzLiRzZWVrQmFyU2NydWJiZXIucmVtb3ZlQ2xhc3MoJ21lZGlhLWNvbnRyb2wtbm90cmFuc2l0aW9uJylcbiAgICB0aGlzLiRzZWVrQmFyUG9zaXRpb24uY3NzKHsgd2lkdGg6IGAke3ZhbHVlfSVgIH0pXG4gICAgdGhpcy4kc2Vla0JhclNjcnViYmVyLmNzcyh7IGxlZnQ6IGAke3ZhbHVlfSVgIH0pXG4gIH1cblxuICBzZWVrUmVsYXRpdmUoZGVsdGEpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2Vla0VuYWJsZWQpIHJldHVyblxuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLmNvbnRhaW5lci5nZXRDdXJyZW50VGltZSgpXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmNvbnRhaW5lci5nZXREdXJhdGlvbigpXG4gICAgbGV0IHBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoY3VycmVudFRpbWUgKyBkZWx0YSwgMCksIGR1cmF0aW9uKVxuICAgIHBvc2l0aW9uID0gTWF0aC5taW4ocG9zaXRpb24gKiAxMDAgLyBkdXJhdGlvbiwgMTAwKVxuICAgIHRoaXMuY29udGFpbmVyLnNlZWtQZXJjZW50YWdlKHBvc2l0aW9uKVxuICB9XG5cbiAgYmluZEtleUFuZFNob3coa2V5LCBjYWxsYmFjaykge1xuICAgIHRoaXMua2liby5kb3duKGtleSwgKCkgPT4ge1xuICAgICAgdGhpcy5zaG93KClcbiAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRLZXlFdmVudHMoKSB7XG4gICAgaWYgKEJyb3dzZXIuaXNNb2JpbGUgfHwgdGhpcy5vcHRpb25zLmRpc2FibGVLZXlib2FyZFNob3J0Y3V0cykgcmV0dXJuXG5cbiAgICB0aGlzLnVuYmluZEtleUV2ZW50cygpXG4gICAgdGhpcy5raWJvID0gbmV3IEtpYm8odGhpcy5vcHRpb25zLmZvY3VzRWxlbWVudCB8fCB0aGlzLm9wdGlvbnMucGFyZW50RWxlbWVudClcbiAgICB0aGlzLmJpbmRLZXlBbmRTaG93KCdzcGFjZScsICgpID0+IHRoaXMudG9nZ2xlUGxheVBhdXNlKCkpXG4gICAgdGhpcy5iaW5kS2V5QW5kU2hvdygnbGVmdCcsICgpID0+IHRoaXMuc2Vla1JlbGF0aXZlKC01KSlcbiAgICB0aGlzLmJpbmRLZXlBbmRTaG93KCdyaWdodCcsICgpID0+IHRoaXMuc2Vla1JlbGF0aXZlKDUpKVxuICAgIHRoaXMuYmluZEtleUFuZFNob3coJ3NoaWZ0IGxlZnQnLCAoKSA9PiB0aGlzLnNlZWtSZWxhdGl2ZSgtMTApKVxuICAgIHRoaXMuYmluZEtleUFuZFNob3coJ3NoaWZ0IHJpZ2h0JywgKCkgPT4gdGhpcy5zZWVrUmVsYXRpdmUoMTApKVxuICAgIHRoaXMuYmluZEtleUFuZFNob3coJ3NoaWZ0IGN0cmwgbGVmdCcsICgpID0+IHRoaXMuc2Vla1JlbGF0aXZlKC0xNSkpXG4gICAgdGhpcy5iaW5kS2V5QW5kU2hvdygnc2hpZnQgY3RybCByaWdodCcsICgpID0+IHRoaXMuc2Vla1JlbGF0aXZlKDE1KSlcbiAgICBjb25zdCBrZXlzID0gWycxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknLCcwJ11cbiAgICBrZXlzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuYmluZEtleUFuZFNob3coaSwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnNlZWtFbmFibGVkICYmIHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLnNlZWtQZXJjZW50YWdlKGkgKiAxMClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHVuYmluZEtleUV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5raWJvKSB7XG4gICAgICB0aGlzLmtpYm8ub2ZmKCdzcGFjZScpXG4gICAgICB0aGlzLmtpYm8ub2ZmKCdsZWZ0JylcbiAgICAgIHRoaXMua2liby5vZmYoJ3JpZ2h0JylcbiAgICAgIHRoaXMua2liby5vZmYoJ3NoaWZ0IGxlZnQnKVxuICAgICAgdGhpcy5raWJvLm9mZignc2hpZnQgcmlnaHQnKVxuICAgICAgdGhpcy5raWJvLm9mZignc2hpZnQgY3RybCBsZWZ0JylcbiAgICAgIHRoaXMua2liby5vZmYoJ3NoaWZ0IGN0cmwgcmlnaHQnKVxuICAgICAgdGhpcy5raWJvLm9mZihbJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzcnLCc4JywnOScsJzAnXSlcbiAgICB9XG4gIH1cblxuICBwYXJzZUNvbG9ycygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhY29udHJvbCkge1xuICAgICAgdGhpcy5idXR0b25zQ29sb3IgPSB0aGlzLm9wdGlvbnMubWVkaWFjb250cm9sLmJ1dHRvbnNcbiAgICAgIGNvbnN0IHNlZWtiYXJDb2xvciA9IHRoaXMub3B0aW9ucy5tZWRpYWNvbnRyb2wuc2Vla2JhclxuICAgICAgdGhpcy4kZWwuZmluZCgnLmJhci1maWxsLTJbZGF0YS1zZWVrYmFyXScpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHNlZWtiYXJDb2xvcilcbiAgICAgIHRoaXMuJGVsLmZpbmQoJy5tZWRpYS1jb250cm9sLWljb24gc3ZnIHBhdGgnKS5jc3MoJ2ZpbGwnLCB0aGlzLmJ1dHRvbnNDb2xvcilcbiAgICAgIHRoaXMuJGVsLmZpbmQoJy5zZWdtZW50ZWQtYmFyLWVsZW1lbnRbZGF0YS12b2x1bWVdJykuY3NzKCdib3hTaGFkb3cnLCAnaW5zZXQgMnB4IDAgMCAnICsgdGhpcy5idXR0b25zQ29sb3IpXG4gICAgfVxuICB9XG5cbiAgYXBwbHlCdXR0b25TdHlsZShlbGVtZW50KSB7XG4gICAgdGhpcy5idXR0b25zQ29sb3IgJiYgZWxlbWVudCAmJiAkKGVsZW1lbnQpLmZpbmQoJ3N2ZyBwYXRoJykuY3NzKCdmaWxsJywgdGhpcy5idXR0b25zQ29sb3IpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgICQoZG9jdW1lbnQpLnVuYmluZCgnbW91c2V1cCcsIHRoaXMuc3RvcERyYWdIYW5kbGVyKVxuICAgICQoZG9jdW1lbnQpLnVuYmluZCgnbW91c2Vtb3ZlJywgdGhpcy51cGRhdGVEcmFnSGFuZGxlcilcbiAgICB0aGlzLnVuYmluZEtleUV2ZW50cygpXG4gICAgdGhpcy5zdG9wTGlzdGVuaW5nKClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBlbmFibGVzIHRvIGNvbmZpZ3VyZSB0aGUgbWVkaWEgY29udHJvbCBhZnRlciBpdHMgY3JlYXRpb25cbiAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWxsIHRoZSBvcHRpb25zIHRvIGNoYW5nZSBpbiBmb3JtIG9mIGEgamF2YXNjcmlwdCBvYmplY3RcbiAgICovXG4gIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gICAgLy8gQ2hlY2sgaWYgY2hyb21lbGVzcyBtb2RlIG9yIGlmIGNvbmZpZ3VyZSBpcyBjYWxsZWQgd2l0aCBuZXcgc291cmNlKHMpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jaHJvbWVsZXNzIHx8IG9wdGlvbnMuc291cmNlIHx8IG9wdGlvbnMuc291cmNlcylcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgZWxzZVxuICAgICAgdGhpcy5lbmFibGUoKVxuXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQUNPTlRST0xfT1BUSU9OU19DSEFOR0UpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgdGltZW91dCA9IHRoaXMub3B0aW9ucy5oaWRlTWVkaWFDb250cm9sRGVsYXkgfHwgMjAwMFxuICAgIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHsgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MgfSkpXG4gICAgdGhpcy5jcmVhdGVDYWNoZWRFbGVtZW50cygpXG4gICAgdGhpcy4kcGxheVBhdXNlVG9nZ2xlLmFkZENsYXNzKCdwYXVzZWQnKVxuICAgIHRoaXMuJHBsYXlTdG9wVG9nZ2xlLmFkZENsYXNzKCdzdG9wcGVkJylcblxuICAgIHRoaXMuY2hhbmdlVG9nZ2xlUGxheSgpXG5cbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuaGlkZUlkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGUoKSwgdGltZW91dClcbiAgICAgIHRoaXMuZGlzYWJsZWQgJiYgdGhpcy5oaWRlKClcbiAgICB9XG5cbiAgICAvLyBWaWRlbyB2b2x1bWUgY2Fubm90IGJlIGNoYW5nZWQgd2l0aCBTYWZhcmkgb24gbW9iaWxlIGRldmljZXNcbiAgICAvLyBEaXNwbGF5IG11dGUvdW5tdXRlIGljb24gb25seSBpZiBTYWZhcmkgdmVyc2lvbiA+PSAxMFxuICAgIGlmIChCcm93c2VyLmlzU2FmYXJpICYmIEJyb3dzZXIuaXNNb2JpbGUpIHtcbiAgICAgIGlmIChCcm93c2VyLnZlcnNpb24gPCAxMClcbiAgICAgICAgdGhpcy4kdm9sdW1lQ29udGFpbmVyLmNzcygnZGlzcGxheScsJ25vbmUnKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLiR2b2x1bWVCYXJDb250YWluZXIuY3NzKCdkaXNwbGF5Jywnbm9uZScpXG5cbiAgICB9XG5cbiAgICB0aGlzLiRzZWVrQmFyUG9zaXRpb24uYWRkQ2xhc3MoJ21lZGlhLWNvbnRyb2wtbm90cmFuc2l0aW9uJylcbiAgICB0aGlzLiRzZWVrQmFyU2NydWJiZXIuYWRkQ2xhc3MoJ21lZGlhLWNvbnRyb2wtbm90cmFuc2l0aW9uJylcblxuICAgIGxldCBwcmV2aW91c1NlZWtQZXJjZW50YWdlID0gMFxuICAgIGlmICh0aGlzLmRpc3BsYXllZFNlZWtCYXJQZXJjZW50YWdlKVxuICAgICAgcHJldmlvdXNTZWVrUGVyY2VudGFnZSA9IHRoaXMuZGlzcGxheWVkU2Vla0JhclBlcmNlbnRhZ2VcblxuICAgIHRoaXMuZGlzcGxheWVkU2Vla0JhclBlcmNlbnRhZ2UgPSBudWxsXG4gICAgdGhpcy5zZXRTZWVrUGVyY2VudGFnZShwcmV2aW91c1NlZWtQZXJjZW50YWdlKVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAhdGhpcy5zZXR0aW5ncy5zZWVrRW5hYmxlZCAmJiB0aGlzLiRzZWVrQmFyQ29udGFpbmVyLmFkZENsYXNzKCdzZWVrLWRpc2FibGVkJylcbiAgICAgICFCcm93c2VyLmlzTW9iaWxlICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZUtleWJvYXJkU2hvcnRjdXRzICYmIHRoaXMuYmluZEtleUV2ZW50cygpXG4gICAgICB0aGlzLnBsYXllclJlc2l6ZSh7IHdpZHRoOiB0aGlzLm9wdGlvbnMud2lkdGgsIGhlaWdodDogdGhpcy5vcHRpb25zLmhlaWdodCB9KVxuICAgICAgdGhpcy5oaWRlVm9sdW1lQmFyKDApXG4gICAgfSlcblxuICAgIHRoaXMucGFyc2VDb2xvcnMoKVxuICAgIHRoaXMuaGlnaERlZmluaXRpb25VcGRhdGUodGhpcy5pc0hEKVxuXG4gICAgdGhpcy5jb3JlLiRlbC5hcHBlbmQodGhpcy5lbClcblxuICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlXG4gICAgdGhpcy51cGRhdGVWb2x1bWVVSSgpXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQUNPTlRST0xfUkVOREVSRUQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5NZWRpYUNvbnRyb2wuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICByZXR1cm4gZXh0ZW5kKE1lZGlhQ29udHJvbCwgcHJvcGVydGllcylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJtZWRpYS1jb250cm9sLWJhY2tncm91bmRcXFwiIGRhdGEtYmFja2dyb3VuZD48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJtZWRpYS1jb250cm9sLWxheWVyXFxcIiBkYXRhLWNvbnRyb2xzPlxcbiAgPCUgIHZhciByZW5kZXJCYXIgPSBmdW5jdGlvbihuYW1lKSB7ICU+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYmFyLWNvbnRhaW5lclxcXCIgZGF0YS08JT0gbmFtZSAlPj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJhci1iYWNrZ3JvdW5kXFxcIiBkYXRhLTwlPSBuYW1lICU+PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYXItZmlsbC0xXFxcIiBkYXRhLTwlPSBuYW1lICU+PjwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYXItZmlsbC0yXFxcIiBkYXRhLTwlPSBuYW1lICU+PjwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYXItaG92ZXJcXFwiIGRhdGEtPCU9IG5hbWUgJT4+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJhci1zY3J1YmJlclxcXCIgZGF0YS08JT0gbmFtZSAlPj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFyLXNjcnViYmVyLWljb25cXFwiIGRhdGEtPCU9IG5hbWUgJT4+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gIDwlICB9OyAlPlxcbiAgPCUgIHZhciByZW5kZXJTZWdtZW50ZWRCYXIgPSBmdW5jdGlvbihuYW1lLCBzZWdtZW50cykge1xcbiAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMgfHwgMTA7ICU+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJhci1jb250YWluZXJcXFwiIGRhdGEtPCU9IG5hbWUgJT4+XFxuICAgIDwlIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykgeyAlPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNlZ21lbnRlZC1iYXItZWxlbWVudFxcXCIgZGF0YS08JT0gbmFtZSAlPj48L2Rpdj5cXG4gICAgPCUgfSAlPlxcbiAgICA8L2Rpdj5cXG4gIDwlIH07ICU+XFxuICA8JSB2YXIgcmVuZGVyRHJhd2VyID0gZnVuY3Rpb24obmFtZSwgcmVuZGVyQ29udGVudCkgeyAlPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImRyYXdlci1jb250YWluZXJcXFwiIGRhdGEtPCU9IG5hbWUgJT4+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcmF3ZXItaWNvbi1jb250YWluZXJcXFwiIGRhdGEtPCU9IG5hbWUgJT4+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRyYXdlci1pY29uIG1lZGlhLWNvbnRyb2wtaWNvblxcXCIgZGF0YS08JT0gbmFtZSAlPj48L2Rpdj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImRyYXdlci10ZXh0XFxcIiBkYXRhLTwlPSBuYW1lICU+Pjwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPCUgcmVuZGVyQ29udGVudChuYW1lKTsgJT5cXG4gICAgICA8L2Rpdj5cXG4gIDwlIH07ICU+XFxuICA8JSB2YXIgcmVuZGVySW5kaWNhdG9yID0gZnVuY3Rpb24obmFtZSkgeyAlPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWNvbnRyb2wtaW5kaWNhdG9yXFxcIiBkYXRhLTwlPSBuYW1lICU+PjwvZGl2PlxcbiAgPCUgfTsgJT5cXG4gIDwlIHZhciByZW5kZXJCdXR0b24gPSBmdW5jdGlvbihuYW1lKSB7ICU+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibWVkaWEtY29udHJvbC1idXR0b24gbWVkaWEtY29udHJvbC1pY29uXFxcIiBkYXRhLTwlPSBuYW1lICU+IGFyaWEtbGFiZWw9XFxcIjwlPSBuYW1lICU+XFxcIj48L2J1dHRvbj5cXG4gIDwlIH07ICU+XFxuICA8JSAgdmFyIHRlbXBsYXRlcyA9IHtcXG4gICAgICAgIGJhcjogcmVuZGVyQmFyLFxcbiAgICAgICAgc2VnbWVudGVkQmFyOiByZW5kZXJTZWdtZW50ZWRCYXIsXFxuICAgICAgfTtcXG4gICAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24oc2V0dGluZ3NMaXN0KSB7XFxuICAgICAgICBzZXR0aW5nc0xpc3QuZm9yRWFjaChmdW5jdGlvbihzZXR0aW5nKSB7XFxuICAgICAgICAgIGlmKHNldHRpbmcgPT09IFxcXCJzZWVrYmFyXFxcIikge1xcbiAgICAgICAgICAgIHJlbmRlckJhcihzZXR0aW5nKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5nID09PSBcXFwidm9sdW1lXFxcIikge1xcbiAgICAgICAgICAgIHJlbmRlckRyYXdlcihzZXR0aW5nLCBzZXR0aW5ncy52b2x1bWVCYXJUZW1wbGF0ZSA/IHRlbXBsYXRlc1tzZXR0aW5ncy52b2x1bWVCYXJUZW1wbGF0ZV0gOiBmdW5jdGlvbihuYW1lKSB7IHJldHVybiByZW5kZXJTZWdtZW50ZWRCYXIobmFtZSk7IH0pO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmcgPT09IFxcXCJkdXJhdGlvblxcXCIgfHwgc2V0dGluZyA9PT0gXFxcInBvc2l0aW9uXFxcIikge1xcbiAgICAgICAgICAgIHJlbmRlckluZGljYXRvcihzZXR0aW5nKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZW5kZXJCdXR0b24oc2V0dGluZyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH07ICU+XFxuICA8JSBpZiAoc2V0dGluZ3MuZGVmYXVsdCAmJiBzZXR0aW5ncy5kZWZhdWx0Lmxlbmd0aCkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwibWVkaWEtY29udHJvbC1jZW50ZXItcGFuZWxcXFwiIGRhdGEtbWVkaWEtY29udHJvbD5cXG4gICAgPCUgcmVuZGVyKHNldHRpbmdzLmRlZmF1bHQpOyAlPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuICA8JSBpZiAoc2V0dGluZ3MubGVmdCAmJiBzZXR0aW5ncy5sZWZ0Lmxlbmd0aCkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwibWVkaWEtY29udHJvbC1sZWZ0LXBhbmVsXFxcIiBkYXRhLW1lZGlhLWNvbnRyb2w+XFxuICAgIDwlIHJlbmRlcihzZXR0aW5ncy5sZWZ0KTsgJT5cXG4gIDwvZGl2PlxcbiAgPCUgfSAlPlxcbiAgPCUgaWYgKHNldHRpbmdzLnJpZ2h0ICYmIHNldHRpbmdzLnJpZ2h0Lmxlbmd0aCkgeyAlPlxcbiAgPGRpdiBjbGFzcz1cXFwibWVkaWEtY29udHJvbC1yaWdodC1wYW5lbFxcXCIgZGF0YS1tZWRpYS1jb250cm9sPlxcbiAgICA8JSByZW5kZXIoc2V0dGluZ3MucmlnaHQpOyAlPlxcbiAgPC9kaXY+XFxuICA8JSB9ICU+XFxuPC9kaXY+XFxuXCI7IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9tZWRpYS1jb250cm9sLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcInNpbmdsZXRvblwiOnRydWUsXCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vbWVkaWEtY29udHJvbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL21lZGlhLWNvbnRyb2wuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCBQb3N0ZXJQbHVnaW4gZnJvbSAnLi9wb3N0ZXInXG5leHBvcnQgZGVmYXVsdCBQb3N0ZXJQbHVnaW5cbiIsIi8vQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IFVJQ29udGFpbmVyUGx1Z2luIGZyb20gJy4uLy4uL2Jhc2UvdWlfY29udGFpbmVyX3BsdWdpbidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi4vLi4vYmFzZS90ZW1wbGF0ZSdcbmltcG9ydCBQbGF5YmFjayBmcm9tICcuLi8uLi9iYXNlL3BsYXliYWNrJ1xuaW1wb3J0IFBsYXllckVycm9yIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvZXJyb3IvZXJyb3InXG5pbXBvcnQgcG9zdGVySFRNTCBmcm9tICcuL3B1YmxpYy9wb3N0ZXIuaHRtbCdcbmltcG9ydCB7IFN2Z0ljb25zIH0gZnJvbSAnLi4vLi4vYmFzZS91dGlscydcbmltcG9ydCAnLi9wdWJsaWMvcG9zdGVyLnNjc3MnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc3RlclBsdWdpbiBleHRlbmRzIFVJQ29udGFpbmVyUGx1Z2luIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAncG9zdGVyJyB9XG4gIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIHRlbXBsYXRlKHBvc3RlckhUTUwpIH1cbiAgZ2V0IHNob3VsZFJlbmRlcigpIHtcbiAgICBjb25zdCBzaG93Rm9yTm9PcCA9ICEhKHRoaXMub3B0aW9ucy5wb3N0ZXIgJiYgdGhpcy5vcHRpb25zLnBvc3Rlci5zaG93Rm9yTm9PcClcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXIucGxheWJhY2submFtZSAhPT0gJ2h0bWxfaW1nJyAmJiAodGhpcy5jb250YWluZXIucGxheWJhY2suZ2V0UGxheWJhY2tUeXBlKCkgIT09IFBsYXliYWNrLk5PX09QIHx8IHNob3dGb3JOb09wKVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjbGFzcyc6ICdwbGF5ZXItcG9zdGVyJyxcbiAgICAgICdkYXRhLXBvc3Rlcic6ICcnXG4gICAgfVxuICB9XG5cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2NsaWNrJzogJ2NsaWNrZWQnXG4gICAgfVxuICB9XG5cbiAgZ2V0IHNob3dPblZpZGVvRW5kKCkge1xuICAgIHJldHVybiAhdGhpcy5vcHRpb25zLnBvc3RlciB8fCB0aGlzLm9wdGlvbnMucG9zdGVyLnNob3dPblZpZGVvRW5kIHx8IHRoaXMub3B0aW9ucy5wb3N0ZXIuc2hvd09uVmlkZW9FbmQgPT09IHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyKVxuICAgIHRoaXMuaGFzU3RhcnRlZFBsYXlpbmcgPSBmYWxzZVxuICAgIHRoaXMucGxheVJlcXVlc3RlZCA9IGZhbHNlXG4gICAgdGhpcy5yZW5kZXIoKVxuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy51cGRhdGUoKSlcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVE9QLCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1BMQVksIHRoaXMub25QbGF5KVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfU1RBVEVfQlVGRkVSSU5HLCB0aGlzLnVwZGF0ZSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUQVRFX0JVRkZFUkZVTEwsIHRoaXMudXBkYXRlKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfT1BUSU9OU19DSEFOR0UsIHRoaXMucmVuZGVyKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfRVJST1IsIHRoaXMub25FcnJvcilcbiAgICB0aGlzLnNob3dPblZpZGVvRW5kICYmIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfRU5ERUQsIHRoaXMub25TdG9wKVxuICB9XG5cbiAgb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuaGFzRmF0YWxFcnJvciA9IGVycm9yLmxldmVsID09PSBQbGF5ZXJFcnJvci5MZXZlbHMuRkFUQUxcblxuICAgIGlmICh0aGlzLmhhc0ZhdGFsRXJyb3IpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZFBsYXlpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5wbGF5UmVxdWVzdGVkID0gZmFsc2VcbiAgICAgIHRoaXMuc2hvd1BsYXlCdXR0b24oKVxuICAgIH1cbiAgfVxuXG4gIG9uUGxheSgpIHtcbiAgICB0aGlzLmhhc1N0YXJ0ZWRQbGF5aW5nID0gdHJ1ZVxuICAgIHRoaXMudXBkYXRlKClcbiAgfVxuXG4gIG9uU3RvcCgpIHtcbiAgICB0aGlzLmhhc1N0YXJ0ZWRQbGF5aW5nID0gZmFsc2VcbiAgICB0aGlzLnBsYXlSZXF1ZXN0ZWQgPSBmYWxzZVxuICAgIHRoaXMudXBkYXRlKClcbiAgfVxuXG4gIHVwZGF0ZVBsYXlCdXR0b24oc2hvdykge1xuICAgIGlmIChzaG93ICYmICghdGhpcy5vcHRpb25zLmNocm9tZWxlc3MgfHwgdGhpcy5vcHRpb25zLmFsbG93VXNlckludGVyYWN0aW9uKSlcbiAgICAgIHRoaXMuc2hvd1BsYXlCdXR0b24oKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuaGlkZVBsYXlCdXR0b24oKVxuICB9XG5cbiAgc2hvd1BsYXlCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuaGFzRmF0YWxFcnJvciAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVFcnJvclNjcmVlbikgcmV0dXJuXG5cbiAgICB0aGlzLiRwbGF5QnV0dG9uLnNob3coKVxuICAgIHRoaXMuJGVsLmFkZENsYXNzKCdjbGlja2FibGUnKVxuICB9XG5cbiAgaGlkZVBsYXlCdXR0b24oKSB7XG4gICAgdGhpcy4kcGxheUJ1dHRvbi5oaWRlKClcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcygnY2xpY2thYmxlJylcbiAgfVxuXG4gIGNsaWNrZWQoKSB7XG4gICAgLy8gTGV0IFwiY2xpY2tfdG9fcGF1c2VcIiBwbHVnaW4gaGFuZGxlIGNsaWNrIGV2ZW50IGlmIG1lZGlhIGhhcyBzdGFydGVkIHBsYXlpbmdcbiAgICBpZiAoISB0aGlzLmhhc1N0YXJ0ZWRQbGF5aW5nKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jaHJvbWVsZXNzIHx8IHRoaXMub3B0aW9ucy5hbGxvd1VzZXJJbnRlcmFjdGlvbikge1xuICAgICAgICB0aGlzLnBsYXlSZXF1ZXN0ZWQgPSB0cnVlXG4gICAgICAgIHRoaXMudXBkYXRlKClcbiAgICAgICAgdGhpcy5jb250YWluZXIucGxheSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBzaG91bGRIaWRlT25QbGF5KCkge1xuICAgIC8vIEF1ZGlvIGJyb2FkY2FzdHMgc2hvdWxkIGtlZXAgdGhlIHBvc3RlciB1cDsgdmlkZW8gc2hvdWxkIGhpZGUgcG9zdGVyIHdoaWxlIHBsYXlpbmcuXG4gICAgcmV0dXJuICF0aGlzLmNvbnRhaW5lci5wbGF5YmFjay5pc0F1ZGlvT25seVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5zaG91bGRSZW5kZXIpXG4gICAgICByZXR1cm5cblxuICAgIGxldCBzaG93UGxheUJ1dHRvbiA9ICF0aGlzLnBsYXlSZXF1ZXN0ZWQgICYmICF0aGlzLmhhc1N0YXJ0ZWRQbGF5aW5nICYmICF0aGlzLmNvbnRhaW5lci5idWZmZXJpbmdcbiAgICB0aGlzLnVwZGF0ZVBsYXlCdXR0b24oc2hvd1BsYXlCdXR0b24pXG4gICAgdGhpcy51cGRhdGVQb3N0ZXIoKVxuICB9XG5cbiAgdXBkYXRlUG9zdGVyKCkge1xuICAgIGlmICghdGhpcy5oYXNTdGFydGVkUGxheWluZykgdGhpcy5zaG93UG9zdGVyKClcbiAgICBlbHNlIHRoaXMuaGlkZVBvc3RlcigpXG4gIH1cblxuICBzaG93UG9zdGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmRpc2FibGVNZWRpYUNvbnRyb2woKVxuICAgIHRoaXMuJGVsLnNob3coKVxuICB9XG5cbiAgaGlkZVBvc3RlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5lbmFibGVNZWRpYUNvbnRyb2woKVxuICAgIGlmICh0aGlzLnNob3VsZEhpZGVPblBsYXkoKSlcbiAgICAgIHRoaXMuJGVsLmhpZGUoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5zaG91bGRSZW5kZXIpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSgpKVxuXG4gICAgY29uc3QgaXNSZWd1bGFyUG9zdGVyID0gdGhpcy5vcHRpb25zLnBvc3RlciAmJiB0aGlzLm9wdGlvbnMucG9zdGVyLmN1c3RvbSA9PT0gdW5kZWZpbmVkXG5cbiAgICBpZiAoaXNSZWd1bGFyUG9zdGVyKSB7XG4gICAgICBjb25zdCBwb3N0ZXJVcmwgPSB0aGlzLm9wdGlvbnMucG9zdGVyLnVybCB8fCB0aGlzLm9wdGlvbnMucG9zdGVyXG4gICAgICB0aGlzLiRlbC5jc3MoeyAnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoJyArIHBvc3RlclVybCArICcpJyB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBvc3RlcikgeyB0aGlzLiRlbC5jc3MoeyAnYmFja2dyb3VuZCc6IHRoaXMub3B0aW9ucy5wb3N0ZXIuY3VzdG9tIH0pIH1cblxuICAgIHRoaXMuY29udGFpbmVyLiRlbC5hcHBlbmQodGhpcy5lbClcbiAgICB0aGlzLiRwbGF5V3JhcHBlciA9IHRoaXMuJGVsLmZpbmQoJy5wbGF5LXdyYXBwZXInKVxuICAgIHRoaXMuJHBsYXlXcmFwcGVyLmFwcGVuZChTdmdJY29ucy5wbGF5KVxuICAgIHRoaXMuJHBsYXlCdXR0b24gPSB0aGlzLiRwbGF5V3JhcHBlci5maW5kKCdzdmcnKVxuICAgIHRoaXMuJHBsYXlCdXR0b24uYWRkQ2xhc3MoJ3Bvc3Rlci1pY29uJylcbiAgICB0aGlzLiRwbGF5QnV0dG9uLmF0dHIoJ2RhdGEtcG9zdGVyJywgJycpXG5cbiAgICBsZXQgYnV0dG9uc0NvbG9yID0gdGhpcy5vcHRpb25zLm1lZGlhY29udHJvbCAmJiB0aGlzLm9wdGlvbnMubWVkaWFjb250cm9sLmJ1dHRvbnNcbiAgICBpZiAoYnV0dG9uc0NvbG9yKVxuICAgICAgdGhpcy4kZWwuZmluZCgnc3ZnIHBhdGgnKS5jc3MoJ2ZpbGwnLCBidXR0b25zQ29sb3IpXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhY29udHJvbCAmJiB0aGlzLm9wdGlvbnMubWVkaWFjb250cm9sLmJ1dHRvbnMpIHtcbiAgICAgIGJ1dHRvbnNDb2xvciA9IHRoaXMub3B0aW9ucy5tZWRpYWNvbnRyb2wuYnV0dG9uc1xuICAgICAgdGhpcy4kcGxheUJ1dHRvbi5jc3MoJ2NvbG9yJywgYnV0dG9uc0NvbG9yKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInBsYXktd3JhcHBlclxcXCIgZGF0YS1wb3N0ZXI+PC9kaXY+XFxuXCI7IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9wb3N0ZXIuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wic2luZ2xldG9uXCI6dHJ1ZSxcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9wb3N0ZXIuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9wb3N0ZXIuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCBTZWVrVGltZSBmcm9tICcuL3NlZWtfdGltZSdcbmV4cG9ydCBkZWZhdWx0IFNlZWtUaW1lXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHNwYW4gZGF0YS1zZWVrLXRpbWU+PC9zcGFuPlxcbjxzcGFuIGRhdGEtZHVyYXRpb24+PC9zcGFuPlxcblwiOyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc2Vla190aW1lLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcInNpbmdsZXRvblwiOnRydWUsXCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc2Vla190aW1lLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc2Vla190aW1lLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvLyBDb3B5cmlnaHQgMjAxNCBHbG9iby5jb20gUGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZVxuLy8gbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuXG5pbXBvcnQgeyBmb3JtYXRUaW1lIH0gZnJvbSAnLi4vLi4vYmFzZS91dGlscydcblxuaW1wb3J0IFVJQ29yZVBsdWdpbiBmcm9tICcuLi8uLi9iYXNlL3VpX2NvcmVfcGx1Z2luJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL2Jhc2UvdGVtcGxhdGUnXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IFBsYXliYWNrIGZyb20gJy4uLy4uL2Jhc2UvcGxheWJhY2snXG5pbXBvcnQgc2Vla1RpbWVIVE1MIGZyb20gJy4vcHVibGljL3NlZWtfdGltZS5odG1sJ1xuaW1wb3J0ICcuL3B1YmxpYy9zZWVrX3RpbWUuc2NzcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vla1RpbWUgZXh0ZW5kcyBVSUNvcmVQbHVnaW4ge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdzZWVrX3RpbWUnIH1cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZShzZWVrVGltZUhUTUwpXG4gIH1cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdjbGFzcyc6ICdzZWVrLXRpbWUnLFxuICAgICAgJ2RhdGEtc2Vlay10aW1lJzogJydcbiAgICB9XG4gIH1cbiAgZ2V0IG1lZGlhQ29udHJvbCgpIHsgcmV0dXJuIHRoaXMuY29yZS5tZWRpYUNvbnRyb2wgfVxuICBnZXQgbWVkaWFDb250cm9sQ29udGFpbmVyKCkgeyByZXR1cm4gdGhpcy5tZWRpYUNvbnRyb2wuY29udGFpbmVyIH1cbiAgZ2V0IGlzTGl2ZVN0cmVhbVdpdGhEdnIoKSB7IHJldHVybiB0aGlzLm1lZGlhQ29udHJvbENvbnRhaW5lciAmJiB0aGlzLm1lZGlhQ29udHJvbENvbnRhaW5lci5nZXRQbGF5YmFja1R5cGUoKSA9PT0gUGxheWJhY2suTElWRSAmJiB0aGlzLm1lZGlhQ29udHJvbENvbnRhaW5lci5pc0R2ckVuYWJsZWQoKSB9XG4gIGdldCBkdXJhdGlvblNob3duKCkgeyByZXR1cm4gdGhpcy5pc0xpdmVTdHJlYW1XaXRoRHZyICYmICF0aGlzLmFjdHVhbExpdmVUaW1lIH1cbiAgZ2V0IHVzZUFjdHVhbExpdmVUaW1lKCkgeyByZXR1cm4gdGhpcy5hY3R1YWxMaXZlVGltZSAmJiB0aGlzLmlzTGl2ZVN0cmVhbVdpdGhEdnIgfVxuICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG4gICAgc3VwZXIoY29yZSlcbiAgICB0aGlzLmhvdmVyaW5nT3ZlclNlZWtCYXIgPSBmYWxzZVxuICAgIHRoaXMuaG92ZXJQb3NpdGlvbiA9IG51bGxcbiAgICB0aGlzLmR1cmF0aW9uID0gbnVsbFxuICAgIHRoaXMuZmlyc3RGcmFnRGF0ZVRpbWUgPSBudWxsXG4gICAgdGhpcy5hY3R1YWxMaXZlVGltZSA9ICEhdGhpcy5tZWRpYUNvbnRyb2wub3B0aW9ucy5hY3R1YWxMaXZlVGltZVxuICAgIGlmICh0aGlzLmFjdHVhbExpdmVUaW1lKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUNvbnRyb2wub3B0aW9ucy5hY3R1YWxMaXZlU2VydmVyVGltZSlcbiAgICAgICAgdGhpcy5hY3R1YWxMaXZlU2VydmVyVGltZURpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIG5ldyBEYXRlKHRoaXMubWVkaWFDb250cm9sLm9wdGlvbnMuYWN0dWFsTGl2ZVNlcnZlclRpbWUpLmdldFRpbWUoKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLmFjdHVhbExpdmVTZXJ2ZXJUaW1lRGlmZiA9IDBcbiAgICB9XG4gIH1cblxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tZWRpYUNvbnRyb2wsIEV2ZW50cy5NRURJQUNPTlRST0xfUkVOREVSRUQsIHRoaXMucmVuZGVyKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5tZWRpYUNvbnRyb2wsIEV2ZW50cy5NRURJQUNPTlRST0xfTU9VU0VNT1ZFX1NFRUtCQVIsIHRoaXMuc2hvd1RpbWUpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1lZGlhQ29udHJvbCwgRXZlbnRzLk1FRElBQ09OVFJPTF9NT1VTRUxFQVZFX1NFRUtCQVIsIHRoaXMuaGlkZVRpbWUpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1lZGlhQ29udHJvbCwgRXZlbnRzLk1FRElBQ09OVFJPTF9DT05UQUlORVJDSEFOR0VELCB0aGlzLm9uQ29udGFpbmVyQ2hhbmdlZClcbiAgICBpZiAodGhpcy5tZWRpYUNvbnRyb2xDb250YWluZXIpIHtcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tZWRpYUNvbnRyb2xDb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfUExBWUJBQ0tEVlJTVEFURUNIQU5HRUQsIHRoaXMudXBkYXRlKVxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1lZGlhQ29udHJvbENvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9USU1FVVBEQVRFLCB0aGlzLnVwZGF0ZUR1cmF0aW9uKVxuICAgIH1cbiAgfVxuXG4gIG9uQ29udGFpbmVyQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKVxuICAgIHRoaXMuYmluZEV2ZW50cygpXG4gIH1cblxuICB1cGRhdGVEdXJhdGlvbih0aW1lUHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gdGltZVByb2dyZXNzLnRvdGFsXG4gICAgdGhpcy5maXJzdEZyYWdEYXRlVGltZSA9IHRpbWVQcm9ncmVzcy5maXJzdEZyYWdEYXRlVGltZVxuICAgIHRoaXMudXBkYXRlKClcbiAgfVxuXG4gIHNob3dUaW1lKGV2ZW50KSB7XG4gICAgdGhpcy5ob3ZlcmluZ092ZXJTZWVrQmFyID0gdHJ1ZVxuICAgIHRoaXMuY2FsY3VsYXRlSG92ZXJQb3NpdGlvbihldmVudClcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cblxuICBoaWRlVGltZSgpIHtcbiAgICB0aGlzLmhvdmVyaW5nT3ZlclNlZWtCYXIgPSBmYWxzZVxuICAgIHRoaXMudXBkYXRlKClcbiAgfVxuXG4gIGNhbGN1bGF0ZUhvdmVyUG9zaXRpb24oZXZlbnQpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBldmVudC5wYWdlWCAtIHRoaXMubWVkaWFDb250cm9sLiRzZWVrQmFyQ29udGFpbmVyLm9mZnNldCgpLmxlZnRcbiAgICAvLyBwcm9wb3J0aW9uIGludG8gdGhlIHNlZWsgYmFyIHRoYXQgdGhlIG1vdXNlIGlzIGhvdmVyZWQgb3ZlciAwLTFcbiAgICB0aGlzLmhvdmVyUG9zaXRpb24gPSBNYXRoLm1pbigxLCBNYXRoLm1heChvZmZzZXQvdGhpcy5tZWRpYUNvbnRyb2wuJHNlZWtCYXJDb250YWluZXIud2lkdGgoKSwgMCkpXG4gIH1cblxuICBnZXRTZWVrVGltZSgpIHtcbiAgICBsZXQgc2Vla1RpbWUsIHNlY29uZHNTaW5jZU1pZG5pZ2h0LCBkLCBlXG4gICAgaWYgKHRoaXMudXNlQWN0dWFsTGl2ZVRpbWUpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0RnJhZ0RhdGVUaW1lKSB7XG4gICAgICAgIGUgPSBuZXcgRGF0ZSh0aGlzLmZpcnN0RnJhZ0RhdGVUaW1lKVxuICAgICAgICBkID0gbmV3IERhdGUodGhpcy5maXJzdEZyYWdEYXRlVGltZSlcbiAgICAgICAgZC5zZXRIb3VycygwLDAsMCwwKVxuICAgICAgICBzZWNvbmRzU2luY2VNaWRuaWdodCA9ICgoZS5nZXRUaW1lKCkgLSBkLmdldFRpbWUoKSkgLyAxMDAwKSArIHRoaXMuZHVyYXRpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuYWN0dWFsTGl2ZVNlcnZlclRpbWVEaWZmKVxuICAgICAgICBlID0gbmV3IERhdGUoZClcbiAgICAgICAgc2Vjb25kc1NpbmNlTWlkbmlnaHQgPSAoZSAtIGQuc2V0SG91cnMoMCwwLDAsMCkpIC8gMTAwMFxuICAgICAgfVxuICAgICAgc2Vla1RpbWUgPSAoc2Vjb25kc1NpbmNlTWlkbmlnaHQgLSB0aGlzLmR1cmF0aW9uKSArICh0aGlzLmhvdmVyUG9zaXRpb24gKiB0aGlzLmR1cmF0aW9uKVxuICAgICAgaWYgKHNlZWtUaW1lIDwgMClcbiAgICAgICAgc2Vla1RpbWUgKz0gODY0MDBcblxuICAgIH0gZWxzZSB7IHNlZWtUaW1lID0gdGhpcy5ob3ZlclBvc2l0aW9uICogdGhpcy5kdXJhdGlvbiB9XG5cbiAgICByZXR1cm4geyBzZWVrVGltZSwgc2Vjb25kc1NpbmNlTWlkbmlnaHQgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlZCkge1xuICAgICAgLy8gdXBkYXRlKCkgaXMgYWx3YXlzIGNhbGxlZCBhZnRlciBhIHJlbmRlclxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghdGhpcy5zaG91bGRCZVZpc2libGUoKSkge1xuICAgICAgdGhpcy4kZWwuaGlkZSgpXG4gICAgICB0aGlzLiRlbC5jc3MoJ2xlZnQnLCAnLTEwMCUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZWVrVGltZSA9IHRoaXMuZ2V0U2Vla1RpbWUoKVxuICAgICAgY29uc3QgY3VycmVudFNlZWtUaW1lID0gZm9ybWF0VGltZShzZWVrVGltZS5zZWVrVGltZSwgdGhpcy51c2VBY3R1YWxMaXZlVGltZSlcbiAgICAgIC8vIG9ubHkgdXBkYXRlIGRvbSBpZiBuZWNlc3NhcnksIGllIHRpbWUgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKGN1cnJlbnRTZWVrVGltZSAhPT0gdGhpcy5kaXNwbGF5ZWRTZWVrVGltZSkge1xuICAgICAgICB0aGlzLiRzZWVrVGltZUVsLnRleHQoY3VycmVudFNlZWtUaW1lKVxuICAgICAgICB0aGlzLmRpc3BsYXllZFNlZWtUaW1lID0gY3VycmVudFNlZWtUaW1lXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uU2hvd24pIHtcbiAgICAgICAgdGhpcy4kZHVyYXRpb25FbC5zaG93KClcbiAgICAgICAgY29uc3QgY3VycmVudER1cmF0aW9uID0gZm9ybWF0VGltZSh0aGlzLmFjdHVhbExpdmVUaW1lID8gc2Vla1RpbWUuc2Vjb25kc1NpbmNlTWlkbmlnaHQgOiB0aGlzLmR1cmF0aW9uLCB0aGlzLmFjdHVhbExpdmVUaW1lKVxuICAgICAgICBpZiAoY3VycmVudER1cmF0aW9uICE9PSB0aGlzLmRpc3BsYXllZER1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy4kZHVyYXRpb25FbC50ZXh0KGN1cnJlbnREdXJhdGlvbilcbiAgICAgICAgICB0aGlzLmRpc3BsYXllZER1cmF0aW9uID0gY3VycmVudER1cmF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IHRoaXMuJGR1cmF0aW9uRWwuaGlkZSgpIH1cblxuXG4gICAgICAvLyB0aGUgZWxlbWVudCBtdXN0IGJlIHVuaGlkZGVuIGJlZm9yZSBpdHMgd2lkdGggaXMgcmVxdWVzdGVkLCBvdGhlcndpc2UgaXQncyB3aWR0aCB3aWxsIGJlIHJlcG9ydGVkIGFzIDBcbiAgICAgIHRoaXMuJGVsLnNob3coKVxuICAgICAgY29uc3QgY29udGFpbmVyV2lkdGggPSB0aGlzLm1lZGlhQ29udHJvbC4kc2Vla0JhckNvbnRhaW5lci53aWR0aCgpXG4gICAgICBjb25zdCBlbFdpZHRoID0gdGhpcy4kZWwud2lkdGgoKVxuICAgICAgbGV0IGVsTGVmdFBvcyA9IHRoaXMuaG92ZXJQb3NpdGlvbiAqIGNvbnRhaW5lcldpZHRoXG4gICAgICBlbExlZnRQb3MgLT0gZWxXaWR0aCAvIDJcbiAgICAgIGVsTGVmdFBvcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVsTGVmdFBvcywgY29udGFpbmVyV2lkdGggLSBlbFdpZHRoKSlcbiAgICAgIHRoaXMuJGVsLmNzcygnbGVmdCcsIGVsTGVmdFBvcylcbiAgICB9XG4gIH1cblxuICBzaG91bGRCZVZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWFDb250cm9sQ29udGFpbmVyICYmIHRoaXMubWVkaWFDb250cm9sQ29udGFpbmVyLnNldHRpbmdzLnNlZWtFbmFibGVkICYmIHRoaXMuaG92ZXJpbmdPdmVyU2Vla0JhciAmJiB0aGlzLmhvdmVyUG9zaXRpb24gIT09IG51bGwgJiYgdGhpcy5kdXJhdGlvbiAhPT0gbnVsbFxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlXG4gICAgdGhpcy5kaXNwbGF5ZWREdXJhdGlvbiA9IG51bGxcbiAgICB0aGlzLmRpc3BsYXllZFNlZWtUaW1lID0gbnVsbFxuICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSgpKVxuICAgIHRoaXMuJGVsLmhpZGUoKVxuICAgIHRoaXMubWVkaWFDb250cm9sLiRlbC5hcHBlbmQodGhpcy5lbClcbiAgICB0aGlzLiRzZWVrVGltZUVsID0gdGhpcy4kZWwuZmluZCgnW2RhdGEtc2Vlay10aW1lXScpXG4gICAgdGhpcy4kZHVyYXRpb25FbCA9IHRoaXMuJGVsLmZpbmQoJ1tkYXRhLWR1cmF0aW9uXScpXG4gICAgdGhpcy4kZHVyYXRpb25FbC5oaWRlKClcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cbn1cbiIsImltcG9ydCBDb3JlUGx1Z2luIGZyb20gJy4uL2Jhc2UvY29yZV9wbHVnaW4nXG5cbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vYmFzZS9ldmVudHMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvdXJjZXNQbHVnaW4gZXh0ZW5kcyBDb3JlUGx1Z2luIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnc291cmNlcycgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvcmUsIEV2ZW50cy5DT1JFX0NPTlRBSU5FUlNfQ1JFQVRFRCwgdGhpcy5vbkNvbnRhaW5lcnNDcmVhdGVkKVxuICB9XG5cbiAgb25Db250YWluZXJzQ3JlYXRlZCgpIHtcbiAgICBjb25zdCBmaXJzdFZhbGlkU291cmNlID0gdGhpcy5jb3JlLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiBjb250YWluZXIucGxheWJhY2submFtZSAhPT0gJ25vX29wJylbMF0gfHwgdGhpcy5jb3JlLmNvbnRhaW5lcnNbMF1cbiAgICBpZiAoZmlyc3RWYWxpZFNvdXJjZSkge1xuICAgICAgdGhpcy5jb3JlLmNvbnRhaW5lcnMuZm9yRWFjaCgoY29udGFpbmVyKSA9PiB7XG4gICAgICAgIGlmIChjb250YWluZXIgIT09IGZpcnN0VmFsaWRTb3VyY2UpXG4gICAgICAgICAgY29udGFpbmVyLmRlc3Ryb3koKVxuXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFNwaW5uZXJUaHJlZUJvdW5jZVBsdWdpbiBmcm9tICcuL3NwaW5uZXJfdGhyZWVfYm91bmNlJ1xuZXhwb3J0IGRlZmF1bHQgU3Bpbm5lclRocmVlQm91bmNlUGx1Z2luXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBkYXRhLWJvdW5jZTE+PC9kaXY+PGRpdiBkYXRhLWJvdW5jZTI+PC9kaXY+PGRpdiBkYXRhLWJvdW5jZTM+PC9kaXY+XFxuXCI7IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/aW5jbHVkZVBhdGhzW109L1VzZXJzL2FydGVtbXl6bmlrb3YvcHJvamVjdHMvY2xhcHByL3NyYy9iYXNlL3Njc3MhLi9zcGlubmVyLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcInNpbmdsZXRvblwiOnRydWUsXCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzP2luY2x1ZGVQYXRoc1tdPS9Vc2Vycy9hcnRlbW15em5pa292L3Byb2plY3RzL2NsYXBwci9zcmMvYmFzZS9zY3NzIS4vc3Bpbm5lci5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3NwaW5uZXIuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBVSUNvbnRhaW5lclBsdWdpbiBmcm9tICcuLi8uLi9iYXNlL3VpX2NvbnRhaW5lcl9wbHVnaW4nXG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2Jhc2UvZXZlbnRzJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL2Jhc2UvdGVtcGxhdGUnXG5pbXBvcnQgc3Bpbm5lckhUTUwgZnJvbSAnLi9wdWJsaWMvc3Bpbm5lci5odG1sJ1xuaW1wb3J0ICcuL3B1YmxpYy9zcGlubmVyLnNjc3MnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaW5uZXJUaHJlZUJvdW5jZVBsdWdpbiBleHRlbmRzIFVJQ29udGFpbmVyUGx1Z2luIHtcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiAnc3Bpbm5lcicgfVxuICBnZXQgYXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2RhdGEtc3Bpbm5lcic6JycsXG4gICAgICAnY2xhc3MnOiAnc3Bpbm5lci10aHJlZS1ib3VuY2UnXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyKVxuICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZShzcGlubmVySFRNTClcbiAgICB0aGlzLnNob3dUaW1lb3V0ID0gbnVsbFxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfU1RBVEVfQlVGRkVSSU5HLCB0aGlzLm9uQnVmZmVyaW5nKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfU1RBVEVfQlVGRkVSRlVMTCwgdGhpcy5vbkJ1ZmZlckZ1bGwpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVE9QLCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX0VOREVELCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX0VSUk9SLCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLnJlbmRlcigpXG4gIH1cblxuICBvbkJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLnNob3coKVxuICB9XG5cbiAgb25CdWZmZXJGdWxsKCkge1xuICAgIHRoaXMuaGlkZSgpXG4gIH1cblxuICBvblN0b3AoKSB7XG4gICAgdGhpcy5oaWRlKClcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuc2hvd1RpbWVvdXQgPT09IG51bGwpXG4gICAgICB0aGlzLnNob3dUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLiRlbC5zaG93KCksIDMwMClcblxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5zaG93VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd1RpbWVvdXQpXG4gICAgICB0aGlzLnNob3dUaW1lb3V0ID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLiRlbC5oaWRlKClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoKSlcbiAgICB0aGlzLmNvbnRhaW5lci4kZWwuYXBwZW5kKHRoaXMuJGVsKVxuICAgIHRoaXMuJGVsLmhpZGUoKVxuICAgIGlmICh0aGlzLmNvbnRhaW5lci5idWZmZXJpbmcpXG4gICAgICB0aGlzLm9uQnVmZmVyaW5nKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cbiIsImltcG9ydCBTdGF0c1BsdWdpbiBmcm9tICcuL3N0YXRzJ1xuZXhwb3J0IGRlZmF1bHQgU3RhdHNQbHVnaW5cbiIsIi8vIENvcHlyaWdodCAyMDE0IEdsb2JvLmNvbSBQbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5cbmltcG9ydCBDb250YWluZXJQbHVnaW4gZnJvbSAnLi4vLi4vYmFzZS9jb250YWluZXJfcGx1Z2luJ1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9iYXNlL2V2ZW50cydcbmltcG9ydCAkIGZyb20gJ2NsYXBwci16ZXB0bydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdHNQbHVnaW4gZXh0ZW5kcyBDb250YWluZXJQbHVnaW4ge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICdzdGF0cycgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgIHN1cGVyKGNvbnRhaW5lcilcbiAgICB0aGlzLnNldEluaXRpYWxBdHRycygpXG4gICAgdGhpcy5yZXBvcnRJbnRlcnZhbCA9IHRoaXMub3B0aW9ucy5yZXBvcnRJbnRlcnZhbCB8fCA1MDAwXG4gICAgdGhpcy5zdGF0ZSA9ICdJRExFJ1xuICB9XG5cbiAgYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLnBsYXliYWNrLCBFdmVudHMuUExBWUJBQ0tfUExBWSwgdGhpcy5vblBsYXkpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVE9QLCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX0VOREVELCB0aGlzLm9uU3RvcClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX0RFU1RST1lFRCwgdGhpcy5vblN0b3ApXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVEFURV9CVUZGRVJJTkcsIHRoaXMub25CdWZmZXJpbmcpXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9TVEFURV9CVUZGRVJGVUxMLCB0aGlzLm9uQnVmZmVyRnVsbClcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUQVRTX0FERCwgdGhpcy5vblN0YXRzQWRkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfQklUUkFURSwgdGhpcy5vblN0YXRzQWRkKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIucGxheWJhY2ssIEV2ZW50cy5QTEFZQkFDS19TVEFUU19BREQsIHRoaXMub25TdGF0c0FkZClcbiAgfVxuXG4gIHNldEluaXRpYWxBdHRycygpIHtcbiAgICB0aGlzLmZpcnN0UGxheSA9IHRydWVcbiAgICB0aGlzLnN0YXJ0dXBUaW1lID0gMFxuICAgIHRoaXMucmVidWZmZXJpbmdUaW1lID0gMFxuICAgIHRoaXMud2F0Y2hpbmdUaW1lID0gMFxuICAgIHRoaXMucmVidWZmZXJzID0gMFxuICAgIHRoaXMuZXh0ZXJuYWxNZXRyaWNzID0ge31cbiAgfVxuXG4gIG9uUGxheSgpIHtcbiAgICB0aGlzLnN0YXRlID0gJ1BMQVlJTkcnXG4gICAgdGhpcy53YXRjaGluZ1RpbWVJbml0ID0gRGF0ZS5ub3coKVxuICAgIGlmICghdGhpcy5pbnRlcnZhbElkKVxuICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy5yZXBvcnQuYmluZCh0aGlzKSwgdGhpcy5yZXBvcnRJbnRlcnZhbClcblxuICB9XG5cbiAgb25TdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKVxuICAgIHRoaXMucmVwb3J0KClcbiAgICB0aGlzLmludGVydmFsSWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnN0YXRlID0gJ1NUT1BQRUQnXG4gIH1cblxuICBvbkJ1ZmZlcmluZygpIHtcbiAgICBpZiAodGhpcy5maXJzdFBsYXkpXG4gICAgICB0aGlzLnN0YXJ0dXBUaW1lSW5pdCA9IERhdGUubm93KClcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYnVmZmVyaW5nVGltZUluaXQgPSBEYXRlLm5vdygpXG5cbiAgICB0aGlzLnN0YXRlID0gJ0JVRkZFUklORydcbiAgICB0aGlzLnJlYnVmZmVycysrXG4gIH1cblxuICBvbkJ1ZmZlckZ1bGwoKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RQbGF5ICYmIHRoaXMuc3RhcnR1cFRpbWVJbml0KSB7XG4gICAgICB0aGlzLmZpcnN0UGxheSA9IGZhbHNlXG4gICAgICB0aGlzLnN0YXJ0dXBUaW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnR1cFRpbWVJbml0XG4gICAgICB0aGlzLndhdGNoaW5nVGltZUluaXQgPSBEYXRlLm5vdygpXG4gICAgfSBlbHNlIGlmICh0aGlzLnJlYnVmZmVyaW5nVGltZUluaXQpIHsgdGhpcy5yZWJ1ZmZlcmluZ1RpbWUgKz0gdGhpcy5nZXRSZWJ1ZmZlcmluZ1RpbWUoKSB9XG5cbiAgICB0aGlzLnJlYnVmZmVyaW5nVGltZUluaXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnN0YXRlID0gJ1BMQVlJTkcnXG4gIH1cblxuICBnZXRSZWJ1ZmZlcmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnJlYnVmZmVyaW5nVGltZUluaXRcbiAgfVxuXG4gIGdldFdhdGNoaW5nVGltZSgpIHtcbiAgICBjb25zdCB0b3RhbFRpbWUgPSAoRGF0ZS5ub3coKSAtIHRoaXMud2F0Y2hpbmdUaW1lSW5pdClcbiAgICByZXR1cm4gdG90YWxUaW1lIC0gdGhpcy5yZWJ1ZmZlcmluZ1RpbWVcbiAgfVxuXG4gIGlzUmVidWZmZXJpbmcoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZWJ1ZmZlcmluZ1RpbWVJbml0XG4gIH1cblxuICBvblN0YXRzQWRkKG1ldHJpYykge1xuICAgICQuZXh0ZW5kKHRoaXMuZXh0ZXJuYWxNZXRyaWNzLCBtZXRyaWMpXG4gIH1cblxuICBnZXRTdGF0cygpIHtcbiAgICBjb25zdCBtZXRyaWNzID0ge1xuICAgICAgc3RhcnR1cFRpbWU6ICAgICB0aGlzLnN0YXJ0dXBUaW1lLFxuICAgICAgcmVidWZmZXJzOiAgICAgICB0aGlzLnJlYnVmZmVycyxcbiAgICAgIHJlYnVmZmVyaW5nVGltZTogdGhpcy5pc1JlYnVmZmVyaW5nKCk/IHRoaXMucmVidWZmZXJpbmdUaW1lICsgdGhpcy5nZXRSZWJ1ZmZlcmluZ1RpbWUoKTogdGhpcy5yZWJ1ZmZlcmluZ1RpbWUsXG4gICAgICB3YXRjaGluZ1RpbWU6ICAgIHRoaXMuaXNSZWJ1ZmZlcmluZygpPyB0aGlzLmdldFdhdGNoaW5nVGltZSgpIC0gdGhpcy5nZXRSZWJ1ZmZlcmluZ1RpbWUoKTogdGhpcy5nZXRXYXRjaGluZ1RpbWUoKVxuICAgIH1cbiAgICAkLmV4dGVuZChtZXRyaWNzLCB0aGlzLmV4dGVybmFsTWV0cmljcylcbiAgICByZXR1cm4gbWV0cmljc1xuICB9XG5cbiAgcmVwb3J0KCkge1xuICAgIHRoaXMuY29udGFpbmVyLnN0YXRzUmVwb3J0KHRoaXMuZ2V0U3RhdHMoKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgZ2V0QnJvd3Nlckxhbmd1YWdlIH0gZnJvbSAnLi4vYmFzZS91dGlscydcbmltcG9ydCAkIGZyb20gJ2NsYXBwci16ZXB0bydcbmltcG9ydCBDb3JlUGx1Z2luIGZyb20gJy4uL2Jhc2UvY29yZV9wbHVnaW4nXG5cbi8qKlxuICogVGhlIGludGVybmF0aW9uYWxpemF0aW9uIChpMThuKSBwbHVnaW5cbiAqIEBjbGFzcyBTdHJpbmdzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvcmVQbHVnaW5cbiAqIEBtb2R1bGUgcGx1Z2luc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdzIGV4dGVuZHMgQ29yZVBsdWdpbiB7XG4gIGdldCBuYW1lKCkgeyByZXR1cm4gJ3N0cmluZ3MnIH1cblxuICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG4gICAgc3VwZXIoY29yZSlcbiAgICB0aGlzLl9pbml0aWFsaXplTWVzc2FnZXMoKVxuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdHJhbnNsYXRlZCBzdHJpbmcgZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAqIEBtZXRob2QgdFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gYWxsIG1lc3NhZ2VzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdHJhbnNsYXRlZCBsYWJlbFxuICAgKi9cbiAgdChrZXkpIHtcbiAgICBjb25zdCBsYW5nID0gdGhpcy5fbGFuZ3VhZ2UoKVxuICAgIGNvbnN0IGZhbGxiYWNrTGFuZyA9IHRoaXMuX21lc3NhZ2VzWydlbiddXG4gICAgY29uc3QgaTE4biA9IGxhbmcgJiYgdGhpcy5fbWVzc2FnZXNbbGFuZ10gfHwgZmFsbGJhY2tMYW5nXG4gICAgcmV0dXJuIGkxOG5ba2V5XSB8fCBmYWxsYmFja0xhbmdba2V5XSB8fCBrZXlcbiAgfVxuXG4gIF9sYW5ndWFnZSgpIHsgcmV0dXJuIHRoaXMuY29yZS5vcHRpb25zLmxhbmd1YWdlIHx8IGdldEJyb3dzZXJMYW5ndWFnZSgpIH1cblxuICBfaW5pdGlhbGl6ZU1lc3NhZ2VzKCkge1xuICAgIGNvbnN0IGRlZmF1bHRNZXNzYWdlcyA9IHtcbiAgICAgICdlbic6IHtcbiAgICAgICAgJ2xpdmUnOiAnbGl2ZScsXG4gICAgICAgICdiYWNrX3RvX2xpdmUnOiAnYmFjayB0byBsaXZlJyxcbiAgICAgICAgJ2Rpc2FibGVkJzogJ0Rpc2FibGVkJyxcbiAgICAgICAgJ3BsYXliYWNrX25vdF9zdXBwb3J0ZWQnOiAnWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHBsYXliYWNrIG9mIHRoaXMgdmlkZW8uIFBsZWFzZSB0cnkgdXNpbmcgYSBkaWZmZXJlbnQgYnJvd3Nlci4nLFxuICAgICAgICAnZGVmYXVsdF9lcnJvcl90aXRsZSc6ICdDb3VsZCBub3QgcGxheSB2aWRlby4nLFxuICAgICAgICAnZGVmYXVsdF9lcnJvcl9tZXNzYWdlJzogJ1RoZXJlIHdhcyBhIHByb2JsZW0gdHJ5aW5nIHRvIGxvYWQgdGhlIHZpZGVvLicsXG4gICAgICB9LFxuICAgICAgJ3B0Jzoge1xuICAgICAgICAnbGl2ZSc6ICdhbyB2aXZvJyxcbiAgICAgICAgJ2JhY2tfdG9fbGl2ZSc6ICd2b2x0YXIgcGFyYSBvIGFvIHZpdm8nLFxuICAgICAgICAnZGlzYWJsZWQnOiAnRGVzYXRpdmFkbycsXG4gICAgICAgICdwbGF5YmFja19ub3Rfc3VwcG9ydGVkJzogJ1NldSBuYXZlZ2Fkb3IgbsOjbyBzdXBwb3J0YSBhIHJlcHJvZHXDp8OjbyBkZXN0ZSB2aWRlby4gUG9yIGZhdm9yLCB0ZW50ZSB1c2FyIHVtIG5hdmVnYWRvciBkaWZlcmVudGUuJyxcbiAgICAgICAgJ2RlZmF1bHRfZXJyb3JfdGl0bGUnOiAnTsOjbyBmb2kgcG9zc8OtdmVsIHJlcHJvZHV6aXIgbyB2w61kZW8uJyxcbiAgICAgICAgJ2RlZmF1bHRfZXJyb3JfbWVzc2FnZSc6ICdPY29ycmV1IHVtIHByb2JsZW1hIGFvIHRlbnRhciBjYXJyZWdhciBvIHbDrWRlby4nLFxuICAgICAgfSxcbiAgICAgICdlcyc6IHtcbiAgICAgICAgJ2xpdmUnOiAndml2bycsXG4gICAgICAgICdiYWNrX3RvX2xpdmUnOiAndm9sdmVyIGVuIHZpdm8nLFxuICAgICAgICAnZGlzYWJsZWQnOiAnRGlzY2FwYWNpdGFkbycsXG4gICAgICAgICdwbGF5YmFja19ub3Rfc3VwcG9ydGVkJzogJ1N1IG5hdmVnYWRvciBubyBzb3BvcnRhIGxhIHJlcHJvZHVjY2nDs24gZGUgdW4gdmlkZW8uIFBvciBmYXZvciwgdHJhdGUgZGUgdXNhciB1biBuYXZlZ2Fkb3IgZGlmZXJlbnRlLicsXG4gICAgICB9LFxuICAgICAgJ3J1Jzoge1xuICAgICAgICAnbGl2ZSc6ICfQv9GA0Y/QvNC+0Lkg0Y3RhNC40YAnLFxuICAgICAgICAnYmFja190b19saXZlJzogJ9C6INC/0YDRj9C80L7QvNGDINGN0YTQuNGA0YMnLFxuICAgICAgICAnZGlzYWJsZWQnOiAn0J7RgtC60LvRjtGH0LXQvdC+JyxcbiAgICAgICAgJ3BsYXliYWNrX25vdF9zdXBwb3J0ZWQnOiAn0JLQsNGIINCx0YDQsNGD0LfQtdGAINC90LUg0L/QvtC00LTQtdGA0LbQuNCy0LDQtdGCINCy0L7RgdC/0YDQvtC40LfQstC10LTQtdC90LjQtSDRjdGC0L7Qs9C+INCy0LjQtNC10L4uINCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C+0L/RgNC+0LHRg9C50YLQtSDQtNGA0YPQs9C+0Lkg0LHRgNCw0YPQt9C10YAuJyxcbiAgICAgIH0sXG4gICAgICAnZnInOiB7XG4gICAgICAgICdsaXZlJzogJ2VuIGRpcmVjdCcsXG4gICAgICAgICdiYWNrX3RvX2xpdmUnOiAncmV0b3VyIGF1IGRpcmVjdCcsXG4gICAgICAgICdkaXNhYmxlZCc6ICdEw6lzYWN0aXbDqScsXG4gICAgICAgICdwbGF5YmFja19ub3Rfc3VwcG9ydGVkJzogJ1ZvdHJlIG5hdmlnYXRldXIgbmUgc3VwcG9ydGUgcGFzIGxhIGxlY3R1cmUgZGUgY2V0dGUgdmlkw6lvLiBNZXJjaSBkZSB0ZW50ZXIgc3VyIHVuIGF1dHJlIG5hdmlnYXRldXIuJyxcbiAgICAgICAgJ2RlZmF1bHRfZXJyb3JfdGl0bGUnOiAnSW1wb3NzaWJsZSBkZSBsaXJlIGxhIHZpZMOpby4nLFxuICAgICAgICAnZGVmYXVsdF9lcnJvcl9tZXNzYWdlJzogJ1VuIHByb2Jsw6htZSBlc3Qgc3VydmVudSBsb3JzIGR1IGNoYXJnZW1lbnQgZGUgbGEgdmlkw6lvLicsXG4gICAgICB9LFxuICAgICAgJ3RyJzoge1xuICAgICAgICAnbGl2ZSc6ICdjYW5sxLEnLFxuICAgICAgICAnYmFja190b19saXZlJzogJ2NhbmzEsSB5YXnEsW5hIGTDtm4nLFxuICAgICAgICAnZGlzYWJsZWQnOiAnRW5nZWxsaScsXG4gICAgICAgICdwbGF5YmFja19ub3Rfc3VwcG9ydGVkJzogJ1RhcmF5xLFjxLFuxLF6IGJ1IHZpZGVveXUgb3luYXRtYSBkZXN0ZcSfaW5lIHNhaGlwIGRlxJ9pbC4gTMO8dGZlbiBmYXJrbMSxIGJpciB0YXJhecSxY8SxIGlsZSBkZW5leWluLicsXG4gICAgICB9LFxuICAgICAgJ2V0Jzoge1xuICAgICAgICAnbGl2ZSc6ICdPdHNlw7xsZWthbm5lJyxcbiAgICAgICAgJ2JhY2tfdG9fbGl2ZSc6ICdUYWdhc2kgb3RzZcO8bGVrYW5kZSBqdXVyZGUnLFxuICAgICAgICAnZGlzYWJsZWQnOiAnS2VlbGF0dWQnLFxuICAgICAgICAncGxheWJhY2tfbm90X3N1cHBvcnRlZCc6ICdUZWllIGJyYXVzZXIgZWkgdG9ldGEgc2VsbGUgdmlkZW8gdGFhc2VzaXR1c3QuIFByb292aWdlIGthc3V0YWRhIG11dWQgYnJhdXNlcml0LicsXG4gICAgICB9LFxuICAgICAgJ2FyJzoge1xuICAgICAgICAnbGl2ZSc6ICfZhdio2KfYtNixJyxcbiAgICAgICAgJ2JhY2tfdG9fbGl2ZSc6ICfYp9mE2LHYrNmI2Lkg2KXZhNmJINin2YTZhdio2KfYtNixJyxcbiAgICAgICAgJ2Rpc2FibGVkJzogJ9mF2LnYt9mR2YQnLFxuICAgICAgICAncGxheWJhY2tfbm90X3N1cHBvcnRlZCc6ICfYp9mE2YXYqti12YHYrSDYp9mE2LDZiiDYqtiz2KrYrtiv2YXZhyDZhNinINmK2K/YudmFINiq2LTYutmK2YQg2YfYsNinINin2YTZgdmK2K/ZitmILiDYp9mE2LHYrNin2KEg2KXYs9iq2K7Yr9in2YUg2YXYqti12YHYrSDYotiu2LEuJyxcbiAgICAgICAgJ2RlZmF1bHRfZXJyb3JfdGl0bGUnOiAn2LrZitixINmC2KfYr9ixINin2YTZiSDYp9mE2KrYtNi62YrZhC4nLFxuICAgICAgICAnZGVmYXVsdF9lcnJvcl9tZXNzYWdlJzogJ9it2K/Yq9iqINmF2LTZg9mE2Kkg2KPYq9mG2KfYoSDYqtit2YXZitmEINin2YTZgdmK2K/ZitmILicsXG4gICAgICB9LFxuICAgIH1cblxuICAgIHRoaXMuX21lc3NhZ2VzID0gJC5leHRlbmQodHJ1ZSwgZGVmYXVsdE1lc3NhZ2VzLCB0aGlzLmNvcmUub3B0aW9ucy5zdHJpbmdzIHx8IHt9KVxuICAgIHRoaXMuX21lc3NhZ2VzWydwdC1CUiddID0gdGhpcy5fbWVzc2FnZXNbJ3B0J11cbiAgICB0aGlzLl9tZXNzYWdlc1snZW4tVVMnXSA9IHRoaXMuX21lc3NhZ2VzWydlbiddXG4gICAgdGhpcy5fbWVzc2FnZXNbJ2VzLTQxOSddID0gdGhpcy5fbWVzc2FnZXNbJ2VzJ11cbiAgICB0aGlzLl9tZXNzYWdlc1snZnItRlInXSA9IHRoaXMuX21lc3NhZ2VzWydmciddXG4gICAgdGhpcy5fbWVzc2FnZXNbJ3RyLVRSJ10gPSB0aGlzLl9tZXNzYWdlc1sndHInXVxuICAgIHRoaXMuX21lc3NhZ2VzWydldC1FRSddID0gdGhpcy5fbWVzc2FnZXNbJ2V0J11cbiAgICB0aGlzLl9tZXNzYWdlc1snYXItSVEnXSA9IHRoaXMuX21lc3NhZ2VzWydhciddXG4gIH1cbn1cbiIsImltcG9ydCBXYXRlck1hcmtQbHVnaW4gZnJvbSAnLi93YXRlcm1hcmsnXG5leHBvcnQgZGVmYXVsdCBXYXRlck1hcmtQbHVnaW5cbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjbGFwcHItd2F0ZXJtYXJrXFxcIiBkYXRhLXdhdGVybWFyayBkYXRhLXdhdGVybWFyay08JT1wb3NpdGlvbiAlPj5cXG48JSBpZih0eXBlb2YgaW1hZ2VMaW5rICE9PSAndW5kZWZpbmVkJykgeyAlPlxcbjxhIHRhcmdldD1fYmxhbmsgaHJlZj1cXFwiPCU9IGltYWdlTGluayAlPlxcXCI+XFxuPCUgfSAlPlxcbjxpbWcgc3JjPVxcXCI8JT0gaW1hZ2VVcmwgJT5cXFwiPlxcbjwlIGlmKHR5cGVvZiBpbWFnZUxpbmsgIT09ICd1bmRlZmluZWQnKSB7ICU+XFxuPC9hPlxcbjwlIH0gJT5cXG48L2Rpdj5cXG5cIjsiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3dhdGVybWFyay5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJzaW5nbGV0b25cIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3dhdGVybWFyay5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz9pbmNsdWRlUGF0aHNbXT0vVXNlcnMvYXJ0ZW1teXpuaWtvdi9wcm9qZWN0cy9jbGFwcHIvc3JjL2Jhc2Uvc2NzcyEuL3dhdGVybWFyay5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gQ29weXJpZ2h0IDIwMTQgR2xvYm8uY29tIFBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGVcbi8vIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZS5cblxuaW1wb3J0IFVJQ29udGFpbmVyUGx1Z2luIGZyb20gJy4uLy4uL2Jhc2UvdWlfY29udGFpbmVyX3BsdWdpbidcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vYmFzZS9ldmVudHMnXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi4vLi4vYmFzZS90ZW1wbGF0ZSdcbmltcG9ydCB3YXRlcm1hcmtIVE1MIGZyb20gJy4vcHVibGljL3dhdGVybWFyay5odG1sJ1xuaW1wb3J0ICcuL3B1YmxpYy93YXRlcm1hcmsuc2NzcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F0ZXJNYXJrUGx1Z2luIGV4dGVuZHMgVUlDb250YWluZXJQbHVnaW4ge1xuICBnZXQgbmFtZSgpIHsgcmV0dXJuICd3YXRlcm1hcmsnIH1cblxuICBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiB0ZW1wbGF0ZSh3YXRlcm1hcmtIVE1MKSB9XG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoY29udGFpbmVyKVxuICAgIHRoaXMuY29uZmlndXJlKClcbiAgfVxuXG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbnRhaW5lciwgRXZlbnRzLkNPTlRBSU5FUl9QTEFZLCB0aGlzLm9uUGxheSlcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29udGFpbmVyLCBFdmVudHMuQ09OVEFJTkVSX1NUT1AsIHRoaXMub25TdG9wKVxuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb250YWluZXIsIEV2ZW50cy5DT05UQUlORVJfT1BUSU9OU19DSEFOR0UsIHRoaXMuY29uZmlndXJlKVxuICB9XG5cbiAgY29uZmlndXJlKCkge1xuICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb24gfHwgJ2JvdHRvbS1yaWdodCdcbiAgICBpZiAodGhpcy5vcHRpb25zLndhdGVybWFyaykge1xuICAgICAgdGhpcy5pbWFnZVVybCA9IHRoaXMub3B0aW9ucy53YXRlcm1hcmtcbiAgICAgIHRoaXMuaW1hZ2VMaW5rID0gdGhpcy5vcHRpb25zLndhdGVybWFya0xpbmtcbiAgICAgIHRoaXMucmVuZGVyKClcbiAgICB9IGVsc2UgeyB0aGlzLiRlbC5yZW1vdmUoKSB9XG5cbiAgfVxuXG4gIG9uUGxheSgpIHtcbiAgICBpZiAoIXRoaXMuaGlkZGVuKVxuICAgICAgdGhpcy4kZWwuc2hvdygpXG4gIH1cblxuICBvblN0b3AoKSB7XG4gICAgdGhpcy4kZWwuaGlkZSgpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy4kZWwuaGlkZSgpXG4gICAgY29uc3QgdGVtcGxhdGVPcHRpb25zID0geyBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbiwgaW1hZ2VVcmw6IHRoaXMuaW1hZ2VVcmwsIGltYWdlTGluazogdGhpcy5pbWFnZUxpbmsgfVxuICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh0ZW1wbGF0ZU9wdGlvbnMpKVxuICAgIHRoaXMuY29udGFpbmVyLiRlbC5hcHBlbmQodGhpcy4kZWwpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuIiwiaW1wb3J0IEtpYm8gZnJvbSAnLi9raWJvJ1xuXG5leHBvcnQgZGVmYXVsdCB7IEtpYm8gfVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEtpYm8gaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBDb3B5cmlnaHQgKGMpIDIwMTMgbWFycXVldGUuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcnF1ZXRlL2tpYm9cblxudmFyIEtpYm8gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xuICB0aGlzLmluaXRpYWxpemUoKTtcbn07XG5cbktpYm8uS0VZX05BTUVTX0JZX0NPREUgPSB7XG4gIDg6ICdiYWNrc3BhY2UnLCA5OiAndGFiJywgMTM6ICdlbnRlcicsXG4gIDE2OiAnc2hpZnQnLCAxNzogJ2N0cmwnLCAxODogJ2FsdCcsXG4gIDIwOiAnY2Fwc19sb2NrJyxcbiAgMjc6ICdlc2MnLFxuICAzMjogJ3NwYWNlJyxcbiAgMzc6ICdsZWZ0JywgMzg6ICd1cCcsIDM5OiAncmlnaHQnLCA0MDogJ2Rvd24nLFxuICA0ODogJzAnLCA0OTogJzEnLCA1MDogJzInLCA1MTogJzMnLCA1MjogJzQnLCA1MzogJzUnLCA1NDogJzYnLCA1NTogJzcnLCA1NjogJzgnLCA1NzogJzknLFxuICA2NTogJ2EnLCA2NjogJ2InLCA2NzogJ2MnLCA2ODogJ2QnLCA2OTogJ2UnLCA3MDogJ2YnLCA3MTogJ2cnLCA3MjogJ2gnLCA3MzogJ2knLCA3NDogJ2onLFxuICA3NTogJ2snLCA3NjogJ2wnLCA3NzogJ20nLCA3ODogJ24nLCA3OTogJ28nLCA4MDogJ3AnLCA4MTogJ3EnLCA4MjogJ3InLCA4MzogJ3MnLCA4NDogJ3QnLFxuICA4NTogJ3UnLCA4NjogJ3YnLCA4NzogJ3cnLCA4ODogJ3gnLCA4OTogJ3knLCA5MDogJ3onLCAxMTI6ICdmMScsIDExMzogJ2YyJywgMTE0OiAnZjMnLFxuICAxMTU6ICdmNCcsIDExNjogJ2Y1JywgMTE3OiAnZjYnLCAxMTg6ICdmNycsIDExOTogJ2Y4JywgMTIwOiAnZjknLCAxMjE6ICdmMTAnLCAxMjI6ICdmMTEnLCAxMjM6ICdmMTInXG59O1xuXG5LaWJvLktFWV9DT0RFU19CWV9OQU1FID0ge307XG4oZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIga2V5IGluIEtpYm8uS0VZX05BTUVTX0JZX0NPREUpIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoS2liby5LRVlfTkFNRVNfQllfQ09ERSwga2V5KSkge1xuICAgICAgS2liby5LRVlfQ09ERVNfQllfTkFNRVtLaWJvLktFWV9OQU1FU19CWV9DT0RFW2tleV1dID0gK2tleTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbktpYm8uTU9ESUZJRVJTID0gWydzaGlmdCcsICdjdHJsJywgJ2FsdCddO1xuXG5LaWJvLnJlZ2lzdGVyRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gIGlmKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBmdW5jKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgZnVuYykge1xuICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBmdW5jKTtcbiAgICB9O1xuICB9XG59KSgpO1xuXG5LaWJvLnVucmVnaXN0ZXJFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgaWYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGZ1bmMpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYoZG9jdW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBmdW5jKSB7XG4gICAgICBlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGZ1bmMpO1xuICAgIH07XG4gIH1cbn0pKCk7XG5cbktpYm8uc3RyaW5nQ29udGFpbnMgPSBmdW5jdGlvbihzdHJpbmcsIHN1YnN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nKSAhPT0gLTE7XG59O1xuXG5LaWJvLm5lYXRTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xufTtcblxuS2liby5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eLi8sIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbktpYm8uaXNTdHJpbmcgPSBmdW5jdGlvbih3aGF0KSB7XG4gIHJldHVybiBLaWJvLnN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aGF0KSwgJ1N0cmluZycpO1xufTtcblxuS2liby5hcnJheUluY2x1ZGVzID0gKGZ1bmN0aW9uKCkge1xuICBpZihBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIHJldHVybiBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoaGF5c3RhY2tbaV0gPT09IG5lZWRsZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufSkoKTtcblxuS2liby5leHRyYWN0TW9kaWZpZXJzID0gZnVuY3Rpb24oa2V5Q29tYmluYXRpb24pIHtcbiAgdmFyIG1vZGlmaWVycywgaVxuICBtb2RpZmllcnMgPSBbXTtcbiAgZm9yKGkgPSAwOyBpIDwgS2liby5NT0RJRklFUlMubGVuZ3RoOyBpKyspIHtcbiAgICBpZihLaWJvLnN0cmluZ0NvbnRhaW5zKGtleUNvbWJpbmF0aW9uLCBLaWJvLk1PRElGSUVSU1tpXSkpIHtcbiAgICAgIG1vZGlmaWVycy5wdXNoKEtpYm8uTU9ESUZJRVJTW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVycztcbn1cblxuS2liby5leHRyYWN0S2V5ID0gZnVuY3Rpb24oa2V5Q29tYmluYXRpb24pIHtcbiAgdmFyIGtleXMsIGk7XG4gIGtleXMgPSBLaWJvLm5lYXRTdHJpbmcoa2V5Q29tYmluYXRpb24pLnNwbGl0KCcgJyk7XG4gIGZvcihpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZighS2liby5hcnJheUluY2x1ZGVzKEtpYm8uTU9ESUZJRVJTLCBrZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfVxuICB9XG59O1xuXG5LaWJvLm1vZGlmaWVyc0FuZEtleSA9IGZ1bmN0aW9uKGtleUNvbWJpbmF0aW9uKSB7XG4gIHZhciByZXN1bHQsIGtleTtcblxuICBpZihLaWJvLnN0cmluZ0NvbnRhaW5zKGtleUNvbWJpbmF0aW9uLCAnYW55JykpIHtcbiAgICByZXR1cm4gS2liby5uZWF0U3RyaW5nKGtleUNvbWJpbmF0aW9uKS5zcGxpdCgnICcpLnNsaWNlKDAsIDIpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJlc3VsdCA9IEtpYm8uZXh0cmFjdE1vZGlmaWVycyhrZXlDb21iaW5hdGlvbik7XG5cbiAga2V5ID0gS2liby5leHRyYWN0S2V5KGtleUNvbWJpbmF0aW9uKTtcbiAgaWYoa2V5ICYmICFLaWJvLmFycmF5SW5jbHVkZXMoS2liby5NT0RJRklFUlMsIGtleSkpIHtcbiAgICByZXN1bHQucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5cbktpYm8ua2V5TmFtZSA9IGZ1bmN0aW9uKGtleUNvZGUpIHtcbiAgcmV0dXJuIEtpYm8uS0VZX05BTUVTX0JZX0NPREVba2V5Q29kZSArICcnXTtcbn07XG5cbktpYm8ua2V5Q29kZSA9IGZ1bmN0aW9uKGtleU5hbWUpIHtcbiAgcmV0dXJuICtLaWJvLktFWV9DT0RFU19CWV9OQU1FW2tleU5hbWVdO1xufTtcblxuS2liby5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgdGhhdCA9IHRoaXM7XG5cbiAgdGhpcy5sYXN0S2V5Q29kZSA9IC0xO1xuICB0aGlzLmxhc3RNb2RpZmllcnMgPSB7fTtcbiAgZm9yKGkgPSAwOyBpIDwgS2liby5NT0RJRklFUlMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmxhc3RNb2RpZmllcnNbS2liby5NT0RJRklFUlNbaV1dID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLmtleXNEb3duID0geyBhbnk6IFtdIH07XG4gIHRoaXMua2V5c1VwID0geyBhbnk6IFtdIH07XG4gIHRoaXMuZG93bkhhbmRsZXIgPSB0aGlzLmhhbmRsZXIoJ2Rvd24nKTtcbiAgdGhpcy51cEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIoJ3VwJyk7XG5cbiAgS2liby5yZWdpc3RlckV2ZW50KHRoaXMuZWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLmRvd25IYW5kbGVyKTtcbiAgS2liby5yZWdpc3RlckV2ZW50KHRoaXMuZWxlbWVudCwgJ2tleXVwJywgdGhpcy51cEhhbmRsZXIpO1xuICBLaWJvLnJlZ2lzdGVyRXZlbnQod2luZG93LCAndW5sb2FkJywgZnVuY3Rpb24gdW5sb2FkZXIoKSB7XG4gICAgS2liby51bnJlZ2lzdGVyRXZlbnQodGhhdC5lbGVtZW50LCAna2V5ZG93bicsIHRoYXQuZG93bkhhbmRsZXIpO1xuICAgIEtpYm8udW5yZWdpc3RlckV2ZW50KHRoYXQuZWxlbWVudCwgJ2tleXVwJywgdGhhdC51cEhhbmRsZXIpO1xuICAgIEtpYm8udW5yZWdpc3RlckV2ZW50KHdpbmRvdywgJ3VubG9hZCcsIHVubG9hZGVyKTtcbiAgfSk7XG59O1xuXG5LaWJvLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odXBPckRvd24pIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHZhciBpLCByZWdpc3RlcmVkS2V5cywgbGFzdE1vZGlmaWVyc0FuZEtleTtcblxuICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgIHRoYXQubGFzdEtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgZm9yKGkgPSAwOyBpIDwgS2liby5NT0RJRklFUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXQubGFzdE1vZGlmaWVyc1tLaWJvLk1PRElGSUVSU1tpXV0gPSBlW0tpYm8uTU9ESUZJRVJTW2ldICsgJ0tleSddO1xuICAgIH1cbiAgICBpZihLaWJvLmFycmF5SW5jbHVkZXMoS2liby5NT0RJRklFUlMsIEtpYm8ua2V5TmFtZSh0aGF0Lmxhc3RLZXlDb2RlKSkpIHtcbiAgICAgIHRoYXQubGFzdE1vZGlmaWVyc1tLaWJvLmtleU5hbWUodGhhdC5sYXN0S2V5Q29kZSldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZWdpc3RlcmVkS2V5cyA9IHRoYXRbJ2tleXMnICsgS2liby5jYXBpdGFsaXplKHVwT3JEb3duKV07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCByZWdpc3RlcmVkS2V5cy5hbnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKChyZWdpc3RlcmVkS2V5cy5hbnlbaV0oZSkgPT09IGZhbHNlKSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0TW9kaWZpZXJzQW5kS2V5ID0gdGhhdC5sYXN0TW9kaWZpZXJzQW5kS2V5KCk7XG4gICAgaWYocmVnaXN0ZXJlZEtleXNbbGFzdE1vZGlmaWVyc0FuZEtleV0pIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IHJlZ2lzdGVyZWRLZXlzW2xhc3RNb2RpZmllcnNBbmRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKChyZWdpc3RlcmVkS2V5c1tsYXN0TW9kaWZpZXJzQW5kS2V5XVtpXShlKSA9PT0gZmFsc2UpICYmIGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5LaWJvLnByb3RvdHlwZS5yZWdpc3RlcktleXMgPSBmdW5jdGlvbih1cE9yRG93biwgbmV3S2V5cywgZnVuYykge1xuICB2YXIgaSwga2V5cywgcmVnaXN0ZXJlZEtleXMgPSB0aGlzWydrZXlzJyArIEtpYm8uY2FwaXRhbGl6ZSh1cE9yRG93bildO1xuXG4gIGlmKEtpYm8uaXNTdHJpbmcobmV3S2V5cykpIHtcbiAgICBuZXdLZXlzID0gW25ld0tleXNdO1xuICB9XG5cbiAgZm9yKGkgPSAwOyBpIDwgbmV3S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleXMgPSBuZXdLZXlzW2ldO1xuICAgIGtleXMgPSBLaWJvLm1vZGlmaWVyc0FuZEtleShrZXlzICsgJycpO1xuXG4gICAgaWYocmVnaXN0ZXJlZEtleXNba2V5c10pIHtcbiAgICAgIHJlZ2lzdGVyZWRLZXlzW2tleXNdLnB1c2goZnVuYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyZWRLZXlzW2tleXNdID0gW2Z1bmNdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8ganNoaW50IG1heGRlcHRoOjVcbktpYm8ucHJvdG90eXBlLnVucmVnaXN0ZXJLZXlzID0gZnVuY3Rpb24odXBPckRvd24sIG5ld0tleXMsIGZ1bmMpIHtcbiAgdmFyIGksIGosIGtleXMsIHJlZ2lzdGVyZWRLZXlzID0gdGhpc1sna2V5cycgKyBLaWJvLmNhcGl0YWxpemUodXBPckRvd24pXTtcblxuICBpZihLaWJvLmlzU3RyaW5nKG5ld0tleXMpKSB7XG4gICAgbmV3S2V5cyA9IFtuZXdLZXlzXTtcbiAgfVxuXG4gIGZvcihpID0gMDsgaSA8IG5ld0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXlzID0gbmV3S2V5c1tpXTtcbiAgICBrZXlzID0gS2liby5tb2RpZmllcnNBbmRLZXkoa2V5cyArICcnKTtcblxuICAgIGlmKGZ1bmMgPT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSByZWdpc3RlcmVkS2V5c1trZXlzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYocmVnaXN0ZXJlZEtleXNba2V5c10pIHtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgcmVnaXN0ZXJlZEtleXNba2V5c10ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZihTdHJpbmcocmVnaXN0ZXJlZEtleXNba2V5c11bal0pID09PSBTdHJpbmcoZnVuYykpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRLZXlzW2tleXNdLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuS2liby5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oa2V5cykge1xuICByZXR1cm4gdGhpcy51bnJlZ2lzdGVyS2V5cygnZG93bicsIGtleXMsIG51bGwpO1xufVxuXG5LaWJvLnByb3RvdHlwZS5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHVwT3JEb3duLCBrZXlzLCBmdW5jKSB7XG4gIHJldHVybiAoZnVuYyAhPT0gbnVsbCB8fCBmdW5jICE9PSB1bmRlZmluZWQpID8gdGhpcy5yZWdpc3RlcktleXModXBPckRvd24sIGtleXMsIGZ1bmMpIDogdGhpcy51bnJlZ2lzdGVyS2V5cyh1cE9yRG93biwga2V5cywgZnVuYyk7XG59O1xuXG5LaWJvLnByb3RvdHlwZS5kb3duID0gZnVuY3Rpb24oa2V5cywgZnVuYykge1xuICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSgnZG93bicsIGtleXMsIGZ1bmMpO1xufTtcblxuS2liby5wcm90b3R5cGUudXAgPSBmdW5jdGlvbihrZXlzLCBmdW5jKSB7XG4gIHJldHVybiB0aGlzLmRlbGVnYXRlKCd1cCcsIGtleXMsIGZ1bmMpO1xufTtcblxuS2liby5wcm90b3R5cGUubGFzdEtleSA9IGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gIGlmKCFtb2RpZmllcikge1xuICAgIHJldHVybiBLaWJvLmtleU5hbWUodGhpcy5sYXN0S2V5Q29kZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5sYXN0TW9kaWZpZXJzW21vZGlmaWVyXTtcbn07XG5cbktpYm8ucHJvdG90eXBlLmxhc3RNb2RpZmllcnNBbmRLZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICByZXN1bHQgPSBbXTtcbiAgZm9yKGkgPSAwOyBpIDwgS2liby5NT0RJRklFUlMubGVuZ3RoOyBpKyspIHtcbiAgICBpZih0aGlzLmxhc3RLZXkoS2liby5NT0RJRklFUlNbaV0pKSB7XG4gICAgICByZXN1bHQucHVzaChLaWJvLk1PRElGSUVSU1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYoIUtpYm8uYXJyYXlJbmNsdWRlcyhyZXN1bHQsIHRoaXMubGFzdEtleSgpKSkge1xuICAgIHJlc3VsdC5wdXNoKHRoaXMubGFzdEtleSgpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignICcpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgS2lib1xuIl0sInNvdXJjZVJvb3QiOiIifQ==